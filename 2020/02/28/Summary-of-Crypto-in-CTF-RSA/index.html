<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Summary of Crypto in CTF(RSA) | 0xDktb's Blog</title><meta name="description" content="RSA - How to Use openssl Given flag.enc, pubkey.pem&#x2F;pub.key 1openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem Then we get (e, n), after getting d: 1234from Crypto.Util.number import byt"><meta name="keywords" content="RSA"><meta name="author" content="0xDktb"><meta name="copyright" content="0xDktb"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Summary of Crypto in CTF(RSA)"><meta property="og:url" content="https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/"><meta property="og:site_name" content="0xDktb's Blog"><meta property="og:description" content="RSA - How to Use openssl Given flag.enc, pubkey.pem&#x2F;pub.key 1openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem Then we get (e, n), after getting d: 1234from Crypto.Util.number import byt"><meta property="og:image" content="https://0xdktb.top/img/star.jpg"><meta property="article:published_time" content="2020-02-28T14:31:20.000Z"><meta property="article:modified_time" content="2020-04-02T04:03:04.584Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Lattice-Learning-1" href="https://0xdktb.top/2020/02/29/Lattice-Learning-1/"><link rel="next" title="[ByteCTF2019] - boring_code" href="https://0xdktb.top/2019/10/22/ByteCTF2019-boring-code/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---how-to-use-openssl"><span class="toc-number">1.</span> <span class="toc-text">RSA - How to Use openssl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---given-e-d-n"><span class="toc-number">2.</span> <span class="toc-text">RSA - Given (e, d, (n))</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem"><span class="toc-number">2.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-number">2.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#note"><span class="toc-number">2.3.</span> <span class="toc-text">Note</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---given-e-dp-n"><span class="toc-number">3.</span> <span class="toc-text">RSA - Given (e, dp, n)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-1"><span class="toc-number">3.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-1"><span class="toc-number">3.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---given-p-q-dp-dq"><span class="toc-number">4.</span> <span class="toc-text">RSA - Given (p, q, dp, dq)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-2"><span class="toc-number">4.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-2"><span class="toc-number">4.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sage"><span class="toc-number">4.3.</span> <span class="toc-text">sage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---wieners-attack"><span class="toc-number">5.</span> <span class="toc-text">RSA - Wiener&#39;s Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-3"><span class="toc-number">5.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-3"><span class="toc-number">5.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---partial_m"><span class="toc-number">6.</span> <span class="toc-text">RSA - Partial_m</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-4"><span class="toc-number">6.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-4"><span class="toc-number">6.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#note-1"><span class="toc-number">6.3.</span> <span class="toc-text">Note</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---partial_p"><span class="toc-number">7.</span> <span class="toc-text">RSA - Partial_p</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-5"><span class="toc-number">7.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-5"><span class="toc-number">7.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#note-2"><span class="toc-number">7.3.</span> <span class="toc-text">Note</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---partial_d"><span class="toc-number">8.</span> <span class="toc-text">RSA - Partial_d</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-6"><span class="toc-number">8.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-6"><span class="toc-number">8.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-7"><span class="toc-number">8.3.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-7"><span class="toc-number">8.4.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#note-3"><span class="toc-number">8.5.</span> <span class="toc-text">Note</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---boneh-durfee-attack"><span class="toc-number">9.</span> <span class="toc-text">RSA - Boneh Durfee Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-8"><span class="toc-number">9.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-8"><span class="toc-number">9.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---gcdevarphinneq-1"><span class="toc-number">10.</span> <span class="toc-text">RSA - \(gcd(e,\varphi(n)\neq 1)\)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-9"><span class="toc-number">10.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#example"><span class="toc-number">10.2.</span> <span class="toc-text">Example</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---polynomial-based-rsa"><span class="toc-number">11.</span> <span class="toc-text">RSA - Polynomial based RSA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-10"><span class="toc-number">11.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-9"><span class="toc-number">11.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---large-common-factor-of-p-1-and-q-1"><span class="toc-number">12.</span> <span class="toc-text">RSA - Large Common Factor of p-1 and q-1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-11"><span class="toc-number">12.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-10"><span class="toc-number">12.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#more"><span class="toc-number">12.3.</span> <span class="toc-text">More</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---small-crt-private-exponents"><span class="toc-number">13.</span> <span class="toc-text">RSA - Small CRT Private Exponents</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-12"><span class="toc-number">13.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-11"><span class="toc-number">13.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---parity-oracle"><span class="toc-number">14.</span> <span class="toc-text">RSA - Parity Oracle</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-13"><span class="toc-number">14.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-12"><span class="toc-number">14.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---williams-p1-and-pollards-p-1"><span class="toc-number">15.</span> <span class="toc-text">RSA - William&#39;s p+1 and Pollard&#39;s p-1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-14"><span class="toc-number">15.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-13"><span class="toc-number">15.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#more-1"><span class="toc-number">15.3.</span> <span class="toc-text">More</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#link"><span class="toc-number">15.4.</span> <span class="toc-text">Link</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---square-root-in-f_p"><span class="toc-number">16.</span> <span class="toc-text">RSA - Square Root in \(F_{p}\)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-15"><span class="toc-number">16.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-14"><span class="toc-number">16.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#more-2"><span class="toc-number">16.3.</span> <span class="toc-text">More</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rsa---emid-p-1emid-q-1"><span class="toc-number">17.</span> <span class="toc-text">RSA - \(e\mid (p-1),e\mid (q-1)\)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#theorem-16"><span class="toc-number">17.1.</span> <span class="toc-text">Theorem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-15"><span class="toc-number">17.2.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#more-3"><span class="toc-number">17.3.</span> <span class="toc-text">More</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#link-1"><span class="toc-number">17.4.</span> <span class="toc-text">Link</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><header class="post-bg" id="page-header" style="background-image: url(/img/star.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">0xDktb's Blog</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Summary of Crypto in CTF(RSA)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-02-28 22:31:20"><i class="far fa-calendar-alt fa-fw"></i> Created 2020-02-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-04-02 12:03:04"><i class="fas fa-history fa-fw"></i> Updated 2020-04-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Crypto/">Crypto</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="rsa---how-to-use-openssl">RSA - How to Use openssl</h3>
<p>Given <em>flag.enc</em>, <em>pubkey.pem/pub.key</em></p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem</span><br></pre></td></tr></table></figure></p>
<p>Then we get (e, n), after getting d:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes</span><br><span class="line"></span><br><span class="line">c = bytes_to_long(open(<span class="string">'flag.enc'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure>
<h3 id="rsa---given-e-d-n">RSA - Given (e, d, (n))</h3>
<h4 id="theorem">Theorem</h4>
<ol type="1">
<li>[Initialize] Set <span class="math inline">\(k\leftarrow d\cdot e-1\)</span></li>
<li>[Try a random g] Choose random small primes g = 2, 3, 5, 7, ...</li>
<li>[Next k] If <span class="math inline">\(2\mid k,k\leftarrow\frac{k}{2}\)</span> and <span class="math inline">\(x\leftarrow g^k\)</span> mod n, else go to step 2 (g <span class="math inline">\(\leftarrow\)</span> next_prime(g))</li>
<li>[Finish?] If <span class="math inline">\(y\leftarrow gcd(x-1,n)\ mod\ n&gt;1,p\leftarrow y,q\leftarrow n//y\)</span>, quit. Else go to step 3.</li>
</ol>
<h4 id="exp">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime, gcd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorize</span><span class="params">(n, e, d)</span>:</span></span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = e * d - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            k //= <span class="number">2</span></span><br><span class="line">            p = int(gcd(pow(g, k, n) - <span class="number">1</span>, n)) % n</span><br><span class="line">            <span class="keyword">if</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">        g = int(next_prime(g))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    d = </span><br><span class="line">    print(Factorize(n, e, d))</span><br></pre></td></tr></table></figure>
<h4 id="note">Note</h4>
<p>Given only (e, d) - [NCTF2019] babyRSA</p>
<h3 id="rsa---given-e-dp-n">RSA - Given (e, dp, n)</h3>
<h4 id="theorem-1">Theorem</h4>
<p><span class="math display">\[
Known(e,dp,n),assume\ dp\equiv d(mod\ (p-1))
\]</span></p>
<hr>
<p><span class="math inline">\(\because dp\cdot e\equiv d\cdot e\equiv 1(mod\ (p-1))\)</span></p>
<p><span class="math inline">\(\therefore dp\cdot e-1=k\cdot (p-1)\)</span></p>
<p><span class="math inline">\(\because dp\cdot e\equiv d\cdot e\equiv 1(mod\ (p-1))\)</span></p>
<p><span class="math inline">\(\therefore dp\cdot e-1=k\cdot (p-1)\)</span></p>
<p><span class="math inline">\(\therefore (dp\cdot e-1)\cdot d\cdot e=k&#39;\cdot (p-1),\quad k&#39;=k\cdot d\cdot e\)</span></p>
<p><span class="math inline">\(\Leftrightarrow d*e=-k&#39;\cdot (p-1)+dp\cdot e\cdot d\cdot e\equiv 1(mod\ \varphi(n))\Leftrightarrow -k&#39;\cdot (p-1)+dp\cdot e\equiv 1(mod\ \varphi(n))\)</span></p>
<p><span class="math inline">\(\therefore k_{1}\cdot (p-1)+dp\cdot e-1=k_{2}\cdot (p-1)\cdot (q-1)\Leftrightarrow (p-1)\cdot (k_{2}\cdot (q-1)-k_{1})+1=dp\cdot e\)</span></p>
<p><span class="math inline">\(\because dp&lt;p-1\quad \therefore (k_{2}\cdot (q-1)-k_{1})\in (0, e)\)</span></p>
<p><span class="math inline">\(\therefore\)</span>遍历i in range(1, e)，当同时满足</p>
<p><span class="math inline">\((dp\cdot e-1)\%i==0\)</span>和<span class="math inline">\(n\%((dp\cdot e-1)//i+1)==0时\)</span>，N成功分解.</p>
<h4 id="exp-1">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(e, dp, n)</span>:</span></span><br><span class="line">    _ = dp * e - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, e):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _ % i:</span><br><span class="line">            p = _ // i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n % p:</span><br><span class="line">                q = n // p</span><br><span class="line">                phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">                d = int(gmpy2.invert(e, phi))</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    e = int(input(<span class="string">"e = "</span>))</span><br><span class="line">    dp = int(input(<span class="string">"dp = "</span>))</span><br><span class="line">    n = int(input(<span class="string">"n = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = decrypt(e, dp, n)</span><br><span class="line">    print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure>
<h3 id="rsa---given-p-q-dp-dq">RSA - Given (p, q, dp, dq)</h3>
<h4 id="theorem-2">Theorem</h4>
<p><span class="math display">\[
Known(p,q,dp,dq),assume\ dp\equiv d(mod\ (p-1)),dq\equiv d(mod\ (q-1))
\]</span></p>
<hr>
<p><span class="math inline">\(d\equiv dp(mod\ (p-1)),d\equiv dq(mod\ (q-1))\rightarrow ext\_CRT\ (\because gcd(p-1,q-1)\)</span>不一定等于1)</p>
<p><span class="math inline">\(\because d=k_{1}(p-1)+dp=k_{2}(q-1)+dq\Leftrightarrow k_{1}(p-1)=(dq-dp)+k_{2}(q-1)\)</span></p>
<p><span class="math inline">\(\Leftrightarrow k_{1}\frac{p-1}{gcd(p-1,q-1)}=\frac{dq-dp}{gcd(p-1,q-1)}+k_{2}\frac{q-1}{gcd(p-1,q-1)}\)</span></p>
<p><span class="math inline">\(\Rightarrow k_{1}\frac{p-1}{gcd(p-1,q-1)}\equiv\frac{dq-dp}{gcd(p-1,q-1)}(mod\ \frac{q-1}{gcd(p-1,q-1)})\)</span></p>
<p><span class="math inline">\(\Leftrightarrow k_{1}\equiv invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{dq-dp}{gcd(p-1,q-1)}(mod\ \frac{q-1}{gcd(p-1,q-1)})\)</span></p>
<p>将<span class="math inline">\(k_{1}=k_{3}\frac{q-1}{gcd(p-1,q-1)}+invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{dq-dp}{gcd(p-1,q-1)}\)</span>代入<span class="math inline">\(d=k_{1}(p-1)+dp\)</span></p>
<p><span class="math inline">\(d=k_{3}\frac{(p-1)(q-1)}{gcd(p-1,q-1)}+invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{gcd(p-1,q-1)}+dp\)</span></p>
<p><span class="math inline">\(\Rightarrow d\equiv invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{gcd(p-1,q-1)}+dp(mod\ \frac{(p-1)(q-1)}{gcd(p-1,q-1)})\)</span></p>
<h4 id="exp-2">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(p, q, dp, dq)</span>:</span></span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    dd = int(gmpy2.gcd(p - <span class="number">1</span>, q - <span class="number">1</span>))</span><br><span class="line">    modules = phi // dd</span><br><span class="line">    d = int(gmpy2.invert((p - <span class="number">1</span>) // dd, (q - <span class="number">1</span>) // dd)) * \</span><br><span class="line">        (dq - dp) * (p - <span class="number">1</span>) // dd + dp</span><br><span class="line">    d %= modules</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> gmpy2.gcd(d, phi) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        d += modules</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = int(input(<span class="string">"p = "</span>))</span><br><span class="line">    q = int(input(<span class="string">"q = "</span>))</span><br><span class="line">    dp = int(input(<span class="string">"dp = "</span>))</span><br><span class="line">    dq = int(input(<span class="string">"dq = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = decrypt(p, q, dp, dq)</span><br><span class="line">    plaintext = long_to_bytes(pow(c, d, p * q))</span><br><span class="line">    print(plaintext)</span><br></pre></td></tr></table></figure>
<h4 id="sage">sage</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = crt(dp, dq, p - <span class="number">1</span>, q - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="rsa---wieners-attack">RSA - Wiener's Attack</h3>
<h4 id="theorem-3">Theorem</h4>
<p><span class="math display">\[
Let \ N=pq\ with\ q&lt;p&lt;2q. Let\ d&lt;\frac{1}{3}N^{\frac{1}{4}}.\\\\
Known (N,e),we\ can\ use\ Wiener&#39;s\ attack.\\\\
\]</span></p>
<hr>
<p><span class="math inline">\(Since\ ed\equiv 1(mod\ \varphi(N)),\exists k\in N,s.t.\ ed=k\varphi(N)+1\Rightarrow\left|\frac{e}{\varphi(N)}-\frac{k}{d}\right|=1.\)</span> From q&lt;p&lt;2q, it follows <span class="math inline">\(\sqrt{N}&lt;p&lt;\sqrt{2N}\)</span>, hence <span class="math inline">\(N-\varphi(N)=p+q-1=p+\frac{N}{p}-1&lt;\frac{3\sqrt{2}}{2}\sqrt{N}&lt;3\sqrt{N}\)</span> <span class="math inline">\(\therefore\left|\frac{e}{N}-\frac{k}{d}\right|=\left|\frac{ed-k\varphi(N)+k\varphi(N)-kN}{Nd}\right|=\left|\frac{1+k(\varphi(N)-N)}{Nd}\right|\leq\left|\frac{3k\sqrt{N}}{Nd}\right|=\left|\frac{3k}{\sqrt{N}d}\right|\)</span> <span class="math inline">\(\because k\varphi(N)=ed-1&lt;ed,\ e&lt;\varphi(N)\quad \therefore k\varphi(N)&lt;d\varphi(N)\rightarrow k&lt;d&lt;\frac{1}{3}N^{\frac{1}{4}}\)</span> <span class="math inline">\(\therefore\left|\frac{e}{N}-\frac{k}{d}\right|\leq\left|\frac{3k}{\sqrt{N}d}\right|&lt;\left|\frac{3k}{\sqrt{N}d}\right|&lt;\frac{1}{3d\cdot d}&lt;\frac{1}{2d^2}\)</span></p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/image-20200122234635721.png"></p>
<p>Therefore,we can get <span class="math inline">\(\frac{k}{d}\)</span> from the convergents of <span class="math inline">\(\frac{e}{N}\)</span>.</p>
<h4 id="exp-3">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rational_to_quotients</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    a = x // y</span><br><span class="line">    quotients = [a]</span><br><span class="line">    <span class="keyword">while</span> a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        quotients.append(a)</span><br><span class="line">    <span class="keyword">return</span> quotients</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents_from_quotients</span><span class="params">(quotients)</span>:</span></span><br><span class="line">    convergents = [(quotients[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(quotients) + <span class="number">1</span>):</span><br><span class="line">        quotients_partion = quotients[<span class="number">0</span>:i]</span><br><span class="line">        denom = quotients_partion[<span class="number">-1</span>]  <span class="comment"># 分母</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">-2</span>, -len(quotients_partion), <span class="number">-1</span>):</span><br><span class="line">            num, denom = denom, quotients_partion[_] * denom + num</span><br><span class="line">        num += denom * quotients_partion[<span class="number">0</span>]</span><br><span class="line">        convergents.append((num, denom))</span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WienerAttack</span><span class="params">(e, n)</span>:</span></span><br><span class="line">    quotients = rational_to_quotients(e, n)</span><br><span class="line">    convergents = convergents_from_quotients(quotients)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">and</span> <span class="keyword">not</span> (e * d - <span class="number">1</span>) % k:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            <span class="comment"># check if (x^2 - coef * x + n = 0) has integer roots</span></span><br><span class="line">            coef = n - phi + <span class="number">1</span></span><br><span class="line">            delta = coef * coef - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> delta &gt; <span class="number">0</span> <span class="keyword">and</span> gmpy2.iroot(delta, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">                print(<span class="string">'d = '</span> + str(d))</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    e = int(input(<span class="string">"e = "</span>))</span><br><span class="line">    n = int(input(<span class="string">"n = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = WienerAttack(e, n)</span><br><span class="line">    plaintext = long_to_bytes(pow(c, d, n))</span><br><span class="line">    print(plaintext)</span><br></pre></td></tr></table></figure>
<h3 id="rsa---partial_m">RSA - Partial_m</h3>
<h4 id="theorem-4">Theorem</h4>
<p>求解一元同余方程的问题可以这样来表达：给定一个未知分解的合数N，b是N的一个因子（注意b是合数），且对一个已知的<span class="math inline">\(\beta(0&lt;\beta&lt;1)\)</span>，满足<span class="math inline">\(b\geq N^{\beta}\)</span>。给定一个度数为<span class="math inline">\(\delta\)</span>，首1的单变量多项式<span class="math inline">\(f_{b}(x)\in Z[X]\)</span>，在<span class="math inline">\(\delta\)</span>和N的比特长度的多项式函数时间内找到所有<span class="math inline">\(b|f_{b}(x)\)</span>的满足<span class="math inline">\(|x_{0}|\leq X\)</span>的根<span class="math inline">\(x_{0}\in Z\)</span>，X是<span class="math inline">\(x_{0}\)</span>的上界。目标是通过尽可能宽松的界X获得更大的解出x的可能性。</p>
<p><strong>定理1</strong> (Coppersmith 96)：<span class="math inline">\(N,b,\beta,f,\delta\)</span>定义同上。此时我们可以在<span class="math inline">\(O(c\delta^{5}log^{9}N)\)</span>内得到满足条件：</p>
<p><span class="math inline">\(|x_{0}|\leq \frac{1}{2}N^{\frac{\beta^{2}}{\delta}-\epsilon}\)</span></p>
<p>的，一元同余方程f(x)=0 mod b的解 (<span class="math inline">\(\epsilon\)</span>多取<span class="math inline">\(\frac{\beta}{7}\)</span>, 证明略)</p>
<p><strong>定理2</strong> (CopperSmith 96[2])：定理1在N=b时的特殊情况，可以在(log N,<span class="math inline">\(\delta\)</span>)的多项式时间内求出所有满足：</p>
<p><span class="math inline">\(|x_{0}|\leq N^{\frac{1}{\delta}}\)</span></p>
<p>的模等式<span class="math inline">\(f_{N}(x)=0\ mod\ N\)</span>的解</p>
<p><span class="math inline">\(\therefore\)</span> e足够小，且部分明文泄露时，可以采用coppersmith单变量模等式的攻击，如下：</p>
<p><span class="math inline">\(c:=m^{e}\ mod\ n=(mbar+x_{0})^{e}\ mod\ n\)</span> , (mbar = (m &gt;&gt; kbits) &lt;&lt; kbits)</p>
<p>定理2知，<span class="math inline">\(|x_{0}|\leq N^{\frac{1}{e}}\)</span>时，可以在logN和e的多项式时间内求出x</p>
<h4 id="exp-4">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">mbar = </span><br><span class="line">kbits = </span><br><span class="line"></span><br><span class="line">beta = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">nbits = n.nbits()</span><br><span class="line">print(<span class="string">"upper &#123;&#125; bits of &#123;&#125; bits is given"</span>.format(nbits - kbits, nbits))</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (mbar + x)^e - c</span><br><span class="line"></span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor = n</span></span><br><span class="line">print(<span class="string">"m:"</span>, mbar + x0)</span><br></pre></td></tr></table></figure>
<h4 id="note-1">Note</h4>
<p>m高位泄露是coppersmith的原版结论，实际上可以扩展到高位/低位/高低位泄露的一般情况</p>
<p><span class="math inline">\(m=M+x_{0}\cdot 2^{k}+M&#39;\)</span></p>
<p><span class="math inline">\(f_{n}(x):=(M+x_{0}\cdot 2^{k}+M&#39;)^{e}-c\)</span></p>
<p>化为首1即可sage求解（只要未知明文<span class="math inline">\(|x_{0}|\leq N^{\frac{1}{e}}\)</span>）</p>
<h3 id="rsa---partial_p">RSA - Partial_p</h3>
<h4 id="theorem-5">Theorem</h4>
<p><strong>定理3</strong> (Coppersmith: kp高位比特)：<span class="math inline">\(p&gt;q,k\in N^{*},q\nmid k\)</span>，如果对于kp的一个估计值<span class="math inline">\(\widetilde{p}\)</span>满足<span class="math inline">\(|kp-\widetilde{p}|\leq 2N^{\frac{1}{4}}\)</span></p>
<p>那么在多项式时间内可以得到N的分解</p>
<p>Proof：</p>
<p><span class="math inline">\(f_{p}(x):=x+\widetilde{p}\)</span>的一个解<span class="math inline">\(x_{0}=(kp-\widetilde{p})\ mod\ p\)</span> 满足<span class="math inline">\(x_{0}\leq 2N^{\frac{1}{4}}\)</span>。该多项式首1，且<span class="math inline">\(p\geq N^{\frac{1}{2}}\)</span>，由定理1知该方程有解</p>
<p>往一般形式上推广，发现p的低位比特泄露也能使用coppersmith攻击，化为首1即可，可类比partial_m的扩展形式</p>
<h4 id="exp-5">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">pbar = </span><br><span class="line">kbits = </span><br><span class="line"></span><br><span class="line">print(<span class="string">"upper %d bits (of %d bits) is given"</span> % (pbar.nbits()-kbits, pbar.nbits()))</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + pbar</span><br><span class="line"></span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line">p = x0 + pbar</span><br><span class="line">print(<span class="string">"p:"</span>, p)</span><br><span class="line">q = n // int(p)</span><br><span class="line">d = inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">print(<span class="string">"m:"</span>, pow(c, d, n))</span><br></pre></td></tr></table></figure>
<h4 id="note-2">Note</h4>
<p>sage的small_root传参X不能过大，需自行判断阈值并调整（如果X过大，即使存在X内的解，也无法求出）</p>
<p>比如p的低位泄露时因为不确定缺失高位的具体比特数，所以要在<span class="math inline">\(2^{\frac{n.nbits()}{2}-kbits}\)</span>附近作X的阈值估计</p>
<p>无法确定拿到的p是否大于q，所以对<span class="math inline">\(\beta=0.5\)</span>进行调整至0.4</p>
<h3 id="rsa---partial_d">RSA - Partial_d</h3>
<h4 id="theorem-6">Theorem</h4>
<p>Given the <span class="math inline">\(\frac{n.nbits()}{4}\)</span> least significant bits of d，we can compute all of d in polynomial time in n and e.</p>
<p>Proof：</p>
<p><span class="math inline">\(s \leftarrow p+q\)</span>，<span class="math inline">\(ed=1+k\phi (n)=1+k(n-s+1)\)</span></p>
<p><span class="math inline">\(\therefore ed_{0}\equiv 1+k(n-s+1)\ mod\ 2^{\frac{n}{4}}\quad (1)\)</span></p>
<p><span class="math inline">\(\because p^{2}-sp+n\equiv 0\ mod\ 2^{\frac{n}{4}}\quad (2)\)</span></p>
<p><span class="math inline">\(\therefore p\cdot(1),k\cdot(2)\rightarrow ed_{0}p\equiv p+kpn-kp^{2}-kn+kp\ mod\ 2^{\frac{n}{4}}\quad (2)\)</span></p>
<p><span class="math inline">\(\therefore\)</span>解一元同余方程<span class="math inline">\(ed_{0}x-kx(n-x+1)+kn\equiv x\ (mod\ 2^{d_{0}.nbits()})\)</span>即可得到p的部分低位<span class="math inline">\(p_{0}\)</span></p>
<p>问题转化为partial_p</p>
<h4 id="exp-6">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span><span class="params">(p0, kbits, n)</span>:</span></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    f = <span class="number">2</span>^kbits*x + p0</span><br><span class="line">    f = f.monic()</span><br><span class="line">    roots = f.small_roots(X=<span class="number">2</span>^(nbits//<span class="number">2</span>-kbits), beta=<span class="number">0.4</span>)  <span class="comment"># find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.4</span></span><br><span class="line">    <span class="keyword">if</span> roots:</span><br><span class="line">        x0 = roots[<span class="number">0</span>]</span><br><span class="line">        p = gcd(<span class="number">2</span>^kbits*x0 + p0, n)</span><br><span class="line">        <span class="keyword">return</span> ZZ(p)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span><span class="params">(d0, kbits, e, n)</span>:</span></span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        results = solve_mod([e*d0*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            p0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            p = partial_p(p0, kbits, n)</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> p != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    d0 = </span><br><span class="line">    beta = <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    kbits = d0.nbits()</span><br><span class="line">    print(<span class="string">"lower %d bits (of %d bits) is given"</span> % (kbits, nbits))</span><br><span class="line"></span><br><span class="line">    p = int(find_p(d0, kbits, e, n))</span><br><span class="line">    print(<span class="string">"found p: %d"</span> % p)</span><br><span class="line">    q = n//int(p)</span><br><span class="line">    print(<span class="string">"d:"</span>, inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>)))</span><br></pre></td></tr></table></figure>
<p>### RSA - Short Pad Attack &amp; Related Message Attack</p>
<h4 id="theorem-7">Theorem</h4>
<p>当padding长度<span class="math inline">\(m\in (0,\lfloor\frac{n.nbits()}{e^{2}}\rfloor]\)</span>时，<span class="math inline">\(g_{1}=x^{e}-c_{1},g_{2} = (x+y)^{e}-c_{2}\)</span>，可以先用结式求解上述二元高次方程组</p>
<p><strong>定理4</strong>：如果<span class="math inline">\((x_{0},y_{0})\)</span>是方程组<span class="math display">\[\left\{\begin{aligned}f(x,y)=0\\\\g(x,y)=0\end{aligned}\right.\]</span>的解，则<span class="math inline">\(y_{0}\)</span>是<span class="math inline">\(Res_{x}(f,g)\)</span>的一个根</p>
<p>sage里可以用resultant来实现结式计算，<span class="math inline">\(g_{1}.resultant(g_{2})\)</span>默认将结式以第二个变量来表示，也可以指定<span class="math inline">\(g_{1}.resultant(g_{2},y)\)</span>来将结式以x表示</p>
<p>求出y后，采用Related Message Attack，简要概括就是求解<span class="math inline">\(gcd(g_{1},g_{2})\)</span>，如果结果是线性的，则攻击成功(<span class="math inline">\(x=-gcd(g_{1}, g_{2})[0]\)</span>)</p>
<h4 id="exp-7">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_pad_attack</span><span class="params">(c1, c2, e, n)</span>:</span></span><br><span class="line">    PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+y)^e - c2</span><br><span class="line"></span><br><span class="line">    q1 = g1.change_ring(PRZZ)</span><br><span class="line">    q2 = g2.change_ring(PRZZ)</span><br><span class="line"></span><br><span class="line">    h = q2.resultant(q1)</span><br><span class="line">    h = h.univariate_polynomial()</span><br><span class="line">    h = h.change_ring(PRx).subs(y=xn)</span><br><span class="line">    h = h.monic()</span><br><span class="line"></span><br><span class="line">    kbits = n.nbits()//(<span class="number">2</span>*e*e)</span><br><span class="line">    diff = h.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diff</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">related_message_attack</span><span class="params">(c1, c2, diff, e, n)</span>:</span></span><br><span class="line">    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+diff)^e - c2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(g1, g2)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        <span class="keyword">return</span> g1.monic()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -gcd(g1, g2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line"></span><br><span class="line">    c1 =</span><br><span class="line">    c2 = </span><br><span class="line"></span><br><span class="line">    diff = short_pad_attack(c1, c2, e, n)</span><br><span class="line">    print(<span class="string">"difference of two messages is %d"</span> % diff)</span><br><span class="line"></span><br><span class="line">    m1 = related_message_attack(c1, c2, diff, e, n)</span><br><span class="line">    print(<span class="string">"m1:"</span>, m1)</span><br><span class="line">    print(<span class="string">"m2:"</span>, m1 + diff)</span><br></pre></td></tr></table></figure>
<h4 id="note-3">Note</h4>
<p>exp的change_ring缺失即报错，但同环下转换的具体原因，估计要翻sage手册orz</p>
<h3 id="rsa---boneh-durfee-attack">RSA - Boneh Durfee Attack</h3>
<h4 id="theorem-8">Theorem</h4>
<p>比维纳攻击强度更高的小私钥攻击</p>
<p>引用ctf-wiki上的简略推导过程：</p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/image-20200218203256633.png"></p>
<p>后续应该用到了coppersmith对于多元模等式的攻击（坑有点儿深，具体证明略）</p>
<h4 id="exp-8">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Config</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Setting debug to true will display more informations</span></span><br><span class="line"><span class="string">about the lattice, the bounds, the vectors...</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Setting strict to true will stop the algorithm (and</span></span><br><span class="line"><span class="string">return (-1, -1)) if we don't have a correct </span></span><br><span class="line"><span class="string">upperbound on the determinant. Note that this </span></span><br><span class="line"><span class="string">doesn't necesseraly mean that no solutions </span></span><br><span class="line"><span class="string">will be found since the theoretical upperbound is</span></span><br><span class="line"><span class="string">usualy far away from actual results. That is why</span></span><br><span class="line"><span class="string">you should probably use `strict = False`</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">strict = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is experimental, but has provided remarkable results</span></span><br><span class="line"><span class="string">so far. It tries to reduce the lattice as much as it can</span></span><br><span class="line"><span class="string">while keeping its efficiency. I see no reason not to use</span></span><br><span class="line"><span class="string">this option, but if things don't work, you should try</span></span><br><span class="line"><span class="string">disabling it</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">helpful_only = <span class="literal">True</span></span><br><span class="line">dimension_min = <span class="number">7</span> <span class="comment"># stop removing if lattice reaches that dimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Functions</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># display stats on helpful vectors</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helpful_vectors</span><span class="params">(BB, modulus)</span>:</span></span><br><span class="line">    nothelpful = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> BB[ii,ii] &gt;= modulus:</span><br><span class="line">            nothelpful += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(nothelpful, <span class="string">"/"</span>, BB.dimensions()[<span class="number">0</span>], <span class="string">" vectors are not helpful"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># display matrix picture with 0 and X</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_overview</span><span class="params">(BB, bound)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = (<span class="string">'%02d '</span> % ii)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            a += <span class="string">'0'</span> <span class="keyword">if</span> BB[ii,jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">'X'</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">' '</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            a += <span class="string">'~'</span></span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tries to remove unhelpful vectors</span></span><br><span class="line"><span class="comment"># we start at current = n-1 (last vector)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_unhelpful</span><span class="params">(BB, monomials, bound, current)</span>:</span></span><br><span class="line">    <span class="comment"># end of our recursive function</span></span><br><span class="line">    <span class="keyword">if</span> current == <span class="number">-1</span> <span class="keyword">or</span> BB.dimensions()[<span class="number">0</span>] &lt;= dimension_min:</span><br><span class="line">        <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">    <span class="comment"># we start by checking from the end</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(current, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># if it is unhelpful:</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            affected_vectors = <span class="number">0</span></span><br><span class="line">            affected_vector_index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># let's check if it affects other vectors</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> range(ii + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                <span class="comment"># if another vector is affected:</span></span><br><span class="line">                <span class="comment"># we increase the count</span></span><br><span class="line">                <span class="keyword">if</span> BB[jj, ii] != <span class="number">0</span>:</span><br><span class="line">                    affected_vectors += <span class="number">1</span></span><br><span class="line">                    affected_vector_index = jj</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:0</span></span><br><span class="line">            <span class="comment"># if no other vectors end up affected</span></span><br><span class="line">            <span class="comment"># we remove it</span></span><br><span class="line">            <span class="keyword">if</span> affected_vectors == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"* removing unhelpful vector"</span>, ii)</span><br><span class="line">                BB = BB.delete_columns([ii])</span><br><span class="line">                BB = BB.delete_rows([ii])</span><br><span class="line">                monomials.pop(ii)</span><br><span class="line">                BB = remove_unhelpful(BB, monomials, bound, ii<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:1</span></span><br><span class="line">            <span class="comment"># if just one was affected we check</span></span><br><span class="line">            <span class="comment"># if it is affecting someone else</span></span><br><span class="line">            <span class="keyword">elif</span> affected_vectors == <span class="number">1</span>:</span><br><span class="line">                affected_deeper = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> kk <span class="keyword">in</span> range(affected_vector_index + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                    <span class="comment"># if it is affecting even one vector</span></span><br><span class="line">                    <span class="comment"># we give up on this one</span></span><br><span class="line">                    <span class="keyword">if</span> BB[kk, affected_vector_index] != <span class="number">0</span>:</span><br><span class="line">                        affected_deeper = <span class="literal">False</span></span><br><span class="line">                <span class="comment"># remove both it if no other vector was affected and</span></span><br><span class="line">                <span class="comment"># this helpful vector is not helpful enough</span></span><br><span class="line">                <span class="comment"># compared to our unhelpful one</span></span><br><span class="line">                <span class="keyword">if</span> affected_deeper <span class="keyword">and</span> abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]):</span><br><span class="line">                    print(<span class="string">"* removing unhelpful vectors"</span>, ii, <span class="string">"and"</span>, affected_vector_index)</span><br><span class="line">                    BB = BB.delete_columns([affected_vector_index, ii])</span><br><span class="line">                    BB = BB.delete_rows([affected_vector_index, ii])</span><br><span class="line">                    monomials.pop(affected_vector_index)</span><br><span class="line">                    monomials.pop(ii)</span><br><span class="line">                    BB = remove_unhelpful(BB, monomials, bound, ii<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> BB</span><br><span class="line">    <span class="comment"># nothing happened</span></span><br><span class="line">    <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">* 0,0   if it fails</span></span><br><span class="line"><span class="string">* -1,-1 if `strict=true`, and determinant doesn't bound</span></span><br><span class="line"><span class="string">* x0,y0 the solutions of `pol`</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boneh_durfee</span><span class="params">(pol, modulus, mm, tt, XX, YY)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Boneh and Durfee revisited by Herrmann and May</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    finds a solution if:</span></span><br><span class="line"><span class="string">    * d &lt; N^delta</span></span><br><span class="line"><span class="string">    * |x| &lt; e^delta</span></span><br><span class="line"><span class="string">    * |y| &lt; e^0.5</span></span><br><span class="line"><span class="string">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># substitution (Herrman and May)</span></span><br><span class="line">    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    Q = PR.quotient(x*y + <span class="number">1</span> - u) <span class="comment"># u = xy + 1</span></span><br><span class="line">    polZ = Q(pol).lift()</span><br><span class="line"></span><br><span class="line">    UU = XX*YY + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts</span></span><br><span class="line">    gg = []</span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> range(mm + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> range(mm - kk + <span class="number">1</span>):</span><br><span class="line">            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk</span><br><span class="line">            gg.append(xshift)</span><br><span class="line">    gg.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts list of monomials</span></span><br><span class="line">    monomials = []</span><br><span class="line">    <span class="keyword">for</span> polynomial <span class="keyword">in</span> gg:</span><br><span class="line">        <span class="keyword">for</span> monomial <span class="keyword">in</span> polynomial.monomials():</span><br><span class="line">            <span class="keyword">if</span> monomial <span class="keyword">not</span> <span class="keyword">in</span> monomials:</span><br><span class="line">                monomials.append(monomial)</span><br><span class="line">    monomials.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts (selected by Herrman and May)</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> range(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)</span><br><span class="line">            yshift = Q(yshift).lift()</span><br><span class="line">            gg.append(yshift) <span class="comment"># substitution</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts list of monomials</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> range(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            monomials.append(u^kk * y^jj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice B</span></span><br><span class="line">    nn = len(monomials)</span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(nn):</span><br><span class="line">        BB[ii, <span class="number">0</span>] = gg[ii](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, ii + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> gg[ii].monomials():</span><br><span class="line">                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prototype to reduce the lattice</span></span><br><span class="line">    <span class="keyword">if</span> helpful_only:</span><br><span class="line">        <span class="comment"># automatically remove</span></span><br><span class="line">        BB = remove_unhelpful(BB, monomials, modulus^mm, nn<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># reset dimension</span></span><br><span class="line">        nn = BB.dimensions()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> nn == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"failure"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if vectors are helpful</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        helpful_vectors(BB, modulus^mm)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># check if determinant is correctly bounded</span></span><br><span class="line">    det = BB.det()</span><br><span class="line">    bound = modulus^(mm*nn)</span><br><span class="line">    <span class="keyword">if</span> det &gt;= bound:</span><br><span class="line">        print(<span class="string">"We do not have det &lt; bound. Solutions might not be found."</span>)</span><br><span class="line">        print(<span class="string">"Try with highers m and t."</span>)</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            diff = (log(det) - log(bound)) / log(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">"size det(L) - size e^(m*n) = "</span>, floor(diff))</span><br><span class="line">        <span class="keyword">if</span> strict:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display the lattice basis</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        matrix_overview(BB, modulus^mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"optimizing basis of the lattice via LLL, this can take a long time"</span>)</span><br><span class="line"></span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"LLL is done!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"looking for independent vectors in the lattice"</span>)</span><br><span class="line">    found_polynomials = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pol1_idx <span class="keyword">in</span> range(nn - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> pol2_idx <span class="keyword">in</span> range(pol1_idx + <span class="number">1</span>, nn):</span><br><span class="line">            <span class="comment"># for i and j, create the two polynomials</span></span><br><span class="line">            PR.&lt;w,z&gt; = PolynomialRing(ZZ)</span><br><span class="line">            pol1 = pol2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> range(nn):</span><br><span class="line">                pol1 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line">                pol2 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># resultant</span></span><br><span class="line">            PR.&lt;q&gt; = PolynomialRing(ZZ)</span><br><span class="line">            rr = pol1.resultant(pol2)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># are these good polynomials?</span></span><br><span class="line">            <span class="keyword">if</span> rr.is_zero() <span class="keyword">or</span> rr.monomials() == [<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"found them, using vectors"</span>, pol1_idx, <span class="string">"and"</span>, pol2_idx)</span><br><span class="line">                found_polynomials = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found_polynomials:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found_polynomials:</span><br><span class="line">        print(<span class="string">"no independant vectors could be found. This should very rarely happen..."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    rr = rr(q, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># solutions</span></span><br><span class="line">    soly = rr.roots()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(soly) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Your prediction (delta) is too small"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    soly = soly[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    ss = pol1(q, soly)</span><br><span class="line">    solx = ss.roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">return</span> solx, soly</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">############################################</span></span><br><span class="line">    <span class="comment"># How To Use This Script</span></span><br><span class="line">    <span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># The problem to solve (edit the following values)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the modulus</span></span><br><span class="line">    N = <span class="number">0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27</span></span><br><span class="line">    <span class="comment"># the public exponent</span></span><br><span class="line">    e = <span class="number">0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb</span></span><br><span class="line">    c = <span class="number">0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the hypothesis on the private exponent (the theoretical maximum is 0.292)</span></span><br><span class="line">    delta = <span class="number">.28</span> <span class="comment"># this means that d &lt; N^delta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Lattice (tweak those values)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># you should tweak this (after a first run), (e.g. increment it until a solution is found)</span></span><br><span class="line">    m = <span class="number">4</span> <span class="comment"># size of the lattice (bigger the better/slower)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># you need to be a lattice master to tweak these</span></span><br><span class="line">    t = int((<span class="number">1</span><span class="number">-2</span>*delta) * m)  <span class="comment"># optimization from Herrmann and May</span></span><br><span class="line">    X = <span class="number">2</span>*floor(N^delta)  <span class="comment"># this _might_ be too much</span></span><br><span class="line">    Y = floor(N^(<span class="number">1</span>/<span class="number">2</span>))    <span class="comment"># correct if p, q are ~ same size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Don't touch anything below</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Problem put in equation</span></span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    A = int((N+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    pol = <span class="number">1</span> + x * (A + y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Find the solutions!</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Checking bounds</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== checking values ==="</span>)</span><br><span class="line">        print(<span class="string">"* delta:"</span>, delta)</span><br><span class="line">        print(<span class="string">"* delta &lt; 0.292"</span>, delta &lt; <span class="number">0.292</span>)</span><br><span class="line">        print(<span class="string">"* size of e:"</span>, int(log(e)/log(<span class="number">2</span>)))</span><br><span class="line">        print(<span class="string">"* size of N:"</span>, int(log(N)/log(<span class="number">2</span>)))</span><br><span class="line">        print(<span class="string">"* m:"</span>, m, <span class="string">", t:"</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># boneh_durfee</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== running algorithm ==="</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">    solx, soly = boneh_durfee(pol, e, m, t, X, Y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># found a solution?</span></span><br><span class="line">    <span class="keyword">if</span> solx &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"=== solution found ==="</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">False</span>:</span><br><span class="line">            print(<span class="string">"x:"</span>, solx)</span><br><span class="line">            print(<span class="string">"y:"</span>, soly)</span><br><span class="line"></span><br><span class="line">        d = int(pol(solx, soly) / e)</span><br><span class="line">        print(<span class="string">"private key found:"</span>, d)</span><br><span class="line">        print(<span class="string">"plaintext:"</span>, pow(c, d, N))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"=== no solution was found ==="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== %s seconds ==="</span> % (time.time() - start_time))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    example()</span><br></pre></td></tr></table></figure>
<h3 id="rsa---gcdevarphinneq-1">RSA - <span class="math inline">\(gcd(e,\varphi(n)\neq 1)\)</span></h3>
<h4 id="theorem-9">Theorem</h4>
<p><span class="math inline">\(gcd(e,\varphi(n))\neq 1\)</span>时，<span class="math inline">\(e&#39;\leftarrow e//gcd(e,\varphi(n)),d\leftarrow invert(e&#39;,\varphi(n))\)</span>，<span class="math inline">\(c^{d}\equiv m^{gcd(e,\varphi(n))}\ mod\ n\)</span></p>
<p>已知<span class="math inline">\(m^{gcd(e,\varphi(n))}\)</span>后攻击方向不定，视题目而定</p>
<h4 id="example">Example</h4>
<p>De1CTF2019 - Baby RSA</p>
<p>最后步骤的加密：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(c1==pow(flag,e1,p*q1))</span><br><span class="line"><span class="keyword">assert</span>(c2==pow(flag,e2,p*q2))</span><br></pre></td></tr></table></figure>
<p>p, q1, q2 均为素数，<span class="math inline">\(f_{1}=gcd(e_{1},\varphi(pq_{1}))\neq 1,f_{2}=gcd(e_{2},\varphi(pq_{2}))\neq 1\)</span></p>
<p>但发现<span class="math inline">\(gcd(e_{1},\varphi(pq_{1}))=gcd(e_{2},\varphi(pq_{2}))=14\)</span>，于是可以用ext_gcd求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="comment"># mi,ai分别表示模数和取模后的值,都为列表结构</span></span><br><span class="line">    curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">        d = gmpy2.gcd(curm, m)</span><br><span class="line">        c = a - cura</span><br><span class="line">        <span class="keyword">assert</span> (c % d == <span class="number">0</span>) <span class="comment">#不成立则不存在解</span></span><br><span class="line">        K = c // d * gmpy2.invert(curm // d, m // d)</span><br><span class="line">        cura += curm * K</span><br><span class="line">        curm = curm * m // d</span><br><span class="line">        cura %= curm</span><br><span class="line">    <span class="keyword">return</span> (cura % curm, curm) <span class="comment">#(解,最小公倍数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f3, lcm = GCRT([n1, n2], [f1, f2])</span><br><span class="line"><span class="keyword">assert</span>(f3 % n1 == f1)</span><br><span class="line"><span class="keyword">assert</span>(f3 % n2 == f2)</span><br><span class="line"><span class="keyword">assert</span>(lcm == q1*q2*p)</span><br></pre></td></tr></table></figure>
<p>又发现gcd=14的因子7来自p，所以令<span class="math inline">\(n_{3}=q_{1}\cdot q_{2},c_{3}=f_{3}\%n_{3}\)</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d3 = gmpy2.invert(<span class="number">7</span>, phi3)</span><br><span class="line">m3 = pow(c3, d3, n3)</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(m_{3}\equiv m^{2}\ mod\ n_{3}\)</span></p>
<p>作小公钥指数的爆破即可.</p>
<p>但m如果太大时，就要用到一些有限域上开二次根的算法，在本文后面会有所提及.</p>
<h3 id="rsa---polynomial-based-rsa">RSA - Polynomial based RSA</h3>
<h4 id="theorem-10">Theorem</h4>
<p>设p为素数，<span class="math inline">\(F_{p}\)</span>为p元有限域，<span class="math inline">\(F_{p}\)</span>上多项式形式的RSA是基于<span class="math inline">\(F_{p}\)</span>上多项式的一个已知定理，可类比欧拉定理</p>
<p>设<span class="math inline">\(F_{p}[x]\)</span>是<span class="math inline">\(F_{p}\)</span>上的一元多项式环，P和Q为<span class="math inline">\(F_{p}(x)\)</span>上的既约多项式，<span class="math inline">\(N=P\cdot Q\)</span>，<span class="math inline">\(F_{p}[x]\)</span>的模N商环下的多项式M满足gcd(M,N)=1</p>
<p>则<span class="math inline">\(M^{\varphi(N)}=1\)</span>（对于多项式下的<span class="math inline">\(\varphi(N)\)</span>，不同于ZZ上RSA的<span class="math inline">\((p-1)\cdot (q-1)\)</span>，但基本定义相同，即度小于degree(N)的所有满足gcd(*,N)的多项式*）</p>
<p><span class="math inline">\(\because\)</span> P, Q均为既约多项式， <span class="math inline">\(\therefore\varphi(P)=p^{P.degree()}-1,\varphi(Q)=p^{Q.degree()}-1,\varphi(N)=(p^{P.degree()}-1)\cdot (p^{Q.degree()}-1)\)</span></p>
<p>加密过程中，明文m的多项式表示方法大致有以下两种：</p>
<ol type="1">
<li><p>对应ascii码作多项式系数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_irreducable_poly</span><span class="params">(deg)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        out = R.random_element(degree=deg)</span><br><span class="line">        <span class="keyword">if</span> out.is_irreducible():</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line">       </span><br><span class="line">P = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line">Q = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">N = P*Q</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">'xxxx'</span></span><br><span class="line">flag = list(bytearray(flag.encode()))</span><br><span class="line">m = S(flag)</span><br><span class="line">c = m^e</span><br></pre></td></tr></table></figure></li>
<li><p>在<span class="math inline">\(GF(p^{nbits})\)</span>上fetch_int</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P.&lt;x&gt;=PolynomialRing(GF(p))</span><br><span class="line"><span class="comment">## 略去P,Q,N生成代码</span></span><br><span class="line">R.&lt;y&gt; = GF(p^<span class="number">2049</span>)</span><br><span class="line">m_int = Integer(bytes_to_long(flag))</span><br><span class="line">m_poly = P(R.fetch_int(m_int))</span><br><span class="line">c_poly = pow(m_poly, e, n)</span><br><span class="line">c_int = R(c_poly).integer_representation()</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="exp-9">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line">N = </span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">p, q = N.factor()</span><br><span class="line">p, q = p[<span class="number">0</span>], q[<span class="number">0</span>]</span><br><span class="line">phi = (p**P.degree()<span class="number">-1</span>)*(p**Q.degree()<span class="number">-1</span>)</span><br><span class="line">e = </span><br><span class="line">d = inverse_mod(e, phi)</span><br><span class="line"></span><br><span class="line">m = c^d</span><br><span class="line">print(<span class="string">""</span>.join([chr(c) <span class="keyword">for</span> c <span class="keyword">in</span> m.list()]))</span><br></pre></td></tr></table></figure>
<h3 id="rsa---large-common-factor-of-p-1-and-q-1">RSA - Large Common Factor of p-1 and q-1</h3>
<h4 id="theorem-11">Theorem</h4>
<p>Given <span class="math inline">\(N=pq,g|(p-1),g|(q-1)\)</span>. (We call it common prime RSA)</p>
<p>If g is large enough, we have an efficient factoring method for N. (魔改rho)</p>
<p>[可行分析]</p>
<p><span class="math inline">\(p-1=ga,q-1=gb,N-1=gh(h=gab+a+b)\)</span> <span class="math inline">\(\therefore x^{N-1}\ (mod\ p)\)</span>至多有a个值 <span class="math inline">\(\therefore\)</span>用<span class="math inline">\(x\rightarrow x^{N-1}+3\)</span>代替rho中的迭代函数，能在<span class="math inline">\(O(\sqrt a)=O(N^{1/4-\gamma /2})\)</span>下分解N.</p>
<h4 id="exp-10">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (pow(x, n - <span class="number">1</span>, n) + <span class="number">3</span>) % n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rho</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomRange(<span class="number">2</span>, n)</span><br><span class="line">        b = f(a, n)</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            p = GCD(abs(a - b), n)</span><br><span class="line">            print(<span class="string">'&#123;&#125; in &#123;&#125; circle'</span>.format(j, i))</span><br><span class="line">            <span class="keyword">if</span> p == n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = f(a, n)</span><br><span class="line">                b = f(f(b, n), n)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">2062899536811871554818178359324161185631864322612928428737135410318396234838612759353304630466467882907238599097155276236974469077407927587176395102072905755064272779705304103155044175760772870357960042973800466612294120431806053764425995115279842108284227580763784948966673592802930476849233889221985236020626654664840038198318033843640935727802767372332931755961464416884826343968074190784107977317020369409515252779597705798495979144688260140280406347997234735504377161004933444363855269475346955181189441066456092467816293921375731674289071178645028262851698651731976240122083422857066357348367076175249101149547</span></span><br><span class="line">    print(rho(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="more">More</h4>
<p>common prime RSA在g过小时，g也能轻易通过分解N-1来解出（rho等算法分解出的小因子尝试即可）</p>
<p>关于这类的题型我还没在CTF赛题中见到过，下面给出生成的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_prime</span><span class="params">(nbits, gamma)</span>:</span></span><br><span class="line">    g = <span class="number">2</span> * getPrime(int(nbits * gamma))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">        p = g * a + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            b = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">            q = g * b + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> isPrime(q) <span class="keyword">or</span> GCD(a, b) != <span class="number">1</span>:</span><br><span class="line">                b = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">                q = g * b + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_key</span><span class="params">(nbits, gamma)</span>:</span></span><br><span class="line">    p, q = gen_prime(nbits, gamma)</span><br><span class="line">    n = p * q</span><br><span class="line">    lcm = (p * q) // GCD(p, q)</span><br><span class="line">    e = getPrime(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">while</span> GCD(e, lcm) != <span class="number">1</span>:</span><br><span class="line">        e = getPrime(<span class="number">16</span>)</span><br><span class="line">    d = inverse(e, lcm)</span><br><span class="line">    <span class="keyword">return</span> (n, e), (p, q, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    (n, e), (p, q, d) = gen_key(<span class="number">2048</span>, <span class="number">0.485</span>)</span><br><span class="line">    print(<span class="string">'n ='</span>, n)</span><br><span class="line">    print(<span class="string">'p ='</span>, p)</span><br><span class="line">    print(<span class="string">'q ='</span>, q)</span><br><span class="line">    print(<span class="string">'e ='</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="rsa---small-crt-private-exponents">RSA - Small CRT Private Exponents</h3>
<h4 id="theorem-12">Theorem</h4>
<p>平衡的RSA-CRT密码系统下，q&lt;p&lt;2q. 且满足<span class="math inline">\(ed_{p}\equiv 1(mod\ p-1),ed_{q}\equiv 1(mod\ q-1)\)</span></p>
<p>则<span class="math inline">\(d_{p},d_{q}&lt;min\\{\frac{1}{4}(\frac{N}{e})^{\frac{2}{5}},\frac{1}{3}N^{\frac{1}{4}}\\}\)</span>成立时，可有效破解RSA-CRT算法. <span class="math display">\[
\because ed_{p}=1+k(p-1),ed_{q}=1+l(q-1)\\\\
\therefore e^{2}d_{p}d_{q}+kl(1-N)+e(d_{p}(l-1)+d_{q}(k-1))=k+l-1.\\\\
令x=d_{p}(l-1)+d_{q}(k-1),y=kl,z=k+l-1,\omega =d_{p}d_{q}\\\\
有ex+(1-N)y+e^{2}\omega = z,矩阵表示下则为
\]</span> <img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-15_22-34-31.png"></p>
<p>构造一组基如下：</p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-15_22-36-36.png"></p>
<p>我们有如下结论：</p>
<p>记<span class="math inline">\(v_{0}=(4ex,4N^{\frac{1}{2}}y,e^{\frac{3}{5}}N^{\frac{2}{5}}z)\)</span>. 则可以看出<span class="math inline">\(v_{0}\)</span>一定是L约化基的三个行向量的线性组合.</p>
<p>LLL计算后的约化基<span class="math inline">\(\\{b_{1},b_{2},b_{3}\\}\)</span>，选取一个适当的上界M，令<span class="math inline">\(|a_{i}|\leq M\)</span>, 则验证线性组合<span class="math inline">\(v=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}\)</span>对应的<span class="math inline">\(x,y,z,\omega\)</span>，看得到的数据能否正确分解N即可.</p>
<p>M视具体情况而定</p>
<h4 id="exp-11">exp</h4>
<p>暂无（因为生成满足要求的<span class="math inline">\(d_{p},d_{q}\)</span>以及使对应的<span class="math inline">\(d&gt;N^{0.292}\)</span>有点困难）</p>
<h3 id="rsa---parity-oracle">RSA - Parity Oracle</h3>
<h4 id="theorem-13">Theorem</h4>
<p>假设存在一个oracle，能对给定密文进行解密并给出对应明文的奇偶信息，则我们只需要log(N)次就能解密任意密文.</p>
<p><span class="math inline">\(c\equiv m^{e}(mod\ N)\)</span>, 向oracle机发送<span class="math inline">\(2^{e}c\equiv (2m)^{e}(mod\ N)\)</span>,则返回奇时，说明<span class="math inline">\(2m&gt;N\)</span>，反之<span class="math inline">\(2m&lt;N\)</span></p>
<p>继续往下分析，此时发送<span class="math inline">\((2^{2})^{e}c(mod\ N)\)</span>, 如果先前返回奇，则此时等同于在校验<span class="math inline">\(2(2m-N)\)</span>与N的大小关系，即返回奇说明<span class="math inline">\(m\in (\frac{3N}{4},N)\)</span>，反之<span class="math inline">\(m\in (\frac{N}{2},\frac{3N}{4})\)</span>，先前返回偶的这一轮次不再分析</p>
<p>接下来轮次也类似，二分log(N)次即可.</p>
<h4 id="exp-12">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(c)</span>:</span></span><br><span class="line">    io = remote(<span class="string">'111.198.29.45'</span>, <span class="string">'42484'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'You can input ciphertext(hexdecimal) now\n'</span>)</span><br><span class="line">    c = hex(c)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> len(c) &amp; <span class="number">1</span>:</span><br><span class="line">        c = <span class="string">'0'</span> + c</span><br><span class="line">    io.sendline(c)</span><br><span class="line">    res = io.recvline(keepends=<span class="literal">False</span>)</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">assert</span>(res == <span class="string">b'odd'</span> <span class="keyword">or</span> res == <span class="string">b'even'</span>)</span><br><span class="line">    <span class="keyword">return</span> res == <span class="string">b'odd'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(c, e, n)</span>:</span></span><br><span class="line">    nbits = n.bit_length()</span><br><span class="line">    decimal.getcontext().prec = nbits</span><br><span class="line">    low = decimal.Decimal(<span class="number">0</span>)</span><br><span class="line">    high = decimal.Decimal(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nbits):</span><br><span class="line">        c = (c * pow(<span class="number">2</span>, e, n)) % n</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> oracle(c):</span><br><span class="line">            high = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = (low + high) / <span class="number">2</span></span><br><span class="line">        print(i, <span class="string">'/'</span>, nbits)</span><br><span class="line">    <span class="keyword">return</span> int(high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#c = int(input("c = "))</span></span><br><span class="line">    <span class="comment">#e = int(input("e = "))</span></span><br><span class="line">    <span class="comment">#n = int(input("n = "))</span></span><br><span class="line">    e = <span class="number">0x10001</span></span><br><span class="line">    n = <span class="number">0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db</span></span><br><span class="line">    c = <span class="number">0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0</span></span><br><span class="line">    m = partial(c, e, n)</span><br><span class="line">    print(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="rsa---williams-p1-and-pollards-p-1">RSA - William's p+1 and Pollard's p-1</h3>
<h4 id="theorem-14">Theorem</h4>
<p>如果要分解的N包含的素数因子p，使得p+1或p-1是平滑的（即只有适当上界的小因子），则William's p+1和Pollard's p-1算法能很好实现分解.</p>
<ul>
<li><p>William's p+1 Algorithm</p>
<p>Step 1：选择整数A(A&gt;2)来表征卢卡斯序列<span class="math inline">\(V_{j}=AV_{j-1}-V_{j-2}\)</span>，并初始化<span class="math inline">\(V_{0}=2,V_{1}=A\)</span>.</p>
<p>Step 2：计算序列到<span class="math inline">\(j=m!\)</span>.</p>
<p>​ ps：这步有很大的操作空间（在More里会涉及相关简化计算和证明）</p>
<p>Step 3：计算<span class="math inline">\(gcd(V_{j}-2,N)\)</span>，如果结果等于1或N，则m++并返回Step2，否则进入Step4.</p>
<p>Step 4：检查p+1是否是m!的因子，如果是，则说明找到的p是p+1平滑的.</p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-18_20-33-25.png"></p>
<p>因为我们事先不知道p，所以也就无从计算雅各比符号(D/p)，但平方非剩余概率趋于1/2，考虑选取多个A多线程即可（n个A就能使互斥事件的概率降到大约<span class="math inline">\(\frac{1}{2^{n}}\)</span>）</p></li>
<li><p>Pollard's p-1 Algorithm</p>
<p>p-1是B-smooth时，很大概率上<span class="math inline">\((p-1)|B!\)</span>（不考虑p-1有很多重复的趋近于B的质因子）</p>
<p>所以计算<span class="math inline">\(a^{m!}-1\)</span>，以及校验gcd即可，<span class="math inline">\(m_{max}\)</span>可以是B也可以适当上调.</p></li>
</ul>
<h4 id="exp-13">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">factor_state = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow_with_sqrt</span><span class="params">(a, c, b, n, mod)</span>:</span>  <span class="comment"># (a+c*sqrt(b))^n</span></span><br><span class="line">    states = [(a % mod, c % mod)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.log(n, <span class="number">2</span>))):</span><br><span class="line">        new_state = ((pow(states[i][<span class="number">0</span>], <span class="number">2</span>, mod) + b * pow(states[i][<span class="number">1</span>], <span class="number">2</span>, mod)) %</span><br><span class="line">                     mod, (<span class="number">2</span> * states[i][<span class="number">0</span>] * states[i][<span class="number">1</span>]) % mod)</span><br><span class="line">        states.append(new_state)</span><br><span class="line">    n_bin = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">    res_x = <span class="number">1</span></span><br><span class="line">    res_y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_bin)):</span><br><span class="line">        <span class="keyword">if</span> n_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">            res_x, res_y = (res_x * states[i][<span class="number">0</span>] + res_y * states[i][<span class="number">1</span>] *</span><br><span class="line">                            b) % mod, (res_x * states[i][<span class="number">1</span>] + res_y * states[i][<span class="number">0</span>]) % mod</span><br><span class="line">    <span class="keyword">return</span> res_x, res_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">william_factor</span><span class="params">(n, index)</span>:</span></span><br><span class="line">    start = time.clock()</span><br><span class="line">    <span class="keyword">global</span> factor_state</span><br><span class="line">    A = getRandomRange(<span class="number">3</span>, n)</span><br><span class="line">    <span class="comment">#m = 2</span></span><br><span class="line">    <span class="comment">#next_pos = 1</span></span><br><span class="line">    m = <span class="number">3000</span></span><br><span class="line">    next_pos = reduce(<span class="keyword">lambda</span> x, y : x * y, [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>)])</span><br><span class="line">    B = A**<span class="number">2</span> - <span class="number">4</span></span><br><span class="line">    <span class="comment">#res_x1, res_y1 = A, -1</span></span><br><span class="line">    <span class="comment">#res_x2, res_y2 = A, 1</span></span><br><span class="line">    res_x1, res_y1 = pow_with_sqrt(A, <span class="number">-1</span>, B, next_pos, n)</span><br><span class="line">    res_x2, res_y2 = pow_with_sqrt(A, <span class="number">1</span>, B, next_pos, n)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> factor_state == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print((index, m))</span><br><span class="line">        next_pos *= m <span class="comment">#next_pos = m!</span></span><br><span class="line">        C = inverse(pow(<span class="number">2</span>, next_pos, n), n)</span><br><span class="line">        res_x1, res_y1 = pow_with_sqrt(res_x1, res_y1, B, m, n)</span><br><span class="line">        res_x2, res_y2 = pow_with_sqrt(res_x2, res_y2, B, m, n)</span><br><span class="line">        res_x, res_y = (res_x1 + res_x2) % n, (res_y1 + res_y2) % n</span><br><span class="line">        <span class="keyword">assert</span>(iroot(B, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">False</span> <span class="keyword">and</span> res_y != n)</span><br><span class="line">        <span class="keyword">if</span> iroot(B, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            res_x = (res_x + res_y * iroot(B, <span class="number">2</span>)[<span class="number">0</span>]) % n</span><br><span class="line">        <span class="comment"># Vi = C((A-sqrt(B))^(m!)+(A+sqrt(B))^(m!))</span></span><br><span class="line">        Vi = (C * res_x) % n</span><br><span class="line">        p = GCD(Vi - <span class="number">2</span>, n)</span><br><span class="line">        <span class="keyword">assert</span>(p != n) <span class="comment">#p=n说明lucas序列下标过大</span></span><br><span class="line">        <span class="keyword">if</span> p != <span class="number">1</span>:</span><br><span class="line">            factor_state = <span class="literal">True</span></span><br><span class="line">            print(<span class="string">'p ='</span>, p)</span><br><span class="line">            end = time.clock()</span><br><span class="line">            print(<span class="string">'cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        m += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409</span></span><br><span class="line">    <span class="comment">#n = 112729</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=william_factor, args=(n, i))</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="more-1">More</h4>
<p>关于William's p+1 Algorithm的证明：</p>
<p>Lucas Functions：设<span class="math inline">\(\alpha,\beta\)</span>是<span class="math inline">\(x^{2}-Px+Q=0\)</span>的根，且有<img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_15-57-19.png" style="zoom:60%;"></p>
<p>则定义<span class="math inline">\(\Delta=(\alpha-\beta)^{2}=P^{2}-4Q\)</span>，知<span class="math inline">\(P=\alpha + \beta,Q=\alpha\beta\)</span>.</p>
<p>有如下定理：</p>
<p>p为奇素数，且<span class="math inline">\(p\nmid Q\)</span>，勒让德符号<span class="math inline">\((\frac{\Delta}{p})=\epsilon\)</span>，则有 <span class="math display">\[
U_{(p-\epsilon)m}(P,Q)\equiv 0(mod\ p)\\\\
V_{(p-\epsilon)m}(P,Q)\equiv 2Q^{\frac{m(1-\epsilon)}{2}}(mod\ p)
\]</span> 假设我们有p+1|R，Q=1，<span class="math inline">\((\frac{\Delta}{p})=\epsilon=-1\)</span>，则由上述定理可知： <span class="math display">\[
U_{R}(P,1)\equiv 0(mod\ p)\\\\
V_{R}(P,1)-2\equiv 0(mod\ p)
\]</span> 因为易推出<span class="math inline">\(V_{n+1}=PV_{n}-QV_{n-1}=PV_{n}-V_{n-1}\)</span>，则只要在该lucas序列下求出<span class="math inline">\(V_{R}\)</span>即可.</p>
<p>我上面的exp里取的R是<span class="math inline">\(m!(m\in N^{+})\)</span>，但m足够大时（如m=1000时，<span class="math inline">\(R≈2^{8000}\)</span>），逐项递推变得低效不可解.</p>
<p>因此简化思想如下：</p>
<p>上述Lucas序列对应通项为<span class="math inline">\(\frac{(P-\sqrt{P^{2}-4})^{n}+(P+\sqrt{P^{2}-4})^{n}}{2^{n}}\)</span>，先fuzz出一个m（m过大时，<span class="math inline">\(gcd(V_R-2,N)=N\)</span>），再从<span class="math inline">\(V_{m!}\)</span>开始p+1 factor即可，这里还应记住保留前状态<span class="math inline">\((P-\sqrt{P^{2}-4})^{(m-1)!}\)</span>，以便在求解<span class="math inline">\((P-\sqrt{P^{2}-4})^{m!}\)</span>时只要做前状态的m次幂。</p>
<p>这里也记录一下Coinc1dens师傅的出题笔记：</p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_17-28-56.png"></p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_17-28-41.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prime = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>,<span class="number">283</span>,<span class="number">293</span>,<span class="number">307</span>,<span class="number">311</span>,<span class="number">313</span>,<span class="number">317</span>,<span class="number">331</span>,<span class="number">337</span>,<span class="number">347</span>,<span class="number">349</span>,<span class="number">353</span>,<span class="number">359</span>,<span class="number">367</span>,<span class="number">373</span>,<span class="number">379</span>,<span class="number">383</span>,<span class="number">389</span>,<span class="number">397</span>,<span class="number">401</span>,<span class="number">409</span>,<span class="number">419</span>,<span class="number">421</span>,<span class="number">431</span>,<span class="number">433</span>,<span class="number">439</span>,<span class="number">443</span>,<span class="number">449</span>,<span class="number">457</span>,<span class="number">461</span>,<span class="number">463</span>,<span class="number">467</span>,<span class="number">479</span>,<span class="number">487</span>,<span class="number">491</span>,<span class="number">499</span>,<span class="number">503</span>,<span class="number">509</span>,<span class="number">521</span>,<span class="number">523</span>,<span class="number">541</span>,<span class="number">547</span>,<span class="number">557</span>,<span class="number">563</span>,<span class="number">569</span>,<span class="number">571</span>,<span class="number">577</span>,<span class="number">587</span>,<span class="number">593</span>,<span class="number">599</span>,<span class="number">601</span>,<span class="number">607</span>,<span class="number">613</span>,<span class="number">617</span>,<span class="number">619</span>,<span class="number">631</span>,<span class="number">641</span>,<span class="number">643</span>,<span class="number">647</span>,<span class="number">653</span>,<span class="number">659</span>,<span class="number">661</span>,<span class="number">673</span>,<span class="number">677</span>,<span class="number">683</span>,<span class="number">691</span>,<span class="number">701</span>,<span class="number">709</span>,<span class="number">719</span>,<span class="number">727</span>,<span class="number">733</span>,<span class="number">739</span>,<span class="number">743</span>,<span class="number">751</span>,<span class="number">757</span>,<span class="number">761</span>,<span class="number">769</span>,<span class="number">773</span>,<span class="number">787</span>,<span class="number">797</span>,<span class="number">809</span>,<span class="number">811</span>,<span class="number">821</span>,<span class="number">823</span>,<span class="number">827</span>,<span class="number">829</span>,<span class="number">839</span>,<span class="number">853</span>,<span class="number">857</span>,<span class="number">859</span>,<span class="number">863</span>,<span class="number">877</span>,<span class="number">881</span>,<span class="number">883</span>,<span class="number">887</span>,<span class="number">907</span>,<span class="number">911</span>,<span class="number">919</span>,<span class="number">929</span>,<span class="number">937</span>,<span class="number">941</span>,<span class="number">947</span>,<span class="number">953</span>,<span class="number">967</span>,<span class="number">971</span>,<span class="number">977</span>,<span class="number">983</span>,<span class="number">991</span>,<span class="number">997</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lucas_pow</span><span class="params">(P, R)</span>:</span></span><br><span class="line">    A, B = P, <span class="number">2</span></span><br><span class="line">    R = bin(R)[<span class="number">3</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> R:</span><br><span class="line">        <span class="keyword">if</span> int(i) == <span class="number">1</span>:</span><br><span class="line">            A, B = (P * A**<span class="number">2</span> - A * B - P) % n, (A**<span class="number">2</span> - <span class="number">2</span>) % n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A, B = (A**<span class="number">2</span> - <span class="number">2</span>) % n, (A * B - P) % n</span><br><span class="line">    <span class="keyword">return</span> gcd(A - <span class="number">2</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Williams_p_1</span><span class="params">()</span>:</span></span><br><span class="line">    R = <span class="number">1</span></span><br><span class="line">    B = iroot(n, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    B = log(B)</span><br><span class="line">    <span class="keyword">for</span> pi <span class="keyword">in</span> prime:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(B//log(pi)):</span><br><span class="line">            R *= pi</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        P = random.randint(<span class="number">2</span>, B)</span><br><span class="line">        p = Lucas_pow(P, R)</span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">1</span> <span class="keyword">and</span> p &lt; n:</span><br><span class="line">            <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<p>可以看到上述算法的R选取和先前选的m!不同，且采用<span class="math inline">\(V_{f}\rightarrow V_{2f}\)</span>的跨度进行递推.</p>
<p>实验发现在p+1的小素数因子上限B已知时，采取上述方法会明显快一些（当然也可以求出该方法中的R，再通项直接求R，大约5s就能出）.</p>
<h4 id="link">Link</h4>
<p><a href="https://math.boisestate.edu/~liljanab/BOISECRYPTFall09/Sundling.pdf" target="_blank" rel="noopener">https://math.boisestate.edu/~liljanab/BOISECRYPTFall09/Sundling.pdf</a></p>
<p><a href="https://www.ams.org/journals/mcom/1982-39-159/S0025-5718-1982-0658227-7/S0025-5718-1982-0658227-7.pdf" target="_blank" rel="noopener">https://www.ams.org/journals/mcom/1982-39-159/S0025-5718-1982-0658227-7/S0025-5718-1982-0658227-7.pdf</a></p>
<h3 id="rsa---square-root-in-f_p">RSA - Square Root in <span class="math inline">\(F_{p}\)</span></h3>
<h4 id="theorem-15">Theorem</h4>
<p>Given <span class="math inline">\(b^{2}\equiv a(mod\ p)\)</span></p>
<ul>
<li><p>Case 1：<span class="math inline">\(p\equiv 3(mod\ 4)\rightarrow b:=\pm a^{\frac{p+1}{4}}(mod\ p)\)</span></p></li>
<li><p>Case 2：Cipolla's algorithm（一般性）</p>
<ul>
<li><p>Step 1：在<span class="math inline">\(F_{p}\)</span>上找到一个t，使得<span class="math inline">\(u:=t^{2}-a\)</span>是一个模p的平方非剩余（因为平方非剩余的概率趋于1/2，所以随机选取并用欧拉判别即可）</p></li>
<li><p>Step 2：定义<span class="math inline">\(F_{p^{2}}=F_{p}(\sqrt{t^{2}-a})=\\{x+y\sqrt{t^{2}-a}:x,y\in F_{p}\\}\)</span>，关于<span class="math inline">\(F_{p^{2}}\)</span>是域的证明此处略. （当然，<span class="math inline">\(\omega:=\sqrt{t^{2}-a}\)</span>在<span class="math inline">\(F_{p}\)</span>上不存在，因此类似虚数存在）.先来证明两个引理：(1) <span class="math inline">\((x+y\omega)^{p}=\sum_{i=0}^{p}C_{p}^{i}x^{p-i}(y\omega)^{i}\)</span>，因为u是平方非剩余，所以<span class="math inline">\(\omega^{p-1}=(\omega^{2})^{\frac{p-1}{2}}=u^{\frac{p-1}{2}}=-1\)</span>. 且p均整除二项式展开中间系数，上式可转化为<span class="math inline">\(x^{p}+y^{p}\omega^{p}(费马小定理)=x+y\omega^{p}=x-y\omega\)</span>.；(2) <span class="math inline">\(((t+\omega)^{\frac{p+1}{2}})^{2}=(t+\omega)^{p+1}=(t+\omega)(t-\omega)=t^{2}-\omega^{2}=a\)</span>.</p>
<p>所以计算<span class="math inline">\((t+\omega)^{\frac{p+1}{2}}\)</span>即为二次根b.</p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-17_17-12-37.png"></p></li>
</ul></li>
<li><p>Case 3：Atkin’s algorithm（<span class="math inline">\(p\equiv 5(mod\ 8)\)</span>）</p>
<p><span class="math inline">\(c\leftarrow (2a)^{\frac{p-5}{8}}\)</span></p>
<p><span class="math inline">\(i\leftarrow 2ac^{2}\)</span></p>
<p><span class="math inline">\(b\leftarrow ac(i-1)\)</span></p></li>
</ul>
<h4 id="exp-14">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euler_judge</span><span class="params">(x, p)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pow(x, (p - <span class="number">1</span>) // <span class="number">2</span>, p) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow_in_Fp2</span><span class="params">(a, b, n, p)</span>:</span>  <span class="comment"># (a+sqrt(b))^n in Fp^2</span></span><br><span class="line">    states = [(a % p, <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.log(n, <span class="number">2</span>))):</span><br><span class="line">        new_state = ((pow(states[i][<span class="number">0</span>], <span class="number">2</span>, p) + b * pow(states[i][<span class="number">1</span>], <span class="number">2</span>, p)) %</span><br><span class="line">                     p, (<span class="number">2</span> * states[i][<span class="number">0</span>] * states[i][<span class="number">1</span>]) % p)</span><br><span class="line">        states.append(new_state)</span><br><span class="line">    n_bin = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">    res_x = <span class="number">1</span></span><br><span class="line">    res_y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_bin)):</span><br><span class="line">        <span class="keyword">if</span> n_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">            res_x, res_y = (res_x * states[i][<span class="number">0</span>] + res_y * states[i][<span class="number">1</span>]</span><br><span class="line">                            * b) % p, (res_x * states[i][<span class="number">1</span>] + res_y * states[i][<span class="number">0</span>]) % p</span><br><span class="line">    <span class="keyword">return</span> res_x, res_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root</span><span class="params">(a, p)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(euler_judge(a, p) == <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> p % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        b = pow(a, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line">    <span class="keyword">elif</span> p % <span class="number">8</span> == <span class="number">5</span>:</span><br><span class="line">        c = pow(<span class="number">2</span> * a, (p - <span class="number">5</span>) // <span class="number">8</span>, p)</span><br><span class="line">        i = (<span class="number">2</span> * a * c**<span class="number">2</span>) % p</span><br><span class="line">        b = (a * c * (i - <span class="number">1</span>)) % p</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t = getRandomRange(<span class="number">1</span>, p)</span><br><span class="line">        u = t**<span class="number">2</span> - a</span><br><span class="line">        <span class="keyword">while</span> euler_judge(u, p):</span><br><span class="line">            t = getRandomRange(<span class="number">1</span>, p)</span><br><span class="line">            u = t**<span class="number">2</span> - a</span><br><span class="line">        b, check = pow_in_Fp2(t, u, (p + <span class="number">1</span>) // <span class="number">2</span>, p)</span><br><span class="line">        <span class="keyword">assert</span>(check == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> b, -b % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    root = square_root(<span class="number">19</span>, <span class="number">65537</span>)</span><br><span class="line">    print(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="more-2">More</h4>
<p>有限域下的n-th root其实在sympy中也有函数处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy.ntheory.residue_ntheory <span class="keyword">import</span> nthroot_mod</span><br><span class="line"></span><br><span class="line">x = nthroot_mod(a, <span class="number">2</span>, p, all_roots=<span class="literal">False</span>) <span class="comment">#求二次根</span></span><br></pre></td></tr></table></figure>
<p>但p和n过大时，nthroot_mod在有限域上求解也会变得极其困难，因此下面再做一个该类型的拓展.</p>
<h3 id="rsa---emid-p-1emid-q-1">RSA - <span class="math inline">\(e\mid (p-1),e\mid (q-1)\)</span></h3>
<h4 id="theorem-16">Theorem</h4>
<p>前面提到过<span class="math inline">\(gcd(e,\varphi(n))\neq 1\)</span>的情况，但不针对<span class="math inline">\(gcd(e,\varphi(n))=e\)</span>，于是这里就对<span class="math inline">\(e\mid (p-1),e\mid (q-1)\)</span>的特殊情况进行讨论.</p>
<p>解题思路即求解m mod p和m mod q，再通过CRT还原m mod n. 主要难点则是在<span class="math inline">\(GF(p)\)</span>上求e次根.</p>
<p>在有限域上求r-th root有两个常见算法（Adleman-Manders-Miller algorithm和Cipolla-Lehmer algorithm），但这里介绍的是Namhun Koo提出的一种更具一般性的开根算法，且在s足够小的时候更高效（<span class="math inline">\(r^{s}\mid (p-1),r^{s}\nmid (p-1)\)</span>）.</p>
<ul>
<li><strong>New r-th root extraction formula over <span class="math inline">\(F_{q}\)</span> for <span class="math inline">\(q\equiv lr^{s}+1(mod\ r^{s+1})\)</span> and r is a prime</strong></li>
</ul>
<p><strong>[Theorem 1]</strong></p>
<p>设c是在<span class="math inline">\(F_q\)</span>上的一个r次剩余，则<span class="math inline">\(\exists b\in F_{q},s.t.\ ord_{q}(c^{r-1}b^{r})=r^{t}.(0\leq t&lt;s)\)</span></p>
<p>Proof：</p>
<p><span class="math inline">\(\because gcd(r,l)=1\quad \therefore\exists(\alpha,\beta),s.t.\ r\beta +r-1=l\alpha\)</span>.</p>
<p><span class="math inline">\(\alpha =\frac{r\beta +r-1}{l}\)</span>，令<span class="math inline">\(\zeta=(c^{\alpha})^{\frac{q-1}{r^{s}}}=(c^{\alpha})^{\frac{q-1}{r^{s}}}c^{r\beta +r-1-l\alpha}=c^{r-1}(c^{\beta+\alpha\frac{q-1-lr^{s}}{r^{s+1}}})^{r}=c^{r-1}b^{r}\)</span>.</p>
<p><span class="math inline">\(\because c\)</span>是<span class="math inline">\(F_{q}\)</span>上的r次剩余，且指数含<span class="math inline">\(\frac{q-1}{r^{s}}\)</span>，则<span class="math inline">\(ord_{q}(\zeta)=r^{t}.(t&lt;s)\)</span></p>
<p>则由Theorem 1，我们令<span class="math inline">\(\xi\)</span>为<span class="math inline">\(F_{q}\)</span>上的一<span class="math inline">\(r^{s}\)</span>阶单位根，要取符合要求的<span class="math inline">\(\xi\)</span>，我们可以使得<span class="math inline">\(\xi=d^{\frac{q-1}{r^{s}}}\)</span>，其中d为模q的r次非剩余（概率约为<span class="math inline">\(\frac{r-1}{r}\)</span>）.</p>
<p>则存在唯一的<span class="math inline">\((i,j)\)</span>，使得<span class="math inline">\(\xi^{r^{s-t}}=\zeta^{i},\zeta=(\xi^{r^{s-t}})^j\)</span>，即<span class="math inline">\(ij\equiv 1(mod\ r^{t})\)</span>.</p>
<p><strong>[Theorem 2]</strong></p>
<p>令<span class="math inline">\(u\equiv j(r^{t}-1)r^{s-t-1}\equiv -jr^{s-t-1}(mod\ r^{s-1})\)</span>，则<span class="math inline">\(F_{q}\)</span>下c的一个r次根即为<span class="math inline">\(cb\xi^{u}\)</span>，b在Theorem 1中已给出定义.</p>
<p>Proof：</p>
<p><span class="math inline">\((cb\xi^{u})^{r}=cc^{r-1}b^{r}\xi^{ur}=c\zeta\xi^{ur}\)</span>.</p>
<p><span class="math inline">\(\because u=j(r^{t}-1)r^{s-t-1}+kr^{s-1},\xi^{r^{s}}=1.\)</span></p>
<p><span class="math inline">\(\therefore \zeta\xi^{ur}=(\xi^{r^{s-t}})^{j}\xi^{ur}=\xi^{jr^{s-t}+ur}=\xi^{jr^{s-t}+kr^{s}+j(r^{t}-1)r^{s-t}}=\xi^{jr^{s}}=1.\)</span></p>
<p><span class="math inline">\(\therefore (cb\xi^{u})^{r}=c.\)</span></p>
<p><strong>[Remark 1]</strong></p>
<p>Theorem里的<span class="math inline">\(r\beta +r-1=l\alpha\)</span>确定的<span class="math inline">\(\alpha\)</span> mod r和<span class="math inline">\(\beta\)</span> mod l是唯一的. 且上式可以扩展到<span class="math inline">\(\frac{q-1}{r}\)</span>的模域上（<span class="math inline">\(r\beta + r-1\equiv l\alpha(mod\ \frac{q-1}{r})\)</span>），因为c是<span class="math inline">\(F_{q}\)</span>上的r次剩余，即<span class="math inline">\(c^{\frac{q-1}{r}}=1\)</span>.</p>
<p><strong>[Remark 2]</strong></p>
<p><span class="math inline">\(cb=c^{\beta+1+\alpha\frac{q-1-lr^{s}}{r^{s+1}}}=c^{\frac{(\beta+1)r^{s+1}+\alpha(q-1)-\alpha lr^{s}}{r^{s+1}}}=c^{\frac{r^{s}((\beta+1)r-\alpha l)+\alpha(q-1)}{r^{s+1}}}=c^{\frac{1+\frac{\alpha(q-1)}{r^{s}}}{r}}.\)</span></p>
<p><strong>[Remark 3]</strong></p>
<p>Theorem 1结尾提到的<span class="math inline">\((i,j)\)</span>在<span class="math inline">\(r^{t}\)</span>较大时求解困难，因此本方法在r和t过大时并不高效.</p>
<p><strong>[利用]</strong></p>
<ul>
<li><p>s = 1时（即<span class="math inline">\(q\equiv lr+1(mod\ r^{2})\)</span>时）</p>
<p><span class="math inline">\(\because t&lt;s\quad\therefore t=0,u=0.\)</span></p>
<p><span class="math inline">\(cb\xi^{u}=cb\)</span>即为一个满足要求的r次根.</p>
<p>由Remark 3知，<span class="math inline">\(cb=c^{\frac{1+\frac{\alpha(q-1)}{r^{s}}}{r}}=c^{\frac{1+\frac{\alpha(q-1)}{r}}{r}}\)</span>，至于<span class="math inline">\(\alpha\)</span>可以通过扩展欧几里得算法很轻易得到.</p></li>
<li><p>s &gt; 1时，t可能落在{0, ..., s - 1}上，因此分析时要分的情况会多不少（在这里就不占篇幅去写了，paper链接会在Link中给出）</p></li>
<li><p>上述算法给出的只是<span class="math inline">\(G_{q}\)</span>上c的其中一个r次根，但要找出所有的r次根也很简单，只要借助r次单位根即可</p>
<p><span class="math inline">\(G_{q}\)</span>上的r次单位根(<span class="math inline">\(r\mid (q-1)\)</span>)为{<span class="math inline">\(x^{i(\frac{q-1}{r})}\)</span>}(<span class="math inline">\(i\in[0,q)\)</span>), 我们取一个不为1的r次单位根与我们先前找到的特解生成一个r阶循环群即找到通解.</p></li>
</ul>
<h4 id="exp-15">exp</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rthroot</span><span class="params">(c, r, q)</span>:</span></span><br><span class="line">    c %= q</span><br><span class="line">    <span class="keyword">assert</span>(isPrime(r) <span class="keyword">and</span> (q - <span class="number">1</span>) % r == <span class="number">0</span> <span class="keyword">and</span> (q - <span class="number">1</span>) % (r**<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">    l = ((q - <span class="number">1</span>) % (r**<span class="number">2</span>)) // r</span><br><span class="line">    alpha = (-inverse(l, r)) % r</span><br><span class="line">    root = pow(c, ((<span class="number">1</span> + alpha * (q - <span class="number">1</span>) // r) // r), q)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allroot</span><span class="params">(r, q, root)</span>:</span></span><br><span class="line">    all_root = set()</span><br><span class="line">    all_root.add(root)</span><br><span class="line">    <span class="keyword">while</span> len(all_root) &lt; r:</span><br><span class="line">        new_root = root</span><br><span class="line">        unity = pow(getRandomRange(<span class="number">2</span>, q), (q - <span class="number">1</span>) // r, q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r - <span class="number">1</span>):</span><br><span class="line">            new_root = (new_root * unity) % q</span><br><span class="line">            all_root.add(new_root)</span><br><span class="line">    <span class="keyword">return</span> all_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def crt(ai, mi):</span></span><br><span class="line"><span class="string">    a1, m1 = ai[0], mi[0]</span></span><br><span class="line"><span class="string">    a2, m2 = ai[1], mi[1]</span></span><br><span class="line"><span class="string">    return (a1 * inverse(m2, m1) * m2 + a2 * inverse(m1, m2) * m1) % (m1 * m2)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(proot, qroot, p, q)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = len(proot) * len(qroot)</span><br><span class="line">    step = total // <span class="number">100</span></span><br><span class="line">    t1 = inverse(q, p)</span><br><span class="line">    t2 = inverse(p, q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> proot:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> qroot:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % step == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'\r&#123;&#125;%'</span>.format(count // step), end=<span class="string">''</span>)</span><br><span class="line">            <span class="comment">#root = (i, j)</span></span><br><span class="line">            <span class="comment">#m = crt(root, (p, q))</span></span><br><span class="line">            m = (i * t1 * q + j * t2 * p) % (p * q)</span><br><span class="line">            <span class="keyword">if</span> unhexlify(hex(m)[<span class="number">2</span>:<span class="number">10</span>]) == <span class="string">b'NCTF'</span>:</span><br><span class="line">                print(<span class="string">'\n'</span>, long_to_bytes(m))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = <span class="number">199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059</span></span><br><span class="line">    q = <span class="number">112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741</span></span><br><span class="line">    e = <span class="number">0x1337</span></span><br><span class="line">    c = <span class="number">10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359</span></span><br><span class="line">    print(<span class="string">'[+] Calculating e-th root...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    proot = rthroot(c, e, p)</span><br><span class="line">    qroot = rthroot(c, e, q)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(<span class="string">'[+] Calculating all e-th roots...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    all_proot = allroot(e, p, proot)</span><br><span class="line">    all_qroot = allroot(e, q, qroot)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(<span class="string">'[+] CRT cracking...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    decrypt(all_proot, all_qroot, p, q)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="more-3">More</h4>
<p>exp对应2019-NCTF-easyRSA.</p>
<p>做完以后去找了官方wp，发现预期解是Adleman-Manders-Miller algorithm，这里给出链接</p>
<p><a href="http://www.soreatu.com/ctf/writeups/Writeup%20for%20Crypto%20problems%20in%20NCTF%202019.html#easyrsa" target="_blank" rel="noopener">http://www.soreatu.com/ctf/writeups/Writeup%20for%20Crypto%20problems%20in%20NCTF%202019.html#easyrsa</a></p>
<p>[注]</p>
<p>exp第一次调试的时候发现速度很慢-.-后来发现是大量crt的调用使得计算了接近<span class="math inline">\(e^{2}\)</span>次的inverse(p, q)和inverse(q,p)，因此将这两个crt中用到的变量锁定即可.</p>
<p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-25_09-54-37.png"></p>
<h4 id="link-1">Link</h4>
<p><a href="https://eprint.iacr.org/2013/117.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2013/117.pdf</a></p>
<p><a href="https://arxiv.org/pdf/1111.4877.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1111.4877.pdf</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">0xDktb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/">https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RSA/">RSA</a></div><div class="post_share"><div class="social-share" data-image="/img/star.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wx.jpg" alt="wechat" onclick="window.open('/img/wx.jpg')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/zfb.jpg" alt="alipay" onclick="window.open('/img/zfb.jpg')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/Lattice-Learning-1/"><img class="prev-cover" data-src="/img/star.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Lattice-Learning-1</div></div></a></div><div class="next-post pull-right"><a href="/2019/10/22/ByteCTF2019-boring-code/"><img class="next-cover" data-src="/img/star.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">[ByteCTF2019] - boring_code</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/img/star.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2023 By 0xDktb</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>湘ICP备19022012号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font_plus" title="Increase Font Size"><i class="fas fa-plus"></i></button><button id="font_minus" title="Decrease Font Size"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button></div><div id="rightside-config-show"><button id="rightside_config" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script></body></html>